//
// This is a asciidoc document. Edit here, but view the HTML
//

Bringup and Diagnostic Kit (BDK) Frequently Asked Questions
===========================================================

Overview
--------

The Bringup and Diagnostic Kit (BDK) is a large and sophisticated software
system and it takes a while before someone can understand how to use the it.
The novice user will have many questions and this document is an attempt to
answer the most common questions.

=== How does the BDK differ from the SDK?
* While both development kits are customer deliverables and provide low-level
software for operating an OCTEON processor, the BDK is intended for board
bring-up and only focuses on current generation OCTEONs. The SDK has a wider
audience. It supports all OCTEONs and is intended as the basis for programming
customer applications. Relative to the SDK, the BDK is quite sparse.
* The BDK and SDK are corelated. Initial work on a new OCTEON uses the BDK. As
this work proceeds, the BDK team documents what changed in the BDK to support
the new OCTEON. This change docuement goes to the SDK development staff where
they make appropriate changes to the SDK to also support the new processor.

=== Does the BDK depend upon SDK Bootloader?
* No, BDK applications are self-contained and have all of the code required to
start the OCTEON (DDR3 setup, TLB configuration, and so forth). A BDK
application can reside in boot bus FLASH memory and starts when an OCTEON
powers-up.
* It is possible to write the Bootloader as a BDK application (using the normal
BDK facilities to load it and execute it). The Bootloader, in its turn, can run
SDK applications.

=== What is the difference between an ELF image versus a binary image?
* Standard BDK Makefiles create two executible images: an ELF image, similar to
what the SDK generates; and a .bin (binary) image.
* An ELF image is the larger of the pair and may only run from the bootload.
The image uses the ELF relocation facilities to ready the image for execution.
The BDK ELF image is fundamentaly no different than an SDK image or a Linux
executable.
* BDK binary images are smaller, have fewer restrictions the ELF image, and can
run on a raw board where there is no bootload. BDK binaries are designed to
load anywhere in memory and have little need for relocation. Binary images also
can run from the bootbus FLASH memory in place of the normal bootloader.
* Binary images always use the .bin suffix while ELF images have no suffix.

=== What is the Difference Between Full BDK and Minimal BDK?
* BDK applications must fit into the OCTEON's L2Cache, especially if they must
run when the memory channel is not operating. Early members of the OCTEON-II
family have 2Mb caches which allow for a rather large BDK application, but
later members have smaller caches which can not hold large applications.
* To meet the small cache limit, we developed a slimmed down BDK image that
only supports Host-side Lua scripting. There is no local interactive Lua
interpretor and certain things such as the CSR database are not longer carried
in this Minimal BDK.
* The original, full function BDK is now called the FULL BDK. It supports the
interactive Lua interpretor, the /rom and /ram file systems, and all of the
other features you have come to depend upon.

=== Can I Write My Own Applications With the BDK Libraries?
* You can create a application which uses the BDK libraries and BDK facilities
in fashion similar to what you would do with the SDK. BDK supports a file
system, console (terminal) interaction, networking, and many other facilities
all exposed through a C API. Hence you can write a traditional C program,
build and run it as a BDK application.
* As BDK applications can run from the bootloader, the BDK can replace the SDK
as your development environment.
* There are restrictions. For instance, the BDK libraries do not support
command line argument passing from the bootloader. The BDK C API can and WILL
CHANGE. One of the motivations for the BDK is to rapidly create software for
the latest of OCTEONs and this demands rapid evolution of the BDK. Hence, any
application you write, may require radical changes in a short time. The BDK
makes no claim on preserving backwards compatibility.

=== Can I Write My Own Lua Scripts?
* The Lua scripts reside in the /rom filesystem. This filesystem is create by
the Makefile when building a BDK application. The Makefile has facilities for
you to specify what Lua files to include in the /rom filesystem. You can take
a standard Lua script, say traffic-gen.lua, make a local copy, edit it to add
your special features, and then rebuild the BDK application including this new
Lua file in /rom.

=== Can I Write My Own BDK Application With a Lua Interpretor?
* It is possible to write a BDK application which calls upon the Lua
interpretor to run you own scripts from /rom. In fact we encourage you to take
full advantage of Lua as it can greatly simplify writing applications.
* There is a special API to expose C routines from your application for use by
Lua. Your routines appear as part of the +octeon.c+ module. The Lua names may
be different from the C routine names.


Running BDK Applications from the SDK Bootloader
------------------------------------------------

You can use any of the SDK's bootloader filedown load methods to read a BDK
application into memory. Since there are two types of executible images:
(an ELF image and a binary image), there are different bootloader commands
required to run the images: +bootoct+ for ELF images; and +go+ for binary
images. The following items deal with various ways of downloading and running
BDK applications.

=== How do you run a BDK Application from the Compact Flash via the SDK Bootloader?
* The SDK bootloader can load a BDK application from the Compact Flash available
on most EBBs. For this example, assume we want to run a binary image.
* Use +fatload ide 0 0x40000 <application>+ where <application> is the file
name of the binary BDK application on the Compact Flash to download the
application into the memory at the address 0x400000. The choice of address is
arbitrary with the only restriction that it lies in the range 1Mb to 256Mb. The
SDK Bootloader may report an overwrite error that you can ignore.
* +go 0x40000+ runs the application. Control transfers immediately from the
bootloader to the BDK application. There is no linkage editing as occurs with an
ELF image.

=== How do you run a BDK Application from a TFTP server via the SDK Bootloader?
* When the EBB has a network connection, say through a managment port, you can
use the bootloader's +tftp+ command to load the BDK application. For this
example, assume we want to download and run a binary BDK application,
* Run +dhcp+ to establish your IP address. This only need be done once after
the EBB powers up. You may want to define a bootcmd environment variable to run
dhcp automatically after booting.
* Define the IP address of your TFTP server by setting the serverip environment
variable: +setenv serverip 192.168.140.112+ for instance.
* +tftp 0x40000 <application>+ loads the <application> from the tftp server to
the memory address 0x400000. The choice of address is arbitrary with the only
restriction that it lies in the range 1Mb to 256Mb. The SDK Bootloader may
report an overwrite error that you can ignore.
* +go 0x40000+ runs the application. Control transfers immediately from the
bootloader to the BDK application. There is no linkage editing as occurs with an
ELF image.

=== How do you run a BDK Application from the serial link via SDK Bootloader?
* When using a serial connection for the bootloader console, you can download
a BDK application with a combination of the bootloader's +loadb+ command and
the terminal emulator's Kermit file transfer facility. Linux's minicom has such
facilities, but alas, few of the Windows-based terminal emulators have this
facility. For this example, assume we want to downland and run a BDK ELF
application and we are using minicom as the terminal emulator.
* Use +loadb+ to boot the bootloder into file transfer mode.
* Type the +Control-A, K+ sequence to put minicom into Kermit mode. When you
see the Kermit prompt, type +send <application>+ where application is the name
of the ELF application. The transfers should start and you will see some status
updates. When the transfer completes, type +quit+ to return to the bootloader
* Run the application by typing +bootoct 0+.

=== Can a BDK Application run via the EBB6800 Telnet Octeon Console?
* EBB6800 revision 1 or 2 boards as they did not implement hardware flow control.
However BDK does have support for software flow control so it is possble run a
BDK application on these boards, but software flow control is not always
reliable and may have problems when there are large volumns of traffic flowing
over the console interface.


Octeon Simulator
----------------

BDK applications can run on the OCTEON simulator, a software emulation of an
OCTEON processor. This is useful when dealing with a new device that is not
yet available. The simulator also gives the user a detailed view of what is
happening and can spot trouble that might be hidden on a real processor. Of
course, a software emulation runs thousands of times slower than real hardware.

=== How can I use the OCTEON simulator to test my BDK application?
* Many makefiles provide a 'run' target for this purpose. When creating your
project, start with an existing project's Makefile and adjust the 'run' target
to execute your application.

=== How do I run a multi-core application on the simulator?
* Set the simulator's command line '-numcores' option to the desired number of
cores. The simulator only assumes a single core unless told otherwise. Running
a multi-core application on a single-core simulation results in the application
hanging.

=== How can I select the OCTEON model?
* There are means to select the OCTEON model: one is to setup the SIMULATOR
variable in bdk.mk to reference the desired OCTEON (i.e. cn63xxx); the second
is to use the simulator's command line '-pass=' option.


Octeon-Side Lua Scripts
-----------------------

=== Where Does the /rom File System Come From?
* The BDK /rom directory contains the sources of all of the files found in the
runtime /rom file system.
* The sources are compiled into .o files via ???? tool. The tool reads the
source file and generates a C language structure whose contents is a series
of hexidecimal byte constants which mirrors the source file. When linking a
BDK application, the linker imports all of the generated .o files and creates
the file system image. When the application runs and references a /rom file,
it really is traversing a memory data structure to find the contents from
the linked in .o file.
* This file system idea mirrors the Linux RAMDISK concept and is implemented in
a similar fashion.


Host-Side Lua Scripts
---------------------

=== Is There Support for a Host Running Windows?
* There is no support at this time.


PCIe and EJTAG Remote Access Tools
----------------------------------

The BDK does have equivalents for the SDK remote tools, allowing access to an
OCTEON via the PCIe bus and/or the EJTAG port via a probe (Cavium partners with
several probe vendors and the BDK supports all of these).

