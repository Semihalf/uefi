
Interacting with the Bringup and Diagnostic Kit
===============================================

Overview
--------

The "Bringup and Diagnostic Kit" (BDK) is a set of executables and
scripts designed to ease the bringup of new hardware based on Cavium
Networks line of OCTEON processors.  This document covers the usage of
the BDK from an interactive console after the BDK has been installed.
For installation information, see the document link:bdk.html[Bringup and
Diagnostic Kit].

Navigating Menus and Answering Prompts
--------------------------------------

All menus in the BDK start with a banner followed by a list of
numbered options.  Options are chosen by typing the associated number
into the "Menu Choice:" prompt and pressing ENTER.  Leaving a prompt
blank signals that input should be aborted, passing control passes
back to the menu.  All menus have the last option as an exit of the
menu and return to the previous menu.

Some menu options require extra input from the user.  These accept
keyboard input followed by the ENTER key.  Leaving a field blank, or
hitting Control-C abort input.  Control goes back to the menu.
Numeric input can be in decimal (default) or hexadecimal by beginning
the number with "0x" (zero followed by "x", similar to the C
programming language).

Line Editing
~~~~~~~~~~~~

Any prompt ending with ">" supports full line editing and history. Generally
speaking, arrow keys, home, end, insert, and delete work as expected.

* Use 'ARROW KEYS', 'HOME', 'END' or *vi* style commands 'ESC-h', 'ESC-j', 'ESC-k', 'ESC-l', 'ESC-0', 'ESC-$', 'ESC-w', or 'ESC-b' for navigation.
* Scroll through previous commands using the 'UP' and 'DOWN' arrow keys.
* Use 'INSERT' to toggle insert/overwrite mode, 'DELETE' to delete, 'F1' for help.
* Many *vi* style modes are available for command and history navigation.
* Use 'TAB' for command completion, multiple to cycle, or 'CTRL-D' for a list of possible commands.
* Use 'ESC-i', 'ESC-A' ,'ESC-a', 'ESC-c' for insert mode, 'ESC-R', 'ESC-r' for overwrite mode (behavior like *vi*).
* Use '!!', '!<num>' or '!<string>' to repeat previous commands in the history.
* Use '::', ':<num>' or ':<string>' to recall previous commands in the history to current.
* Use '?<string>', '/<string>', 'ESC-?<string>', 'ESC-/<string>', 'ESC-n', 'ESC-N' to also recall to current.
* Use 'CTRL-l' erase the screen, 'ESC-D' to clear the rest of the current line.
* Use 'ESC-d<movement>' to delete, 'ESC-~' to change case, 'ESC-u' to undo (one level).
* See the *vi* man page for more info on the operation of various commands.

Getting started at the Main Menu
--------------------------------

After initial boot, the BDK displays the first, or main, menu.  This
provides a list of high level options that are available
interactively.  Most menu choices bringup sub menus of additional
options.

.Sample Main Menu
----
include::main_menu.capture[]
----

Each menu option supports a logically distinct set of options:

Configuration options::

Use this option to configure the BDK for your board.  The specifics of
PHY addresses, MAC addresses, etc change for each board.  See
<<CONFIGURE, Configuring the BDK for your Board>>.

File options::

Here you'll find options for dealing with the BDK virtual filesystem.
These are normally most useful when writing scripts for the BDK.

Flash options::

Option for dealing with a NOR flash connected to chip select 0.

DDR options::

Options for configuring DDR3.

PCIe options::

PCIe discovery, enumeration, and probing can be accessed through this
menu. See <<PCIE, Testing PCIe>>.

SRIO options::

SRIO discovery, enumeration, and probing can be accessed through this
menu. See <<SRIO, Testing SRIO>>.

TWSI options::

Scan or probe TWSI bus devices.

SMI/MDIO options::

Scan or probe SMI/MDIO bus devices.

Interactive Lua prompt::

This provides direct access to the Lua interpreter running in the BDK.
This can be used to probe and configure any type of hardware inside or
connected to OCTEON.  Scripting using Lua is cover in another
document.

TCP/IP networking::

The BDK contains a full TCP/IP stack with servers for TFTP and Telnet.
Use this menu option to configure an IP address on an OCTEON network
interface.

Traffic Generator::

This menu option starts a simple traffic generator on OCTEON.  It can
be used to transmit and receive packets on all OCTEON packet
interfaces.  In combination with an external loopback, this can
quickly verify the interfaces on a board.

Reboot::

Perform a soft reset of OCTEON.  This can be useful for a quick reboot
without power cycling the entire board.

[[CONFIGURE]]
Configuring the BDK for your Board
----------------------------------

The configuration menu allows access to the parameters used to
configure the BDK.  These options control PHY address for various
interfaces as well as other attributes.  These need to be configured
for your board before the networking interfaces are brought up.

.Sample Configuration Menu from CN68XX
----
include::configure_menu.capture[]
----

MAC address::

The Ethernet MAC address used for all ports.  This should be input as
a sequence of hex digits beginning with "0x".

RGMII/MII port X PHY address::

The PHY address to use for the RGMII/MII management port.  The format
of the PHY address is the SMI/MDIO address plus 0x100 time the OCTEON
SMI/MDIO bus number.  For example, 0x203 would program the RGMII/MII
address to be on bus two, SMI/MDIO address three.

SGMII interface X, port Y PHY address::

The PHY address to use for the SGMII port Y on interface X.  The
format of the PHY address is the SMI/MDIO address plus 0x100 time the
OCTEON SMI/MDIO bus number.  For example, 0x203 would program the
RGMII/MII address to be on bus two, SMI/MDIO address three.


Interlaken port X lanes::

The number of QLM lanes to use for Interlaken port X.  Must be 0-8.

Interlaken port X channels::

The number of virtual channels to configure for Interlaken port X.
Must be 0-16.


[[PCIE]]
Testing PCIe
------------

The BDK supports testing OCTEON's PCIe ports in root complex mode.
Basic bus initialization and enumeration can be performed even before
DDR3 is working.  The sequence is simply to perform the items in the
PCIe menu it order.

.Sample PCIe Menu
----
include::pcie_menu.capture[]
----

PCIe#: Initialize::

Bringup PCIe link "#" and report the number of lanes and speed of the interface.

PCIe#: Scan for devices::

Use PCIe config cycles to scan bus "#" for devices.  The devices found
can be displayed in a following menu option.  Note that this option
only finds devices and does not assign resources.  This makes it easier
to see device discovery when a PCIe analyzer is connected.

PCIe#: Enumerate devices::

Iterate through the devices found in the scan an assign resources to
them.  After this step is complete, devices will have valid BAR setups
and respond to memory transactions.

PCIe#: Display devices::

Display the devices found on the bus and show details about each BAR
register.

PCIe#: Perform a memory read::

Issue a PCIe memory read transaction on the bus.  Prompts will be
issued for the PCIe address to read from and the number of bytes to
read.

PCIe#: Perform a memory write::

Issue a PCIe memory write transaction on the bus.  Prompts will be
issued for the PCIe address to write and the data.  The data should be
input as a series of hex digits, two per byte.

PCIe#: Shutdown::

Shutdown the PCIe link.  This might be useful if you want to test link
robustness by performing a series of initialization and shutdown
sequences.

[[SRIO]]
Testing SRIO
------------

Serial Rapid I/O ports support discovery, enumeration, and basic
transactions.  The main SRIO menu allows you to toggle global debug
options and select which hardware port to work with.

.Sample SRIO Main Menu
----
include::srio_main_menu.capture[]
----

SRIO port #::

Enter the SRIO sub menu for transaction for port "#".

Toggle extra debug output. Currently OFF::

Enable or disable extra debug option for SRIO operations.  These
generally give extra information about SRIO switches and devices as
they are discovered.

Toggle logging of maintenance. Currently OFF::

When this option is enable, every SRIO maintenance transaction is
logged to the console.  This can be useful for determining exactly
what transactions are happening to each device.

.Sample SRIO Sub Menu
----
include::srio_sub_menu.capture[]
----

SRIO#: Initialize::

Bringup the SRIO link and report its status.

SRIO#: Scan for devices::

Use maintenance transactions to scan the SRIO bus for devices.
Devices found can be displayed using a following menu option.

SRIO#: Enumerate devices::

Iterate through all devices found in the scan and assign device IDs,
set link enables, and program switch route tables.  After enumeration,
devices are capable of responding to SRIO transactions.

SRIO#: Display devices::

Display the known device SRIO devices along with information about
each device.

SRIO#: Perform a maintenance read::

Issue a maintenance read transaction.  Prompts will request the device
ID to access, transaction format (8 or 16 bit), the SRIO hopcount, and
the register address to read.

SRIO#: Perform a maintenance write::

Issue a maintenance write transaction.  Prompts will request the
device ID to access, transaction format (8 or 16 bit), the SRIO
hopcount, the register address to write, and the write data.

SRIO#: Send a doorbell::

Send a SRIO doorbell to a device.  Prompts will request the device ID
to access, transaction format (8 or 16 bit), the priority if the
doorbell (0-3), and the doorbell data (a 16bit number).

SRIO#: Receive a doorbell::

Displays a list of all doorbells received.

SRIO#: Perform a memory read::

TBD

SRIO#: Perform a memory write::

TBD


Testing DDR
-----------

TBD

Probing using TWSI
------------------

TWSI (I2C) operations allow you to probe various devices connected to
the OCTEON TWSI busses.  The top level menu selects which of the TWSI
busses to use.

.Sample TWSI Main Menu
----
include::twsi_main_menu.capture[]
----

Once a bus is selected, the TWSI sub menu allows operations on the bus.

.Sample TWSI Sub Menu
----
include::twsi_sub_menu.capture[]
----

Initialize bus::

Perform one time bus initialization of the OCTEON TWSI controller.
This needs to be done once before any other transactions are issued.

Scan bus::

Scan all valid TWSI addresses looking for devices.  Each device that
responds is displayed in a list.  This can be useful way of
determining what devices are available on a board.  Below is sample
scan from a EBB6800 board.
+
.TWSI Bus 0 scan on an EBB6800
----
TWSI0: Scanning bus...
TWSI0: Address   0 (0x00) responded
TWSI0: Address   1 (0x01) responded
TWSI0: Address   2 (0x02) responded
TWSI0: Address   3 (0x03) responded
TWSI0: Address   4 (0x04) responded
TWSI0: Address   5 (0x05) responded
TWSI0: Address   6 (0x06) responded
TWSI0: Address   7 (0x07) responded
TWSI0: Address   8 (0x08) responded
TWSI0: Address  27 (0x1b) responded
TWSI0: Address  76 (0x4c) responded
TWSI0: Address  86 (0x56) responded
TWSI0: Address  88 (0x58) responded
TWSI0: Address  90 (0x5a) responded
TWSI0: Address  91 (0x5b) responded
TWSI0: Address  96 (0x60) responded
TWSI0: Address 104 (0x68) responded
TWSI0: Address 112 (0x70) responded
TWSI0: Address 113 (0x71) responded
TWSI0: Address 116 (0x74) responded
TWSI0: Address 124 (0x7c) responded
TWSI0: Address 125 (0x7d) responded
TWSI0: Address 126 (0x7e) responded
TWSI0: Address 127 (0x7f) responded
----

Read::

Perform a TWSI read.  Prompts will ask for the device address,
internal address width, internal address, and number of bytes to read
(1,2,4).
+
.Sample TWSI read
----
Device address(13INS)> 1
Internal address width (0, 1, or 2)(14INS)> 0
Number of bytes to read(15INS)> 1
Result: 246 (0xf6)
----

Write::

Perform a TWSI write.  Prompts will ask for the device address,
internal address width, internal address, number of bytes to write
(1,2,4), and the data to write.
+
.Sample TWSI write
----
Device address(10INS)> 11
Internal address width (0, 1, or 2)(11INS)> 1
Internal address(12INS)> 0
Number of bytes to write(13INS)> 4
Data to write(14INS)> 0x11223344
----


Probing using SMI / MDIO
------------------------

SMI/MDIO busses are used to communicate with Ethernet PHYs.  PHYs
support one of two protocols, clause 22 and clause 45.  Both of these
protocols are supported through the BDK menuing interface.  The main
SMI/MDIO menu selects which of the OCTEON busses to access.

.Sample SMI/MDIO Main Menu
----
include::mdio_main_menu.capture[]
----

Once a bus is selected, various operations are available for both
protocol types.

.Sample SMI/MDIO Sub Menu
----
include::mdio_sub_menu.capture[]
----

Scan bus (Clause 22)::

Performs a read fro mall possible SMI/MDIO addresses and list the
addresses where the reads succeeded.  This can be used to quickly find
all the device connected to the bus.  Note that the scan performs
clause 22 reads and may not show clause 45 only devices.

Read a register (Clause 22)::

Performs a SMI/MDIO read using the clause 22 protocol.

Write a register (Clause 22)::

Performs a SMI/MDIO write using the clause 22 protocol.

Read a register (Clause 45)::

Performs a SMI/MDIO read using the clause 45 protocol.

Write a register (Clause 45)::

Performs a SMI/MDIO write using the clause 45 protocol.


Generating Ethernet Traffic
---------------------------

TBD

Traffic Generator Port Naming
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Device ports are named based on their type, interface collection, and
port in a collection.  All names are of the form:

----
TYPE INTERFACE INDEX
----

TYPE::

The port type is based on the underlying transport layer.  Some of the
support types are SGMII, XAUI, ILK, SRIO, LOOP, and MGMT.

INTERFACE::

Each type of port has an internal chip interface.  These interfaces
are number 0-X, where X is the maximum supported for the chip.  The
exact numbering is dictated by the wiring of OCTEON's I/Os on the
board.

INDEX::

Some port types, such as SGMII, have multiple ports in each interface.
This number represents the index number into the interfaces.
Interfaces not supporting multiple ports, such as XAUI, will always
use zero for this number.  Channelized interfaces, such as Interlaken,
will use this index as the channel number.

Most commands take an optional port range.  The port range is
specified as a series of names separated by commas or dashes.  Dashes
include all ports between the named ports.  Commas are used to
separate independent port, making a list.  No spaces are allowed in a
port range.  Some example port ranges are "SGMII00-SGMII03",
"XAUI00,XAUI10", and "LOOP00-LOOP03".  When not specified, the port
range is taken from the range given in the last "default" command.

The exact list of valid ports varies based on the OCTEON chip being
used and the wiring of the board it is on.  To get a list of all
possible ports, issue the command *default all*.


Traffic Generator Commands
~~~~~~~~~~~~~~~~~~~~~~~~~~
Control Commands
^^^^^^^^^^^^^^^^
cls::

Clear the screen.

csr <csr name> [value]::

Read or write a CSR by name.

default [port range]::

Set the range of ports commands should use when an explicit range is
not specified.

display_packet [port range] on|off::

Enable or disable the display of each packet as it is received.

help::

Show a list of the possible commands.

hide::

Hide all statistics counters.

output_count [port range] count::

Set the number of packet to transmit on a port. Use zero to transmit forever.

output_packet_size [port range] size::

Set the size of the packet to transmit (60-65524).

quit::

Exit the traffic generator.  Note that this will not stop traffic, so
you need to issue a *stop all* before quiting.

readline on|off::

Enable or disable readline support.  Turning readline support off can
be useful if you are driving the traffic generator with a script.
Defaults to on.

reboot::

Perform a soft reset of OCTEON.

reset::

Clear all counters and reset the port configuration to the default.

scan_sizes [port range]::

Scan through all possible packet sizes, making sure every packet sent
is received back.  TBD.

show [port range]::

Display statistics for the port range on the screen as a constantly
updating GUI.

start [port range]::

Start transmitting packets on the port range.

stop [port range]::

Stop transmitting packets on the port range.

tx_percent [port range] percent::

Set the transmit rate as a percentage of 1Gbps.  Note that this does
not affect ports that are transmitting until they stop and restart.

tx_rate [port range] packet/s::

Set the transmit rate in packets per second.  Note that this does not
affect ports that are transmitting until they stop and restart.

validate [port range] on|off::

Turn packet validation on or off. This should normally be on. TBD.

Statistics Commands
^^^^^^^^^^^^^^^^^^^

clear [port range]::

Clear the statistics for the port range.

l2_stats on | off::

Turn on/off detailed L2 usage and statistics counters. TBD.

rx_backpressure [port range]::

Display counters of backpressure received on a port range.

rx_dropped_octets [port range]::

Number of bytes dropped during reception for each port.

rx_dropped_packets [port range]::

Number of packets dropped during reception for each port.

rx_errors [port range]::

Number of receive errors for each port.

rx_octets_total [port range]::

Number of bytes received for each port.

rx_packets_total [port range]::

Number of packets received for each port.

rx_validation_errors [port range]::

Number of validation errors received for each port.

tx_octets_total [port range]::

Number of bytes transmitted for each port.

tx_packets_total [port range]::

Number of packets transmitted for each port.


Traffic Generator Shortcut Keys
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* F1 = 'help': Show a list of supported commands.
* F9 = 'validate all on': Enable packet validation on all ports.
* F10 = 'stop all': Stop transmitting on all ports.
* F11 = 'start default': Transmit on the ports specified in the last 'default' command.
* F12 = 'stop default': Stop transmit on the ports specified in the last 'default' command.
* PageDown = 'clear default': Clear the statistics counters for the ports in the default range.
* PageUp = 'clear all': Clear the statistics counters for all ports.

Below is a sample screen capture from the traffic generator.  Two
commands were issued, one to set the default ports to SGMII40 through
SGMII43, and the second to show the port statistics.

.Sample Traffic Generator Screen
----
                Port|   SGMII40|   SGMII41|   SGMII42|   SGMII43|    Totals
rx backpressure     |         0|         0|         0|         0|         0
rx Mbps             |         0|         0|         0|         0|         0
rx dropped octets   |         0|         0|         0|         0|         0
rx dropped packets  |         0|         0|         0|         0|         0
rx errors           |         0|         0|         0|         0|         0
rx octets           |         0|         0|         0|         0|         0
rx octets total     |         0|         0|         0|         0|         0
rx packets          |         0|         0|         0|         0|         0
rx packets total    |         0|         0|         0|         0|         0
rx validation errors|         0|         0|         0|         0|         0
tx Mbps             |         0|         0|         0|         0|         0
tx octets           |         0|         0|         0|         0|         0
tx octets total     |         0|         0|         0|         0|         0
tx packets          |         0|         0|         0|         0|         0
tx packets total    |         0|         0|         0|         0|         0
Lua memory(KB)      |       277
C memory(KB)        |      3732
 -------

BDK Traffic Generator

Type "help" for a list of commands
SGMII40: Link up, 1000 Mbps, Full duplex
SGMII41: Link up, 1000 Mbps, Full duplex
SGMII42: Link up, 1000 Mbps, Full duplex
SGMII43: Link up, 1000 Mbps, Full duplex
XAUI00: Link up, 10000 Mbps, Full duplex, 2 lanes
XAUI10: Link up, 10000 Mbps, Full duplex, 2 lanes
MGMT00: Link up, 1000 Mbps, Full duplex
Command(1INS)> default SGMII40-SGMII43
Default ports: SGMII40 SGMII41 SGMII42 SGMII43
Command(2INS)> show
Command(3INS)>
----


Access the BDK through Telnet
-----------------------------

The BDK contains a full TCP/IP stack with a builtin Telnet server.
The server is automatically started on boot, but is not accessible
until an IPv4 address is assigned to an Ethernet interface.  IPv4
addresses are controlled by the TCP/IP networking menu.  Once an IPv4
address is assigned, any Telnet client may connect to the BDK through
port 23, the standard Telnet port.

CAUTION: The builtin traffic generator interferes with TCP/IP.  If you
use TCP/IP, do not use the builtin traffic generator.  Using the
generator will disrupt TCP/IP and stop all connections.

.Sample TCP/IP Networking Menu
----
include::tcp_menu.capture[]
----

Show all port configurations::

This option list all supported Ethernet devices and their current IPv4
configuration.

Configure MGMT0 with a static IP 10.0.0.2/24::

This option allows you to quickly assign a fixed IPv4 address to
management port 0.  This can be useful in a private network setup
where two machines are directly connected.  OCTEON will use 10.0.0.2,
while the host machine will likely use 10.0.0.1.  This option should
not be used on anything other than a small, private, test network.

Configure a network port with DHCP::

Use DHCP to automatically configure an Ethernet device.  A prompt will
ask for which interface to configure.  The valid options are shown in
the list for "Show all port configurations".

Configure a network port with a static IP::

Statically configure an Ethernet interface with pre determined IPv4
address.  Prompts will request the device to configure, the IP address
in dot notation, the netmask in dot notation, and the gateway in dot
notation.

Configure a network port with auto IP::

Dynamically assigns a local 169.254.*.* based on the zero
configuration method used by Microsoft Windows and Mac OS X.  This
address is suitable for private networks, but should normally not be
used on corporate LANs.  Note that configuring this method takes time
to perform a number of ARPs and wait for responses.  The resulting
address is not available for several seconds.


Access the BDK through TFTP
---------------------------

In addition to the builtin Telnet server, the BDK also contains a TFTP
server.  Once a valid IPv4 address is configured, the TFTP server can
be used to transfer files to and from the BDK.  Most any TFTP client
should work.  If you are running Linux, the recommended TFTP client is
HPA enhanced TFTP client.  For Debian systems, this can be installed
with:

.Installing a TFTP client on Debian
----
aptitude install tftp-hpa
----

.Sample TFTP transfer (OCTEON -> Host)
[source, sh]
----
tftp 169.254.1.240 -c get /rom/ilua.lua
----

.Sample TFTP transfer (Host -> OCTEON)
[source, sh]
----
tftp 169.254.1.240 -c put myscript.lua /ram/myscript.lua
----

