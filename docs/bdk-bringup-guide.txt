
Board Validation with the Bringup and Diagnostic Kit
====================================================

Overview
--------

This document is a step by step procedure for verifying proper
hardware functionality of boards based on OCTEON processors.  The
target audenice is either board designers or validation engineers
charged with the task of verifing hardware. By following this guide,
the following goals should be met.

.Final Goals
* The OCTEON processor booted and running software.
* All packet interfaces verfied as operational.
* Miscelanious I/O busses verfied as operational, such as TWSI and SMI/MDIO.
* If applicable, PCIe as a root complex verfied as operational.
* If applicable, SRIO verfied as operational.
* DRAM configured and tested.
* Board ready to be handed to software for further development.


Step 1 - Minimum Prerequisites
------------------------------

Certain minimum requirements must be met before progress can continue.
OCTEON must progress through the reset sequence documented in the
hardware manual. OCTEON's UART0 must be connected to a serial terminal
in order to monitor the boot progress.

* OCTEON reference clock must be at 50 Mhz.
* OCTEON reset sequence must follow the hardware reference manual.
* UART0 connected to a serial terminal. Baud rate of 115200, no parity, one stop bit.
* If booting from flash, a NOR flash must be connected to OCTEON's bootbus.

Step 2 - Boot the BDK
---------------------

Burn bdk-boot.bin to NOR flash
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use a flash programmer to burn the image *bdk-boot.bin* to the
beginning of the NOR flash.  The first byte of *bdk-boot.bin* should
be at address zero, the second at address one, etc.

Boot over PCIe
~~~~~~~~~~~~~~

The target board must be connected as a PCIe endpoint to a PC system
running Linux.

. Apply any additional power need for the target board.
. Boot the PCIe host PC into Linux.
. Install the BDK on the PC by following the instructions in link:bdk.html[BDK documentation].
. Issue the following shell commands.

[source, sh]
----
$ export OCTEON_REMOTE_PROTCOL=pci
$ bdk-remote boot bdk-boot/bdk-boot.bin
----

Boot over EJTAG
~~~~~~~~~~~~~~~

The BDK has been tested with multiple EJTAG probes.  The best
supported probe is the Macraigor mpDemon.  The following section
details the process of booting the BDK using the mpDemon. Other EJTAG
probes should be similar.

Get the latest mpDemon Firmware
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Firmware and software updates are available for free from the Macraigor
website. Be sure the software installed meets the minimum version lists
below.

----
Model		Minimum Firmware
-----		----------------
mpDemon		3.0.3.9
----

Macraigor website with details about the mpDemon::

link:http://www.macraigor.com/mpDemon.htm[]

Link to the latest firmware for the mpDemon::

link:http://www.macraigor.com/downloads/mpDemon_Update.zip[]


Setting up a Macraigor mpDemon for use with Octeon
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Connect to the 9 pin serial port on the mpDemon with a straight through
serial cable. Using a baud rate of 19200, no parity, 8 bits, and 1 stop bit,
you should get the following menu after hitting return:

----
    Macraigor Systems mpDemon(tm) version 3.0.3.9

Licenses           :
API Baud Rate      : 115200
Use DHCP?          : Yes
DHCP Hostname      : mpdemon1
TCP/IP Address     : 192.168.162.166
       Mask        : 255.255.255.  0
       Gateway     : 192.168.162.  1
MAC Address        : 00.60.bf.01.01.b7
API TCP/IP Port    : 1000
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=8893 <- TDI

   mpDemon Command Menu:

  B - Set Serial API baud Rate             D - Set DHCP option
  N - Set DHCP hostName
  O - Set OCDREMOTE Configuration          T - Test OCDREMOTE Configuration
  L - Update License Code(s)               C - Set Macraigor API TCP/IP port
  P - Ping TCP/IP address                  J - Analyze JTAG Scan Chain
  E - Display Error Log                    R - Reboot mpDemon
  Type Command (<Enter> will refresh screen) ->
----

. Choose "D" to enable DHCP for the probe.
+
----
Type Command (<Enter> will refresh screen) -> D
Use DHCP? (Y/N) ->y
----

. Choose "N" to set the hostname that will be used during DHCP to name the
device. The following example configures the probe to use the name of
"mpdemon1".
+
----
Type Command (<Enter> will refresh screen) -> N
DHCP hostname ->mpdemon1

MUST REBOOT mpDEMON FOR DHCP CHANGE TO TAKE EFFECT
----

. Choose "O" to configure the builtin GDB remote stub. This is used to allow
interactive debugging using the GDB remote protocol. Again, the following
example is from a CN63XX.
+
----
  Type Command (<Enter> will refresh screen) -> O

Initial JTAG speed (1 - 8) [1] ->1
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=
8893 <- TDI
Do you want to change the JTAG chain [no]? y
Number of Devices in Scan Chain (0 - 16) [6] ->6
Device List:
            ...
            Cavium 64-bit Family:
              301x CN300x CN3020 CN31xx CN36xx
              CN38xx CN502X CN52xx CN56xx CN58xx
              CN63xx CN68xx N3 O1P O2P
              O9N O52 O56 O5020
            ...

Device1 [CN63xx] --> CN63xx
TCP/IP port number : [8888] ->

Device2 [CN63xx] --> CN63xx
TCP/IP port number : [8889] ->

Device3 [CN63xx] --> CN63xx
TCP/IP port number : [8890] ->

Device4 [CN63xx] --> CN63xx
TCP/IP port number : [8891] ->

Device5 [CN63xx] --> CN63xx
TCP/IP port number : [8892] ->

Device6 [CN63xx] --> CN63xx
TCP/IP port number : [8893] ->
   Reboot mpDemon to run with new parameters
   hit any key to continue
----

. At this time, configuration is complete. Reboot the probe with the "R" command
and view the new configuration.
+
----
  Type Command (<Enter> will refresh screen) -> r
Are you sure you want to reboot? y
Rebooting...
OK

    Macraigor Systems mpDemon(tm) version 3.0.3.9

Licenses           :
API Baud Rate      : 115200
Use DHCP?          : Yes
DHCP Hostname      : mpdemon1
TCP/IP Address     : 192.168.162. 53
       Mask        : 255.255.255.  0
       Gateway     : 192.168.162.  1
MAC Address        : 00.60.bf.01.01.b7
API TCP/IP Port    : 1000
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=
8893 <- TDI

   mpDemon Command Menu:

  B - Set Serial API baud Rate             D - Set DHCP option
  N - Set DHCP hostName
  O - Set OCDREMOTE Configuration          T - Test OCDREMOTE Configuration
  L - Update License Code(s)               C - Set Macraigor API TCP/IP port
  P - Ping TCP/IP address                  J - Analyze JTAG Scan Chain
  E - Display Error Log                    R - Reboot mpDemon
  Type Command (<Enter> will refresh screen) ->
----


Configuring the BDK Host tools to use the mpDemon
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The environment variable *OCTEON_REMOTE_PROTOCOL* controls how the
*bdk-remote* utility communicates with OCTEON.  Tot use the native
capabilities of the Macraigor mpDemon, this variable should be set as
follows:

[source, sh]
----
export OCTEON_REMOTE_PROTOCOL=macraigor:mpdemon1,1000,1
----

The different parts of this environment variable are defined below.

macraigor::

This is the EJTAG protocol being used. For the mpdemon, this is the best
protocol.

mpdemon1::

This is the hostname of the mpDemon.  You can either use a name or
IPv4 address in X.X.X.X format.

1000::

This is the TCP/IP port number used to connect to the mpDemon.  This
matches the "API TCP/IP Port" configuration of the probe.  The default
port is '1000' for the mpDemon.

1::

This is the EJTAG clock speed divider.  Generally the fastest speed of
'1' is best.  If you have trouble, try increasing this value to '2' or
'3'.  If trouble persists, try '8'.

Booting the BDK
^^^^^^^^^^^^^^^

Now that the mpDemon is configured and the *OCTEON_REMOTE_PROTCOL*
envionment variable is set, the BDK can be booted on the board.  Issue
the following *bdk-remote* command.

[source, sh]
----
bdk-remote boot bdk-boot/bdk-boot.bin
----

Successful Booting
~~~~~~~~~~~~~~~~~~

If everything went well, the following output should be visible in the
serial terminal.  If booting did not succeed, re-check step 1.

.Example Successful Boot
----
include::boot_messages.capture[]
include::main_menu.capture[]
Menu choice: (0INS)>
----


Step 3 - Configure the Board
----------------------------

Before detailed testing begins, some paramters need to be set in order
to customize the BDK for the board.  For ethernet tests, covered
later, the PHY addresses and MAC address needs to be set.

CAUTION: Configuration options are *not saved* and will be lost on
reset.  Configuration needs to be redone after every boot.

.Sample Configuration Menu from CN68XX
----
include::configure_menu.capture[]
----

Configure the MAC Address
~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK creates a semi random MAC address based on internal chip
parameters.  This default is normally good enough for lab testing, but
it should be replaced before the board is used on a large LAN.  The
BDK default starts with Cavium's OUI with the locally administered bit
set, '02:0f:b7'.  The next three bytes are derived based on internal
chip data.

Configure PHY Addresses
~~~~~~~~~~~~~~~~~~~~~~~

RGMII, MII, and SGMII ports on the board should have ethernet PHYs
conencted to OCTEON using SMI/MDIO.  Before these ports can be used,
the SMI/MDIO address for each PHY needs to be programmed.  Choose the menu option
for each RGMII, MII, and SGMII port. When prompted, enter the PHY address encoded as follows:

----
Address = <SMI/MDIO address> + 256 * <OCTEON SMI/BDIO bus>
----

SMI/MDIO address::

This is the address of the PHY as configured by strapping on the board.

OCTEON SMI/BDIO bus::

This is the number of the SMI/MDIO bus used on Octeon.

TIP: If the PHY addresses are unknown, the scan utility in the
SMI/MDIO menu can be useful.  It will display all the devices OCTEON
can autoamtically find.


Step 4 - Test TWSI
------------------

The BDK support probing TWSI (I2C) usign basic operations.  Testing
general conenctivity is done using an automated device address scan.
Further details about individual TWSI devices can be probed using
manual reads and writes.  The first step is to choose an OCTEON TWSI
bus for testing.  This is done in the main TWSI menu.

.Sample TWSI Main Menu
----
include::twsi_main_menu.capture[]
----

Once a bus is selected, the TWSI sub menu allows operations on the bus.

.Sample TWSI Sub Menu
----
include::twsi_sub_menu.capture[]
----

Initialize TWSI
~~~~~~~~~~~~~~~

Perform one time bus initialization of the OCTEON TWSI controller.
This needs to be done once before any other transactions are issued.


Scan TWSI
~~~~~~~~~

Scan all valid TWSI addresses looking for devices.  Each device that
responds is displayed in a list.  This can be useful way of
determining what devices are available on a board.  Below is sample
scan from a EBB6800 board.
+
.TWSI Bus 0 scan on an EBB6800
----
TWSI0: Scanning bus...
TWSI0: Address   0 (0x00) responded
TWSI0: Address   1 (0x01) responded
TWSI0: Address   2 (0x02) responded
TWSI0: Address   3 (0x03) responded
TWSI0: Address   4 (0x04) responded
TWSI0: Address   5 (0x05) responded
TWSI0: Address   6 (0x06) responded
TWSI0: Address   7 (0x07) responded
TWSI0: Address   8 (0x08) responded
TWSI0: Address  27 (0x1b) responded
TWSI0: Address  76 (0x4c) responded
TWSI0: Address  86 (0x56) responded
TWSI0: Address  88 (0x58) responded
TWSI0: Address  90 (0x5a) responded
TWSI0: Address  91 (0x5b) responded
TWSI0: Address  96 (0x60) responded
TWSI0: Address 104 (0x68) responded
TWSI0: Address 112 (0x70) responded
TWSI0: Address 113 (0x71) responded
TWSI0: Address 116 (0x74) responded
TWSI0: Address 124 (0x7c) responded
TWSI0: Address 125 (0x7d) responded
TWSI0: Address 126 (0x7e) responded
TWSI0: Address 127 (0x7f) responded
----

TIP: Be sure to note the address and bus of any DIMMs.  Later when
DDR3 is tested, SPD data will need to be read from TWSI using these
addresses.

Read
~~~~

Perform a TWSI read.  Prompts will ask for the device address,
internal address width, internal address, and number of bytes to read
(1,2,4).
+
.Sample TWSI read
----
Device address(13INS)> 1
Internal address width (0, 1, or 2)(14INS)> 0
Number of bytes to read(15INS)> 1
Result: 246 (0xf6)
----

Write
~~~~~

Perform a TWSI write.  Prompts will ask for the device address,
internal address width, internal address, number of bytes to write
(1,2,4), and the data to write.
+
.Sample TWSI write
----
Device address(10INS)> 11
Internal address width (0, 1, or 2)(11INS)> 1
Internal address(12INS)> 0
Number of bytes to write(13INS)> 4
Data to write(14INS)> 0x11223344
----


Step 5 - Test SMI/MDIO
----------------------

SMI/MDIO busses are used to communicate with Ethernet PHYs.  PHYs
support one of two protocols, clause 22 amd clause 45.  Both of these
protocols are supported through the BDK menuing interface.  The main
SMI/MDIO menu selects which of the OCTEON busses to access.

.Sample SMI/MDIO Main Menu
----
include::mdio_main_menu.capture[]
----

Once a bus is selected, various operations are available for both
protocol types.

.Sample SMI/MDIO Sub Menu
----
include::mdio_sub_menu.capture[]
----

Scan bus (Clause 22)
~~~~~~~~~~~~~~~~~~~~

Performs a read from all possible SMI/MDIO addresses and list the
addreses where the reads succeeded.  This can be used to quickly find
all the device connected to the bus.  Note that the scan performs
clause 22 reads and may not show clause 45 only devices.

TIP: Note that the PHY address found here should match the PHY address
set in the configuration menu.

Read a register (Clause 22)::

Performs a SMI/MDIO read using the clause 22 protocol.

Write a register (Clause 22)::

Performs a SMI/MDIO write using the clause 22 protocol.

Read a register (Clause 45)::

Performs a SMI/MDIO read using the clause 45 protocol.

Write a register (Clause 45)::

Performs a SMI/MDIO write using the clause 45 protocol.


Step 6 - Test PCIe
------------------

The BDK supports testing OCTEON's PCIe ports in root complex mode.
Basic bus initialization and enumeration can be performed even before
DDR3 is working.  The sequence is simply to perform the items in the
PCIe menu it order.

.Sample PCIe Menu
----
include::pcie_menu.capture[]
----

PCIe#: Initialize
~~~~~~~~~~~~~~~~~

Bringup PCIe link "#" and report the number of lanes and speed of the interface.

PCIe#: Scan for devices
~~~~~~~~~~~~~~~~~~~~~~~

Use PCIe config cycles to scan bus "#" for devices.  The devices found
can be displayed in a following menu option.  Note that this option
only finds devices and does not assign resources.  This makes it easier
to see device discovery when a PCIe analyzer is connected.

PCIe#: Enumerate devices
~~~~~~~~~~~~~~~~~~~~~~~~

Iterate through the devices found in the scan an assign resources to
them.  After this step is complete, devices will have valid BAR setups
and respond to memory transactions.

PCIe#: Display devices
~~~~~~~~~~~~~~~~~~~~~~

Display the devices found on the bus and show details about each BAR
register.

PCIe#: Perform a memory read
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a PCIe memory read transaction on the bus.  Prompts will be
issued for the PCIe address to read from and the number of bytes to
read.

PCIe#: Perform a memory write
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a PCIe memory write transaction on the bus.  Prompts will be
issued for the PCIe address to write and the data.  The data should be
input as a series of hex digits, two per byte.

PCIe#: Shutdown
~~~~~~~~~~~~~~~

Shutdown the PCIe link.  This might be useful if you want to test link
robustness by performing a series of initialization and shutdown
sequences.


Step 7 - Test the RGMII/MII Management Ports
--------------------------------------------

TBD


Step 8 - Test SGMII
-------------------

TBD


Step 9 - Test XAUI
------------------

TBD


Step 10 - Test Interlaken
-------------------------

TBD


Step 11 - Test SRIO
-------------------

Serial Rapid I/O ports support discovery, enumeration, and basic
transactions.  The main SRIO menu allows you to toggle global debug
options and select which hardware port to work with.

.Sample SRIO Main Menu
----
include::srio_main_menu.capture[]
----

SRIO port #::

Enter the SRIO sub menu for transaction for port "#".

Toggle extra debug output. Currently OFF::

Enable or disable extra debug option for SRIO operations.  These
generally give extra information about SRIO switches and devices as
they are discovered.

Toggle logging of maintenance. Currently OFF::

When this option is enable, every SRIO maintenance transaction is
logged to the console.  This can be useful for determining exactly
what transactions are happening to each device.

.Sample SRIO Sub Menu
----
include::srio_sub_menu.capture[]
----

SRIO#: Initialize
~~~~~~~~~~~~~~~~~

Bringup the SRIO link and report its status.

SRIO#: Scan for devices
~~~~~~~~~~~~~~~~~~~~~~~

Use maintenance transactions to scan the SRIO bus for devices.
Devices found can be displayed using a following menu option.

SRIO#: Enumerate devices
~~~~~~~~~~~~~~~~~~~~~~~~

Iterate through all devices found in the scan and assign device IDs,
set link enables, and program switch route tables.  After enumeration,
devices are capable of responding to SRIO transactions.

SRIO#: Display devices
~~~~~~~~~~~~~~~~~~~~~~

Display the known device SRIO devices along with information about
each device.

SRIO#: Perform a maintenance read
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a maintenance read transaction.  Prompts will request the device
ID to access, transaction format (8 or 16 bit), the SRIO hopcount, and
the register address to read.

SRIO#: Perform a maintenance write
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a maintenance write transaction.  Prompts will request the
device ID to access, transaction format (8 or 16 bit), the SRIO
hopcount, the register address to write, and the write data.


More Advanced SRIO Testing
~~~~~~~~~~~~~~~~~~~~~~~~~~

After basic enumeration completes successfully, SRIO is known to be in
a working state.  If you have devices connected to SRIO which support
more advanced operation, you can perform more detailed probing.  The
exact sequence to perform varies based on the connected device.  The
following section give a brief overview of some of the functions
available in the BDK.

SRIO#: Send a doorbell
^^^^^^^^^^^^^^^^^^^^^^

Send a SRIO doorbell to a device.  Prompts will request the device ID
to access, transaction format (8 or 16 bit), the priority if the
doorbell (0-3), and the doorbell data (a 16bit number).

SRIO#: Receive a doorbell
^^^^^^^^^^^^^^^^^^^^^^^^^

Displays a list of all doorbells received.

SRIO#: Perform a memory read
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TBD

SRIO#: Perform a memory write
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TBD


Step 12 - Configure DDR
-----------------------

TBD


Step 13 - Test DDR
------------------

TBD


Step 14 - Test NAND
-------------------

TBD


Step 15 - Test USB
------------------

TBD


Step 16 - Test GPIO
-------------------

TBD

Next Steps
----------

After completing the test steps outlined in this document, most board
I/O interfaces have been validated.  With working DDR3 and validated
I/Os, software development can start on the board.  Software should
burn the normal bootloader into NOR flash, overwriting the BDK.  This
can be done either using a flash programmer, or the flash menu in the
BDK.

.The Flash Menu
----
include::flash_menu.capture[]
----

View flash::

Dumps the contents of flash in a hexadecimal dump.

Write flash::

Allows writing a file directly to flash.  Refer to the general BDK
documentation for information about files.

TIP: During the software development process it can be useful to have
known good binaries that exersize the board.  Keep the BDK around as
it makes a good test bench.  One board running the BDK can be used to
help debug software running on another board.
