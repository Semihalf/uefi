//
// This is a asciidoc document. Edit here, but view the HTML
//

= Internals

Overview
--------

This document goes through the internal details of the BDK.  Its
purpose is to help people writing applications understand how the BDK
works.  Users of the BDK's binary applications do not need these
details.  The BDK supplies a standard C programming environment with
as few hardware requirements as possible.  BDK applications can be run
directly from flash without any other software.  DRAM is optional.

=== Key Aspects of the BDK Programming Environment
* Full C library supplied using newlib.
* Run from flash and L2 before DRAM is available.
* Threaded programming model.
* Stack, globals, and heap variables can be used for DMA.
* Standard C file operations are used to present a simple filesystem.
* Single library (libbdk.a) needed for linking.
* Full 64bit programming model.
* One single file, bdh.h, defines all API functions.
* Complex makefile details abstracted out into a common include (bdk.mk).

=== BDK layout

.docs/
	All documentation for the BDK.

.libbdk-arch/
	Library and C files related to OCTEON II architecture. This
	contains the minimal code needed to write any code for OCTEON II
	with the minimal amount of abstractions as possible. This contains
	CSR and assembly defines and access functions . Higher level APIs
	are not part of this library.

.libbdk-dram/
	Library and C files related to OCTEON II DRAM initialization. These
	files are meant to be shared by all loaders and early diagnostics
	that need to setup DRAM.

.libbdk-hal/
	Library and C files providing a API for interfacing with OCTEON II
	hardware. This is similar to the "executive" in the OCTEON SDK.

.libbdk-lua/
	Libraries for accessing OCTEON hardware from the Lua scripting language.

.libbdk-os/
	System call support and initialization code required for the C library
	to function.

.libbdk/
	This is a combined library and single header file for using all of
	the libbdk-* features. Normally, this contains the only C header
	and library that applications should ever reference. Make sure bdk.h
	is the very first line in C files to make sure the precompiled header
	works properly.

.libc/
	The Newlib C library configured for use with the BDK. Most all C
	standard library functions are supported.

.liblua/
	The Lua scripting language library http://www.lua.org/.

.bdk-boot/
	The main BDK application that starts a menu driven Lua environment.

.rom/
	All files in here are included into BDK applications for access using
	standard filesystem calls.


Build Dependencies
------------------

For Debian 6.0 (Squeeze), the following packages msut be installed to
build the BDK.

* subversion-tools
* build-essential
* swig
* gcc-multilib
* asciidoc 8.6.5
* doxygen 1.7.1
* graphviz
* luarocks

Install these luarocks.

[source, sh]
----
sudo luarocks install lua-discount
sudo luarocks install penlight
sudo luarocks install markdown
----


Memory Management
-----------------

The BDK does all memory management using the standard C library.  No
special functions are needed for allocating DMA buffers, or other
large block of memory.  The most useful library functions are:

=== Memory Functions
* void *memalign(size_t boundary, size_t size);
* void *calloc(size_t nmemb, size_t size);
* void *malloc(size_t size);
* void free(void *ptr);

The function "memalign" should be used for most DMA buffer
allocations.  The convenient FPA functions use it internally.
Conversion between pointers an OCTEON physical address are done using
*bdk_ptr_to_phys()* and *bdk_phys_to_ptr()*.

uint64_t bdk_ptr_to_phys(void *ptr)::

Convert a C pointer into an OCTEON physical address.  This works on
stack data, global variables, heap data, and even code.  Note that
there is a performance impact for using the function on global
variables and code.  It is fastest when used with stack and heap data.

void *bdk_phys_to_ptr(uint64_t physical_address)::

Convert an OCTEON physical address into a C pointer.  This function is
quite fast as all it does is translate the address into XKPHYS.  Note
that "*bdk_phys_to_ptr(bdk_ptr_to_phys(foo))*" may not be equal to the
original address of "foo".  The result of
"*bdk_ptr_to_phys(bdk_phys_to_ptr(paddr))*" is guaranteed to be "*paddr*".


Threading
---------

The BDK takes a major departure from the OCTEON SDK by choosing a
multi-threaded model of execution versus a forked model.  Threads are
implemented on a low overhead cooperative threading scheme.  A thread
only yields execution specifically with a call to *bdk_thread_yield()*.
Most functions that stall in the BDK automatically yield for you.  In
a multi-core environment, threads will be schedule simultaneously on all
available cores.  Each core runs the next available thread in round
robin fashion.  You can specify a core mask to control which cores a
thread can run on, but you normally specify zero and let the scheduler
figure it out.

=== Thead Functions
void bdk_thread_yield(void)::

Yield execution to another thread.

int bdk_thread_create(uint64_t coremask, bdk_thread_func_t func, int arg0, void *arg1);::

Create a new thread running 'func(arg0, arg1)'. Both 'arg0' and 'arg1' can be
anything the application wants. The thread will run on the next 'yield'.

void bdk_thread_destroy(void);::

Kill the current thread of execution. Normally a thread automatically
dies when its initial function returns. This allows premature
termination of thread.


Filesystem
----------

The BDK provides standard system calls for filesystem access.  The
filesystem supports multiple types of files accessed through virtual
name spaces.  Any file may be accessed using either the standard
system calls (open, read, write, close, etc) or the higher level C
interface (fopen, fread, fwrite, fclose, etc).  More detail is available
in the link:bdk.html[BDK documentation].


Abstract Network Packet API
---------------------------

The BDK provides a high level interface to all packet based interfaces
that are similar to ethernet.  OCTEON's SGMII, XAUI, RGMII, ILK, Loop
devices, and PCIe engines are all available through this common
interface.

=== Packet Functions
int bdk_if_init(void)::

Initialize all packet interfaces of all types for use.  This is the
one call needed to get all interfaces configured.  Enable needs to be
called on each handle before actual packets flow.

int bdk_if_num_interfaces(bdk_if_t iftype)::

Get the number of interfaces for the given type.

int bdk_if_num_ports(bdk_if_t iftype, int interface)::

For a given interface, return the number of ports supported by that
interface.

bdk_if_handle_t bdk_if_next_port(bdk_if_handle_t handle)::

Get the next valid port handle after the supplied handle.  Returns the
first port handle when argument is NULL.  This meant to make it easy
to write loops that iterate over ports.

int bdk_if_enable(bdk_if_handle_t handle)::

Enable the given port for packet I/O.

int bdk_if_disable(bdk_if_handle_t handle)::

Disable the given port for packet I/O.

bdk_if_link_t bdk_if_link_autoconf(bdk_if_handle_t handle)::

Get the link status for the port and configure it for that speed.

const bdk_if_stats_t *bdk_if_get_stats(bdk_if_handle_t handle)::

Get the interface RX and TX counters.

int bdk_if_transmit(bdk_if_handle_t handle, bdk_if_packet_t *packet)::

Send a packet.

int bdk_if_receive(bdk_if_packet_t *packet)::

Receive a packet from any enabled interface.

void bdk_if_free(bdk_if_packet_t *packet)::

Free a packet back to the FPA pools.

=== Example looping through all Network Interfaces

The following code loops through all supported network interfaces and
enables them.  The *switch* statement shows an example of how to do
custom operations based on the type of interface.

[source,c]
----
for (bdk_if_handle_t handle = bdk_if_next_port(NULL); handle != NULL; handle = bdk_if_next_port(handle))
{
    switch (bdk_if_get_type(handle))
    {
	case BDK_IF_SGMII:
	case BDK_IF_XAUI:
	    ...
	    break;
	default:
	    break;
    }
    bdk_if_enable(handle);
}
----


Creating a standalone application
---------------------------------

Building BDK applications also requires the SDK tools (OCTEON specific
compiler, linker, libraries, and other tools) which need another set of
environment variables. To set these up, run the SDK's env-setup script
with the appropriate arguments (see the SDK documentation for  details).

Code
~~~~

Your C code needs have the following line as the first line. The BDK include must be
first to make sure the GCC precompiled header support is triggered. This allows
us to save compile time as the BDK headers are quite long.

.Required Include
[source,c]
----
#include <bdk.h>
----

.The classic Hello World application
[source,c]
----
#include <bdk.h>
#include <stdio.h>
int main(int argc, const char *argv[])
{
    printf("Hello World\n");
    return 0;
}
----

Make
~~~~

The compiler command lines for creating BDK applications is quite
complex.  To simplify the use of the BDK, an include file for 'make' is
included.  Once this file is included inside your 'Makefile', building
the application is very easy.

.Sample Makefile for Traffic-gen
[source,sh]
----
include $(BDK_ROOT)/libbdk/bdk.mk

traffic-gen.bin: traffic-gen
traffic-gen: traffic-gen.o $(BDK_ROOT)/libbdk/libbdk.a

clean:
	rm -f *.o traffic-gen traffic-gen.bin
----

The make system attempts to handle dependencies automatically.

TIP: The environment variable *BDK_ROOT* must be defined to the top level
	BDK directory.


Running an Application
~~~~~~~~~~~~~~~~~~~~~~

.Ways you can run an application
* Burn it to the beginning of flash
* Burn it using the bootloader.  A BDK image can be burned using the
	standard Uboot 'bootloaderupdate' command.  It will replace the normal
	bootloader, but the failsafe image will still be there.
* Jump directly to the code. Use the bootloader 'go' command to execute the
	image from anywhere.

TIP: Uboot's 'go' command doesn't work for addresses above 256MB.


The BDK API
-----------

The BDK contains many functions to support OCTEON code development.
Here is a short list of the major areas:

TIP: The doxygen generated link:api-docs/html/modules.html[BDK API Reference] can be useful.

CSRs
~~~~

.Useful CSR related defines and functions
BDK_CSR_DEFINE(name, csr)::

This macro makes it easy to define a variable of the correct type for a CSR.

BDK_CSR_INIT(name, csr)::

This macro makes it easy to define a variable and initialize it with a CSR.

BDK_CSR_READ(csr)::

Macro to read a CSR. Does the right thing for 'all' types of CSRs (32bit, 64bit, config, etc).

BDK_CSR_WRITE(csr, value)::

Macro to write a CSR. Does the right thing for 'all' types of CSRs (32bit, 64bit, config, etc).

BDK_CSR_MODIFY(name, csr, code_block)::

Macro to make a read, modify, and write sequence easy. The 'code_block'
should be replaced with a C code block or a comma separated list of
'name.s.field = value'.

BDK_CSR_WAIT_FOR_FIELD(csr, field, op, value, timeout_usec)::

This macro spins on a field waiting for it to reach a value. It
is common in code to need to wait for a specific field in a CSR
to match a specific value. Conceptually this macro expands to:
. Read csr
. Check if ('csr'.s.'field' 'op' 'value')
. If #2 isn't true loop to #1 unless too much time has passed.

Signalling Errors
~~~~~~~~~~~~~~~~~

The BDK supplies a few function to make error reporting more standardized.

.Error reporting
* void bdk_fatal(const char *format, ...);
* void bdk_error(const char *format, ...);
* void bdk_warn(const char *format, ...);
* bdk_warn_if(expression, format, ...);

Lua Scripting
-------------

The BDK contains the scripting environment Lua.  Lua allows you to
write simple scripts to easily control OCTEON tests and perform remote
operations.  Take a look at the link:lua/readme.html[documentation for
Lua] for more information about the Lua language.  Many BDK functions
can be called from Lua.  Under the Lua environment, a module _octeon_
is supplied.

TIP: The link:lua/contents.html[Lua Reference] can be useful.

Checking OCTEON Models
~~~~~~~~~~~~~~~~~~~~~~
octeon.is_model()::

Check which OCTEON model you are using. Pass it one of the following:

* octeon.CN70XX
* octeon.CN78XX

Calling BDK Functions
~~~~~~~~~~~~~~~~~~~~~
octeon.c.bdk_*::

Many BDK functions are exported to Lua.  The functions are exported by
searching the symbol table at compile time, so not all functions are
useful.  You must be careful to get the arguments right as Lua doesn't
do any checking.

.Find the current core clock rate
[source,lua]
----
print (octeon.c.bdk_clock_get_rate(0))
----

CSR Access
~~~~~~~~~~
octeon.csr()::

Returns an iterator suitable for use with a _for_ loop. The following code
will print out the possible CSR names:

.List all CSRs from Lua
[source,lua]
----
for name in octeon.csr()
do
    print (name)
end
----

octeon.csr.NAME.read()::

Read a CSR and return its raw value.  _NAME_ is any valid CSR name.
The code above will display the valid CSR names.

.Read the CIU_FUSE register
[source,lua]
----
print (octeon.csr.CIU_FUSE.read())
----

octeon.csr.NAME.write(value)::

Write a raw CSR value.  _NAME_ is any valid CSR name.
The code above will display the valid CSR names.

.Force a soft reset
[source,lua]
----
octeon.csr.CIU_SOFT_RST.write(1))
----


Boot Sequence
-------------
__start(bdk-start.S)::

Main entry point for the code.  Can be installed at the reset vector,
chain loaded from an 64KB aligned address in flash, or jump to in
memory.  This is just a branch it *__init* so the first part of the
image can use a standard bootloader image header.

__init(bdk-start.S)::

First real code.  Setup CVMSEG to act as a stack and jump into the C
function *bdk_init()*.  Note that the first argument for bdk_init is the
actual run address if the function.  This will be different from the
functions link address as the TLB has not been setup.

bdk_init(bdk-init.c)::

First C code run.  This function can only use a limited subset of the
C language since it is running from a different address than it was
linked at.  At a low level, the 'code must not contain jump
instructions'. The codes finishes the low level initialization enough
that normal C code is capable of running. It does the following:
* Sets up early COP0 requirements.
* Flushes the TLB.
* Sets up the TLB for running C code.
* Flushes the Icache.
* If running from flash, relocates chip select 0 such that the image
is aligned properly in memory to match the TLB.
* Jumps through *bdk_init_trampoline* to transfer out of the bootbus.

bdk_init_trampoline(bdk-start.S)::

Low level assembly function used to program the bootbus chip select
zero and jump to the real C code *bdk_init_stage2*.  The trampoline is
needed as you can't change the bootbus configuration while you are
running from it.

bdk_init_stage2(bdk-init.c)::

This is the first C code running where the text segment is fully
setup.  Function calls now work as expected.  These steps are performed:
* Uart0 is initialized.
* The BDK banner is displayed.
* Exception handlers are installed.
* Global data banner is displayed.
* The data segment is relocated to L2/DRAM.
* Clearing BSS banner is displayed.
* BSS segment is zeroed.
* Display a message about the main thread.
* Initialize threading and create a thread for *main()*.
* Display the scheduler banner.
* Do any final COP0 setup by calling *__bdk_init_cop0()*.
* Transfer control to the main thread.

__bdk_thread_body(bdk-thread.c)::

This function takes control right before *main()* is run. It does the
common initialization needed by all threads.

main(int argc, const char*argv[])::

Control transfers to the normal C main.


Bootbus Memory Map
~~~~~~~~~~~~~~~~~~

The following table details the layout of a BDK application in NOR
flash.  The table assumes the application is installed at the reset
vector.  Since the BDK dynamically maps itself, applications can be
located anywhere in flash.

.Flash Physical Layout
[options="header"]
|==========================================================================
|Address	|Description
|1FC0 0000	|Reset code and image header
|1FC0 0200	|TLB
|1FC0 0280	|XTLB
|1FC0 0300	|Cache Error
|1FC0 0380	|General Exception
|1FC0 0400	|Interrupt
|1FC0 0480	|EJTAG Debug
|1FC0 0500	|Unused
|1FC0 2000	|BDK boot code, followed by data, followed by code
|==========================================================================


L2/DRAM Memory Map
~~~~~~~~~~~~~~~~~~

After a BDK application relocates into DRAM, the following table describes
the physical and virtual layout.

* Exception vectors use KSEG0, Kernel unmapped
* Data uses KSSEG, Supervisor mapped
* Code uses KSEG3, Kernel mapped
* Heap uses XKSEG, 64bit kernel unmapped

[options="header"]
|==========================================================================
|Physical	|Virtual	|Description
|0000 0000	|8000 0000 	|(kseg0) TLB (EPC)
|0000 0080	|8000 0080	|(kseg0) XTLB (EPC)
|0000 0100	|A000 0100	|(kseg1) Cache Error (ErrorEPC)
|0000 0180	|8000 0180	|(kseg0) General Exception (EPC)
|0000 0200	|8000 0200	|(kseg0) Interrupt (EPC)
|0000 0280	|8000 0280	|Zero padding to the beginning of data
|0000 0500	|8000 0500	|Remote console
|0000 0700	|8000 0700	|Unused
|0000 1000	|8000 1000	|4KB for Uboot environment (Address hard coded in Uboot)
|0000 2000	|8000 2000	|(kseg0) Init code
|0000 2xxx	|C000 2xxx	|(ksseg) Data starting after init code
|...            |               |
|0xxx x000	|Exxx x000	|(kseg3) Code cache line aligned
|...            |               |
|0xxx xxxx	|XKPHYS		|(xkphys) Start of heap, after code
|1000 0000	|B000 0000	|(kseg1) Bootbus
|2000 0000	|XKPHYS		|(xkphys) Rest of memory
|==========================================================================


TLB
~~~

BDK uses two wired TLB entries, currently 4MB each.  The two entries
point to the same 4MB region starting at zero.  The first TLB entry
maps the code starting at virtual address 0xE0000000.  The second TLB
entry maps the data starting at virtual address 0xC0000000.  All other
TLB entries are invalid.

[options="header"]
|==========================================================================
|Virtual	|Physical	|Size	|Description
|E000 0000	|0000 0000	|4MB	|Code in L2/DRAM
|C000 0000	|0000 0000	|4MB	|Data in L2/DRAM
|==========================================================================

Notes
~~~~~
* Init code copies the entire image very early, before the TLB is setup.
* BDK images can start at any alignment. They immediately relocate to zero.
* Install bootbus region on reset vector to report reset/NMI. A real chip
	reset will move it out of the way automatically.
