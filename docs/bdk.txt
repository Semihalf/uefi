
Bringup and Diagnostic Kit
==========================

Overview
--------

The "Bringup and Diagnostic Kit" (BDK) is a set of executables and
scripts designed to ease the bringup of new hardware based on Cavium
Networks line of Octeon processors.  To ease development and increase
maintainability, diagnostics are written in a high level scripting
language, Lua.  Lua was chosen due to its simple syntax, ease of
integration with C, and small resource requirements.  The BDK is
capable of running a full interactive Lua environment from L2 cache
before DRAM is configured.

.Features of the BDK
* Simple menu driven interface for testing many IOs.
* Built in traffic generation for ethernet based IOs.
* Many IOs can be tested before DRAM is configured.
* Prebuilt known good binaries for booting new hardware.
* Easy automation of tasks through scripts running on a PC.
* Fast PC based test development using a remote board.
* GUI based interactive script debugger.
* Lua remote procedure calls over serial.
* Remote booting over PCIe and EJTAG.


.The directory layout of the BDK

bin/::

All host binaries and scripts.

docs::

All documentation for the BDK.

readme.txt::

Short description of the BDK.

rom/::

All files in here are included into BDK applications for access using
standard filesystem calls.

target-bin/::

All binaries, ELF files, and memory maps for use on Octeon targets.

version.txt::

Version of the BDK


Host Scripts and Utilities
--------------------------

Before running any BDK scripts or executables, the shell environment needs
to be setup. The following example works for Bash and other Bourne shell
derivatives.

.Setup the environment for the BDK
[source, sh]
----
export BDK_ROOT=`pwd`
export PATH=${PATH}:${BDK_ROOT}/bin
----


bdk-lua
~~~~~~~

The BDK supplies the executable *bdk-lua* for scripting on a host PC.
This should be used for the shell to execute Lua scripts for remote
controlling Octeon either on the command line, or through scripts.

.Usage for *bdk-lua*
----
usage: bdk-lua [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  --       stop handling options
  -        stop handling options and execute stdin
----

bdk-debug
~~~~~~~~~

Lua scripts can be interactively debugged using the *bdk-debug*
script.  Start your Lua scripts as follows to debug them:

----
bdk-debug <script.lua> <script arguments>
----

image::bdk-debug.png[bdk-debug screenshot]

The *bdk-debug* user interface is divided into four regions.

* The 'cyan' area contains the current call stack.  The active stack
entry is in bold.  Use the *up* and *down* commands to flip through
the stack.

* The 'green' area contains all local variables in the current stack
frame.  Note that Lua variables start their scope at the definition
line, so functions and variables don't show up until you execute their
definitions.

* The 'blue' area contains the source code for the current stack
context.  Breakpoints are highlighted in red.  The current line is
shown in bold.

* The uncolored region contains program and debugger output along with
the debugger command line.

.Commands supported by *bdk-debug*
----
help     Show this help
s        Step into
n        Step over
c        Continue
b        Insert or list breakpoints
db       Delete breakpoint
up       Move up the call stack
down     Move down the call stack
quit     Quit the debugger
Empty line is the same as step.
----


bdk-remote
~~~~~~~~~~

The script *bdk-remote* provides access to a remote Octeon from a host
PC.  The script requires that the environment variable
*OCTEON_REMOTE_PROTOCOL* be set to the appropriate value.  Simple
command line access to all Octeon registers, CSRs, memory, profiling
data, and remote booting is supplied.

.Usage for *bdk-remote*
----
bdk-remote:
    csr <csr>
        Read the named CSR and decode it.
    csr <csr> <value>
        Write the named CSR.
    csr <csr> <value> decode
        Decode <value> as if it were the named CSR.

    boot <filename>
        Boot <filename> on Octeon.
    reset
        Reset Octeon.

    core <core>
        Dump all CPU registers, COP0, and TLB entries for <core>.

    reg <core> <register>
        Read CPU <register> for <core>.
    reg <core> <register> <value>
        Write <value> to register <register> for CPU <core>.

    mem <address>
        Read eight bytes from <address>.
    mem <width> <address>
        Read <width> bytes from <address>.
    mem <width> <address> <value>
        Write <value> as <width> bytes to <address>.
    mem load <filename> <address>
        Load <filename> to <address>.
    mem save <filename> <address> <length>
        Save <length> bytes at <address> to <filename>.

    profile
        Profile all cores.
    profile <coremask>
        Profile cores in the supplied <coremask>.

    help
        Display this help.

Parameter descriptions:
    <csr>
        A name of a CSR, such as CIU_FUSE or CIU_INTX_SUM0(0).
    <value>
        A numeric value specified in either decimal or hexadecimal.
    <filename>
        Standard unix format file name.
    <core>
        Octeon CPU core number, starting at zero.
    <address>
        An Octeon physical memory address specified in either decimal or
        hexadecimal.
    <width>
        A byte width. Must be 8, 4, 2, or 1.
    <coremask>
        A decimal or hexadecimal number representing CPU cores. Each set bit
        represents a single CPU core. For example, 0x2f represents cores 0-3
        and 5.
    <register>
        One of the following CPU register names.
BadVAddr     Cause        Compare      Config       Config1      Config2
Config3      Config4      Context      Count        CvmCount     CvmCtl
CvmMemCt     DEPC         DESAVE       DcacheDataHi DcacheDataLo DcacheError
DcacheTagHi  DcacheTagLo  Debug        Debug2       EPC          Ebase
EntryHi      EntryLo0     EntryLo1     ErrorEPC     HWREna       IcacheDataHi
IcacheDataLo IcacheError  IcacheTagLo  Index        IntCtl       Kscratch1
Kscratch2    Kscratch3    MultiCoreDebugPRId         PageGrain    PageMask
PerfControl0 PerfControl1 PerfCount0   PerfCount1   PowThr       Random
SRSCtl       Status       UserLocal    WatchHi0     WatchHi1     WatchLo0
WatchLo1     Wired        XContext     a0           a1           a2
a3           a4           a5           a6           a7           at
gp           hi           k0           k1           lo           ra
s0           s1           s2           s3           s4           s5
s6           s7           s8/fp        sp           t0           t1
t2           t3           t8           t9           v0           v1
zero
----

bdk-update-header
~~~~~~~~~~~~~~~~~

The BDK and the Octeon SDK use a common header format at the beginning
of binary images.  The script *bdk-update-header* updates this header
for specified image file.

.Usage for *bdk-update-header*
----
Usage:
    bdk-update-header <filename>
----


Lua Scripting
-------------

The BDK contains the scripting environment Lua.  Lua allows you to
write simple scripts to easily control Octeon tests and perform remote
operations.  Take a look at the link:lua/readme.html[documentation for
Lua] for more information about the Lua language.  Many BDK functions
can be called from Lua.  Under the Lua environment, a module *octeon*
is supplied.

TIP: The link:lua/contents.html[Lua Reference] can be useful.


Executing Lua on the Host
~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK supplies the executable *bdk-lua* for scripting on a host PC.
This should be used for the shell to execute Lua scripts for remote
controlling Octeon either on the command line, or through scripts.

.Command line
[source,sh]
----
$ bdk-lua script.lua
----

.In scripts
[source,lua]
----
#!/usr/bin/env bdk-lua
print("Hello World!")
----

.Usage of *bdk-lua*
----
usage: bdk-lua [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  --       stop handling options
  -        stop handling options and execute stdin
----

.Printing the functions in a module
----
$ bdk-lua -l utils -e "pprint(table)"
----
.Output of *table* print
----
{
    concat = function
    foreach = function
    foreachi = function
    getn = function
    insert = function
    maxn = function
    pack = function
    remove = function
    sort = function
    sorted_keys = function
    sorted_values = function
    unpack = function
}
----

Executing Lua on the Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TBD

.Booting from NOR flash

Burn *bdk-boot/bdk-boot.bin* to the beginning of the NOR flash
connected to the bootbus chip select 0.

.Booting using *bdk-remote* over PCIe
[source, sh]
----
export OCTEON_REMOTE_PROTCOL=pci
bdk-remote boot bdk-boot/bdk-boot.bin
----

.Booting using Uboot
----
Octeon ebb6300# dhcp
Octeon ebb6300# setenv serverip 192.168.162.148
Octeon ebb6300# tftpboot 0x400000 bdk-boot.bin
Octeon ebb6300# go 0x400000
----


Interactive Lua on the Octeon Target
------------------------------------

The target side binary *bdk-boot.bin* supplies a text menu based
interface to board diagnostic functions.  Each menu expects a numeric
input selecting a valid choice from the list of options.  Generally
the last menu choice returns to the previous menu.  The entire
interactive menu interface is written in Lua for easy expansibility.
The source for the menus can be found in the *rom* directory.

.Main Menu
----
Bring and Diagnostic Kit (BDK)
Setting up global data
Clearing BSS
Transferring to thread scheduler
Performing common initialization
Enabling hardware flow control on UART0
Switching to main
Lua 5.2.0 (work5)  Copyright (C) 1994-2010 Lua.org, PUC-Rio

Octeon Bringup and Diagnostic Kit
Copyright (C) 2010-2011 Cavium Networks


=================================
Main Menu
=================================
 1) File options
 2) Flash options
 3) DDR options
 4) PCIe options
 5) Interactive Lua prompt
 6) Start remote call server
 7) TCP/IP networking
 8) Traffic Generator
 9) Reboot
Menu choice: (0INS)>
----

TIP: Any prompt supporting line editing in *bdk-boot.bin* also
supports RPC calls.  Whenever *bdk-boot.bin* is waiting for user
input, you can send a RPC request and get a response.


Line Editing
~~~~~~~~~~~~

Any prompt ending with `(0INS)>` supports full line editing and
history.  Line editing can also be used for any input using the
*octeon.readline()* function.

* Many vi style modes are available for command and history navigation.
* Use ARROW KEYS, HOME, END or ESC-h,ESC-j,ESC-k,ESC-l,ESC-0,ESC-$,ESC-w,ESC-b, or ESC-fx for navigation.
* Use TAB for command completion, multiple to cycle, or CTRL-D for a list of possible commands.
* Use ESC-i,ESC-A,ESC-a,ESC-c for insert mode, ESC-R,ESC-r for overwrite mode (behavior like vi).
* Use INSERT to toggle insert/overwrite mode, DELETE to delete, F1 for help.
* Use !!, !<num> or !<string> to repeat previous commands in the history.
* Use ::, :<num> or :<string> to recall previous commands in the history to current.
* Use ?<string>, /<string>, ESC-?<string>,ESC-/<string>,ESC-n,ESC-N to also recall to current.
* Use CTRL-l erase the screen, ESC-D to clear the rest of the current line.
* Use ESC-d<movement> to delete, ESC-~ to change case, ESC-u to undo (one level).
* See the vi man page for more info on the operation of various commands.

Configuring the TCP/IP Network Stack
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK contains a port of *lwip*, a light weight TCP/IP stack.  Once
a network interface is configured properly, TCP/IP networking can be
used to transfer data and view the console.  Configuration of the
network interfaces is performed through the 'TCP/IP Networking' option
in the main menu.  The BDK supports static IP addresses, DHCP, and the
zero configuration standard.

.TCP/IP Networking Menu
----
=================================
TCP/IP Networking Menu
=================================
 1) Show port configuration
 2) Configure MGMT0 with a static IP 10.0.0.2/24
 3) Configure a network port with DHCP
 4) Configure a network port with a static IP
 5) Configure a network port with auto IP
 6) Main menu
Menu choice: (1INS)>
----

The simplest way of using networking is to directly connect the board
under test to the development PC using a cable between first
management port and a dedicated ethernet port on the PC.  On the PC,
configure the ethernet port for IP address 10.0.0.1.  On the BDK,
choose option 2.

.Configure an extra ethernet device for direct connection
[source, sh]
----
/usr/bin/ifconfig eth1 10.0.0.1
----

TIP: More information about lwip can be found at link:http://savannah.nongnu.org/projects/lwip/[lwIP - A Lightweight TCP/IP stack].

The Virtual File System
-----------------------

The BDK provides standard system calls for filesystem access.  The
file system supports multiple types of files accessed through virtual
name spaces.  All files are accessible from both native C code and Lua
scripts.

Filesystem Namespaces
~~~~~~~~~~~~~~~~~~~~~

/rom/*::

All files located in *bdk/rom* are statically included into BDK
applications.  Each file can be read be prefixing the name of the file
with '/rom/'.  For example, the first Lua script run is located at
'/rom/init.lua'.

/ram/*::

This is an empty filesystem where applications are free to create
temporary files that are stored in dram.  For example, an application
could store temporary data in '/ram/data.tmp'.

/xmodem::

This is a special file that translates file accesses to reads or
writes to file transferred using XMODEM.  When opened for write the
file to be downloaded from Octeon.  When opened for read the file will
be uploaded to Octeon.  XMODEM, XMODEM-CRC, XMODEM-1K, and
XMODEM-1K-CRC are all supported.

/dev/uart/0::

This is a special device representing Octeon's first uart.  This is
the file that stdin, stdout, and stderr are connected to by default.

/dev/uart/1::

This is a special device representing Octeon's second uart.

/dev/nor/0::

Read and write access to a NOR flash connected to the bootbus using
chip select 0. If the application configures other bootbus regions to
access NOR flash, these can be accessed through '/dev/nor/*'.

/dev/mem::

Read and write access to DRAM.  The file location is a raw physical
address.

/dev/pcie/0::

Read and write access to memory on PCIe port 0.  The file location is a raw
PCIe bus address.

/dev/pcie/1::

Read and write access to memory on PCIe port 1.  The file location is a raw
PCIe bus address.

/tcp/host:port::

Opens a TCP connection to the supplied host and port.  File read/write
operations are mapped to TCP read and write.  This can be used in
combination with 'netcat' (nc) on a PC to transfer data using TCP/IP.
If the network interface was configured using DHCP, then name based
lookups are supported for *host*.  Note that *host* must be a *fully
qualified host name* or an IP address in *x.x.x.x* format.  *Port* is
a TCP port number in decimal.


Builtin TFTP Server
~~~~~~~~~~~~~~~~~~~

The BDK contains a TFTP server inside *bdk-boot.bin*.  It is
available as soon as you configure one of the network interfaces with
an IP address.  The server is very simplistic, expecting exact path
names from the remote client.  For getting files from *bdk-boot.bin*,
you will need to specify the full file system path.  For putting
files, you will need to specify the full remote path as well as
whatever local path needed for the source of the file.  The following
examples are using the *tftp-hpa* client supplied with Debian.  Most
other tftp clients are capable of similar operations although the
syntax differs per client.

.Sample TFTP transfer (Octeon -> Host)
[source, sh]
----
tftp 169.254.1.240 -c get /rom/ilua.lua
----

.Sample TFTP transfer (Host -> Octeon)
[source, sh]
----
tftp 169.254.1.240 -c put myscript.lua /ram/myscript.lua
----



Lua Modules
-----------

Lua functions are organized in terms of packages. Each package implements
many functions related to a specific task. Octeon's Lua contains the default
Lua packages along with some new packages specifically designed for remote
control and testing of Octeon based hardware.

.Lua Base Modules
[options="header"]
|==========================================================================
|Standard Lua Module	|Lua documentation
|Basic functions	|link:lua/manual.html#6.1[]
|coroutine		|link:lua/manual.html#6.2[]
|package		|link:lua/manual.html#6.3[]
|string			|link:lua/manual.html#6.4[]
|table			|link:lua/manual.html#6.5[]
|math			|link:lua/manual.html#6.6[]
|bit32			|link:lua/manual.html#6.7[]
|io			|link:lua/manual.html#6.8[]
|os			|link:lua/manual.html#6.9[]
|debug			|link:lua/manual.html#6.10[]
|socket			|link:luasocket/introduction.html[]
|==========================================================================

Host Modules Specific to Octeon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on a
host PC.

oremote
^^^^^^^

The *oremote* module provides functions for remotely controlling an
Octeon over PCI or EJTAG. This allows Lua scripts to remotely probe and
boot Octeon. Below is a list of the functions supported.

oremote.open(protocol, debug)::
 * protocol = Remote protocol or nil
 * debug = Debug level or nil
 * No return value
+
.Protocol format
[options="header"]
|==========================================================================
|Format			|Description
|PCI:<device>		|Use PCI/PCIe for <device>. Zero is the first Octeon.
|LINUX			|Assume Linux userspace native with direct access.
|GDB:<name>,<tcp_port>	|Use GDB remote protocol to communicate with Octeon.
|MACRAIGOR:<name>,<tcp_port>[,<jtag_speed>]	|Use Macraigor mpDemon EJTAG. Note the <tcp_port> is normally 1000. <jtag_speed> is optional and defaults to 1.
|==========================================================================

TIP: The *protocol* can also be set to *nil*.  When *nil*, the protocol
is read from the environment variable *OCTEON_REMOTE_PROTOCOL*.  Using
the environment variable to specify the protocol makes it easy for a
single script to support many protocols.  The parameter *debug* can
also be specified with *OCTEON_REMOTE_DEBUG*.

oremote.close()::
 * No return value

oremote.read_csr(csr)::
 * csr = Name of CSR as a string
 * Return csr value as a number

oremote.write_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number
 * No return value

oremote.decode_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number. If nil, a read_csr is done
 * No return value. Output goes to stdout

oremote.read_mem(address, length)::
 * address = Physical address to read
 * length = Number of bytes to read
 * Returns string of length

oremote.write_mem(address, bytes)::
 * address = physical address to write
 * bytes = string of bytes to write
 * No return value

oremote.get_model()::
 * Returns Processor ID register as number

oremote.start_cores(mask)::
 * mask = Bitmask of cores to start
 * No return value

oremote.stop_cores(mask)::
 * mask = Bitmask of cores to stop
 * No return value

oremote.get_num_cores()::
 * Returns the number of cores as a number

oremote.get_running_cores()::
 * Returns the bitmask of cores that are running

oremote.get_core_state(core)::
 * core = Core state to get, starting at 0
 * Returns table
 * table[1][1-256] = Normal registers
 * table[2][1-256] = COP0 reg * 8 + sel
 * table[3][1-128][1-4] = TLB

oremote.set_core_state(core, state)::
 * core = Core state to set, starting at 0
 * state = table of format from get_core_state
 * No return value

oremote.read_register(core, register)::
 * core = Core starting at 0
 * register = register number to get
 * Return register as number

oremote.write_register(core, register, value)::
 * core = Core starting at 0
 * register = register number to set
 * value = Register value
 * No return value

oremote.reset(stop_cores)::
 * stop_cores = Cores should stop after reset
 * No return value

oremote.get_sample(mask)::
 * mask = Bitmask of cores to get samples for
 * Return table of PC values indexed by core num+1

oremote.write_mem16(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem32(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem64(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.read_mem16(address)::
 * address = Physical address
 * Return data

oremote.read_mem32(address)::
 * address = Physical address
 * Return data

oremote.read_mem64(address)::
 * address = Physical address
 * Return data

oremote.csr()::

Returns an iterator that iterates through the possible CSR names.
+
.List all CSRs from Lua
[source,lua]
----
for name in oremote.csr()
do
    print (name)
end
----

oremote.csr.NAME.read()::

Read the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* Returns the CSR value

oremote.csr.NAME.write(value)::

Write the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* value = Value to write
* No return value.

oremote.csr.NAME.decode(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and returns a Lua table containing the fields.  If
*optional_value* is not supplied the actual value is read from the
hardware.
* optional_value = If supplied, value of CSR to decode.
* Returns a table of the decoded values.
+
.Decode example
[source, lua]
----
pprint(oremote.csr.ciu_fuse.decode())
----
+
.Decode output
[source, lua]
----
{
    FUSE = 63
    RESERVED_6_63 = 0
}
----

oremote.csr.NAME.encode(table)::

Converts a table of CSR fields into a CSR value and writes it to the
hardware.  The format of the table is identical to the *decode()*
format.  Missing fields are filled with zeros.
* table = Table of fields to encode.
* No return value.

oremote.csr.NAME.FIELD::

Reads the CSR and returns the value of a specific field.

oremote.csr.NAME.FIELD = value::

Performs a read, modify, and write of a CSR changing the specified field.


Target modules specific to Octeon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on
a target Octeon.

octeon
^^^^^^

octeon.is_model(model)::

Returns true if the current chip matches the supplied model.
* model = One of the `octeon.CN*` constants.
** octeon.CN63XX
** octeon.CN63XXP1
** octeon.CN63XXP2
** octeon.CN68XX
** octeon.CN68XXP1

octeon.BDK_CONFIG_*::

Constants for use with octeon.c.bdk_config_get() and
octeon.c.bdk_config_set().

octeon.csr()::

Returns an iterator that iterates through the possible CSR names.
+
.List all CSRs from Lua
[source,lua]
----
for name in octeon.csr()
do
    print (name)
end
----

octeon.csr.NAME.read()::

Read the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* Returns the CSR value

octeon.csr.NAME.write(value)::

Write the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* value = Value to write
* No return value.

octeon.csr.NAME.decode(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and returns a Lua table containing the fields.  If
*optional_value* is not supplied the actual value is read from the
hardware.
* optional_value = If supplied, value of CSR to decode.
* Returns a table of the decoded values.
+
.Decode example
[source, lua]
----
pprint(octeon.csr.ciu_fuse.decode())
----
+
.Decode output
[source, lua]
----
{
    FUSE = 63
    RESERVED_6_63 = 0
}
----

octeon.csr.NAME.encode(table)::

Converts a table of CSR fields into a CSR value and writes it to the
hardware.  The format of the table is identical to the *decode()*
format.  Missing fields are filled with zeros.
* table = Table of fields to encode.
* No return value.

octeon.csr.NAME.FIELD::

Reads the CSR and returns the value of a specific field.

octeon.csr.NAME.FIELD = value::

Performs a read, modify, and write of a CSR changing the specified field.

octeon.c.*::

Many low level C functions are directly exported through this
interface.  No argument checking is performed on these functions, so
it is very important to get the arguments correct.  Errors may crash
the system.

octeon.readline(prompt, completion, timeout_us)::
Prompt the user for input with full line editing and history. Useful for
creating interactive command lines and menus.
* prompt = Prompt to show the user
* completion = Should be nil for now (unsupported)
* timeout_us = Microseconds to wait for input, of zero for no timeout.


bdktrafficgen
^^^^^^^^^^^^^

The module *bdktrafficgen* allows Lua to generate and receive ethernet
traffic on all chip interfaces. A user friendly interactive interface is
available through *trafficgen.lua*.

bdktrafficgen.port_get(index)::
* index = 0 - .., sequential through ports.
* Return port_info_t or nil

bdktrafficgen.port_add(set, pinfo)::
* set = port_set_t to add port too.
* pinfo = port_info_t returned from *bdktrafficgen.port_get()*.
* No return value

bdktrafficgen.do_clear(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.do_reset(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.do_update(bool do_clear)::
* do_clear = boolean whether status should be cleared during update.
* Return zero on success, negative on failure.

bdktrafficgen.do_transmit(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.is_transmitting(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return true if any ports in the range are transmitting.

.bdktrafficgen.port_info_t fields
----
	string name
	port_setup_t setup
	port_stats_t stats
----

.bdktrafficgen.port_stats_t fields
----
    number    tx_packets
    number    tx_octets
    number    tx_packets_total
    number    tx_octets_total
    number    tx_bits

    number    rx_packets
    number    rx_octets
    number    rx_packets_total
    number    rx_octets_total
    number    rx_dropped_octets
    number    rx_dropped_packets
    number    rx_errors
    number    rx_bits
    number    rx_backpressure
    number    rx_validation_errors
----

.bdktrafficgen.packet_type_t enumeration
----
    PACKET_TYPE_IPV4_UDP
    PACKET_TYPE_IPV6_UDP
    PACKET_TYPE_IPV4_TCP
    PACKET_TYPE_IPV6_TCP
    PACKET_TYPE_802_3_PAUSE
    PACKET_TYPE_CBFC_PAUSE
    PACKET_TYPE_CJPAT
----

.bdktrafficgen.payload_t enumeration
----
    DATA_TYPE_ABC=0
    DATA_TYPE_ZERO
    DATA_TYPE_ONE
    DATA_TYPE_INC
    DATA_TYPE_DEC
    DATA_TYPE_RAND
----

.bdktrafficgen.port_setup_t fields
----
    int                     output_rate
    bool                    output_rate_is_mbps
    bool                    output_enable
    int                     output_packet_size
    number                  output_count
    trafficgen_packet_type_t output_packet_type
    trafficgen_payload_t    output_packet_payload
    number                  src_mac
    int32_t                 src_mac_inc
    number                  src_mac_min
    number                  src_mac_max
    number                  dest_mac
    int32_t                 dest_mac_inc
    number                  dest_mac_min
    number                  dest_mac_max
    number                  vlan_size
    uint8_t                 vlan[8]
    uint32_t                src_ip
    int32_t                 src_ip_inc
    uint32_t                src_ip_min
    uint32_t                src_ip_max
    uint32_t                dest_ip
    int32_t                 dest_ip_inc
    uint32_t                dest_ip_min
    uint32_t                dest_ip_max
    uint32_t                ip_tos
    uint16_t                src_port
    int16_t                 src_port_inc
    uint16_t                src_port_min
    uint16_t                src_port_max
    uint16_t                dest_port
    int16_t                 dest_port_inc
    uint16_t                dest_port_min
    uint16_t                dest_port_max
    bool                    do_checksum
    bool                    display_packet
    bool                    validate
    bdk_srio_tx_message_header_t srio
----

bdktrafficgen.port_set_t::

This is a opaque object that represents a set of port_info_t objects.
Use *bdktrafficgen.port_add()* and *bdktrafficgen.port_get()* to build
this.


Source based modules available on both Host and Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any modules written in pure Lua can be used on both the host and
target.  These modules are loaded using the standard *require()*
function call in Lua.  Here is a list of these extra modules provided
by Cavium Networks.

menu
^^^^

menu.show(choices)::
Show a menu to the user and prompt for a choice.
* choices = Table array of menu strings
* Return the selection number

rpc
^^^

This module allows you to make remote procedure calls to Lua.  All
target Lua functions and data can be accessed by a remote host.

.Example RPC client
[source,lua]
----
if #arg < 1 then
    print("You must specify the file to do RPC over. Example /dev/ttyS0")
    return
end

rpc = require("rpc")
r = rpc.connect(arg[1], arg[2])

for k in r.octeon.csr() do
    print(k)
end

print (r._VERSION)
r.foo = {1, 2, 3 ,4}
print("Length of new table:", #r.foo)
r.print("Hello World")
r.print(1, 2, nil, "foo", {foo=1}, true, false)
print("Octeon RCLK:", r.octeon.c.bdk_clock_get_rate(0))
print("Octeon SCLK:", r.octeon.c.bdk_clock_get_rate(1))
print("Octeon CIU_FUSE:", r.octeon.csr.ciu_fuse.read())
print("Is CN63XX?", r.octeon.is_model(r.octeon.CN63XX))
print("Is CN68XX?", r.octeon.is_model(r.octeon.CN68XX))
print("Lua mem:", r.collectgarbage("count"))
print("C mem:", r.octeon.get_sbrk() / 1024)
----

TIP: Lua garbage collection can cause issues with RPC.  The host
running the RPC client normally has lots more memory than the Octeon
RPC target.  This can cause Lua to not garbage collect old RPC
objects.  Since the RPC server can't free objects until the client
releases all references, this can cause the client to run out of
memory.  Simply calling *collectgarbage()* in the client periodically
can solve this issue.

TIP: Any prompt supporting line editing in *bdk-boot.bin* also
supports RPC calls.  Whenever *bdk-boot.bin* is waiting for user
input, you can send a RPC request and get a response.

rpc.connect(instream, outstream)::
Create a RPC connection to a remote Octeon.
* instream = Lua IO stream for input, a host:port for TCP, or a filename to open. (Example: `/dev/ttyS0`)
* outstream = Lua IO stream for output, a host:port for TCP, or a filename to open. (Example: `/dev/ttyS0`). If nil, then instream is used.
* Return value is an RPC object to make calls with.

rpc.serve(instream, outstream)::
Wait for RPC commands and execute them.
* instream = Lua IO stream for input, or a filename to open. (Example: `/dev/ttyS0`)
* outstream = Lua IO stream for output, or a filename to open. (Example: `/dev/ttyS0`). If nil, then instream is used.
* No return value.

strict
^^^^^^

Cavium Networks provides the *strict* module written by Thomas Lauer
to help in writing scripts.  By default Lua considers any new variable
names to be global.  This can make typos and programming errors very
difficult to find.  The *strict* module changes this behavior so that
all variables must be specifically defined.  Cavium Networks recommends
this to promote more robust script development.  Below is the original
description from Thomas Lauer.

----
* Lua Strict by Thomas Lauer
* http://thomaslauer.com/comp/LuaStrict

Strict implements a somewhat stricter handling of global variables than
Lua. There are two basic modes: weak and strong. In the weak mode you
don't need to declare a global but you'd have to initialize it in the
main part of your program (i.e not inside a function).

In strong mode anything not formally declared  (including non-local
functions) gets the whip.

See the examples for more on how to use the module.

Anything wrong or not working? An idea how to make this better? Please
send comments to thomas.lauer@gmail.com or visit my contact page:
http://thomaslauer.com/start/Contact.
----

utils
^^^^^

The *utils* module is a set of Lua functions written by Cavium
Networks to ease writing scripts that deal with Octeon's registers.
Below is a list of the functions provided.

printf::

C style printf function.  printf("format", ...).  See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.

str = "format" % {...}::

Python style string formatting.See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.
* str = "format" % value
* str = "format" % {...}

pprint(...)::

Pretty print and data in a human readable format.  Tables are printed
recursively.

table.sorted_keys(table)::

Return a table's keys in sorted order.

table.sorted_values(table)::

Return a table's values in sorted order.

isglobal(variable_name)::

Determine if a global variable is defined. Use this function to check if
a global is defiend without setting off the *strict* module checking. This
is a useful to automatically switch to RPC when running remotely.
* variable_name = String name of a variable to check.
* Returns true if the global exists, false if it doesn't exist.
+
[source,lua]
----
local csr
if isglobal("octeon") then
    -- We're running natively on Octeon
    csr = octeon.csr
else
    -- We're running remotely. Assume arg[1] is where we should connect to
    local rpc = require("rpc")
    local remote = rpc.connect(arg[1])
    csr = remote.octeon.csr
end
print(csr.CIU_FUSE.FUSE)
----

pcie
^^^^

The *pcie* module provides access to PCIe bus initialization, scanning,
and enumeration to Lua scripts.  The function *pcie.initialize(port)*
returns a *pcie_root* object.  This object can then be used to perform
operations on the PCIe port.

pcie_root = pcie.initialize(pcie_port)::

Initialize a PCIe root complex port and bring the link up.  The return
value is a *pcie_root* object for use in the calls below.
* pcie_port = Hardware port to initialize (0 - 1)
* Returns a pcie_port object or throws an error on failure

pcie_root:scan()::

Scan a PCIe root complex for all devices attached.

pcie_root:enumerate()::

Assign address regions and other resources to all device on the PCIe
root complex.  If *scan()* has not already been called, a device scan
will be performed before enumeration.

pcie_root:display()::

Display all devices on the PCIe root complex in a human readable
format.

pcie_root:get_devices()::

Get an array containing all devices on the PCIe root complex.  Each
*pcie_device* in the array is a PCIe function directly connected to
Octeon.  If the device is a bridge/switch then *pcie_device.isbridge*
will be *true* and *pcie_device.devices* will be an array containing
all children of the device.

pcie_root:shutdown()::

Shutdown a PCIe root complex.

value = pcie_device:read8(config_register)::

Read an 8 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

value = pcie_device:read16(config_register)::

Read a 16 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

value = pcie_device:read32(config_register)::

Read a 32 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

pcie_device:write8(config_register, value)::

Write an 8 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:write16(config_register, value)::

Write a 16 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:write32(config_register, value)::

Write a 32 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:display()::

Display a device and all of its children.

pcie_device:isbridge::

Set to *true* if the device is a switch or bridge, otherwise set to *false*.

bit64
^^^^^

The module *bit64* is specific to the Octeon BDK.  It supports
standard bit operations on 64 bit numbers.  In general this should be
used instead of *bit32*.

output = bit64.arshift(input, shift)::

Perform arithmetic right shift.

output = bit64.band(input1, input2, ...)::

Bitwise AND all arguments together and return the result.

output = bit64.bnot(input)::

Bit invert the input.

output = bit64.bor(input1, input2, ...)::

Bitwise OR all arguments together and return the result.

output_bool = bit64.btest(input1, input2, ...)::

Bitwise AND all arguments together and return true if any bits are set.

output = bit64.bxor(input1, input2, ...)::

Bitwise XOR all arguments together and return the result.

output = bit64.lrotate(input, shift)::

Perform rotate left.

output = bit64.lshift(input, shift)::

Perform left shift.

output = bit64.rrotate(input, shift)::

Perform rotate right.

output = bit64.rshift(input, shift)::

Perform right shift, filling zeros on the left.


fileio
^^^^^^

The BDK supports access to many hardware blocks through virtual device
files.  The module *fileio* provides simple functions for common file
operations with error checking.  Any error causes a Lua error() to be
raised.

handle = fileio.open(filename, mode, seek_to)::

Open a file and optionally seek to a location.
* filename = Name of the file to open
* mode = Lua io.open() mode
* seek_to = Optional seek location, may be nil.
* Returns a file handle or throws an error.

transfer_count = fileio.transfer(source_handle, dest_handle, length)::

Transfers bytes from one file to another.
* source_handle = Source file handle to transfer from.
* dest_handle = Destination file handle to transfer to.
* length = Optional length to transfer. If nil, all bytes until the end of source_handle are transferred.
* Returns the number of bytes transferred or raises as error.

transfer_count = fileio.copy(source, source_seek, dest, dest_seek, length)::

Copy part of one file into another file.
* source = Source filename.
* source_seek = Optional start location in source. Use nil to start at the front.
* dest = Destination filename.
* dest_seek =  Optional start location in dest. Use nil to start at the front.
* length = Optional length to transfer. If nil, all bytes until the end of source are transferred.
* Returns the number of bytes transferred or raises as error.

fileio.hexdump(source, seek_to)::

Displays a file in hex on the console.
* source = File to display
* seek_to = Optional seek start location, may be nil.


Lua Scripting Tips
------------------

Writing scripts in Lua for either the host or target is a powerful way
of developing board bringup and diagnostic tools.  A few scripting
tips and guides can make your scripts much easier to write and
maintain.  Here are a few recommendations from Cavium Networks.

Use */usr/bin/env* to find *bdk-lua*::

The location of the BDK installation may change over time.  Use the
*PATH* environment variable to find the Lua binary for you.  Adding
the following line to the beginning of all your scripts will allow you
to make them directly executable.
+
[source,sh]
----
#!/usr/bin/env bdk-lua
----

Use the *strict* module::

Variables are automatically created as global by default in Lua.  This
can cause simple typographical errors to be very difficult to find.  A
misspelled variable name will silently create a new global variable,
which isn't particularly helpful.  The module *strict* forces variables
to be defined.  It also promotes the use of local variables, which will
make your scripts more modular and easier to maintain.
+
[source,lua]
----
require("strict")
----

Use the *utils* module::

The default *print()* function in Lua is very primitive.  For example,
it won't display the contents of a table.  The *utils* module contains
a number of functions to make your life easier.  The *printf()* and
*pprint()* functions are exceedingly useful.
+
[source,lua]
----
require("utils")
----

Use the *csr* module on *oremote* and *octeon* interchangeably::

Note that the syntax of the oremote.csr.* operations and the
octeon.csr.* operations are exactly the same.  Use this to your
advantage to make scripts portable between the host and target.
+
[source,lua]
----
require("utils")
local csr
if isglobal("octeon") then
    csr = octeon.csr
else
    csr = oremote.csr
end
pprint(csr.ciu_fuse.decode())
----

Use the *rpc* module to develop scripts before running on the target::

TBD


Lua Startup Sequence on Octeon
------------------------------

The following details which Lua scripts are executed on Octeon during
boot of the BDK.

. bdk-boot.bin binary boots.

. */rom/init.lua* is executed.
+
[source,lua]
----
include::../rom/init.lua[]
----

. */rom/main.lua* is executed.
+
[source,lua]
----
include::../rom/main.lua[]
----

. Board specific file is loaded.
+
[source,lua]
----
include::../rom/board-ebb6300.lua[]
----

