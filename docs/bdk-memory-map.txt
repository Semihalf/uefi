//
// This is a asciidoc document. Edit here, but view the HTML
//

Bootbus Memory Map
------------------

The following table details the layout of a BDK application in NOR
flash.  The table assumes the application is installed at the reset
vector.  Since the BDK dynamically maps itself, applications can be
located anywhere in flash.

TIP: Currently BDK applications must be aligned on a 4MB boundary.
	This may change in the future.

.Flash Physical Layout
[options="header"]
|==========================================================================
|Address	|Description
|1FC0 0000	|Reset init boot code. Never copied to L2/DRAM. (Error EPC)
|1FC0 0200	|TLB (EPC)
|1FC0 0280	|XTLB (EPC)
|1FC0 0300	|Cache Error (Error EPC)
|1FC0 0380	|General Exception (EPC)
|1FC0 0400	|Interrupt (EPC)
|1FC0 0480	|EJTAG Debug (DEPC)
|1FC0 0500	|Data starting after Exception Vectors
|...            |
|1FCx x000	|Code 4K Aligned
|==========================================================================


L2/DRAM Memory Map
------------------

After a BDK application relocates into DRAM, the following table describes
the physical and virutal layout.

* Exception vectors use KSEG0, Kernel unmapped
* Data uses KSSEG, Supervisor mapped
* Code uses KSEG3, Kernel mapped
* Heap uses XKSEG, 64bit kernel unmapped

[options="header"]
|==========================================================================
|Physical	|Virtual	|Description
|0000 0000	|8000 0000 	|(kseg0) TLB (EPC)
|0000 0080	|8000 0080	|(kseg0) XTLB (EPC)
|0000 0100	|A000 0100	|(kseg1) Cache Error (ErrorEPC)
|0000 0180	|8000 0180	|(kseg0) General Exception (EPC)
|0000 0200	|8000 0200	|(kseg0) Interrupt (EPC)
|0000 0280	|8000 0280	|Zero padding to the beginning of data
|0000 0500	|C000 0500	|(ksseg) Data starting after Exception Vectors
|...            |               |
|0xxx x000	|Exxx x000	|(kseg3) Code 4K Aligned
|...            |               |
|0xxx xxxx	|XKPHYS		|(xkphys) Start of heap, after code
|1000 0000	|B000 0000	|(kseg1) Bootbus
|2000 0000	|XKPHYS		|(xkphys) Rest of memory
|==========================================================================


TLB
---
* Need 32 pages to map code in 4MB chunks.
* Need 32 pages to map data in 4MB chunks.

[options="header"]
|==========================================================================
|Virtual	|Physical	|Size	|Description
|E000 0000	|0x17c00000..   |4MB	|Early init to run code from flash.
|E000 0000	|1000 0000	|128MB	|After flash size set and BEV=0
|E000 0000	|0000 0000	|128MB	|Code in L2/DRAM
|C000 0000	|1000 0000	|128MB	|After flash size set and BEV=0
|C000 0000	|0000 0000	|128MB	|Data in L2/DRAM
|==========================================================================

Notes
-----
* Init code in 0x1FC00000-0x1FC001ff needs to move flash to 0x1FC00000
	minus 128MB. First 4MB aliases to 0x1FC00000. Maybe setup TLB too?
* Later code needs to set flash start will be at 0x1FC00000 minus the flash
	size.
* Uboot compatible environment stored at the top of flash. Location based on
	flash erase size.
* Max supported flash is 128MB (256MB - 4MB for window, rounded down to a
	power of 2).
* Install bootbus region on reset vector to report reset/NMI. A real chip
	reset will move it out of the way automatically.
