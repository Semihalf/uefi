1. Introduction
---------------
**A8kI2cDxe** is a driver supporting I2C controller on Marvell A8K boards.
It is connected through protocols to generic UEFI I2C stack, which exposes
IO functionality to drivers of specific devices on I2C bus.

**A8kEeprom** exemplifies the latter. It creates EFI_EEPROM_PROTOCOL, which
is used by EepromCmd application.

2. A8kI2cDxe driver design
--------------------------
A8kI2cDxe produces several protocols from generic I2C stack:
 - EFI_I2C_MASTER_PROTOCOL,
 - EFI_I2C_ENUMERATE_PROTOCOL,
 - EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL
 - general-purpose EFI_DRIVER_BINDING_PROTOCOL.

  2.1 EFI_I2C_MASTER_PROTOCOL
  ---------------------------
  This is the most important protocol produced by A8kI2cDxe. Following functions
  are implemented:

      ///
      /// Reset the I2C host controller.
      ///
      EFI_I2C_MASTER_PROTOCOL_RESET             Reset;

      ///
      /// Start an I2C transaction in master mode on the host controller.
      ///
      EFI_I2C_MASTER_PROTOCOL_START_REQUEST     StartRequest;

    StartRequest and Reset functions are used by I2cHost.
    These should **not** be used by I2C device drivers - required
    synchronization is not provided. Instead, members of EFI_I2C_IO_PROTOCOL
    should be used.

  2.2 EFI_I2C_BUS_CONFIGURATION_MANAGEMENT_PROTOCOL
  -------------------------------------------------
  The only function exposed via this protocol is A8kI2cEnableConf. It is
  required by I2C stack in order to allow changing I2C bus configuration from
  device drivers.

  2.3 EFI_I2C_ENUMERATE_PROTOCOL
  ------------------------------
  Provides Enumerate function, which is used by I2cBus code as an iterator over
  devices on I2C bus.

    typedef
    EFI_STATUS
    (EFIAPI *EFI_I2C_ENUMERATE_PROTOCOL_ENUMERATE) (
      IN CONST EFI_I2C_ENUMERATE_PROTOCOL *This,
      IN OUT CONST EFI_I2C_DEVICE         **Device
    ); 

    ///
    /// Traverse the set of I2C devices on an I2C bus.  This routine
    /// returns the next I2C device on an I2C bus.
    ///
    EFI_I2C_ENUMERATE_PROTOCOL_ENUMERATE         Enumerate;

  A8kI2cDevice creates EFI_I2C_DEVICE structure for every device on the bus.
  Due to the fact that hardware-based I2C enumeration isn't safe, information
  about attached devices should be provided through PCDs. After EFI_I2C_DEVICE
  structure is created and filled properly, it is returned to I2cBus. It is
  followed by attachment of I2C device driver (currently - only A8kEeprom).

3. A8kEeprom driver design
--------------------------
Every I2C device driver should implement EFI_DRIVER_BINDING_PROTOCOL and
consume EFI_I2C_IO_PROTOCOL for transactions on I2C bus. A8kEeprom driver
additionally implements EFI_EEPROM_PROTOCOL.

  3.1 EFI_DRIVER_BINDING_PROTOCOL
  -------------------------------
  Driver Binding protocol is extensively covered in UEFI documentation, as
  it is not specific to I2C stack. The only difference is that Supported()
  function should check if EFI_I2C_IO_PROTOCOL provides valid EFI_GUID value.
  Excerpt from A8kEepromSupported():

    Status = gBS->OpenProtocol (
                    ControllerHandle,
                    &gEfiI2cIoProtocolGuid,
                    (VOID **) &TmpI2cIo,
                    gImageHandle,
                    ControllerHandle,
                    EFI_OPEN_PROTOCOL_BY_DRIVER
                    );  
    if (EFI_ERROR(Status)) {
      return EFI_UNSUPPORTED;
    }

    /* get EEPROM devices' addresses from PCD */
    EepromAddresses = PcdGetPtr (PcdEepromI2cAddresses);
    if (EepromAddresses == 0) {
      Status = EFI_UNSUPPORTED;
      goto out;
    }

    Status = EFI_UNSUPPORTED;
    for (i = 0; EepromAddresses[i] != '\0'; i++) {
      /* last byte of GUID contains address on I2C bus */
      EepromGuid.Data4[7] = EepromAddresses[i];
      if (CompareGuid(TmpI2cIo->DeviceGuid, &EepromGuid)) {
        DEBUG((DEBUG_INFO, "A8kEepromSupported: offered GUID fits desired\n"));
        Status = EFI_SUCCESS;
        break;
      }
    }

  3.2 EFI_I2C_IO_PROTOCOL
  -----------------------
  This protocol is provided by generic I2C stack. Multiple drivers can use IO
  protocol at once, as queueing is implemented.

  QueueRequest is a routine that queues an I2C transaction to the I2C controller
  for execution on the I2C bus.

  3.3 EFI_EEPROM_PROTOCOL
  -----------------------
    typedef struct _EFI_EEPROM_PROTOCOL EFI_EEPROM_PROTOCOL;

    #define EEPROM_READ   0x1
    #define EEPROM_WRITE  0x0
    typedef
    EFI_STATUS
    (EFIAPI *EFI_EEPROM_TRANSFER) (
      IN CONST EFI_EEPROM_PROTOCOL  *This,
      IN UINT16                     Address,
      IN UINT32                     Length,
      IN UINT8                      *Buffer,
      IN UINT8                      Operation
      );

    struct _EFI_EEPROM_PROTOCOL {
      EFI_EEPROM_TRANSFER Transfer;
      UINT8		      Identifier;
    };

  This simple protocol is then used by EepromCmd ('eeprom' command).

4. Adding new I2C slave device drivers
--------------------------------------
In order to support I2C slave device other than EEPROM, new driver should
be created. Required steps follow.

  1. Create driver directory (OpenPlatformPkg/Drivers/I2c/Devices/...).
  2. Create stubs of .inf and .c files (A8kEeprom files are a reference),
     include .inf file in platform .dsc and .fdf files.
  3. Implement EFI_DRIVER_BINDING_PROTOCOL - Start(), Stop(), Supported()
     functions' implementation is a must. EFI_DRIVER_BINDING_PROTOCOL
     should be installed at driver's entry point.
  4. Add I2C address of device to PcdI2cSlaveAddresses in .dsc file.
  5. Test available EFI_I2C_IO_PROTOCOLs in Supported() - find instance
     with valid GUID (consisting of I2C_GUID and slave I2C address).
  6. Open EFI_I2C_IO_PROTOCOL for usage in Start(). After that, QueueRequest
     function should be available.
  7. Implement core functionality of driver (using QueueRequest to access I2C).
  8. (not mandatory) Produce/consume additional protocols.
