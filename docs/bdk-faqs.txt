//
// This is a asciidoc document. Edit here, but view the HTML
//

Bringup and Diagnostic Kit (BDK) Frequently Asked Questions
===========================================================

Overview
--------

The Bringup and Diagnostic Kit (BDK) is a large and sophisticated software
system and it takes a while before someone can understand how to use the it.
The novice user will have many questions and this document is an attempt to
answer the most common questions.

=== How does the BDK differ from the SDK?
* While both development kits are customer deliverables and provide low-level
software for operating an OCTEON processor, the BDK is intended for board
bring-up and only focuses on current generation OCTEONs. The SDK has a wider
audience. It supports all OCTEONs and is intended as the basis for programming
customer applications. Relative to the SDK, the BDK is quite sparse.
* The BDK and SDK are corelated. Initial work on a new OCTEON uses the BDK. As
this work proceeds, the BDK team documents what changed in the BDK to support
the new OCTEON. This change docuement goes to the SDK development staff where
they make appropriate changes to the SDK to also support the new processor.

=== Does the BDK depend upon SDK Bootloader?
* No, BDK applications are self-contained and have all of the code required to
start the OCTEON (DDR3 setup, TLB configuration, and so forth). A BDK
application can reside in boot bus FLASH memory and starts when an OCTEON
powers-up.
* It is possible to write the Bootloader as a BDK application (using the normal
BDK facilities to load it and execute it). The Bootloader, in its turn, can run
SDK applications.

=== How do you run a BDK Application from the SDK Bootloader?
* You can use the SDK's bootloader to read a BDK application into memory.
Standard BDK Makefiles create two executible images: an ELF image, similar to
what the SDK generates; and a .bin (binary) image. You can load either via the
bootloader.
* For the ELF image, just use +loadb+ command as you always have done for SDK
applications (+loadb+, followed with a Kermit file transfer over the serial
interface, and then +bootoct+ to start the application).
* BDK binary images are smaller, have fewer restrictions the ELF image, and can
run on a raw board where there is no bootload. To load and run a binary image
from the bootloader, do the following:
** +loadb 0x400000+
** Use Kermit to download the image via the serial port.
** +go 0x400000+ to run the application.
* The load address used above (0x40000) is arbitrary and the place the binary
image into memory at an arbitrary address that lies in the from 1Mb (0x100000) to
less 256Mb (0x10000000). Depending upon where you load, the SDK bootloader may
report an overwrite error. You can ignore this and just proceed to run the
application.

=== How do you run a BDK Application from the Compact Flash via the SDK Bootloader?
* The SDK bootloader can load a BDK application from the Compact Flash available
on most EBBs. The procedure is similar to loading via the serial port (given
above):
* +fatload ide 0 0x40000 <application>+ where <application> is the 
file name of the application on the Compact Flash.
* +go 0x40000+ runs the application. As noted above, you are free to locate the
binary image in the range 1Mb to 256Mb. The SDK Bootloader may report an
overwrite error that you can ignore.

=== How do you run a BDK Application from the Managment Port via the SDK Bootloader?
* When the EBB has a network connection, say through a managment port, you can
use the +tftp+ command to load the BDK application.
* Run +dhcp+ to establish your IP address.
* Define the IP address of your TFTP server.
* +tftp 0x40000 <application>+ loads the <application> from the tftp server.
* +go 0x40000+ runs the application. As noted above, you are free to locate the
binary image in the range 1Mb to 256Mb. The SDK Bootloader may report an
overwrite error that you can ignore.

=== Can a BDK Application run via the EBB6800 Telnet Octeon Console?
* EBB6800 revision 1 or 2 boards as they did not implement hardware flow control.
However BDK does have support for software flow control so it is possble run a
BDK application on these boards, but software flow control is not always
reliable and may have problems when there are large volumns of traffic flowing
over the console interface.

=== Where Does the /rom File System Come From?
* The BDK /rom directory contains the sources of all of the files found in the
runtime /rom file system.
* The sources are compiled into .o files via ???? tool. The tool reads the
source file and generates a C language structure whose contents is a series
of hexidecimal byte constants which mirrors the source file. When linking a
BDK application, the linker imports all of the generated .o files and creates
the file system image. When the application runs and references a /rom file,
it really is traversing a memory data structure to find the contents from
the linked in .o file.
* This file system idea mirrors the Linux RAMDISK concept and is implemented in
a similar fashion.

Octeon Simulator
----------------

BDK applications can run on the OCTEON simulator, a software emulation of an
OCTEON processor. This is useful when dealing with a new device that is not
yet available. The simulator also gives the user a detailed view of what is
happening and can spot trouble that might be hidden on a real processor. Of
course, a software emulation runs thousands of times slower than real hardware.

=== How can I use the OCTEON simulator to test my BDK application?
* Many makefiles provide a 'run' target for this purpose. When creating your
project, start with an existing project's Makefile and adjust the 'run' target
to execute your application.

=== How do I run a multi-core application on the simulator?
* Set the simulator's command line '-numcores' option to the desired number of
cores. The simulator only assumes a single core unless told otherwise. Running
a multi-core application on a single-core simulation results in the application
hanging.

=== How can I select the OCTEON model?
* There are means to select the OCTEON model: one is to setup the SIMULATOR
variable in bdk.mk to reference the desired OCTEON (i.e. cn63xxx); the second
is to use the simulator's command line '-pass=' option.

Octeon-Side Lua Scripts
-----------------------

Host-Side Lua Scripts
---------------------

EJTAG Remote Access Tools
-------------------------

PCIe Remote Access Tools
------------------------
