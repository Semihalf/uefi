
Getting Started with the Bringup and Diagnostic Kit
===================================================

Overview
--------

The "Bringup and Diagnostic Kit" (BDK) is a set of executables and
scripts designed to ease the bringup of new hardware based on Cavium
Networks line of OCTEON processors.  To ease development and increase
maintainability, diagnostics are written in a high level scripting
language, Lua.  Lua was chosen due to its simple syntax, ease of
integration with C, and small resource requirements.  The BDK is
capable of running a full interactive Lua environment from L2 cache
before DRAM is configured.

.Features of the BDK
* Simple menu driven interface for testing many I/Os.
* Built in traffic generation for ethernet based I/Os.
* Many I/Os can be tested before DRAM is configured.
* Prebuilt known good binaries for booting new hardware.
* Easy automation of tasks through scripts running on a PC.
* Fast PC based test development using a remote board.
* GUI based interactive script debugger.
* Lua remote procedure calls over serial, tcp/ip, PCIe, or EJTAG.
* Remote booting over PCIe and EJTAG.


.The directory layout of the BDK

bin/::

All host binaries and scripts.

docs::

All documentation for the BDK.

readme.txt::

Short description of the BDK.

rom/::

All files in here are included into BDK applications for access using
standard filesystem calls.

target-bin/::

All binaries, ELF files, and memory maps for use on OCTEON targets.

version.txt::

Version of the BDK


Development Environment Setup
-----------------------------

Requirements
~~~~~~~~~~~~

* PC compatible, or Octeon system running a Linux distribution
supporting 32bit userspace binaries.  Most 64bit Linux distributions are
also capable of running 32bit binaries.
** Recommended: Debian 7.0 (Wheezy) 32bit or 64bit.

* Python 2.x, version 2.3 or higher. Python 3.x is not supported.
** Recommended: Python 2.7+

* A terminal emulation program supporting serial.
** Recommended: Minicom

Hardware Connections
~~~~~~~~~~~~~~~~~~~~

The BDK supports two basic setups for boards under test, either
standalone or PCIe.  The exact setup is flexible, but one of the
choices below is recommended.

Connections for Standalone Boards
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The most common setup is where the board used for development is
completely standalone and requires only minimal connections to the
development PC.  The board's power supply and other necessities are all
independent from the development PC.

* PC serial COM1 is connected to the OCTEON board's UART0 with a null modem
	cable. You can also conenct the board to a terminal server.
+
CAUTION: Cabling with hardware flow control signals is highly recommended. The BDK
will work without hardware flow control, but serial performance will be
degraded.

* PC with two ethernet cards.
** Ethernet eth0 is connected to your local LAN
** Ethernet eth1 is connected directly to OCTEON's first management port.
+
TIP: Development can be performed using a single ethernet card. IP address
management will be more complex.

* The binary *bdk-full.bin* is burned into the beginning of NOR flash
connected to OCTEON's bootbus.

Connections for PCIe Target Boards
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Another common setup is for the development board to be a PCIe card that runs
inside the development PC. In this case the board appears to be a component
of the development machine.

* PC COM1 is connected to the OCTEON board's UART0 with a null modem cable.
+
CAUTION: Cabling with hardware flow control signals is highly recommended. The BDK
will work without hardware flow control, but serial performance will be
degraded.

* Target board is connected to a PCIe slot in the PC.
+
TIP: Best performance will be available if the slot supports PCIe gen2 with at
least four lanes.

* OCTEON is configured for PCI boot.

TIP: The PCI to name database on most Linux distributions can easily
be updated using the command *update-pciids*.  This can be useful to
allow *lspci* to show text descriptions of OCTEON based PCIe devices.

Installing the BDK
~~~~~~~~~~~~~~~~~~

The BDK release consists of a unix tar file compressed with gzip.  All
files inside the release are contained inside a single directory with
a name based on the BDK version.  It is safe to extract the release
into an existing directory.

.Installing the BDK into your home directory
[source, sh]
----
$ cd ~
# This example used BDK version 2011.3, build r58169
$ tar -zxf octeon-bdk-2011.03-r58169.tgz
$ ls octeon-bdk-2011.03
bin  docs  examples  readme.txt  rom  target-bin  version.txt
----

Environment Variables
~~~~~~~~~~~~~~~~~~~~~

Before running any BDK scripts or executables, the shell environment needs
to be setup. The following example works for Bash and other Bourne shell
derivatives.

.Setup the environment for the BDK
[source, sh]
----
export BDK_ROOT=~/octeon-bdk-VERSION
export PATH=${PATH}:${BDK_ROOT}/bin
----

For bash, adding these lines to *.bashrc* will make sure the proper
environment is alway setup.

TIP: If all development is on a PCIe target board, add
'OCTEON_REMOTE_PROTOCOL=pci' to the environment.  This will make using
*bdk-remote* easier.

Testing the Development System
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Here is a checklist of items to quickly check to make sure your development
system is configured properly and ready to develop and run diagnostics.

. Make sure the environment variable BDK_ROOT is set.
+
[source, sh]
----
$ echo ${BDK_ROOT}
~/octeon-bdk-VERSION
----

. Make sure the BDK *bin* directory is in your path.
+
[source, sh]
----
$ echo ${PATH}
...:~/octeon-bdk-VERSION/bin
----

. Execute bdl-lua and make sure it runs properly.
+
[source, sh]
----
$ bdk-lua -v
Lua 5.2.0  Copyright (C) 1994-2011 Lua.org, PUC-Rio
----

. Make sure Minicom is configured for a baud rate of 115200 and hardware
flow control is enabled. Hardware flow control is not required, but it is
strongly recommended.
+
[source, sh]
----
$ minicom --setup
----

. For PCIe based development, make sure the board shows up in *lspci*.
+
[source, sh]
----
$ lspci
...
05:00.0 MIPS: Cavium Networks Octeon II CN63XX Network Processor (rev 09)
...
----


Host Scripts and Utilities
--------------------------

bdk-lua
~~~~~~~

The BDK supplies the executable *bdk-lua* for scripting on a host PC.
This should be used for the shell to execute Lua scripts for remote
controlling OCTEON either on the command line, or through scripts.

.Usage for *bdk-lua*
----
usage: bdk-lua [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  --       stop handling options
  -        stop handling options and execute stdin
----

bdk-debug
~~~~~~~~~

Lua scripts can be interactively debugged using the *bdk-debug*
script.  Start your Lua scripts as follows to debug them:

----
bdk-debug <script.lua> <script arguments>
----

image::images/bdk-debug.png[bdk-debug screenshot]

The *bdk-debug* user interface is divided into four regions.

* The 'cyan' area contains the current call stack.  The active stack
entry is in bold.  Use the *up* and *down* commands to flip through
the stack.

* The 'green' area contains all local variables in the current stack
frame.  Note that Lua variables start their scope at the definition
line, so functions and variables don't show up until you execute their
definitions.

* The 'blue' area contains the source code for the current stack
context.  Breakpoints are highlighted in red.  The current line is
shown in bold.

* The uncolored region contains program and debugger output along with
the debugger command line.

.Commands supported by *bdk-debug*
----
include::captures/bdk-debug-help.capture[]
----


bdk-remote
~~~~~~~~~~

The script *bdk-remote* provides access to a remote OCTEON from a host
PC.  The script requires that the environment variable
*OCTEON_REMOTE_PROTOCOL* be set to the appropriate value.  Simple
command line access to all OCTEON registers, CSRs, memory, profiling
data, and remote booting is supplied.

.Usage for *bdk-remote*
----
include::captures/bdk-remote.capture[]
----


Lua Scripting
-------------

The BDK contains the scripting environment Lua.  Lua allows you to
write simple scripts to easily control OCTEON tests and perform remote
operations.  Take a look at the link:lua/readme.html[documentation for
Lua] for more information about the Lua language.  Many BDK functions
can be called from Lua.  Under the Lua environment, a module *octeon*
is supplied.

TIP: The link:lua/contents.html[Lua Reference] can be useful.


Executing Lua on the Host
~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK supplies the executable *bdk-lua* for scripting on a host PC.
This should be used for the shell to execute Lua scripts for remote
controlling OCTEON either on the command line, or through scripts.

.Command line
[source,sh]
----
$ bdk-lua script.lua
----

.In scripts
[source,lua]
----
#!/usr/bin/env bdk-lua
print("Hello World!")
----

.Usage of *bdk-lua*
----
usage: bdk-lua [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  --       stop handling options
  -        stop handling options and execute stdin
----

.Printing the functions in a module
----
$ bdk-lua -l utils -e "pprint(table)"
----
.Output of *table* print
----
{
    concat = function
    foreach = function
    foreachi = function
    getn = function
    insert = function
    maxn = function
    pack = function
    remove = function
    sort = function
    sorted_keys = function
    sorted_values = function
    unpack = function
}
----

Executing Lua on the Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Three methods are supported for booting the BDK on the development
board.  Most developers choose to burn the BDK to flash.  If your
board doesn't support flash, or already has a bootloader, then you may
choose a different method.  Below is a list of the most common methods
of loading the BDK.

.Booting from NOR flash

Burn *target-bin/bdk-full.bin* to the beginning of the NOR flash
connected to the bootbus chip select 0.

.Booting using *bdk-remote* over PCIe
[source, sh]
----
$ export OCTEON_REMOTE_PROTOCOL=pci
$ bdk-remote boot target-bin/bdk-full.bin
----

.Booting using a pre-existing Uboot
----
Octeon ebb6300# dhcp
Octeon ebb6300# setenv serverip 192.168.162.148
Octeon ebb6300# tftpboot 0x400000 bdk-full.bin
Octeon ebb6300# go 0x400000
----


Using the BDK host Scripts to Control the Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lua scripts run on the host PC can remotely control the target through
a serial connection. The serial connection can be either through the
host's serial port (example /dev/ttyUSB0) or using a TCP/IP socket
connection to a terminal server. The connection is controlled by a
environment variable on the host, *OCTEON_REMOTE_CONSOLE*.

. For use through a serial port on the PC
+
[source, sh]
----
# export OCTEON_REMOTE_CONSOLE=<device_file>
$ export OCTEON_REMOTE_CONSOLE=/dev/ttyUSB0
----

. For use through a TCP/IP connection to a terminal server
+
[source, sh]
----
# export OCTEON_REMOTE_CONSOLE=<ip_address>:<port>
$ export OCTEON_REMOTE_CONSOLE=192.168.1.1:22
----

. It is also possible to use the remote protocol defined by
*OCTEON_REMOTE_PROTOCOL*. This should only be used if serial
is not available. It works well over PCIe, but EJTAG is generally
not worth using.
+
[source, sh]
----
$ export OCTEON_REMOTE_CONSOLE=remote
----


Interactive Lua on the OCTEON Target
------------------------------------

The target side binary *bdk-full.bin* supplies a text menu based
interface to board diagnostic functions.  Each menu expects a numeric
input selecting a valid choice from the list of options.  Generally
the last menu choice returns to the previous menu.  The entire
interactive menu interface is written in Lua for easy expansibility.
The source for the menus can be found in the *rom* directory.

TIP: More information about interactive use can be found in the
document link:bdk-interactive.html[Interacting with the Bringup and
Diagnostic Kit].

.Main Menu
----
include::captures/boot_messages.capture[]
include::captures/main_menu.capture[]
Menu choice: (0INS)>
----

TIP: Any prompt supporting line editing in *bdk-full.bin* also
supports RPC calls.  Whenever *bdk-full.bin* is waiting for user
input, you can send a RPC request and get a response.


Line Editing
~~~~~~~~~~~~

Any prompt ending with `(0INS)>` supports full line editing and
history.  Line editing can also be used for any input using the
*octeon.readline()* function.

* Many vi style modes are available for command and history navigation.
* Use ARROW KEYS, HOME, END or ESC-h,ESC-j,ESC-k,ESC-l,ESC-0,ESC-$,ESC-w,ESC-b, or ESC-fx for navigation.
* Use TAB for command completion, multiple to cycle, or CTRL-D for a list of possible commands.
* Use ESC-i,ESC-A,ESC-a,ESC-c for insert mode, ESC-R,ESC-r for overwrite mode (behavior like vi).
* Use INSERT to toggle insert/overwrite mode, DELETE to delete, F1 for help.
* Use !!, !<num> or !<string> to repeat previous commands in the history.
* Use ::, :<num> or :<string> to recall previous commands in the history to current.
* Use ?<string>, /<string>, ESC-?<string>,ESC-/<string>,ESC-n,ESC-N to also recall to current.
* Use CTRL-l erase the screen, ESC-D to clear the rest of the current line.
* Use ESC-d<movement> to delete, ESC-~ to change case, ESC-u to undo (one level).
* See the vi man page for more info on the operation of various commands.

Configuring the TCP/IP Network Stack
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK contains a port of *lwip*, a light weight TCP/IP stack.  Once
a network interface is configured properly, TCP/IP networking can be
used to transfer data and view the console.  Configuration of the
network interfaces is performed through the 'TCP/IP Networking' option
in the main menu.  The BDK supports static IP addresses, DHCP, and the
zero configuration standard.

.TCP/IP Networking Menu
----
include::captures/tcp_menu.capture[]
----

The simplest way of using networking is to directly connect the board
under test to the development PC using a cable between first
management port and a dedicated ethernet port on the PC.  On the PC,
configure the ethernet port for IP address 10.0.0.1.  On the BDK,
choose option 2.

.Configure an extra ethernet device for direct connection
[source, sh]
----
/usr/bin/ifconfig eth1 10.0.0.1
----

TIP: More information about lwip can be found at link:http://savannah.nongnu.org/projects/lwip/[lwIP - A Lightweight TCP/IP stack].

The Virtual File System
-----------------------

The BDK provides standard system calls for filesystem access.  The
file system supports multiple types of files accessed through virtual
name spaces.  All files are accessible from both native C code and Lua
scripts.

Filesystem Namespaces
~~~~~~~~~~~~~~~~~~~~~

/rom/*::

All files located in *bdk/rom* are statically included into BDK
applications.  Each file can be read be prefixing the name of the file
with '/rom/'.  For example, the first Lua script run is located at
'/rom/init.lua'.

/ram/*::

This is an empty filesystem where applications are free to create
temporary files that are stored in dram.  For example, an application
could store temporary data in '/ram/data.tmp'.

/xmodem::

This is a special file that translates file accesses to reads or
writes to file transferred using XMODEM.  When opened for write the
file to be downloaded from OCTEON.  When opened for read the file will
be uploaded to OCTEON.  XMODEM, XMODEM-CRC, XMODEM-1K, and
XMODEM-1K-CRC are all supported.

/dev/uart/0::

This is a special device representing OCTEON's first uart.  This is
the file that stdin, stdout, and stderr are connected to by default.

/dev/uart/1::

This is a special device representing OCTEON's second uart.

/dev/nor/0::

Read and write access to a NOR flash connected to the bootbus using
chip select 0. If the application configures other bootbus regions to
access NOR flash, these can be accessed through '/dev/nor/*'.

/dev/mem::

Read and write access to DRAM.  The file location is a raw physical
address.

/dev/pcie/0::

Read and write access to memory on PCIe port 0.  The file location is a raw
PCIe bus address.

/dev/pcie/1::

Read and write access to memory on PCIe port 1.  The file location is a raw
PCIe bus address.

/tcp/host:port::

Opens a TCP connection to the supplied host and port.  File read/write
operations are mapped to TCP read and write.  This can be used in
combination with 'netcat' (nc) on a PC to transfer data using TCP/IP.
If the network interface was configured using DHCP, then name based
lookups are supported for *host*.  Note that *host* must be a *fully
qualified host name* or an IP address in *x.x.x.x* format.  *Port* is
a TCP port number in decimal.


Builtin TFTP Server
~~~~~~~~~~~~~~~~~~~

The BDK contains a TFTP server inside *bdk-full.bin*.  It is
available as soon as you configure one of the network interfaces with
an IP address.  The server is very simplistic, expecting exact path
names from the remote client.  For getting files from *bdk-full.bin*,
you will need to specify the full file system path.  For putting
files, you will need to specify the full remote path as well as
whatever local path needed for the source of the file.  The following
examples are using the *tftp-hpa* client supplied with Debian.  Most
other tftp clients are capable of similar operations although the
syntax differs per client.

.Sample TFTP transfer (OCTEON -> Host)
[source, sh]
----
tftp 169.254.1.240 -m binary -c get /rom/ilua.lua
----

.Sample TFTP transfer (Host -> OCTEON)
[source, sh]
----
tftp 169.254.1.240 -m binary -c put myscript.lua /ram/myscript.lua
----



Lua Modules
-----------

Lua functions are organized in terms of packages. Each package implements
many functions related to a specific task. OCTEON's Lua contains the default
Lua packages along with some new packages specifically designed for remote
control and testing of OCTEON based hardware.

.Lua Base Modules
[options="header"]
|==========================================================================
|Standard Lua Module	|Lua documentation
|Basic functions	|link:lua/manual.html#6.1[]
|coroutine		|link:lua/manual.html#6.2[]
|package		|link:lua/manual.html#6.3[]
|string			|link:lua/manual.html#6.4[]
|table			|link:lua/manual.html#6.5[]
|math			|link:lua/manual.html#6.6[]
|bit32			|link:lua/manual.html#6.7[]
|io			|link:lua/manual.html#6.8[]
|os			|link:lua/manual.html#6.9[]
|debug			|link:lua/manual.html#6.10[]
|socket			|link:luasocket/introduction.html[]
|==========================================================================

Host Modules Specific to OCTEON
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on a
host PC.

oremote
^^^^^^^

The *oremote* module provides functions for remotely controlling an
OCTEON over PCI or EJTAG. This allows Lua scripts to remotely probe and
boot OCTEON. Below is a list of the functions supported.

oremote.open(protocol, debug)::
 * protocol = Remote protocol or nil
 * debug = Debug level or nil
 * No return value
+
.Protocol format
[options="header"]
|==========================================================================
|Format			|Description
|PCI:<device>		|Use PCI/PCIe for <device>. Zero is the first OCTEON.
|LINUX			|Assume Linux userspace native with direct access.
|GDB:<name>,<tcp_port>	|Use GDB remote protocol to communicate with OCTEON.
|MACRAIGOR:<name>,<tcp_port>[,<jtag_speed>]	|Use Macraigor mpDemon EJTAG. Note the <tcp_port> is normally 1000. <jtag_speed> is optional and defaults to 1.
|==========================================================================

TIP: The *protocol* can also be set to *nil*.  When *nil*, the protocol
is read from the environment variable *OCTEON_REMOTE_PROTOCOL*.  Using
the environment variable to specify the protocol makes it easy for a
single script to support many protocols.  The parameter *debug* can
also be specified with *OCTEON_REMOTE_DEBUG*.

oremote.close()::
 * No return value

oremote.read_csr(csr)::
 * csr = Name of CSR as a string
 * Return csr value as a number

oremote.write_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number
 * No return value

oremote.decode_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number. If nil, a read_csr is done
 * No return value. Output goes to stdout

oremote.read_mem(address, length)::
 * address = Physical address to read
 * length = Number of bytes to read
 * Returns string of length

oremote.write_mem(address, bytes)::
 * address = physical address to write
 * bytes = string of bytes to write
 * No return value

oremote.get_model()::
 * Returns Processor ID register as number

oremote.start_cores(mask)::
 * mask = Bitmask of cores to start
 * No return value

oremote.stop_cores(mask)::
 * mask = Bitmask of cores to stop
 * No return value

oremote.get_num_cores()::
 * Returns the number of cores as a number

oremote.get_running_cores()::
 * Returns the bitmask of cores that are running

oremote.get_core_state(core)::
 * core = Core state to get, starting at 0
 * Returns table
 * table[1][1-256] = Normal registers
 * table[2][1-256] = COP0 reg * 8 + sel
 * table[3][1-128][1-4] = TLB

oremote.set_core_state(core, state)::
 * core = Core state to set, starting at 0
 * state = table of format from get_core_state
 * No return value

oremote.read_register(core, register)::
 * core = Core starting at 0
 * register = register number to get
 * Return register as number

oremote.write_register(core, register, value)::
 * core = Core starting at 0
 * register = register number to set
 * value = Register value
 * No return value

oremote.reset(stop_cores)::
 * stop_cores = Cores should stop after reset
 * No return value

oremote.get_sample(mask)::
 * mask = Bitmask of cores to get samples for
 * Return table of PC values indexed by core num+1

oremote.write_mem16(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem32(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem64(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.read_mem16(address)::
 * address = Physical address
 * Return data

oremote.read_mem32(address)::
 * address = Physical address
 * Return data

oremote.read_mem64(address)::
 * address = Physical address
 * Return data

oremote.csr()::

Returns an iterator that iterates through the possible CSR names.
+
.List all CSRs from Lua
[source,lua]
----
for name in oremote.csr()
do
    print (name)
end
----

oremote.csr.NAME.read()::

Read the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* Returns the CSR value

oremote.csr.NAME.write(value)::

Write the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* value = Value to write
* No return value.

oremote.csr.NAME.display(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and dispaly it.  If *optional_value* is not supplied the actual
value is read from the hardware.
* optional_value = If supplied, value of CSR to decode.
* No return value.

oremote.csr.NAME.decode(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and returns a Lua table containing the fields.  If
*optional_value* is not supplied the actual value is read from the
hardware.
* optional_value = If supplied, value of CSR to decode.
* Returns a table of the decoded values.
+
.Decode example
[source, lua]
----
pprint(oremote.csr.ciu_fuse.decode())
----
+
.Decode output
[source, lua]
----
{
    FUSE = 63
    RESERVED_6_63 = 0
}
----

oremote.csr.NAME.encode(table)::

Converts a table of CSR fields into a CSR value and writes it to the
hardware.  The format of the table is identical to the *decode()*
format.  Missing fields are filled with zeros.
* table = Table of fields to encode.
* No return value.

oremote.csr.NAME.FIELD::

Reads the CSR and returns the value of a specific field.

oremote.csr.NAME.FIELD = value::

Performs a read, modify, and write of a CSR changing the specified field.


Modules Available on both Host and Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on
a target OCTEON.  When run on a host system, these modules
automatically translate operations into remote procedure calls.  Any
modules written in pure Lua can be used on both the host and target.
These modules are loaded using the standard *require()* function call
in Lua.

octeon
^^^^^^

octeon.is_model(model)::

Returns true if the current chip matches the supplied model.
* model = One of the `octeon.CN*` constants.
** octeon.CN70XX
** octeon.CN78XX

octeon.BDK_CONFIG_*::

Constants for use with octeon.c.bdk_config_get() and
octeon.c.bdk_config_set().

octeon.csr()::

Returns an iterator that iterates through the possible CSR names.
+
.List all CSRs from Lua
[source,lua]
----
for name in octeon.csr()
do
    print (name)
end
----

octeon.csr.NAME.read()::

Read the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* Returns the CSR value

octeon.csr.NAME.write(value)::

Write the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* value = Value to write
* No return value.

octeon.csr.NAME.display(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and dispaly it.  If *optional_value* is not supplied the actual
value is read from the hardware.
* optional_value = If supplied, value of CSR to decode.
* No return value.

octeon.csr.NAME.decode(optional_value)::

Uses *optional_value* as a numeric value for the CSR.  It then decodes
each field and returns a Lua table containing the fields.  If
*optional_value* is not supplied the actual value is read from the
hardware.
* optional_value = If supplied, value of CSR to decode.
* Returns a table of the decoded values.
+
.Decode example
[source, lua]
----
pprint(octeon.csr.ciu_fuse.decode())
----
+
.Decode output
[source, lua]
----
{
    FUSE = 63
    RESERVED_6_63 = 0
}
----

octeon.csr.NAME.encode(table)::

Converts a table of CSR fields into a CSR value and writes it to the
hardware.  The format of the table is identical to the *decode()*
format.  Missing fields are filled with zeros.
* table = Table of fields to encode.
* No return value.

octeon.csr.NAME.FIELD::

Reads the CSR and returns the value of a specific field.

octeon.csr.NAME.FIELD = value::

Performs a read, modify, and write of a CSR changing the specified field.

octeon.c.*::

Many low level C functions are directly exported through this
interface.  No argument checking is performed on these functions, so
it is very important to get the arguments correct.  Errors may crash
the system.

octeon.readline(prompt, completion, timeout_us)::
Prompt the user for input with full line editing and history. Useful for
creating interactive command lines and menus.
* prompt = Prompt to show the user
* completion = Should be nil for now (unsupported)
* timeout_us = Microseconds to wait for input, of zero for no timeout.


octeon.trafficgen
^^^^^^^^^^^^^^^^^

The module *octeon.trafficgen* allows Lua to generate and receive ethernet
traffic on all chip interfaces. A user friendly interactive interface is
available through *trafficgen.lua*.

octeon.trafficgen.get_port_names()::
* Return all port names as an array of strings

octeon.trafficgen.get_config(port_name)::
* port_name = String port name to get the configuration for.
* Returns a table containing the port configuration.

octeon.trafficgen.set_config(port_name, config_table)::
* port_name = String port name to set the configuration for.
* config_table = Table containing the configuration items to change.
* No return value.

octeon.trafficgen.start(port_array)::
* port_array = Array of port names to start transmitting on.
* No return value.

octeon.trafficgen.stop(port_array)::
* port_array = Array of port names to stop transmitting on.
* No return value.

octeon.trafficgen.is_transmitting(port_array)::
* port_array = Array of port names to check if they are transmitting.
* Returns a boolean true or false depending on if any ports are transmitting.

octeon.trafficgen.clear(port_array)::
* port_array = Array of port names to clear statistics for.
* No return value.

octeon.trafficgen.reset(port_array)::
* port_array = Array of port names to clear statistics and reset config for.
* No return value.

octeon.trafficgen.update(do_clear)::
* do_clear = True if the current statistics counters should be cleared for deltas.
* Table index by port name where each entry is a table of statistics.

.octeon.trafficgen configuration fields
----
    number	dest_ip
    number	dest_mac
    number	dest_port
    boolean	display_packet
    boolean	do_checksum
    number	ip_tos
    number	output_count
    boolean	output_enable
    number	output_packet_size
    number	output_rate
    boolean	output_rate_is_mbps
    number	src_ip
    number	src_mac
    number	src_port
    boolean	validate
----

.octeon.trafficgen statistics fields
----
    number	rx_backpressure
    number	rx_bits
    number	rx_dropped_octets
    number	rx_dropped_packets
    number	rx_errors
    number	rx_octets
    number	rx_octets_total
    number	rx_packets
    number	rx_packets_total
    number	rx_validation_errors
    number	tx_bits
    number	tx_octets
    number	tx_octets_total
    number	tx_packets
    number	tx_packets_total
----


menu
^^^^

The *menu* module provides a few simple functions for interacting with the user.

menu.show(choices)::
Show a menu to the user and prompt for a choice.
* choices = Table array of menu strings
* Return the selection number

menu.prompt_string(prompt)::
Prompt the user for a string. Throw an error if the user aborts input.
* prompt = Prompt to display to the user
* Returns the input

menu.prompt_filename(prompt)::
Prompt the user for a filename. Throw an error if the user aborts input.
* prompt = Prompt to display to the user
* Returns the input

menu.prompt_number(prompt)::
Prompt the user for a number. Throw an error if the user aborts input.
* prompt = Prompt to display to the user
* Returns the input

menu.dofile(filename)::
Execute a Lua file, searching the Lua path as needed to find it
* filename = Filename to execute without the ".lua" extension
* Returns the results of the file


strict
^^^^^^

Cavium Networks provides the *strict* module written by Thomas Lauer
to help in writing scripts.  By default Lua considers any new variable
names to be global.  This can make typos and programming errors very
difficult to find.  The *strict* module changes this behavior so that
all variables must be specifically defined.  Cavium Networks recommends
this to promote more robust script development.  Below is the original
description from Thomas Lauer.

----
* Lua Strict by Thomas Lauer
* http://thomaslauer.com/comp/LuaStrict

Strict implements a somewhat stricter handling of global variables than
Lua. There are two basic modes: weak and strong. In the weak mode you
don't need to declare a global but you'd have to initialize it in the
main part of your program (i.e not inside a function).

In strong mode anything not formally declared  (including non-local
functions) gets the whip.

See the examples for more on how to use the module.

Anything wrong or not working? An idea how to make this better? Please
send comments to thomas.lauer@gmail.com or visit my contact page:
http://thomaslauer.com/start/Contact.
----

utils
^^^^^

The *utils* module is a set of Lua functions written by Cavium
Networks to ease writing scripts that deal with OCTEON's registers.
Below is a list of the functions provided.

printf::

C style printf function.  printf("format", ...).  See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.

str = "format" % {...}::

Python style string formatting.See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.
* str = "format" % value
* str = "format" % {...}

pprint(...)::

Pretty print and data in a human readable format.  Tables are printed
recursively.

table.sorted_keys(table)::

Return a table's keys in sorted order.

table.sorted_values(table)::

Return a table's values in sorted order.

isglobal(variable_name)::

Determine if a global variable is defined. Use this function to check if
a global is defiend without setting off the *strict* module checking.
* variable_name = String name of a variable to check.
* Returns true if the global exists, false if it doesn't exist.
+
[source,lua]
----
local csr
if isglobal("oremote") then
    -- We're running remotely
    csr = oremote.csr
else
    -- We're running natively on OCTEON
    csr = octeon.csr
end
print(csr.CIU_FUSE.FUSE)
----

pcie
^^^^

The *pcie* module provides access to PCIe bus initialization, scanning,
and enumeration to Lua scripts.  The function *pcie.initialize(port)*
returns a *pcie_root* object.  This object can then be used to perform
operations on the PCIe port.

pcie_root = pcie.initialize(pcie_port)::

Initialize a PCIe root complex port and bring the link up.  The return
value is a *pcie_root* object for use in the calls below.
* pcie_port = Hardware port to initialize (0 - 1)
* Returns a pcie_port object or throws an error on failure

pcie_root:scan()::

Scan a PCIe root complex for all devices attached.

pcie_root:enumerate()::

Assign address regions and other resources to all device on the PCIe
root complex.  If *scan()* has not already been called, a device scan
will be performed before enumeration.

pcie_root:display()::

Display all devices on the PCIe root complex in a human readable
format.

pcie_root:get_devices()::

Get an array containing all devices on the PCIe root complex.  Each
*pcie_device* in the array is a PCIe function directly connected to
OCTEON.  If the device is a bridge/switch then *pcie_device.isbridge*
will be *true* and *pcie_device.devices* will be an array containing
all children of the device.

pcie_root:shutdown()::

Shutdown a PCIe root complex.

value = pcie_device:read8(config_register)::

Read an 8 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

value = pcie_device:read16(config_register)::

Read a 16 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

value = pcie_device:read32(config_register)::

Read a 32 bit PCIe config register and return its value.
* config_register = Register address to read.
* Returns the register's value.

pcie_device:write8(config_register, value)::

Write an 8 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:write16(config_register, value)::

Write a 16 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:write32(config_register, value)::

Write a 32 bit PCIe config register.
* config_register = Register address to write.
* value = Value to write.
* No return value.

pcie_device:display()::

Display a device and all of its children.

pcie_device:isbridge::

Set to *true* if the device is a switch or bridge, otherwise set to *false*.

bit64
^^^^^

The module *bit64* is specific to the OCTEON BDK.  It supports
standard bit operations on 64 bit numbers.  In general this should be
used instead of *bit32*.

output = bit64.arshift(input, shift)::

Perform arithmetic right shift.

output = bit64.band(input1, input2, ...)::

Bitwise AND all arguments together and return the result.

output = bit64.bnot(input)::

Bit invert the input.

output = bit64.bor(input1, input2, ...)::

Bitwise OR all arguments together and return the result.

output_bool = bit64.btest(input1, input2, ...)::

Bitwise AND all arguments together and return true if any bits are set.

output = bit64.bxor(input1, input2, ...)::

Bitwise XOR all arguments together and return the result.

output = bit64.lrotate(input, shift)::

Perform rotate left.

output = bit64.lshift(input, shift)::

Perform left shift.

output = bit64.rrotate(input, shift)::

Perform rotate right.

output = bit64.rshift(input, shift)::

Perform right shift, filling zeros on the left.

output = bit64.bextract(input, start, stop)::

Extract the bits [stop:start] from input and return them. If stop is not
supplied, it defaults to start.

output = bit64.binsert(original, input, start, stop)::

Bits [stop:start] from original are replaced with input. If stop is not
supplied, it defaults to start.


fileio
^^^^^^

The BDK supports access to many hardware blocks through virtual device
files.  The module *fileio* provides simple functions for common file
operations with error checking.  Any error causes a Lua error() to be
raised.

handle = fileio.open(filename, mode, seek_to)::

Open a file and optionally seek to a location.
* filename = Name of the file to open
* mode = Lua io.open() mode
* seek_to = Optional seek location, may be nil.
* Returns a file handle or throws an error.

transfer_count = fileio.transfer(source_handle, dest_handle, length)::

Transfers bytes from one file to another.
* source_handle = Source file handle to transfer from.
* dest_handle = Destination file handle to transfer to.
* length = Optional length to transfer. If nil, all bytes until the end of source_handle are transferred.
* Returns the number of bytes transferred or raises as error.

transfer_count = fileio.copy(source, source_seek, dest, dest_seek, length)::

Copy part of one file into another file.
* source = Source filename.
* source_seek = Optional start location in source. Use nil to start at the front.
* dest = Destination filename.
* dest_seek =  Optional start location in dest. Use nil to start at the front.
* length = Optional length to transfer. If nil, all bytes until the end of source are transferred.
* Returns the number of bytes transferred or raises as error.

fileio.hexdump(source, seek_to)::

Displays a file in hex on the console.
* source = File to display
* seek_to = Optional seek start location, may be nil.


Lua Scripting Tips
------------------

Writing scripts in Lua for either the host or target is a powerful way
of developing board bringup and diagnostic tools.  A few scripting
tips and guides can make your scripts much easier to write and
maintain.  Here are a few recommendations from Cavium Networks.

Use */usr/bin/env* to find *bdk-lua*::

The location of the BDK installation may change over time.  Use the
*PATH* environment variable to find the Lua binary for you.  Adding
the following line to the beginning of all your scripts will allow you
to make them directly executable.
+
[source,sh]
----
#!/usr/bin/env bdk-lua
----

Use the *strict* module::

Variables are automatically created as global by default in Lua.  This
can cause simple typographical errors to be very difficult to find.  A
misspelled variable name will silently create a new global variable,
which isn't particularly helpful.  The module *strict* forces variables
to be defined.  It also promotes the use of local variables, which will
make your scripts more modular and easier to maintain.
+
[source,lua]
----
require("strict")
----

Use the *utils* module::

The default *print()* function in Lua is very primitive.  For example,
it won't display the contents of a table.  The *utils* module contains
a number of functions to make your life easier.  The *printf()* and
*pprint()* functions are exceedingly useful.
+
[source,lua]
----
require("utils")
----

Use the *csr* module on *oremote* and *octeon* interchangeably::

Note that the syntax of the oremote.csr.* operations and the
octeon.csr.* operations are exactly the same.  Use this to your
advantage to make scripts portable between the host and target.
+
[source,lua]
----
require("utils")
local csr
if isglobal("oremote") then
    csr = oremote.csr
else
    csr = octeon.csr
end
pprint(csr.ciu_fuse.decode())
----


Lua Startup Sequence on OCTEON
------------------------------

The following details which Lua scripts are executed on OCTEON during
boot of the BDK.

. bdk-full.bin binary boots.

. */rom/init.lua* is executed.
+
[source,lua]
----
include::../rom/full/init.lua[]
----

. */rom/main.lua* is executed.
+
[source,lua]
----
include::../rom/full/main.lua[]
----

. Board specific file is loaded.
+
[source,lua]
----
include::../rom/full/board-evb7000.lua[]
----

