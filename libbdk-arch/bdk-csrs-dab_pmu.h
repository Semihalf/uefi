#ifndef __BDK_CSRS_DAB_PMU__
#define __BDK_CSRS_DAB_PMU__
/* This file is auto-generated. Do not edit */

/***********************license start***************
 * Copyright (c) 2003-2014  Cavium Networks (support@cavium.com). All rights
 * reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.

 *   * Neither the name of Cavium Networks nor the names of
 *     its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written
 *     permission.

 * This Software, including technical data, may be subject to U.S. export  control
 * laws, including the U.S. Export Administration Act and its  associated
 * regulations, and may be subject to export or import  regulations in other
 * countries.

 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
 * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
 * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
 * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
 * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
 * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
 ***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * Cavium DAB_PMU.
 *
 * This file is auto generated. Do not edit.
 *
 */

#include <stdint.h>

extern void csr_fatal(const char *name, int num_args, unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4) __attribute__ ((noreturn));


/**
 * Enumeration PMU_PERF_E
 *
 * Performance Counter Event Enumeration
 * Enumerates the events that may be counted.  See PMU()_PMEVTYPER()_EL0[EVTCOUNT].
 * INTERNAL:
 * \<pre\>
 *    0x0000 to 0x003F    Common architectural and microarchitectural events
 *       0x0020 to 0x03F      ARM house style events
 *       0x0040 to 0x04F      ARM Recommended, implementation defined events (Aka ARM House
 * Style)
 *    0x0040 to 0x00BF    ARM recommended common architectural and microarchitectural events.
 * IMPLEMENTATION DEFINED
 *    0x00C0 to 0x3FFF    IMPLEMENTATION DEFINED
 *      0x0180 to 0x01B7     Cavium Misc Counters
 *      0x01B8 to 0x01FF     Cavium - special instructions and events
 *      0x0300 to 0x03FF     Cavium - can be secure mode only
 *    0x4000 to 0x403F    Common architectural and microarchitectural events
 *    0x4040 to 0x40BF    ARM recommended common architectural and microarchitectural events.
 * IMPLEMENTATION DEFINED
 *    0x40C0 to 0x7FFF    IMPLEMENTATION DEFINED
 *    0x8000 to 0x80BF    Reserved
 *    0x80C0 to 0xBFFF    IMPLEMENTATION DEFINED
 *    0xC000 to 0xC0BF    Reserved
 *    0xC0C0 to 0xFFFF    IMPLEMENTATION DEFINED
 * \</pre\>
 */
enum pmu_perf_e {
	PMU_PERF_E_ASE_SPEC = 0x74,
	PMU_PERF_E_ASID_OVF = 0x300,
	PMU_PERF_E_BADD = 0xe0,
	PMU_PERF_E_BADDL2 = 0xe1,
	PMU_PERF_E_BFILL = 0xe2,
	PMU_PERF_E_BR = 0xc7,
	PMU_PERF_E_BRMIS = 0xc8,
	PMU_PERF_E_BR_FOLDED = 0xc5,
	PMU_PERF_E_BR_FOLDED_RAW = 0xc6,
	PMU_PERF_E_BR_IMMED_RETIRED = 0xd,
	PMU_PERF_E_BR_IMMED_SPEC = 0x78,
	PMU_PERF_E_BR_INDIRECT_SPEC = 0x7a,
	PMU_PERF_E_BR_MIS_PRED = 0x10,
	PMU_PERF_E_BR_MIS_PRED_RETIRED = 0x22,
	PMU_PERF_E_BR_PRED = 0x12,
	PMU_PERF_E_BR_RETIRED = 0x21,
	PMU_PERF_E_BR_RETURN_RETIRED = 0xe,
	PMU_PERF_E_BR_RETURN_SPEC = 0x79,
	PMU_PERF_E_BUS_ACCESS = 0x19,
	PMU_PERF_E_BUS_ACCESS_LD = 0x60,
	PMU_PERF_E_BUS_ACCESS_NORMAL = 0x64,
	PMU_PERF_E_BUS_ACCESS_NOT_SHARED = 0x63,
	PMU_PERF_E_BUS_ACCESS_PERIPH = 0x65,
	PMU_PERF_E_BUS_ACCESS_SHARED = 0x62,
	PMU_PERF_E_BUS_ACCESS_ST = 0x61,
	PMU_PERF_E_BUS_CYCLES = 0x1d,
	PMU_PERF_E_CDMISS = 0xe6,
	PMU_PERF_E_CHAIN = 0x1e,
	PMU_PERF_E_CID_WRITE_RETIRED = 0xb,
	PMU_PERF_E_CIMISS = 0xd8,
	PMU_PERF_E_CPU_CYCLES = 0x11,
	PMU_PERF_E_CRYPTO_SPEC = 0x77,
	PMU_PERF_E_DC_CIVAC = 0x1be,
	PMU_PERF_E_DC_CVAC = 0x1bf,
	PMU_PERF_E_DC_CVAU = 0x1c0,
	PMU_PERF_E_DC_ISW_L1 = 0x1c1,
	PMU_PERF_E_DC_ISW_L2 = 0x1c2,
	PMU_PERF_E_DC_IVAC = 0x1c3,
	PMU_PERF_E_DDIDS = 0xe3,
	PMU_PERF_E_DIDNA = 0xe5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON0 = 0x4e00,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON1 = 0x4e01,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON10 = 0x4e0a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON100 = 0x4e64,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON101 = 0x4e65,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON102 = 0x4e66,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON103 = 0x4e67,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON104 = 0x4e68,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON105 = 0x4e69,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON106 = 0x4e6a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON107 = 0x4e6b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON108 = 0x4e6c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON109 = 0x4e6d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON11 = 0x4e0b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON110 = 0x4e6e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON111 = 0x4e6f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON112 = 0x4e70,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON113 = 0x4e71,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON114 = 0x4e72,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON115 = 0x4e73,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON116 = 0x4e74,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON117 = 0x4e75,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON118 = 0x4e76,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON119 = 0x4e77,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON12 = 0x4e0c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON120 = 0x4e78,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON121 = 0x4e79,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON122 = 0x4e7a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON123 = 0x4e7b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON124 = 0x4e7c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON125 = 0x4e7d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON126 = 0x4e7e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON127 = 0x4e7f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON128 = 0x4e80,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON129 = 0x4e81,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON13 = 0x4e0d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON130 = 0x4e82,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON131 = 0x4e83,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON132 = 0x4e84,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON133 = 0x4e85,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON134 = 0x4e86,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON135 = 0x4e87,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON136 = 0x4e88,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON137 = 0x4e89,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON138 = 0x4e8a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON139 = 0x4e8b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON14 = 0x4e0e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON140 = 0x4e8c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON141 = 0x4e8d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON142 = 0x4e8e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON143 = 0x4e8f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON144 = 0x4e90,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON145 = 0x4e91,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON146 = 0x4e92,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON147 = 0x4e93,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON148 = 0x4e94,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON149 = 0x4e95,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON15 = 0x4e0f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON150 = 0x4e96,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON151 = 0x4e97,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON152 = 0x4e98,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON153 = 0x4e99,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON154 = 0x4e9a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON155 = 0x4e9b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON156 = 0x4e9c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON157 = 0x4e9d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON158 = 0x4e9e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON159 = 0x4e9f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON16 = 0x4e10,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON160 = 0x4ea0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON161 = 0x4ea1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON162 = 0x4ea2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON163 = 0x4ea3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON164 = 0x4ea4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON165 = 0x4ea5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON166 = 0x4ea6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON167 = 0x4ea7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON168 = 0x4ea8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON169 = 0x4ea9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON17 = 0x4e11,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON170 = 0x4eaa,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON171 = 0x4eab,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON172 = 0x4eac,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON173 = 0x4ead,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON174 = 0x4eae,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON175 = 0x4eaf,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON176 = 0x4eb0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON177 = 0x4eb1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON178 = 0x4eb2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON179 = 0x4eb3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON18 = 0x4e12,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON180 = 0x4eb4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON181 = 0x4eb5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON182 = 0x4eb6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON183 = 0x4eb7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON184 = 0x4eb8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON185 = 0x4eb9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON186 = 0x4eba,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON187 = 0x4ebb,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON188 = 0x4ebc,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON189 = 0x4ebd,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON19 = 0x4e13,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON190 = 0x4ebe,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON191 = 0x4ebf,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON192 = 0x4ec0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON193 = 0x4ec1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON194 = 0x4ec2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON195 = 0x4ec3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON196 = 0x4ec4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON197 = 0x4ec5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON198 = 0x4ec6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON199 = 0x4ec7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON2 = 0x4e02,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON20 = 0x4e14,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON200 = 0x4ec8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON201 = 0x4ec9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON202 = 0x4eca,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON203 = 0x4ecb,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON204 = 0x4ecc,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON205 = 0x4ecd,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON206 = 0x4ece,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON207 = 0x4ecf,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON208 = 0x4ed0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON209 = 0x4ed1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON21 = 0x4e15,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON210 = 0x4ed2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON211 = 0x4ed3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON212 = 0x4ed4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON213 = 0x4ed5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON214 = 0x4ed6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON215 = 0x4ed7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON216 = 0x4ed8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON217 = 0x4ed9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON218 = 0x4eda,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON219 = 0x4edb,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON22 = 0x4e16,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON220 = 0x4edc,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON221 = 0x4edd,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON222 = 0x4ede,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON223 = 0x4edf,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON224 = 0x4ee0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON225 = 0x4ee1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON226 = 0x4ee2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON227 = 0x4ee3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON228 = 0x4ee4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON229 = 0x4ee5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON23 = 0x4e17,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON230 = 0x4ee6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON231 = 0x4ee7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON232 = 0x4ee8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON233 = 0x4ee9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON234 = 0x4eea,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON235 = 0x4eeb,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON236 = 0x4eec,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON237 = 0x4eed,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON238 = 0x4eee,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON239 = 0x4eef,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON24 = 0x4e18,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON240 = 0x4ef0,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON241 = 0x4ef1,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON242 = 0x4ef2,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON243 = 0x4ef3,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON244 = 0x4ef4,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON245 = 0x4ef5,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON246 = 0x4ef6,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON247 = 0x4ef7,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON248 = 0x4ef8,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON249 = 0x4ef9,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON25 = 0x4e19,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON250 = 0x4efa,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON251 = 0x4efb,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON252 = 0x4efc,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON253 = 0x4efd,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON254 = 0x4efe,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON255 = 0x4eff,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON26 = 0x4e1a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON27 = 0x4e1b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON28 = 0x4e1c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON29 = 0x4e1d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON3 = 0x4e03,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON30 = 0x4e1e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON31 = 0x4e1f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON32 = 0x4e20,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON33 = 0x4e21,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON34 = 0x4e22,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON35 = 0x4e23,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON36 = 0x4e24,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON37 = 0x4e25,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON38 = 0x4e26,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON39 = 0x4e27,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON4 = 0x4e04,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON40 = 0x4e28,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON41 = 0x4e29,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON42 = 0x4e2a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON43 = 0x4e2b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON44 = 0x4e2c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON45 = 0x4e2d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON46 = 0x4e2e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON47 = 0x4e2f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON48 = 0x4e30,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON49 = 0x4e31,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON5 = 0x4e05,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON50 = 0x4e32,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON51 = 0x4e33,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON52 = 0x4e34,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON53 = 0x4e35,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON54 = 0x4e36,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON55 = 0x4e37,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON56 = 0x4e38,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON57 = 0x4e39,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON58 = 0x4e3a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON59 = 0x4e3b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON6 = 0x4e06,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON60 = 0x4e3c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON61 = 0x4e3d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON62 = 0x4e3e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON63 = 0x4e3f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON64 = 0x4e40,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON65 = 0x4e41,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON66 = 0x4e42,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON67 = 0x4e43,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON68 = 0x4e44,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON69 = 0x4e45,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON7 = 0x4e07,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON70 = 0x4e46,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON71 = 0x4e47,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON72 = 0x4e48,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON73 = 0x4e49,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON74 = 0x4e4a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON75 = 0x4e4b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON76 = 0x4e4c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON77 = 0x4e4d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON78 = 0x4e4e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON79 = 0x4e4f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON8 = 0x4e08,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON80 = 0x4e50,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON81 = 0x4e51,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON82 = 0x4e52,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON83 = 0x4e53,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON84 = 0x4e54,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON85 = 0x4e55,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON86 = 0x4e56,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON87 = 0x4e57,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON88 = 0x4e58,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON89 = 0x4e59,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON9 = 0x4e09,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON90 = 0x4e5a,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON91 = 0x4e5b,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON92 = 0x4e5c,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON93 = 0x4e5d,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON94 = 0x4e5e,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON95 = 0x4e5f,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON96 = 0x4e60,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON97 = 0x4e61,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON98 = 0x4e62,
	PMU_PERF_E_DIDNT_DUAL_ISSUE_REASON99 = 0x4e63,
	PMU_PERF_E_DIDNT_ISSUE_REASON0 = 0x4d00,
	PMU_PERF_E_DIDNT_ISSUE_REASON1 = 0x4d01,
	PMU_PERF_E_DIDNT_ISSUE_REASON10 = 0x4d0a,
	PMU_PERF_E_DIDNT_ISSUE_REASON100 = 0x4d64,
	PMU_PERF_E_DIDNT_ISSUE_REASON101 = 0x4d65,
	PMU_PERF_E_DIDNT_ISSUE_REASON102 = 0x4d66,
	PMU_PERF_E_DIDNT_ISSUE_REASON103 = 0x4d67,
	PMU_PERF_E_DIDNT_ISSUE_REASON104 = 0x4d68,
	PMU_PERF_E_DIDNT_ISSUE_REASON105 = 0x4d69,
	PMU_PERF_E_DIDNT_ISSUE_REASON106 = 0x4d6a,
	PMU_PERF_E_DIDNT_ISSUE_REASON107 = 0x4d6b,
	PMU_PERF_E_DIDNT_ISSUE_REASON108 = 0x4d6c,
	PMU_PERF_E_DIDNT_ISSUE_REASON109 = 0x4d6d,
	PMU_PERF_E_DIDNT_ISSUE_REASON11 = 0x4d0b,
	PMU_PERF_E_DIDNT_ISSUE_REASON110 = 0x4d6e,
	PMU_PERF_E_DIDNT_ISSUE_REASON111 = 0x4d6f,
	PMU_PERF_E_DIDNT_ISSUE_REASON112 = 0x4d70,
	PMU_PERF_E_DIDNT_ISSUE_REASON113 = 0x4d71,
	PMU_PERF_E_DIDNT_ISSUE_REASON114 = 0x4d72,
	PMU_PERF_E_DIDNT_ISSUE_REASON115 = 0x4d73,
	PMU_PERF_E_DIDNT_ISSUE_REASON116 = 0x4d74,
	PMU_PERF_E_DIDNT_ISSUE_REASON117 = 0x4d75,
	PMU_PERF_E_DIDNT_ISSUE_REASON118 = 0x4d76,
	PMU_PERF_E_DIDNT_ISSUE_REASON119 = 0x4d77,
	PMU_PERF_E_DIDNT_ISSUE_REASON12 = 0x4d0c,
	PMU_PERF_E_DIDNT_ISSUE_REASON120 = 0x4d78,
	PMU_PERF_E_DIDNT_ISSUE_REASON121 = 0x4d79,
	PMU_PERF_E_DIDNT_ISSUE_REASON122 = 0x4d7a,
	PMU_PERF_E_DIDNT_ISSUE_REASON123 = 0x4d7b,
	PMU_PERF_E_DIDNT_ISSUE_REASON124 = 0x4d7c,
	PMU_PERF_E_DIDNT_ISSUE_REASON125 = 0x4d7d,
	PMU_PERF_E_DIDNT_ISSUE_REASON126 = 0x4d7e,
	PMU_PERF_E_DIDNT_ISSUE_REASON127 = 0x4d7f,
	PMU_PERF_E_DIDNT_ISSUE_REASON128 = 0x4d80,
	PMU_PERF_E_DIDNT_ISSUE_REASON129 = 0x4d81,
	PMU_PERF_E_DIDNT_ISSUE_REASON13 = 0x4d0d,
	PMU_PERF_E_DIDNT_ISSUE_REASON130 = 0x4d82,
	PMU_PERF_E_DIDNT_ISSUE_REASON131 = 0x4d83,
	PMU_PERF_E_DIDNT_ISSUE_REASON132 = 0x4d84,
	PMU_PERF_E_DIDNT_ISSUE_REASON133 = 0x4d85,
	PMU_PERF_E_DIDNT_ISSUE_REASON134 = 0x4d86,
	PMU_PERF_E_DIDNT_ISSUE_REASON135 = 0x4d87,
	PMU_PERF_E_DIDNT_ISSUE_REASON136 = 0x4d88,
	PMU_PERF_E_DIDNT_ISSUE_REASON137 = 0x4d89,
	PMU_PERF_E_DIDNT_ISSUE_REASON138 = 0x4d8a,
	PMU_PERF_E_DIDNT_ISSUE_REASON139 = 0x4d8b,
	PMU_PERF_E_DIDNT_ISSUE_REASON14 = 0x4d0e,
	PMU_PERF_E_DIDNT_ISSUE_REASON140 = 0x4d8c,
	PMU_PERF_E_DIDNT_ISSUE_REASON141 = 0x4d8d,
	PMU_PERF_E_DIDNT_ISSUE_REASON142 = 0x4d8e,
	PMU_PERF_E_DIDNT_ISSUE_REASON143 = 0x4d8f,
	PMU_PERF_E_DIDNT_ISSUE_REASON144 = 0x4d90,
	PMU_PERF_E_DIDNT_ISSUE_REASON145 = 0x4d91,
	PMU_PERF_E_DIDNT_ISSUE_REASON146 = 0x4d92,
	PMU_PERF_E_DIDNT_ISSUE_REASON147 = 0x4d93,
	PMU_PERF_E_DIDNT_ISSUE_REASON148 = 0x4d94,
	PMU_PERF_E_DIDNT_ISSUE_REASON149 = 0x4d95,
	PMU_PERF_E_DIDNT_ISSUE_REASON15 = 0x4d0f,
	PMU_PERF_E_DIDNT_ISSUE_REASON150 = 0x4d96,
	PMU_PERF_E_DIDNT_ISSUE_REASON151 = 0x4d97,
	PMU_PERF_E_DIDNT_ISSUE_REASON152 = 0x4d98,
	PMU_PERF_E_DIDNT_ISSUE_REASON153 = 0x4d99,
	PMU_PERF_E_DIDNT_ISSUE_REASON154 = 0x4d9a,
	PMU_PERF_E_DIDNT_ISSUE_REASON155 = 0x4d9b,
	PMU_PERF_E_DIDNT_ISSUE_REASON156 = 0x4d9c,
	PMU_PERF_E_DIDNT_ISSUE_REASON157 = 0x4d9d,
	PMU_PERF_E_DIDNT_ISSUE_REASON158 = 0x4d9e,
	PMU_PERF_E_DIDNT_ISSUE_REASON159 = 0x4d9f,
	PMU_PERF_E_DIDNT_ISSUE_REASON16 = 0x4d10,
	PMU_PERF_E_DIDNT_ISSUE_REASON160 = 0x4da0,
	PMU_PERF_E_DIDNT_ISSUE_REASON161 = 0x4da1,
	PMU_PERF_E_DIDNT_ISSUE_REASON162 = 0x4da2,
	PMU_PERF_E_DIDNT_ISSUE_REASON163 = 0x4da3,
	PMU_PERF_E_DIDNT_ISSUE_REASON164 = 0x4da4,
	PMU_PERF_E_DIDNT_ISSUE_REASON165 = 0x4da5,
	PMU_PERF_E_DIDNT_ISSUE_REASON166 = 0x4da6,
	PMU_PERF_E_DIDNT_ISSUE_REASON167 = 0x4da7,
	PMU_PERF_E_DIDNT_ISSUE_REASON168 = 0x4da8,
	PMU_PERF_E_DIDNT_ISSUE_REASON169 = 0x4da9,
	PMU_PERF_E_DIDNT_ISSUE_REASON17 = 0x4d11,
	PMU_PERF_E_DIDNT_ISSUE_REASON170 = 0x4daa,
	PMU_PERF_E_DIDNT_ISSUE_REASON171 = 0x4dab,
	PMU_PERF_E_DIDNT_ISSUE_REASON172 = 0x4dac,
	PMU_PERF_E_DIDNT_ISSUE_REASON173 = 0x4dad,
	PMU_PERF_E_DIDNT_ISSUE_REASON174 = 0x4dae,
	PMU_PERF_E_DIDNT_ISSUE_REASON175 = 0x4daf,
	PMU_PERF_E_DIDNT_ISSUE_REASON176 = 0x4db0,
	PMU_PERF_E_DIDNT_ISSUE_REASON177 = 0x4db1,
	PMU_PERF_E_DIDNT_ISSUE_REASON178 = 0x4db2,
	PMU_PERF_E_DIDNT_ISSUE_REASON179 = 0x4db3,
	PMU_PERF_E_DIDNT_ISSUE_REASON18 = 0x4d12,
	PMU_PERF_E_DIDNT_ISSUE_REASON180 = 0x4db4,
	PMU_PERF_E_DIDNT_ISSUE_REASON181 = 0x4db5,
	PMU_PERF_E_DIDNT_ISSUE_REASON182 = 0x4db6,
	PMU_PERF_E_DIDNT_ISSUE_REASON183 = 0x4db7,
	PMU_PERF_E_DIDNT_ISSUE_REASON184 = 0x4db8,
	PMU_PERF_E_DIDNT_ISSUE_REASON185 = 0x4db9,
	PMU_PERF_E_DIDNT_ISSUE_REASON186 = 0x4dba,
	PMU_PERF_E_DIDNT_ISSUE_REASON187 = 0x4dbb,
	PMU_PERF_E_DIDNT_ISSUE_REASON188 = 0x4dbc,
	PMU_PERF_E_DIDNT_ISSUE_REASON189 = 0x4dbd,
	PMU_PERF_E_DIDNT_ISSUE_REASON19 = 0x4d13,
	PMU_PERF_E_DIDNT_ISSUE_REASON190 = 0x4dbe,
	PMU_PERF_E_DIDNT_ISSUE_REASON191 = 0x4dbf,
	PMU_PERF_E_DIDNT_ISSUE_REASON192 = 0x4dc0,
	PMU_PERF_E_DIDNT_ISSUE_REASON193 = 0x4dc1,
	PMU_PERF_E_DIDNT_ISSUE_REASON194 = 0x4dc2,
	PMU_PERF_E_DIDNT_ISSUE_REASON195 = 0x4dc3,
	PMU_PERF_E_DIDNT_ISSUE_REASON196 = 0x4dc4,
	PMU_PERF_E_DIDNT_ISSUE_REASON197 = 0x4dc5,
	PMU_PERF_E_DIDNT_ISSUE_REASON198 = 0x4dc6,
	PMU_PERF_E_DIDNT_ISSUE_REASON199 = 0x4dc7,
	PMU_PERF_E_DIDNT_ISSUE_REASON2 = 0x4d02,
	PMU_PERF_E_DIDNT_ISSUE_REASON20 = 0x4d14,
	PMU_PERF_E_DIDNT_ISSUE_REASON200 = 0x4dc8,
	PMU_PERF_E_DIDNT_ISSUE_REASON201 = 0x4dc9,
	PMU_PERF_E_DIDNT_ISSUE_REASON202 = 0x4dca,
	PMU_PERF_E_DIDNT_ISSUE_REASON203 = 0x4dcb,
	PMU_PERF_E_DIDNT_ISSUE_REASON204 = 0x4dcc,
	PMU_PERF_E_DIDNT_ISSUE_REASON205 = 0x4dcd,
	PMU_PERF_E_DIDNT_ISSUE_REASON206 = 0x4dce,
	PMU_PERF_E_DIDNT_ISSUE_REASON207 = 0x4dcf,
	PMU_PERF_E_DIDNT_ISSUE_REASON208 = 0x4dd0,
	PMU_PERF_E_DIDNT_ISSUE_REASON209 = 0x4dd1,
	PMU_PERF_E_DIDNT_ISSUE_REASON21 = 0x4d15,
	PMU_PERF_E_DIDNT_ISSUE_REASON210 = 0x4dd2,
	PMU_PERF_E_DIDNT_ISSUE_REASON211 = 0x4dd3,
	PMU_PERF_E_DIDNT_ISSUE_REASON212 = 0x4dd4,
	PMU_PERF_E_DIDNT_ISSUE_REASON213 = 0x4dd5,
	PMU_PERF_E_DIDNT_ISSUE_REASON214 = 0x4dd6,
	PMU_PERF_E_DIDNT_ISSUE_REASON215 = 0x4dd7,
	PMU_PERF_E_DIDNT_ISSUE_REASON216 = 0x4dd8,
	PMU_PERF_E_DIDNT_ISSUE_REASON217 = 0x4dd9,
	PMU_PERF_E_DIDNT_ISSUE_REASON218 = 0x4dda,
	PMU_PERF_E_DIDNT_ISSUE_REASON219 = 0x4ddb,
	PMU_PERF_E_DIDNT_ISSUE_REASON22 = 0x4d16,
	PMU_PERF_E_DIDNT_ISSUE_REASON220 = 0x4ddc,
	PMU_PERF_E_DIDNT_ISSUE_REASON221 = 0x4ddd,
	PMU_PERF_E_DIDNT_ISSUE_REASON222 = 0x4dde,
	PMU_PERF_E_DIDNT_ISSUE_REASON223 = 0x4ddf,
	PMU_PERF_E_DIDNT_ISSUE_REASON224 = 0x4de0,
	PMU_PERF_E_DIDNT_ISSUE_REASON225 = 0x4de1,
	PMU_PERF_E_DIDNT_ISSUE_REASON226 = 0x4de2,
	PMU_PERF_E_DIDNT_ISSUE_REASON227 = 0x4de3,
	PMU_PERF_E_DIDNT_ISSUE_REASON228 = 0x4de4,
	PMU_PERF_E_DIDNT_ISSUE_REASON229 = 0x4de5,
	PMU_PERF_E_DIDNT_ISSUE_REASON23 = 0x4d17,
	PMU_PERF_E_DIDNT_ISSUE_REASON230 = 0x4de6,
	PMU_PERF_E_DIDNT_ISSUE_REASON231 = 0x4de7,
	PMU_PERF_E_DIDNT_ISSUE_REASON232 = 0x4de8,
	PMU_PERF_E_DIDNT_ISSUE_REASON233 = 0x4de9,
	PMU_PERF_E_DIDNT_ISSUE_REASON234 = 0x4dea,
	PMU_PERF_E_DIDNT_ISSUE_REASON235 = 0x4deb,
	PMU_PERF_E_DIDNT_ISSUE_REASON236 = 0x4dec,
	PMU_PERF_E_DIDNT_ISSUE_REASON237 = 0x4ded,
	PMU_PERF_E_DIDNT_ISSUE_REASON238 = 0x4dee,
	PMU_PERF_E_DIDNT_ISSUE_REASON239 = 0x4def,
	PMU_PERF_E_DIDNT_ISSUE_REASON24 = 0x4d18,
	PMU_PERF_E_DIDNT_ISSUE_REASON240 = 0x4df0,
	PMU_PERF_E_DIDNT_ISSUE_REASON241 = 0x4df1,
	PMU_PERF_E_DIDNT_ISSUE_REASON242 = 0x4df2,
	PMU_PERF_E_DIDNT_ISSUE_REASON243 = 0x4df3,
	PMU_PERF_E_DIDNT_ISSUE_REASON244 = 0x4df4,
	PMU_PERF_E_DIDNT_ISSUE_REASON245 = 0x4df5,
	PMU_PERF_E_DIDNT_ISSUE_REASON246 = 0x4df6,
	PMU_PERF_E_DIDNT_ISSUE_REASON247 = 0x4df7,
	PMU_PERF_E_DIDNT_ISSUE_REASON248 = 0x4df8,
	PMU_PERF_E_DIDNT_ISSUE_REASON249 = 0x4df9,
	PMU_PERF_E_DIDNT_ISSUE_REASON25 = 0x4d19,
	PMU_PERF_E_DIDNT_ISSUE_REASON250 = 0x4dfa,
	PMU_PERF_E_DIDNT_ISSUE_REASON251 = 0x4dfb,
	PMU_PERF_E_DIDNT_ISSUE_REASON252 = 0x4dfc,
	PMU_PERF_E_DIDNT_ISSUE_REASON253 = 0x4dfd,
	PMU_PERF_E_DIDNT_ISSUE_REASON254 = 0x4dfe,
	PMU_PERF_E_DIDNT_ISSUE_REASON255 = 0x4dff,
	PMU_PERF_E_DIDNT_ISSUE_REASON26 = 0x4d1a,
	PMU_PERF_E_DIDNT_ISSUE_REASON27 = 0x4d1b,
	PMU_PERF_E_DIDNT_ISSUE_REASON28 = 0x4d1c,
	PMU_PERF_E_DIDNT_ISSUE_REASON29 = 0x4d1d,
	PMU_PERF_E_DIDNT_ISSUE_REASON3 = 0x4d03,
	PMU_PERF_E_DIDNT_ISSUE_REASON30 = 0x4d1e,
	PMU_PERF_E_DIDNT_ISSUE_REASON31 = 0x4d1f,
	PMU_PERF_E_DIDNT_ISSUE_REASON32 = 0x4d20,
	PMU_PERF_E_DIDNT_ISSUE_REASON33 = 0x4d21,
	PMU_PERF_E_DIDNT_ISSUE_REASON34 = 0x4d22,
	PMU_PERF_E_DIDNT_ISSUE_REASON35 = 0x4d23,
	PMU_PERF_E_DIDNT_ISSUE_REASON36 = 0x4d24,
	PMU_PERF_E_DIDNT_ISSUE_REASON37 = 0x4d25,
	PMU_PERF_E_DIDNT_ISSUE_REASON38 = 0x4d26,
	PMU_PERF_E_DIDNT_ISSUE_REASON39 = 0x4d27,
	PMU_PERF_E_DIDNT_ISSUE_REASON4 = 0x4d04,
	PMU_PERF_E_DIDNT_ISSUE_REASON40 = 0x4d28,
	PMU_PERF_E_DIDNT_ISSUE_REASON41 = 0x4d29,
	PMU_PERF_E_DIDNT_ISSUE_REASON42 = 0x4d2a,
	PMU_PERF_E_DIDNT_ISSUE_REASON43 = 0x4d2b,
	PMU_PERF_E_DIDNT_ISSUE_REASON44 = 0x4d2c,
	PMU_PERF_E_DIDNT_ISSUE_REASON45 = 0x4d2d,
	PMU_PERF_E_DIDNT_ISSUE_REASON46 = 0x4d2e,
	PMU_PERF_E_DIDNT_ISSUE_REASON47 = 0x4d2f,
	PMU_PERF_E_DIDNT_ISSUE_REASON48 = 0x4d30,
	PMU_PERF_E_DIDNT_ISSUE_REASON49 = 0x4d31,
	PMU_PERF_E_DIDNT_ISSUE_REASON5 = 0x4d05,
	PMU_PERF_E_DIDNT_ISSUE_REASON50 = 0x4d32,
	PMU_PERF_E_DIDNT_ISSUE_REASON51 = 0x4d33,
	PMU_PERF_E_DIDNT_ISSUE_REASON52 = 0x4d34,
	PMU_PERF_E_DIDNT_ISSUE_REASON53 = 0x4d35,
	PMU_PERF_E_DIDNT_ISSUE_REASON54 = 0x4d36,
	PMU_PERF_E_DIDNT_ISSUE_REASON55 = 0x4d37,
	PMU_PERF_E_DIDNT_ISSUE_REASON56 = 0x4d38,
	PMU_PERF_E_DIDNT_ISSUE_REASON57 = 0x4d39,
	PMU_PERF_E_DIDNT_ISSUE_REASON58 = 0x4d3a,
	PMU_PERF_E_DIDNT_ISSUE_REASON59 = 0x4d3b,
	PMU_PERF_E_DIDNT_ISSUE_REASON6 = 0x4d06,
	PMU_PERF_E_DIDNT_ISSUE_REASON60 = 0x4d3c,
	PMU_PERF_E_DIDNT_ISSUE_REASON61 = 0x4d3d,
	PMU_PERF_E_DIDNT_ISSUE_REASON62 = 0x4d3e,
	PMU_PERF_E_DIDNT_ISSUE_REASON63 = 0x4d3f,
	PMU_PERF_E_DIDNT_ISSUE_REASON64 = 0x4d40,
	PMU_PERF_E_DIDNT_ISSUE_REASON65 = 0x4d41,
	PMU_PERF_E_DIDNT_ISSUE_REASON66 = 0x4d42,
	PMU_PERF_E_DIDNT_ISSUE_REASON67 = 0x4d43,
	PMU_PERF_E_DIDNT_ISSUE_REASON68 = 0x4d44,
	PMU_PERF_E_DIDNT_ISSUE_REASON69 = 0x4d45,
	PMU_PERF_E_DIDNT_ISSUE_REASON7 = 0x4d07,
	PMU_PERF_E_DIDNT_ISSUE_REASON70 = 0x4d46,
	PMU_PERF_E_DIDNT_ISSUE_REASON71 = 0x4d47,
	PMU_PERF_E_DIDNT_ISSUE_REASON72 = 0x4d48,
	PMU_PERF_E_DIDNT_ISSUE_REASON73 = 0x4d49,
	PMU_PERF_E_DIDNT_ISSUE_REASON74 = 0x4d4a,
	PMU_PERF_E_DIDNT_ISSUE_REASON75 = 0x4d4b,
	PMU_PERF_E_DIDNT_ISSUE_REASON76 = 0x4d4c,
	PMU_PERF_E_DIDNT_ISSUE_REASON77 = 0x4d4d,
	PMU_PERF_E_DIDNT_ISSUE_REASON78 = 0x4d4e,
	PMU_PERF_E_DIDNT_ISSUE_REASON79 = 0x4d4f,
	PMU_PERF_E_DIDNT_ISSUE_REASON8 = 0x4d08,
	PMU_PERF_E_DIDNT_ISSUE_REASON80 = 0x4d50,
	PMU_PERF_E_DIDNT_ISSUE_REASON81 = 0x4d51,
	PMU_PERF_E_DIDNT_ISSUE_REASON82 = 0x4d52,
	PMU_PERF_E_DIDNT_ISSUE_REASON83 = 0x4d53,
	PMU_PERF_E_DIDNT_ISSUE_REASON84 = 0x4d54,
	PMU_PERF_E_DIDNT_ISSUE_REASON85 = 0x4d55,
	PMU_PERF_E_DIDNT_ISSUE_REASON86 = 0x4d56,
	PMU_PERF_E_DIDNT_ISSUE_REASON87 = 0x4d57,
	PMU_PERF_E_DIDNT_ISSUE_REASON88 = 0x4d58,
	PMU_PERF_E_DIDNT_ISSUE_REASON89 = 0x4d59,
	PMU_PERF_E_DIDNT_ISSUE_REASON9 = 0x4d09,
	PMU_PERF_E_DIDNT_ISSUE_REASON90 = 0x4d5a,
	PMU_PERF_E_DIDNT_ISSUE_REASON91 = 0x4d5b,
	PMU_PERF_E_DIDNT_ISSUE_REASON92 = 0x4d5c,
	PMU_PERF_E_DIDNT_ISSUE_REASON93 = 0x4d5d,
	PMU_PERF_E_DIDNT_ISSUE_REASON94 = 0x4d5e,
	PMU_PERF_E_DIDNT_ISSUE_REASON95 = 0x4d5f,
	PMU_PERF_E_DIDNT_ISSUE_REASON96 = 0x4d60,
	PMU_PERF_E_DIDNT_ISSUE_REASON97 = 0x4d61,
	PMU_PERF_E_DIDNT_ISSUE_REASON98 = 0x4d62,
	PMU_PERF_E_DIDNT_ISSUE_REASON99 = 0x4d63,
	PMU_PERF_E_DISSUE = 0xc4,
	PMU_PERF_E_DMB_ISH = 0x1f2,
	PMU_PERF_E_DMB_NSH = 0x1f1,
	PMU_PERF_E_DMB_OSH = 0x1f3,
	PMU_PERF_E_DMB_SPEC = 0x7e,
	PMU_PERF_E_DMB_SY = 0x1f4,
	PMU_PERF_E_DP_SPEC = 0x73,
	PMU_PERF_E_DSB_ISH = 0x1f6,
	PMU_PERF_E_DSB_NSH = 0x1f5,
	PMU_PERF_E_DSB_OSH = 0x1f7,
	PMU_PERF_E_DSB_SPEC = 0x7d,
	PMU_PERF_E_DSB_SY = 0x1f8,
	PMU_PERF_E_ERET_MIS = 0xe7,
	PMU_PERF_E_EXC_DABORT = 0x84,
	PMU_PERF_E_EXC_FIQ = 0x87,
	PMU_PERF_E_EXC_HVC = 0x8a,
	PMU_PERF_E_EXC_IRQ = 0x86,
	PMU_PERF_E_EXC_PABORT = 0x83,
	PMU_PERF_E_EXC_RETURN = 0xa,
	PMU_PERF_E_EXC_SMC = 0x88,
	PMU_PERF_E_EXC_SVC = 0x82,
	PMU_PERF_E_EXC_TAKEN = 0x9,
	PMU_PERF_E_EXC_TRAP_DABORT = 0x8c,
	PMU_PERF_E_EXC_TRAP_FIQ = 0x8f,
	PMU_PERF_E_EXC_TRAP_IRQ = 0x8e,
	PMU_PERF_E_EXC_TRAP_OTHER = 0x8d,
	PMU_PERF_E_EXC_TRAP_PABORT = 0x8b,
	PMU_PERF_E_EXC_UNDEF = 0x81,
	PMU_PERF_E_FLEX_EX_DEL0 = 0x180,
	PMU_PERF_E_FLEX_EX_DEL1 = 0x181,
	PMU_PERF_E_FLEX_EX_DEL2 = 0x182,
	PMU_PERF_E_FLEX_EX_DEL3 = 0x183,
	PMU_PERF_E_F_MASK_CYC = 0x302,
	PMU_PERF_E_GLBL_SYNC = 0x1b8,
	PMU_PERF_E_IC_IALLUX = 0x1ba,
	PMU_PERF_E_IC_IALLU_RCVD = 0x1bc,
	PMU_PERF_E_IC_IVAU = 0x1bb,
	PMU_PERF_E_IC_IVAU_RCVD = 0x1bd,
	PMU_PERF_E_IDIDS = 0xe4,
	PMU_PERF_E_IFILL = 0xd3,
	PMU_PERF_E_II = 0xd6,
	PMU_PERF_E_INST_RETIRED = 0x8,
	PMU_PERF_E_INST_SPEC = 0x1b,
	PMU_PERF_E_IP = 0xd7,
	PMU_PERF_E_IPREF_LDI = 0xd1,
	PMU_PERF_E_ISB = 0x1f0,
	PMU_PERF_E_ISB_SPEC = 0x7c,
	PMU_PERF_E_ISSUE = 0xc1,
	PMU_PERF_E_ISSUE_CSRCLK = 0xee,
	PMU_PERF_E_ISSUE_ECLK = 0xc0,
	PMU_PERF_E_IUNA = 0xcc,
	PMU_PERF_E_I_MASK_CYC = 0x303,
	PMU_PERF_E_L0D_TLB_REFILL = 0x190,
	PMU_PERF_E_L0D_TLB_REFILL_LD = 0x191,
	PMU_PERF_E_L0D_TLB_REFILL_ST = 0x192,
	PMU_PERF_E_L0I_TLB_REFILL = 0x18f,
	PMU_PERF_E_L1D_CACHE = 0x4,
	PMU_PERF_E_L1D_CACHE_ALLOCATE = 0x1f,
	PMU_PERF_E_L1D_CACHE_INVAL = 0x48,
	PMU_PERF_E_L1D_CACHE_LD = 0x40,
	PMU_PERF_E_L1D_CACHE_MISS_ST = 0xe9,
	PMU_PERF_E_L1D_CACHE_PREF = 0xea,
	PMU_PERF_E_L1D_CACHE_REFILL = 0x3,
	PMU_PERF_E_L1D_CACHE_REFILL_INNER = 0x44,
	PMU_PERF_E_L1D_CACHE_REFILL_LD = 0x42,
	PMU_PERF_E_L1D_CACHE_REFILL_OUTER = 0x45,
	PMU_PERF_E_L1D_CACHE_REFILL_PREF = 0xeb,
	PMU_PERF_E_L1D_CACHE_REFILL_ST = 0x43,
	PMU_PERF_E_L1D_CACHE_ST = 0x41,
	PMU_PERF_E_L1D_CACHE_WB = 0x15,
	PMU_PERF_E_L1D_CACHE_WB_CLEAN = 0x47,
	PMU_PERF_E_L1D_CACHE_WB_VICTIM = 0x46,
	PMU_PERF_E_L1D_PTW_ACC_IPA_S1 = 0x198,
	PMU_PERF_E_L1D_PTW_ACC_L0_S1 = 0x194,
	PMU_PERF_E_L1D_PTW_ACC_L1_S1 = 0x195,
	PMU_PERF_E_L1D_PTW_ACC_L2_S1 = 0x196,
	PMU_PERF_E_L1D_PTW_ACC_L3_S1 = 0x197,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L0_S1 = 0x19e,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L0_S2 = 0x1a2,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L1_S1 = 0x19f,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L1_S2 = 0x1a3,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L2_S1 = 0x1a0,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L2_S2 = 0x1a4,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L3_S1 = 0x1a1,
	PMU_PERF_E_L1D_PTW_PWC_REFILL_L3_S2 = 0x1a5,
	PMU_PERF_E_L1D_PTW_REFILL_IPA_S2 = 0x19d,
	PMU_PERF_E_L1D_PTW_REFILL_L0_S1 = 0x199,
	PMU_PERF_E_L1D_PTW_REFILL_L1_S1 = 0x19a,
	PMU_PERF_E_L1D_PTW_REFILL_L2_S1 = 0x19b,
	PMU_PERF_E_L1D_PTW_REFILL_L3_S1 = 0x19c,
	PMU_PERF_E_L1D_TLB = 0x25,
	PMU_PERF_E_L1D_TLB_LD = 0x4e,
	PMU_PERF_E_L1D_TLB_REFILL = 0x5,
	PMU_PERF_E_L1D_TLB_REFILL_LD = 0x4c,
	PMU_PERF_E_L1D_TLB_REFILL_ST = 0x4d,
	PMU_PERF_E_L1D_TLB_ST = 0x4f,
	PMU_PERF_E_L1I_CACHE = 0x14,
	PMU_PERF_E_L1I_CACHE_PREF = 0xec,
	PMU_PERF_E_L1I_CACHE_REFILL = 0x1,
	PMU_PERF_E_L1I_CACHE_REFILL_PREF = 0xed,
	PMU_PERF_E_L1I_PTW_ACC_IPA_S1 = 0x1aa,
	PMU_PERF_E_L1I_PTW_ACC_L0_S1 = 0x1a6,
	PMU_PERF_E_L1I_PTW_ACC_L1_S1 = 0x1a7,
	PMU_PERF_E_L1I_PTW_ACC_L2_S1 = 0x1a8,
	PMU_PERF_E_L1I_PTW_ACC_L3_S1 = 0x1a9,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L0_S1 = 0x1b0,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L0_S2 = 0x1b4,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L1_S1 = 0x1b1,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L1_S2 = 0x1b5,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L2_S1 = 0x1b2,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L2_S2 = 0x1b6,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L3_S1 = 0x1b3,
	PMU_PERF_E_L1I_PTW_PWC_REFILL_L3_S2 = 0x1b7,
	PMU_PERF_E_L1I_PTW_REFILL_IPA_S2 = 0x1af,
	PMU_PERF_E_L1I_PTW_REFILL_L0_S1 = 0x1ab,
	PMU_PERF_E_L1I_PTW_REFILL_L1_S1 = 0x1ac,
	PMU_PERF_E_L1I_PTW_REFILL_L2_S1 = 0x1ad,
	PMU_PERF_E_L1I_PTW_REFILL_L3_S1 = 0x1ae,
	PMU_PERF_E_L1I_TLB = 0x26,
	PMU_PERF_E_L1I_TLB_REFILL = 0x2,
	PMU_PERF_E_L2C_EVENT_1 = 0x4c00,
	PMU_PERF_E_L2C_EVENT_10 = 0x4c09,
	PMU_PERF_E_L2C_EVENT_11 = 0x4c0a,
	PMU_PERF_E_L2C_EVENT_12 = 0x4c0b,
	PMU_PERF_E_L2C_EVENT_13 = 0x4c0c,
	PMU_PERF_E_L2C_EVENT_14 = 0x4c0d,
	PMU_PERF_E_L2C_EVENT_15 = 0x4c0e,
	PMU_PERF_E_L2C_EVENT_2 = 0x4c01,
	PMU_PERF_E_L2C_EVENT_3 = 0x4c02,
	PMU_PERF_E_L2C_EVENT_4 = 0x4c03,
	PMU_PERF_E_L2C_EVENT_5 = 0x4c04,
	PMU_PERF_E_L2C_EVENT_6 = 0x4c05,
	PMU_PERF_E_L2C_EVENT_7 = 0x4c06,
	PMU_PERF_E_L2C_EVENT_8 = 0x4c07,
	PMU_PERF_E_L2C_EVENT_9 = 0x4c08,
	PMU_PERF_E_L2D_CACHE = 0x16,
	PMU_PERF_E_L2D_CACHE_ALLOCATE = 0x20,
	PMU_PERF_E_L2D_CACHE_CACHE_INVAL = 0x58,
	PMU_PERF_E_L2D_CACHE_LD = 0x50,
	PMU_PERF_E_L2D_CACHE_REFILL = 0x17,
	PMU_PERF_E_L2D_CACHE_REFILL_LD = 0x52,
	PMU_PERF_E_L2D_CACHE_REFILL_ST = 0x53,
	PMU_PERF_E_L2D_CACHE_ST = 0x51,
	PMU_PERF_E_L2D_CACHE_WB = 0x18,
	PMU_PERF_E_L2D_CACHE_WB_CLEAN = 0x57,
	PMU_PERF_E_L2D_CACHE_WB_VICTIM = 0x56,
	PMU_PERF_E_L2D_TLB = 0x2f,
	PMU_PERF_E_L2D_TLB_REFILL = 0x2d,
	PMU_PERF_E_L2D_TLB_REFILL_LD = 0x5c,
	PMU_PERF_E_L2D_TLB_REFILL_ST = 0x5d,
	PMU_PERF_E_L2I_CACHE = 0x27,
	PMU_PERF_E_L2I_CACHE_REFILL = 0x28,
	PMU_PERF_E_L2I_TLB = 0x30,
	PMU_PERF_E_L2I_TLB_REFILL = 0x2e,
	PMU_PERF_E_L3D_CACHE = 0x2b,
	PMU_PERF_E_L3D_CACHE_ALLOCATE = 0x29,
	PMU_PERF_E_L3D_CACHE_REFILL = 0x2a,
	PMU_PERF_E_L3D_CACHE_WB = 0x2c,
	PMU_PERF_E_LDREX_SPEC = 0x6c,
	PMU_PERF_E_LDST_SPEC = 0x72,
	PMU_PERF_E_LDX = 0x1f9,
	PMU_PERF_E_LD_DEV_IO = 0x188,
	PMU_PERF_E_LD_DEV_MEM = 0x18a,
	PMU_PERF_E_LD_NORM_IO = 0x184,
	PMU_PERF_E_LD_NORM_MEM = 0x186,
	PMU_PERF_E_LD_RETIRED = 0x6,
	PMU_PERF_E_LD_SPEC = 0x70,
	PMU_PERF_E_MEMORY_ERROR = 0x1a,
	PMU_PERF_E_MEM_ACCESS = 0x13,
	PMU_PERF_E_MEM_ACCESS_LD = 0x66,
	PMU_PERF_E_MEM_ACCESS_ST = 0x67,
	PMU_PERF_E_MSR_HAZTR = 0xe8,
	PMU_PERF_E_NISSUE = 0xc2,
	PMU_PERF_E_PC_WRITE_RETIRED = 0xc,
	PMU_PERF_E_PTW_CYCLES = 0x193,
	PMU_PERF_E_RC_LD_SPEC = 0x90,
	PMU_PERF_E_RC_ST_SPEC = 0x91,
	PMU_PERF_E_REPLAY = 0xcb,
	PMU_PERF_E_SEV = 0x1b9,
	PMU_PERF_E_SISSUE = 0xc3,
	PMU_PERF_E_STALL_BACKEND = 0x24,
	PMU_PERF_E_STALL_FRONTEND = 0x23,
	PMU_PERF_E_STREX_FAIL_SPEC = 0x6e,
	PMU_PERF_E_STREX_PASS_SPEC = 0x6d,
	PMU_PERF_E_STX = 0x1fa,
	PMU_PERF_E_STX_FAIL = 0x1fb,
	PMU_PERF_E_ST_DEV_IO = 0x189,
	PMU_PERF_E_ST_DEV_MEM = 0x18b,
	PMU_PERF_E_ST_NORM_IO = 0x185,
	PMU_PERF_E_ST_NORM_MEM = 0x187,
	PMU_PERF_E_ST_RETIRED = 0x7,
	PMU_PERF_E_ST_SPEC = 0x71,
	PMU_PERF_E_SW_INCR = 0x0,
	PMU_PERF_E_THROTTLE_OFF = 0xef,
	PMU_PERF_E_TLBI_ALLE1 = 0x1c6,
	PMU_PERF_E_TLBI_ALLE1IS = 0x1c7,
	PMU_PERF_E_TLBI_ALLE2 = 0x1c8,
	PMU_PERF_E_TLBI_ALLE2IS = 0x1c9,
	PMU_PERF_E_TLBI_ALLE3 = 0x1ca,
	PMU_PERF_E_TLBI_ALLE3IS = 0x1cb,
	PMU_PERF_E_TLBI_ASIDE1 = 0x1cc,
	PMU_PERF_E_TLBI_ASIDE1IS = 0x1cd,
	PMU_PERF_E_TLBI_IPAS2E1 = 0x1ce,
	PMU_PERF_E_TLBI_IPAS2E1IS = 0x1cf,
	PMU_PERF_E_TLBI_IPAS2LE1 = 0x1d0,
	PMU_PERF_E_TLBI_IPAS2LE1IS = 0x1d1,
	PMU_PERF_E_TLBI_RCVD = 0x1c5,
	PMU_PERF_E_TLBI_SENT = 0x1c4,
	PMU_PERF_E_TLBI_VAAE1 = 0x1d2,
	PMU_PERF_E_TLBI_VAAE1IS = 0x1d3,
	PMU_PERF_E_TLBI_VAALE1 = 0x1d4,
	PMU_PERF_E_TLBI_VAALE1IS = 0x1d5,
	PMU_PERF_E_TLBI_VAE1 = 0x1d6,
	PMU_PERF_E_TLBI_VAE1IS = 0x1d7,
	PMU_PERF_E_TLBI_VAE2 = 0x1d8,
	PMU_PERF_E_TLBI_VAE2IS = 0x1d9,
	PMU_PERF_E_TLBI_VAE3 = 0x1da,
	PMU_PERF_E_TLBI_VAE3IS = 0x1db,
	PMU_PERF_E_TLBI_VALE1 = 0x1dc,
	PMU_PERF_E_TLBI_VALE1IS = 0x1dd,
	PMU_PERF_E_TLBI_VALE2 = 0x1de,
	PMU_PERF_E_TLBI_VALE2IS = 0x1df,
	PMU_PERF_E_TLBI_VALE3 = 0x1e0,
	PMU_PERF_E_TLBI_VALE3IS = 0x1e1,
	PMU_PERF_E_TLBI_VMALLE1 = 0x1e2,
	PMU_PERF_E_TLBI_VMALLE1IS = 0x1e3,
	PMU_PERF_E_TLBI_VMALLS12E1 = 0x1e4,
	PMU_PERF_E_TLBI_VMALLS12E1IS = 0x1e5,
	PMU_PERF_E_TLB_REFILL_TTBR0_ELX = 0x18c,
	PMU_PERF_E_TLB_REFILL_TTBR1_ELX = 0x18d,
	PMU_PERF_E_TLB_REFILL_VTTBR_EL2 = 0x18e,
	PMU_PERF_E_TRAP = 0xcd,
	PMU_PERF_E_TRAP_REASON0 = 0x4f00,
	PMU_PERF_E_TRAP_REASON1 = 0x4f01,
	PMU_PERF_E_TRAP_REASON10 = 0x4f0a,
	PMU_PERF_E_TRAP_REASON100 = 0x4f64,
	PMU_PERF_E_TRAP_REASON101 = 0x4f65,
	PMU_PERF_E_TRAP_REASON102 = 0x4f66,
	PMU_PERF_E_TRAP_REASON103 = 0x4f67,
	PMU_PERF_E_TRAP_REASON104 = 0x4f68,
	PMU_PERF_E_TRAP_REASON105 = 0x4f69,
	PMU_PERF_E_TRAP_REASON106 = 0x4f6a,
	PMU_PERF_E_TRAP_REASON107 = 0x4f6b,
	PMU_PERF_E_TRAP_REASON108 = 0x4f6c,
	PMU_PERF_E_TRAP_REASON109 = 0x4f6d,
	PMU_PERF_E_TRAP_REASON11 = 0x4f0b,
	PMU_PERF_E_TRAP_REASON110 = 0x4f6e,
	PMU_PERF_E_TRAP_REASON111 = 0x4f6f,
	PMU_PERF_E_TRAP_REASON112 = 0x4f70,
	PMU_PERF_E_TRAP_REASON113 = 0x4f71,
	PMU_PERF_E_TRAP_REASON114 = 0x4f72,
	PMU_PERF_E_TRAP_REASON115 = 0x4f73,
	PMU_PERF_E_TRAP_REASON116 = 0x4f74,
	PMU_PERF_E_TRAP_REASON117 = 0x4f75,
	PMU_PERF_E_TRAP_REASON118 = 0x4f76,
	PMU_PERF_E_TRAP_REASON119 = 0x4f77,
	PMU_PERF_E_TRAP_REASON12 = 0x4f0c,
	PMU_PERF_E_TRAP_REASON120 = 0x4f78,
	PMU_PERF_E_TRAP_REASON121 = 0x4f79,
	PMU_PERF_E_TRAP_REASON122 = 0x4f7a,
	PMU_PERF_E_TRAP_REASON123 = 0x4f7b,
	PMU_PERF_E_TRAP_REASON124 = 0x4f7c,
	PMU_PERF_E_TRAP_REASON125 = 0x4f7d,
	PMU_PERF_E_TRAP_REASON126 = 0x4f7e,
	PMU_PERF_E_TRAP_REASON127 = 0x4f7f,
	PMU_PERF_E_TRAP_REASON128 = 0x4f80,
	PMU_PERF_E_TRAP_REASON129 = 0x4f81,
	PMU_PERF_E_TRAP_REASON13 = 0x4f0d,
	PMU_PERF_E_TRAP_REASON130 = 0x4f82,
	PMU_PERF_E_TRAP_REASON131 = 0x4f83,
	PMU_PERF_E_TRAP_REASON132 = 0x4f84,
	PMU_PERF_E_TRAP_REASON133 = 0x4f85,
	PMU_PERF_E_TRAP_REASON134 = 0x4f86,
	PMU_PERF_E_TRAP_REASON135 = 0x4f87,
	PMU_PERF_E_TRAP_REASON136 = 0x4f88,
	PMU_PERF_E_TRAP_REASON137 = 0x4f89,
	PMU_PERF_E_TRAP_REASON138 = 0x4f8a,
	PMU_PERF_E_TRAP_REASON139 = 0x4f8b,
	PMU_PERF_E_TRAP_REASON14 = 0x4f0e,
	PMU_PERF_E_TRAP_REASON140 = 0x4f8c,
	PMU_PERF_E_TRAP_REASON141 = 0x4f8d,
	PMU_PERF_E_TRAP_REASON142 = 0x4f8e,
	PMU_PERF_E_TRAP_REASON143 = 0x4f8f,
	PMU_PERF_E_TRAP_REASON144 = 0x4f90,
	PMU_PERF_E_TRAP_REASON145 = 0x4f91,
	PMU_PERF_E_TRAP_REASON146 = 0x4f92,
	PMU_PERF_E_TRAP_REASON147 = 0x4f93,
	PMU_PERF_E_TRAP_REASON148 = 0x4f94,
	PMU_PERF_E_TRAP_REASON149 = 0x4f95,
	PMU_PERF_E_TRAP_REASON15 = 0x4f0f,
	PMU_PERF_E_TRAP_REASON150 = 0x4f96,
	PMU_PERF_E_TRAP_REASON151 = 0x4f97,
	PMU_PERF_E_TRAP_REASON152 = 0x4f98,
	PMU_PERF_E_TRAP_REASON153 = 0x4f99,
	PMU_PERF_E_TRAP_REASON154 = 0x4f9a,
	PMU_PERF_E_TRAP_REASON155 = 0x4f9b,
	PMU_PERF_E_TRAP_REASON156 = 0x4f9c,
	PMU_PERF_E_TRAP_REASON157 = 0x4f9d,
	PMU_PERF_E_TRAP_REASON158 = 0x4f9e,
	PMU_PERF_E_TRAP_REASON159 = 0x4f9f,
	PMU_PERF_E_TRAP_REASON16 = 0x4f10,
	PMU_PERF_E_TRAP_REASON160 = 0x4fa0,
	PMU_PERF_E_TRAP_REASON161 = 0x4fa1,
	PMU_PERF_E_TRAP_REASON162 = 0x4fa2,
	PMU_PERF_E_TRAP_REASON163 = 0x4fa3,
	PMU_PERF_E_TRAP_REASON164 = 0x4fa4,
	PMU_PERF_E_TRAP_REASON165 = 0x4fa5,
	PMU_PERF_E_TRAP_REASON166 = 0x4fa6,
	PMU_PERF_E_TRAP_REASON167 = 0x4fa7,
	PMU_PERF_E_TRAP_REASON168 = 0x4fa8,
	PMU_PERF_E_TRAP_REASON169 = 0x4fa9,
	PMU_PERF_E_TRAP_REASON17 = 0x4f11,
	PMU_PERF_E_TRAP_REASON170 = 0x4faa,
	PMU_PERF_E_TRAP_REASON171 = 0x4fab,
	PMU_PERF_E_TRAP_REASON172 = 0x4fac,
	PMU_PERF_E_TRAP_REASON173 = 0x4fad,
	PMU_PERF_E_TRAP_REASON174 = 0x4fae,
	PMU_PERF_E_TRAP_REASON175 = 0x4faf,
	PMU_PERF_E_TRAP_REASON176 = 0x4fb0,
	PMU_PERF_E_TRAP_REASON177 = 0x4fb1,
	PMU_PERF_E_TRAP_REASON178 = 0x4fb2,
	PMU_PERF_E_TRAP_REASON179 = 0x4fb3,
	PMU_PERF_E_TRAP_REASON18 = 0x4f12,
	PMU_PERF_E_TRAP_REASON180 = 0x4fb4,
	PMU_PERF_E_TRAP_REASON181 = 0x4fb5,
	PMU_PERF_E_TRAP_REASON182 = 0x4fb6,
	PMU_PERF_E_TRAP_REASON183 = 0x4fb7,
	PMU_PERF_E_TRAP_REASON184 = 0x4fb8,
	PMU_PERF_E_TRAP_REASON185 = 0x4fb9,
	PMU_PERF_E_TRAP_REASON186 = 0x4fba,
	PMU_PERF_E_TRAP_REASON187 = 0x4fbb,
	PMU_PERF_E_TRAP_REASON188 = 0x4fbc,
	PMU_PERF_E_TRAP_REASON189 = 0x4fbd,
	PMU_PERF_E_TRAP_REASON19 = 0x4f13,
	PMU_PERF_E_TRAP_REASON190 = 0x4fbe,
	PMU_PERF_E_TRAP_REASON191 = 0x4fbf,
	PMU_PERF_E_TRAP_REASON192 = 0x4fc0,
	PMU_PERF_E_TRAP_REASON193 = 0x4fc1,
	PMU_PERF_E_TRAP_REASON194 = 0x4fc2,
	PMU_PERF_E_TRAP_REASON195 = 0x4fc3,
	PMU_PERF_E_TRAP_REASON196 = 0x4fc4,
	PMU_PERF_E_TRAP_REASON197 = 0x4fc5,
	PMU_PERF_E_TRAP_REASON198 = 0x4fc6,
	PMU_PERF_E_TRAP_REASON199 = 0x4fc7,
	PMU_PERF_E_TRAP_REASON2 = 0x4f02,
	PMU_PERF_E_TRAP_REASON20 = 0x4f14,
	PMU_PERF_E_TRAP_REASON200 = 0x4fc8,
	PMU_PERF_E_TRAP_REASON201 = 0x4fc9,
	PMU_PERF_E_TRAP_REASON202 = 0x4fca,
	PMU_PERF_E_TRAP_REASON203 = 0x4fcb,
	PMU_PERF_E_TRAP_REASON204 = 0x4fcc,
	PMU_PERF_E_TRAP_REASON205 = 0x4fcd,
	PMU_PERF_E_TRAP_REASON206 = 0x4fce,
	PMU_PERF_E_TRAP_REASON207 = 0x4fcf,
	PMU_PERF_E_TRAP_REASON208 = 0x4fd0,
	PMU_PERF_E_TRAP_REASON209 = 0x4fd1,
	PMU_PERF_E_TRAP_REASON21 = 0x4f15,
	PMU_PERF_E_TRAP_REASON210 = 0x4fd2,
	PMU_PERF_E_TRAP_REASON211 = 0x4fd3,
	PMU_PERF_E_TRAP_REASON212 = 0x4fd4,
	PMU_PERF_E_TRAP_REASON213 = 0x4fd5,
	PMU_PERF_E_TRAP_REASON214 = 0x4fd6,
	PMU_PERF_E_TRAP_REASON215 = 0x4fd7,
	PMU_PERF_E_TRAP_REASON216 = 0x4fd8,
	PMU_PERF_E_TRAP_REASON217 = 0x4fd9,
	PMU_PERF_E_TRAP_REASON218 = 0x4fda,
	PMU_PERF_E_TRAP_REASON219 = 0x4fdb,
	PMU_PERF_E_TRAP_REASON22 = 0x4f16,
	PMU_PERF_E_TRAP_REASON220 = 0x4fdc,
	PMU_PERF_E_TRAP_REASON221 = 0x4fdd,
	PMU_PERF_E_TRAP_REASON222 = 0x4fde,
	PMU_PERF_E_TRAP_REASON223 = 0x4fdf,
	PMU_PERF_E_TRAP_REASON224 = 0x4fe0,
	PMU_PERF_E_TRAP_REASON225 = 0x4fe1,
	PMU_PERF_E_TRAP_REASON226 = 0x4fe2,
	PMU_PERF_E_TRAP_REASON227 = 0x4fe3,
	PMU_PERF_E_TRAP_REASON228 = 0x4fe4,
	PMU_PERF_E_TRAP_REASON229 = 0x4fe5,
	PMU_PERF_E_TRAP_REASON23 = 0x4f17,
	PMU_PERF_E_TRAP_REASON230 = 0x4fe6,
	PMU_PERF_E_TRAP_REASON231 = 0x4fe7,
	PMU_PERF_E_TRAP_REASON232 = 0x4fe8,
	PMU_PERF_E_TRAP_REASON233 = 0x4fe9,
	PMU_PERF_E_TRAP_REASON234 = 0x4fea,
	PMU_PERF_E_TRAP_REASON235 = 0x4feb,
	PMU_PERF_E_TRAP_REASON236 = 0x4fec,
	PMU_PERF_E_TRAP_REASON237 = 0x4fed,
	PMU_PERF_E_TRAP_REASON238 = 0x4fee,
	PMU_PERF_E_TRAP_REASON239 = 0x4fef,
	PMU_PERF_E_TRAP_REASON24 = 0x4f18,
	PMU_PERF_E_TRAP_REASON240 = 0x4ff0,
	PMU_PERF_E_TRAP_REASON241 = 0x4ff1,
	PMU_PERF_E_TRAP_REASON242 = 0x4ff2,
	PMU_PERF_E_TRAP_REASON243 = 0x4ff3,
	PMU_PERF_E_TRAP_REASON244 = 0x4ff4,
	PMU_PERF_E_TRAP_REASON245 = 0x4ff5,
	PMU_PERF_E_TRAP_REASON246 = 0x4ff6,
	PMU_PERF_E_TRAP_REASON247 = 0x4ff7,
	PMU_PERF_E_TRAP_REASON248 = 0x4ff8,
	PMU_PERF_E_TRAP_REASON249 = 0x4ff9,
	PMU_PERF_E_TRAP_REASON25 = 0x4f19,
	PMU_PERF_E_TRAP_REASON250 = 0x4ffa,
	PMU_PERF_E_TRAP_REASON251 = 0x4ffb,
	PMU_PERF_E_TRAP_REASON252 = 0x4ffc,
	PMU_PERF_E_TRAP_REASON253 = 0x4ffd,
	PMU_PERF_E_TRAP_REASON254 = 0x4ffe,
	PMU_PERF_E_TRAP_REASON255 = 0x4fff,
	PMU_PERF_E_TRAP_REASON26 = 0x4f1a,
	PMU_PERF_E_TRAP_REASON27 = 0x4f1b,
	PMU_PERF_E_TRAP_REASON28 = 0x4f1c,
	PMU_PERF_E_TRAP_REASON29 = 0x4f1d,
	PMU_PERF_E_TRAP_REASON3 = 0x4f03,
	PMU_PERF_E_TRAP_REASON30 = 0x4f1e,
	PMU_PERF_E_TRAP_REASON31 = 0x4f1f,
	PMU_PERF_E_TRAP_REASON32 = 0x4f20,
	PMU_PERF_E_TRAP_REASON33 = 0x4f21,
	PMU_PERF_E_TRAP_REASON34 = 0x4f22,
	PMU_PERF_E_TRAP_REASON35 = 0x4f23,
	PMU_PERF_E_TRAP_REASON36 = 0x4f24,
	PMU_PERF_E_TRAP_REASON37 = 0x4f25,
	PMU_PERF_E_TRAP_REASON38 = 0x4f26,
	PMU_PERF_E_TRAP_REASON39 = 0x4f27,
	PMU_PERF_E_TRAP_REASON4 = 0x4f04,
	PMU_PERF_E_TRAP_REASON40 = 0x4f28,
	PMU_PERF_E_TRAP_REASON41 = 0x4f29,
	PMU_PERF_E_TRAP_REASON42 = 0x4f2a,
	PMU_PERF_E_TRAP_REASON43 = 0x4f2b,
	PMU_PERF_E_TRAP_REASON44 = 0x4f2c,
	PMU_PERF_E_TRAP_REASON45 = 0x4f2d,
	PMU_PERF_E_TRAP_REASON46 = 0x4f2e,
	PMU_PERF_E_TRAP_REASON47 = 0x4f2f,
	PMU_PERF_E_TRAP_REASON48 = 0x4f30,
	PMU_PERF_E_TRAP_REASON49 = 0x4f31,
	PMU_PERF_E_TRAP_REASON5 = 0x4f05,
	PMU_PERF_E_TRAP_REASON50 = 0x4f32,
	PMU_PERF_E_TRAP_REASON51 = 0x4f33,
	PMU_PERF_E_TRAP_REASON52 = 0x4f34,
	PMU_PERF_E_TRAP_REASON53 = 0x4f35,
	PMU_PERF_E_TRAP_REASON54 = 0x4f36,
	PMU_PERF_E_TRAP_REASON55 = 0x4f37,
	PMU_PERF_E_TRAP_REASON56 = 0x4f38,
	PMU_PERF_E_TRAP_REASON57 = 0x4f39,
	PMU_PERF_E_TRAP_REASON58 = 0x4f3a,
	PMU_PERF_E_TRAP_REASON59 = 0x4f3b,
	PMU_PERF_E_TRAP_REASON6 = 0x4f06,
	PMU_PERF_E_TRAP_REASON60 = 0x4f3c,
	PMU_PERF_E_TRAP_REASON61 = 0x4f3d,
	PMU_PERF_E_TRAP_REASON62 = 0x4f3e,
	PMU_PERF_E_TRAP_REASON63 = 0x4f3f,
	PMU_PERF_E_TRAP_REASON64 = 0x4f40,
	PMU_PERF_E_TRAP_REASON65 = 0x4f41,
	PMU_PERF_E_TRAP_REASON66 = 0x4f42,
	PMU_PERF_E_TRAP_REASON67 = 0x4f43,
	PMU_PERF_E_TRAP_REASON68 = 0x4f44,
	PMU_PERF_E_TRAP_REASON69 = 0x4f45,
	PMU_PERF_E_TRAP_REASON7 = 0x4f07,
	PMU_PERF_E_TRAP_REASON70 = 0x4f46,
	PMU_PERF_E_TRAP_REASON71 = 0x4f47,
	PMU_PERF_E_TRAP_REASON72 = 0x4f48,
	PMU_PERF_E_TRAP_REASON73 = 0x4f49,
	PMU_PERF_E_TRAP_REASON74 = 0x4f4a,
	PMU_PERF_E_TRAP_REASON75 = 0x4f4b,
	PMU_PERF_E_TRAP_REASON76 = 0x4f4c,
	PMU_PERF_E_TRAP_REASON77 = 0x4f4d,
	PMU_PERF_E_TRAP_REASON78 = 0x4f4e,
	PMU_PERF_E_TRAP_REASON79 = 0x4f4f,
	PMU_PERF_E_TRAP_REASON8 = 0x4f08,
	PMU_PERF_E_TRAP_REASON80 = 0x4f50,
	PMU_PERF_E_TRAP_REASON81 = 0x4f51,
	PMU_PERF_E_TRAP_REASON82 = 0x4f52,
	PMU_PERF_E_TRAP_REASON83 = 0x4f53,
	PMU_PERF_E_TRAP_REASON84 = 0x4f54,
	PMU_PERF_E_TRAP_REASON85 = 0x4f55,
	PMU_PERF_E_TRAP_REASON86 = 0x4f56,
	PMU_PERF_E_TRAP_REASON87 = 0x4f57,
	PMU_PERF_E_TRAP_REASON88 = 0x4f58,
	PMU_PERF_E_TRAP_REASON89 = 0x4f59,
	PMU_PERF_E_TRAP_REASON9 = 0x4f09,
	PMU_PERF_E_TRAP_REASON90 = 0x4f5a,
	PMU_PERF_E_TRAP_REASON91 = 0x4f5b,
	PMU_PERF_E_TRAP_REASON92 = 0x4f5c,
	PMU_PERF_E_TRAP_REASON93 = 0x4f5d,
	PMU_PERF_E_TRAP_REASON94 = 0x4f5e,
	PMU_PERF_E_TRAP_REASON95 = 0x4f5f,
	PMU_PERF_E_TRAP_REASON96 = 0x4f60,
	PMU_PERF_E_TRAP_REASON97 = 0x4f61,
	PMU_PERF_E_TRAP_REASON98 = 0x4f62,
	PMU_PERF_E_TRAP_REASON99 = 0x4f63,
	PMU_PERF_E_TTBR_WRITE_RETIRED = 0x1c,
	PMU_PERF_E_ULOAD = 0xce,
	PMU_PERF_E_UNALIGNED_LDST_RETIRED = 0xf,
	PMU_PERF_E_UNALIGNED_LDST_SPEC = 0x6a,
	PMU_PERF_E_UNALIGNED_LD_SPEC = 0x68,
	PMU_PERF_E_UNALIGNED_ST_SPEC = 0x69,
	PMU_PERF_E_USTORE = 0xcf,
	PMU_PERF_E_VFP_SPEC = 0x75,
	PMU_PERF_E_VMID_OVF = 0x301,
	PMU_PERF_E_WBUF = 0xdb,
	PMU_PERF_E_WBUFFL = 0xde,
	PMU_PERF_E_WBUFLD = 0xdd,
	PMU_PERF_E_WBUFTR = 0xdf,
	PMU_PERF_E_WDAT = 0xdc,
	PMU_PERF_E_ENUM_LAST = 0x5000,
};



/**
 * DAB32b - pmu#_pmauthstatus
 *
 * Provides information about the state of the implementation
 * defined authentication interface for performance monitors.
 */
typedef union bdk_pmux_pmauthstatus {
	uint32_t u;
	struct bdk_pmux_pmauthstatus_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t snid                        : 2;  /**< RO - Holds the same value as DBGAUTHSTATUS_EL1.SNID. */
		uint32_t reserved_4_5                : 2;
		uint32_t nsnid                       : 2;  /**< RO - Holds the same value as DBGAUTHSTATUS_EL1.NSNID. */
		uint32_t reserved_0_1                : 2;
#else
		uint32_t reserved_0_1                : 2;
		uint32_t nsnid                       : 2;
		uint32_t reserved_4_5                : 2;
		uint32_t snid                        : 2;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmauthstatus_s     cn85xx; */
	/* struct bdk_pmux_pmauthstatus_s     cn88xx; */
	/* struct bdk_pmux_pmauthstatus_s     cn88xxp1; */
} bdk_pmux_pmauthstatus_t;

static inline uint64_t BDK_PMUX_PMAUTHSTATUS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMAUTHSTATUS(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FB8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMAUTHSTATUS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMAUTHSTATUS(...) bdk_pmux_pmauthstatus_t
#define bustype_BDK_PMUX_PMAUTHSTATUS(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMAUTHSTATUS(p1) (p1)
#define arguments_BDK_PMUX_PMAUTHSTATUS(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMAUTHSTATUS(...) "PMUX_PMAUTHSTATUS"


/**
 * DAB32b - pmu#_pmccfiltr_el0
 *
 * Determines the modes in which the Cycle Counter, PMU()_PMCCNTR_EL0,
 * increments.
 */
typedef union bdk_pmux_pmccfiltr_el0 {
	uint32_t u;
	struct bdk_pmux_pmccfiltr_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t p                           : 1;  /**< R/W - EL1 modes filtering bit. Controls counting in EL1. If EL3 is
                                                                     implemented, then counting in Non-secure EL1 is further
                                                                     controlled by the NSK bit. The possible values of this bit
                                                                     are:
                                                                 0 = Count cycles in EL1.
                                                                 1 = Do not count cycles in EL1. */
		uint32_t u                           : 1;  /**< R/W - EL0 filtering bit. Controls counting in EL0. If EL3 is
                                                                     implemented, then counting in Non-secure EL0 is further
                                                                     controlled by the NSU bit. The possible values of this bit
                                                                     are:
                                                                 0 = Count cycles in EL0.
                                                                 1 = Do not count cycles in EL0. */
		uint32_t nsk                         : 1;  /**< R/W - Non-secure kernel modes filtering bit. Controls counting in
                                                                     Non-secure EL1. If EL3 is not implemented, this bit is RES0.
                                                                 If the value of this bit is equal to the value of P, cycles in
                                                                     Non-secure EL1 are counted.
                                                                 Otherwise, cycles in Non-secure EL1 are not counted. */
		uint32_t nsu                         : 1;  /**< R/W - Non-secure user modes filtering bit. Controls counting in Non-
                                                                     secure EL0. If EL3 is not implemented, this bit is RES0.
                                                                 If the value of this bit is equal to the value of U, cycles in
                                                                     Non-secure EL0 are counted.
                                                                 Otherwise, cycles in Non-secure EL0 are not counted. */
		uint32_t nsh                         : 1;  /**< R/W - Non-secure Hyp modes filtering bit. Controls counting in Non-
                                                                     secure EL2. If EL2 is not implemented, this bit is RES0.
                                                                 0 = Do not count cycles in EL2.
                                                                 1 = Count cycles in EL2. */
		uint32_t m                           : 1;  /**< R/W - Secure EL3 filtering bit. Most applications can ignore this
                                                                     bit and set the value to zero. If EL3 is not implemented, this
                                                                     bit is RES0.
                                                                 If the value of this bit is equal to the value of P, cycles in
                                                                     Secure EL3 are counted.
                                                                 Otherwise, cycles in Secure EL3 are not counted. */
		uint32_t reserved_0_25               : 26;
#else
		uint32_t reserved_0_25               : 26;
		uint32_t m                           : 1;
		uint32_t nsh                         : 1;
		uint32_t nsu                         : 1;
		uint32_t nsk                         : 1;
		uint32_t u                           : 1;
		uint32_t p                           : 1;
#endif
	} s;
	/* struct bdk_pmux_pmccfiltr_el0_s    cn85xx; */
	/* struct bdk_pmux_pmccfiltr_el0_s    cn88xx; */
	/* struct bdk_pmux_pmccfiltr_el0_s    cn88xxp1; */
} bdk_pmux_pmccfiltr_el0_t;

static inline uint64_t BDK_PMUX_PMCCFILTR_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCCFILTR_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A00802047Cull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCCFILTR_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCCFILTR_EL0(...) bdk_pmux_pmccfiltr_el0_t
#define bustype_BDK_PMUX_PMCCFILTR_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCCFILTR_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMCCFILTR_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCCFILTR_EL0(...) "PMUX_PMCCFILTR_EL0"


/**
 * DAB32b - pmu#_pmccntr_el0_hi
 *
 * Holds the value of the processor Cycle Counter, CCNT, that counts processor clock cycles.
 *
 */
typedef union bdk_pmux_pmccntr_el0_hi {
	uint32_t u;
	struct bdk_pmux_pmccntr_el0_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t value                       : 32; /**< R/W - Cycle count. Depending on the values of PMU()_PMCR_EL0[LC,D], the cycle count
                                                                 increments in one of the following ways:
                                                                 * Every processor clock cycle.
                                                                 * Every 64th processor clock cycle.
                                                                 The cycle count can be reset to zero by writing 1 to PMU()_PMCR_EL0[C]. */
#else
		uint32_t value                       : 32;
#endif
	} s;
	/* struct bdk_pmux_pmccntr_el0_hi_s   cn85xx; */
	/* struct bdk_pmux_pmccntr_el0_hi_s   cn88xx; */
	/* struct bdk_pmux_pmccntr_el0_hi_s   cn88xxp1; */
} bdk_pmux_pmccntr_el0_hi_t;

static inline uint64_t BDK_PMUX_PMCCNTR_EL0_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCCNTR_EL0_HI(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A0080200FCull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCCNTR_EL0_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCCNTR_EL0_HI(...) bdk_pmux_pmccntr_el0_hi_t
#define bustype_BDK_PMUX_PMCCNTR_EL0_HI(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCCNTR_EL0_HI(p1) (p1)
#define arguments_BDK_PMUX_PMCCNTR_EL0_HI(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCCNTR_EL0_HI(...) "PMUX_PMCCNTR_EL0_HI"


/**
 * DAB32b - pmu#_pmccntr_el0_lo
 *
 * Holds the value of the processor Cycle Counter, CCNT, that counts processor clock cycles.
 *
 */
typedef union bdk_pmux_pmccntr_el0_lo {
	uint32_t u;
	struct bdk_pmux_pmccntr_el0_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t value                       : 32; /**< R/W - Cycle count. Depending on the values of PMU()_PMCR_EL0[LC,D], the cycle count
                                                                 increments in one of the following ways:
                                                                 * Every processor clock cycle.
                                                                 * Every 64th processor clock cycle.
                                                                 The cycle count can be reset to zero by writing 1 to PMU()_PMCR_EL0[C]. */
#else
		uint32_t value                       : 32;
#endif
	} s;
	/* struct bdk_pmux_pmccntr_el0_lo_s   cn85xx; */
	/* struct bdk_pmux_pmccntr_el0_lo_s   cn88xx; */
	/* struct bdk_pmux_pmccntr_el0_lo_s   cn88xxp1; */
} bdk_pmux_pmccntr_el0_lo_t;

static inline uint64_t BDK_PMUX_PMCCNTR_EL0_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCCNTR_EL0_LO(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A0080200F8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCCNTR_EL0_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCCNTR_EL0_LO(...) bdk_pmux_pmccntr_el0_lo_t
#define bustype_BDK_PMUX_PMCCNTR_EL0_LO(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCCNTR_EL0_LO(p1) (p1)
#define arguments_BDK_PMUX_PMCCNTR_EL0_LO(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCCNTR_EL0_LO(...) "PMUX_PMCCNTR_EL0_LO"


/**
 * DAB32b - pmu#_pmceid0
 *
 * Defines which common architectural and common
 * microarchitectural feature events are implemented. If a
 * particular bit is set to 1, then the event for that bit is
 * implemented. Alias for PMU()_PMCEID1_EL0[31:0].
 */
typedef union bdk_pmux_pmceid0 {
	uint32_t u;
	struct bdk_pmux_pmceid0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ce                          : 32; /**< RO - Common architectural and microarchitectural feature events that can be counted
                                                                 by the PMU event counters.

                                                                 In CNXXXX, the following bits are set to indicate the corresponding events are
                                                                 implemented:
                                                                   30 = 0x001e = CHAIN.
                                                                   28 = 0x001c = TTBR_WRITE_RETIRED.
                                                                   27 = 0x001b = INST_SPEC.
                                                                   26 = 0x001a = MEMORY_ERROR.
                                                                   24 = 0x0018 = L2D_CACHE_WB.
                                                                   23 = 0x0017 = L2D_CACHE_REFILL.
                                                                   22 = 0x0016 = L2D_CACHE.
                                                                   20 = 0x0014 = L1I_CACHE.
                                                                   19 = 0x0013 = MEM_ACCESS.
                                                                   18 = 0x0012 = BR_PRED.
                                                                   17 = 0x0011 = CPU_CYCLES.
                                                                   16 = 0x0010 = BR_MIS_PRED.
                                                                   15 = 0x000f = UNALIGNED_LDST_RETIRED.
                                                                   14 = 0x000e = BR_RETURN_RETIRED.
                                                                   13 = 0x000d = BR_IMMED_RETIRED.
                                                                   12 = 0x000c = PC_WRITE_RETIRED.
                                                                   11 = 0x000b = CID_WRITE_RETIRED.
                                                                   10 = 0x000a = EXC_RETURN.
                                                                    9 = 0x0009 = EXC_TAKEN.
                                                                    8 = 0x0008 = INST_RETIRED.
                                                                    7 = 0x0007 = ST_RETIRED.
                                                                    6 = 0x0006 = LD_RETIRED.
                                                                    5 = 0x0005 = L1D_TLB_REFILL.
                                                                    4 = 0x0004 = L1D_CACHE.
                                                                    3 = 0x0003 = L1D_CACHE_REFILL.
                                                                    2 = 0x0002 = L1I_TLB_REFILL.
                                                                    1 = 0x0001 = L1I_CACHE_REFILL.
                                                                    0 = 0x0000 = SW_INCR. */
#else
		uint32_t ce                          : 32;
#endif
	} s;
	/* struct bdk_pmux_pmceid0_s          cn85xx; */
	/* struct bdk_pmux_pmceid0_s          cn88xx; */
	/* struct bdk_pmux_pmceid0_s          cn88xxp1; */
} bdk_pmux_pmceid0_t;

static inline uint64_t BDK_PMUX_PMCEID0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCEID0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E20ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCEID0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCEID0(...) bdk_pmux_pmceid0_t
#define bustype_BDK_PMUX_PMCEID0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCEID0(p1) (p1)
#define arguments_BDK_PMUX_PMCEID0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCEID0(...) "PMUX_PMCEID0"


/**
 * DAB32b - pmu#_pmceid1
 *
 * Reserved for future indication of which common architectural
 * and common microarchitectural feature events are implemented.
 * These events are in the range 0x20-0x3f.
 * Alias for PMU()_PMCEID1_EL0[31:0].
 */
typedef union bdk_pmux_pmceid1 {
	uint32_t u;
	struct bdk_pmux_pmceid1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ce                          : 32; /**< RO - Common architectural and microarchitectural feature events that can be counted
                                                                 by the PMU event counters.

                                                                 In CNXXXX, the following bits are set to indicate the corresponding events are
                                                                 implemented:
                                                                   15 = 0x002f = L2D_TLB.
                                                                   14 = 0x002e = L2I_TLB_REFILL.
                                                                   13 = 0x002d = L2D_TLB_REFILL.
                                                                   8  = 0x0028 = L2I_CACHE_REFILL.
                                                                   7  = 0x0027 = L2I_CACHE.
                                                                   6  = 0x0026 = L1I_TLB.
                                                                   5  = 0x0025 = L1D_TLB.
                                                                   4  = 0x0024 = STALL_BACKEND.
                                                                   3  = 0x0023 = STALL_FRONTEND.
                                                                   2  = 0x0022 = BR_MIS_PRED_RETIRED.
                                                                   1  = 0x0021 = BR_RETIRED. */
#else
		uint32_t ce                          : 32;
#endif
	} s;
	/* struct bdk_pmux_pmceid1_s          cn85xx; */
	/* struct bdk_pmux_pmceid1_s          cn88xx; */
	/* struct bdk_pmux_pmceid1_s          cn88xxp1; */
} bdk_pmux_pmceid1_t;

static inline uint64_t BDK_PMUX_PMCEID1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCEID1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E24ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCEID1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCEID1(...) bdk_pmux_pmceid1_t
#define bustype_BDK_PMUX_PMCEID1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCEID1(p1) (p1)
#define arguments_BDK_PMUX_PMCEID1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCEID1(...) "PMUX_PMCEID1"


/**
 * DAB32b - pmu#_pmceid2
 *
 * Reserved for future indication of which common architectural
 * and common microarchitectural feature events are implemented.
 * These events are in the range 0x4000-0x401f
 * Alias for PMU()_PMCEID0_EL0[63:32]
 */
typedef union bdk_pmux_pmceid2 {
	uint32_t u;
	struct bdk_pmux_pmceid2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ce                          : 32; /**< RAZ - Reserved. */
#else
		uint32_t ce                          : 32;
#endif
	} s;
	/* struct bdk_pmux_pmceid2_s          cn85xx; */
	/* struct bdk_pmux_pmceid2_s          cn88xx; */
	/* struct bdk_pmux_pmceid2_s          cn88xxp1; */
} bdk_pmux_pmceid2_t;

static inline uint64_t BDK_PMUX_PMCEID2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCEID2(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E28ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCEID2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCEID2(...) bdk_pmux_pmceid2_t
#define bustype_BDK_PMUX_PMCEID2(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCEID2(p1) (p1)
#define arguments_BDK_PMUX_PMCEID2(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCEID2(...) "PMUX_PMCEID2"


/**
 * DAB32b - pmu#_pmceid3
 *
 * Reserved for future indication of which common architectural
 * and common microarchitectural feature events are implemented.
 * These events are in the range 0x4020-0x403f
 * Alias for PMU()_PMCEID1_EL0[63:32]
 */
typedef union bdk_pmux_pmceid3 {
	uint32_t u;
	struct bdk_pmux_pmceid3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_0_31               : 32;
#else
		uint32_t reserved_0_31               : 32;
#endif
	} s;
	/* struct bdk_pmux_pmceid3_s          cn85xx; */
	/* struct bdk_pmux_pmceid3_s          cn88xx; */
	/* struct bdk_pmux_pmceid3_s          cn88xxp1; */
} bdk_pmux_pmceid3_t;

static inline uint64_t BDK_PMUX_PMCEID3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCEID3(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E2Cull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCEID3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCEID3(...) bdk_pmux_pmceid3_t
#define bustype_BDK_PMUX_PMCEID3(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCEID3(p1) (p1)
#define arguments_BDK_PMUX_PMCEID3(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCEID3(...) "PMUX_PMCEID3"


/**
 * DAB32b - pmu#_pmcfgr
 *
 * Contains PMU-specific configuration data.
 *
 */
typedef union bdk_pmux_pmcfgr {
	uint32_t u;
	struct bdk_pmux_pmcfgr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t uen                         : 1;  /**< RO - User-mode Enable Register supported. PMUSERENR_EL0 is not
                                                                 visible in the external debug interface, so this bit is RES0. */
		uint32_t wt                          : 1;  /**< RO - This feature is not supported, so this bit is RES0. */
		uint32_t na                          : 1;  /**< RO - This feature is not supported, so this bit is RES0. */
		uint32_t ex                          : 1;  /**< RO - Export supported. Value is implementation defined.
                                                                 0 = PMU()_PMCR_EL0[X] is RES0.
                                                                 1 = PMU()_PMCR_EL0[X] is read/write.

                                                                 Not supported. */
		uint32_t ccd                         : 1;  /**< RO - Cycle counter has prescale. This is RES1 if AArch32 is
                                                                     supported at any EL, and RES0 otherwise.
                                                                 0 = PMU()_PMCR_EL0[D] is RES0.
                                                                 1 = PMU()_PMCR_EL0[D] is read/write. */
		uint32_t cc                          : 1;  /**< RO - Dedicated cycle counter (counter 31) supported. This bit is
                                                                 RES1. */
		uint32_t size                        : 6;  /**< RO - Size of counters. This field determines the spacing of
                                                                     counters in the memory-map.
                                                                 In v8-A the counters are at doubleword-aligned addresses, and
                                                                     the largest counter is 64-bits, so this field is 0x3f. */
		uint32_t n                           : 8;  /**< RO - Number of counters implemented in addition to the cycle
                                                                     counter, PMU()_PMCCNTR_EL0. The maximum number of event counters is
                                                                     31, so bits[7:5] are always RES0.
                                                                 and so on up to 0x1F PMU()_PMCCNTR_EL0 and 31 event counters
                                                                     implemented.
                                                                 0x0 = Only PMU()_PMCCNTR_EL0 implemented.
                                                                 0x1 = PMU()_PMCCNTR_EL0 plus one event counter implemented. */
#else
		uint32_t n                           : 8;
		uint32_t size                        : 6;
		uint32_t cc                          : 1;
		uint32_t ccd                         : 1;
		uint32_t ex                          : 1;
		uint32_t na                          : 1;
		uint32_t wt                          : 1;
		uint32_t uen                         : 1;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_pmux_pmcfgr_s           cn85xx; */
	/* struct bdk_pmux_pmcfgr_s           cn88xx; */
	/* struct bdk_pmux_pmcfgr_s           cn88xxp1; */
} bdk_pmux_pmcfgr_t;

static inline uint64_t BDK_PMUX_PMCFGR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCFGR(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E00ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCFGR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCFGR(...) bdk_pmux_pmcfgr_t
#define bustype_BDK_PMUX_PMCFGR(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCFGR(p1) (p1)
#define arguments_BDK_PMUX_PMCFGR(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCFGR(...) "PMUX_PMCFGR"


/**
 * DAB32b - pmu#_pmcidr0
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmcidr0 {
	uint32_t u;
	struct bdk_pmux_pmcidr0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t prmbl_0                     : 8;  /**< RO - Preamble. Must read as 0x0D. */
#else
		uint32_t prmbl_0                     : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmcidr0_s          cn85xx; */
	/* struct bdk_pmux_pmcidr0_s          cn88xx; */
	/* struct bdk_pmux_pmcidr0_s          cn88xxp1; */
} bdk_pmux_pmcidr0_t;

static inline uint64_t BDK_PMUX_PMCIDR0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCIDR0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FF0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCIDR0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCIDR0(...) bdk_pmux_pmcidr0_t
#define bustype_BDK_PMUX_PMCIDR0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCIDR0(p1) (p1)
#define arguments_BDK_PMUX_PMCIDR0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCIDR0(...) "PMUX_PMCIDR0"


/**
 * DAB32b - pmu#_pmcidr1
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmcidr1 {
	uint32_t u;
	struct bdk_pmux_pmcidr1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t cclass                      : 4;  /**< RO - Component class. 0x9 = Debug component. */
		uint32_t prmbl_1                     : 4;  /**< RO - Preamble. RAZ. */
#else
		uint32_t prmbl_1                     : 4;
		uint32_t cclass                      : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmcidr1_s          cn85xx; */
	/* struct bdk_pmux_pmcidr1_s          cn88xx; */
	/* struct bdk_pmux_pmcidr1_s          cn88xxp1; */
} bdk_pmux_pmcidr1_t;

static inline uint64_t BDK_PMUX_PMCIDR1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCIDR1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FF4ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCIDR1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCIDR1(...) bdk_pmux_pmcidr1_t
#define bustype_BDK_PMUX_PMCIDR1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCIDR1(p1) (p1)
#define arguments_BDK_PMUX_PMCIDR1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCIDR1(...) "PMUX_PMCIDR1"


/**
 * DAB32b - pmu#_pmcidr2
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmcidr2 {
	uint32_t u;
	struct bdk_pmux_pmcidr2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t prmbl_2                     : 8;  /**< RO - Preamble. Must read as 0x05. */
#else
		uint32_t prmbl_2                     : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmcidr2_s          cn85xx; */
	/* struct bdk_pmux_pmcidr2_s          cn88xx; */
	/* struct bdk_pmux_pmcidr2_s          cn88xxp1; */
} bdk_pmux_pmcidr2_t;

static inline uint64_t BDK_PMUX_PMCIDR2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCIDR2(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FF8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCIDR2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCIDR2(...) bdk_pmux_pmcidr2_t
#define bustype_BDK_PMUX_PMCIDR2(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCIDR2(p1) (p1)
#define arguments_BDK_PMUX_PMCIDR2(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCIDR2(...) "PMUX_PMCIDR2"


/**
 * DAB32b - pmu#_pmcidr3
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmcidr3 {
	uint32_t u;
	struct bdk_pmux_pmcidr3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t prmbl_3                     : 8;  /**< RO - Preamble. Must read as 0xB1. */
#else
		uint32_t prmbl_3                     : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmcidr3_s          cn85xx; */
	/* struct bdk_pmux_pmcidr3_s          cn88xx; */
	/* struct bdk_pmux_pmcidr3_s          cn88xxp1; */
} bdk_pmux_pmcidr3_t;

static inline uint64_t BDK_PMUX_PMCIDR3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCIDR3(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FFCull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCIDR3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCIDR3(...) bdk_pmux_pmcidr3_t
#define bustype_BDK_PMUX_PMCIDR3(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCIDR3(p1) (p1)
#define arguments_BDK_PMUX_PMCIDR3(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCIDR3(...) "PMUX_PMCIDR3"


/**
 * DAB32b - pmu#_pmcntenclr_el0
 *
 * Disables the Cycle Count Register, PMU()_PMCCNTR_EL0, and any
 * implemented event counters PMEVCNTR\<x\>. Reading this register
 * shows which counters are enabled.
 */
typedef union bdk_pmux_pmcntenclr_el0 {
	uint32_t u;
	struct bdk_pmux_pmcntenclr_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 disable bit. Disables the cycle counter register.
                                                                     Possible values are:
                                                                 0 = When read, means the cycle counter is disabled. When written,
                                                                     has no effect.
                                                                 1 = When read, means the cycle counter is enabled. When written,
                                                                     disables the cycle counter. */
		uint32_t p                           : 31; /**< R/W - Event counter disable bit for PMEVCNTR\<x\>.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values of each bit are:
                                                                 0 = When read, means that PMEVCNTR\<x\> is disabled. When written,
                                                                     has no effect.
                                                                 1 = When read, means that PMEVCNTR\<x\> is enabled. When written,
                                                                     disables PMEVCNTR\<x\>. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmcntenclr_el0_s   cn85xx; */
	/* struct bdk_pmux_pmcntenclr_el0_s   cn88xx; */
	/* struct bdk_pmux_pmcntenclr_el0_s   cn88xxp1; */
} bdk_pmux_pmcntenclr_el0_t;

static inline uint64_t BDK_PMUX_PMCNTENCLR_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCNTENCLR_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020C20ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCNTENCLR_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCNTENCLR_EL0(...) bdk_pmux_pmcntenclr_el0_t
#define bustype_BDK_PMUX_PMCNTENCLR_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCNTENCLR_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMCNTENCLR_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCNTENCLR_EL0(...) "PMUX_PMCNTENCLR_EL0"


/**
 * DAB32b - pmu#_pmcntenset_el0
 *
 * Enables the Cycle Count Register, PMU()_PMCCNTR_EL0, and any
 * implemented event counters PMEVCNTR\<x\>. Reading this register
 * shows which counters are enabled.
 */
typedef union bdk_pmux_pmcntenset_el0 {
	uint32_t u;
	struct bdk_pmux_pmcntenset_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 enable bit. Enables the cycle counter register.
                                                                     Possible values are:
                                                                 0 = When read, means the cycle counter is disabled. When written,
                                                                     has no effect.
                                                                 1 = When read, means the cycle counter is enabled. When written,
                                                                     enables the cycle counter. */
		uint32_t p                           : 31; /**< R/W - Event counter enable bit for PMEVCNTR\<x\>.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values of each bit are:
                                                                 0 = When read, means that PMEVCNTR\<x\> is disabled. When written,
                                                                     has no effect.
                                                                 1 = When read, means that PMEVCNTR\<x\> event counter is enabled.
                                                                     When written, enables PMEVCNTR\<x\>. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmcntenset_el0_s   cn85xx; */
	/* struct bdk_pmux_pmcntenset_el0_s   cn88xx; */
	/* struct bdk_pmux_pmcntenset_el0_s   cn88xxp1; */
} bdk_pmux_pmcntenset_el0_t;

static inline uint64_t BDK_PMUX_PMCNTENSET_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCNTENSET_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020C00ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCNTENSET_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCNTENSET_EL0(...) bdk_pmux_pmcntenset_el0_t
#define bustype_BDK_PMUX_PMCNTENSET_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCNTENSET_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMCNTENSET_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCNTENSET_EL0(...) "PMUX_PMCNTENSET_EL0"


/**
 * DAB32b - pmu#_pmcr_el0
 *
 * Provides details of the Performance Monitors implementation,
 * including the number of counters implemented, and configures
 * and controls the counters.
 */
typedef union bdk_pmux_pmcr_el0 {
	uint32_t u;
	struct bdk_pmux_pmcr_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t lc                          : 1;  /**< R/W - Long cycle counter enable. Determines which PMU()_PMCCNTR_EL0 bit
                                                                     generates an overflow recorded by PMOVSR[31].
                                                                 ARM deprecates use of PMU()_PMCR_EL0[LC] = 0.
                                                                 0 = Cycle counter overflow on increment that changes
                                                                     PMU()_PMCCNTR_EL0[31] from 1 to 0.
                                                                 1 = Cycle counter overflow on increment that changes
                                                                     PMU()_PMCCNTR_EL0[63] from 1 to 0. */
		uint32_t dp                          : 1;  /**< R/W - Disable cycle counter when event counting is prohibited. The
                                                                     possible values of this bit are:
                                                                 Event counting is prohibited when
                                                                     ProfilingProhibited(IsSecure(),PSTATE.EL) == TRUE. See the
                                                                     "Performance Monitors and Security" section of the ARMv8 Debug
                                                                     Specification, PRD03-PRDC-010486.
                                                                 This bit is RW.
                                                                 0 =  PMU()_PMCCNTR_EL0, if enabled, counts when event counting is
                                                                     prohibited.
                                                                 1 =  PMU()_PMCCNTR_EL0 does not count when event counting is prohibited. */
		uint32_t x                           : 1;  /**< R/W - Enable export of events in an implementation defined event
                                                                     stream. The possible values of this bit are:
                                                                 This bit is used to permit events to be exported to another
                                                                     debug device, such as an OPTIONAL trace extension, over an
                                                                     event bus. If the implementation does not include such an
                                                                     event bus, this bit is RAZ/WI.
                                                                 This bit does not affect the generation of Performance
                                                                     Monitors overflow interrupt requests or signaling to a cross-
                                                                     trigger interface (CTI) that can be implemented as signals
                                                                     exported from the processor.
                                                                 If the implementation does not include an exported event
                                                                     stream, this bit is RAZ/WI. Otherwise this bit is RW.
                                                                 0 = Do not export events.
                                                                 1 = Export events where not prohibited. */
		uint32_t d_clk                       : 1;  /**< R/W - Clock divider. The possible values of this bit are:
                                                                 This bit is RW.
                                                                 If PMU()_PMCR_EL0[LC] == 1, this bit is ignored and the cycle counter
                                                                     counts every clock cycle.
                                                                 ARM deprecates use of PMU()_PMCR[D] = 1.
                                                                 0 = When enabled, PMU()_PMCCNTR_EL0 counts every clock cycle.
                                                                 1 = When enabled, PMU()_PMCCNTR_EL0 counts once every 64 clock cycles. */
		uint32_t c_rst                       : 1;  /**< R/W - Cycle counter reset. This bit is WO. The effects of writing to
                                                                     this bit are:
                                                                 This bit is always RAZ.
                                                                 Resetting PMU()_PMCCNTR_EL0 does not clear the PMU()_PMCCNTR_EL0 overflow
                                                                     bit to 0.
                                                                 0 = No action.
                                                                 1 = Reset PMU()_PMCCNTR_EL0 to zero. */
		uint32_t p                           : 1;  /**< R/W - Event counter reset. This bit is WO. The effects of writing to
                                                                     this bit are:
                                                                 This bit is always RAZ.
                                                                 Resetting the event counters does not clear any overflow bits
                                                                     to 0.
                                                                 0 = No action.
                                                                 1 = Reset all event counters, not including PMU()_PMCCNTR_EL0, to zero. */
		uint32_t en                          : 1;  /**< R/W - Enable. The possible values of this bit are:
                                                                 This bit is RW.
                                                                 0 = All counters, including PMU()_PMCCNTR_EL0, are disabled.
                                                                 1 = All counters are enabled by PMU()_PMCNTENSET_EL0. */
#else
		uint32_t en                          : 1;
		uint32_t p                           : 1;
		uint32_t c_rst                       : 1;
		uint32_t d_clk                       : 1;
		uint32_t x                           : 1;
		uint32_t dp                          : 1;
		uint32_t lc                          : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_pmux_pmcr_el0_s         cn85xx; */
	/* struct bdk_pmux_pmcr_el0_s         cn88xx; */
	/* struct bdk_pmux_pmcr_el0_s         cn88xxp1; */
} bdk_pmux_pmcr_el0_t;

static inline uint64_t BDK_PMUX_PMCR_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMCR_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020E04ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMCR_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMCR_EL0(...) bdk_pmux_pmcr_el0_t
#define bustype_BDK_PMUX_PMCR_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMCR_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMCR_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMCR_EL0(...) "PMUX_PMCR_EL0"


/**
 * DAB32b - pmu#_pmdevaff0
 *
 * Copy of the low half of the processor MPIDR_EL1 register that
 * allows a debugger to determine which processor in a
 * multiprocessor system the Performance Monitor component
 * relates to.
 */
typedef union bdk_pmux_pmdevaff0 {
	uint32_t u;
	struct bdk_pmux_pmdevaff0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO - MPIDR_EL1 low half
                                                                 MPIDR_EL1 low half. Read-only copy of the low half of
                                                                    MPIDR_EL1, as seen from the highest implemented exception
                                                                    level. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_pmux_pmdevaff0_s        cn85xx; */
	/* struct bdk_pmux_pmdevaff0_s        cn88xx; */
	/* struct bdk_pmux_pmdevaff0_s        cn88xxp1; */
} bdk_pmux_pmdevaff0_t;

static inline uint64_t BDK_PMUX_PMDEVAFF0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMDEVAFF0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FA8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMDEVAFF0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMDEVAFF0(...) bdk_pmux_pmdevaff0_t
#define bustype_BDK_PMUX_PMDEVAFF0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMDEVAFF0(p1) (p1)
#define arguments_BDK_PMUX_PMDEVAFF0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMDEVAFF0(...) "PMUX_PMDEVAFF0"


/**
 * DAB32b - pmu#_pmdevaff1
 *
 * Copy of the high half of the processor MPIDR_EL1 register that
 * allows a debugger to determine which processor in a
 * multiprocessor system the Performance Monitor component
 * relates to.
 */
typedef union bdk_pmux_pmdevaff1 {
	uint32_t u;
	struct bdk_pmux_pmdevaff1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO - MPIDR_EL1 high half
                                                                 MPIDR_EL1 high half. Read-only copy of the high half of
                                                                    MPIDR_EL1, as seen from the highest implemented exception
                                                                    level. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_pmux_pmdevaff1_s        cn85xx; */
	/* struct bdk_pmux_pmdevaff1_s        cn88xx; */
	/* struct bdk_pmux_pmdevaff1_s        cn88xxp1; */
} bdk_pmux_pmdevaff1_t;

static inline uint64_t BDK_PMUX_PMDEVAFF1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMDEVAFF1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FACull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMDEVAFF1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMDEVAFF1(...) bdk_pmux_pmdevaff1_t
#define bustype_BDK_PMUX_PMDEVAFF1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMDEVAFF1(p1) (p1)
#define arguments_BDK_PMUX_PMDEVAFF1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMDEVAFF1(...) "PMUX_PMDEVAFF1"


/**
 * DAB32b - pmu#_pmdevarch
 */
typedef union bdk_pmux_pmdevarch {
	uint32_t u;
	struct bdk_pmux_pmdevarch_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t architect                   : 11; /**< RO - Defines the architecture of the component. For Performance
                                                                     Monitors, this is ARM Limited.

                                                                 Bits [31:28] are the JEP 106 continuation code, 0x4.

                                                                 Bits [27:21] are the JEP 106 ID code, 0x3B. */
		uint32_t present                     : 1;  /**< RO - When set to 1, indicates that the DEVARCH is present.
                                                                 This field is 1 in v8-A. */
		uint32_t revision                    : 4;  /**< RO - Defines the architecture revision. For architectures defined
                                                                     by ARM this is the minor revision.
                                                                 For Performance Monitors, the revision defined by v8-A is 0x0.
                                                                 All other values are reserved. */
		uint32_t archid                      : 16; /**< RO - Defines this part to be a v8-A debug component. For
                                                                     architectures defined by ARM this is further subdivided.
                                                                 For Performance Monitors:
                                                                  Bits [15:12] are the architecture version, 0x2.
                                                                  Bits [11:0] are the architecture part number, 0xA16.

                                                                 This corresponds to Performance Monitors architecture version
                                                                     PMUv3. */
#else
		uint32_t archid                      : 16;
		uint32_t revision                    : 4;
		uint32_t present                     : 1;
		uint32_t architect                   : 11;
#endif
	} s;
	/* struct bdk_pmux_pmdevarch_s        cn85xx; */
	/* struct bdk_pmux_pmdevarch_s        cn88xx; */
	/* struct bdk_pmux_pmdevarch_s        cn88xxp1; */
} bdk_pmux_pmdevarch_t;

static inline uint64_t BDK_PMUX_PMDEVARCH(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMDEVARCH(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FBCull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMDEVARCH", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMDEVARCH(...) bdk_pmux_pmdevarch_t
#define bustype_BDK_PMUX_PMDEVARCH(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMDEVARCH(p1) (p1)
#define arguments_BDK_PMUX_PMDEVARCH(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMDEVARCH(...) "PMUX_PMDEVARCH"


/**
 * DAB32b - pmu#_pmdevtype
 *
 * Indicates to a debugger that this component is part of a
 * processor's performance monitor interface.
 */
typedef union bdk_pmux_pmdevtype {
	uint32_t u;
	struct bdk_pmux_pmdevtype_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t sub                         : 4;  /**< RO - Subtype. Must read as 0x1. */
		uint32_t major                       : 4;  /**< RO - Major type. Must read as 0x6. */
#else
		uint32_t major                       : 4;
		uint32_t sub                         : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmdevtype_s        cn85xx; */
	/* struct bdk_pmux_pmdevtype_s        cn88xx; */
	/* struct bdk_pmux_pmdevtype_s        cn88xxp1; */
} bdk_pmux_pmdevtype_t;

static inline uint64_t BDK_PMUX_PMDEVTYPE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMDEVTYPE(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FCCull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMDEVTYPE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMDEVTYPE(...) bdk_pmux_pmdevtype_t
#define bustype_BDK_PMUX_PMDEVTYPE(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMDEVTYPE(p1) (p1)
#define arguments_BDK_PMUX_PMDEVTYPE(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMDEVTYPE(...) "PMUX_PMDEVTYPE"


/**
 * DAB - pmu#_pmevcntr#_el0
 *
 * Holds event counter n, which counts events, where n is 0 to
 * 30.
 */
typedef union bdk_pmux_pmevcntrx_el0 {
	uint64_t u;
	struct bdk_pmux_pmevcntrx_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_32_63              : 32;
		uint64_t data                        : 32; /**< R/W - Event counter n
                                                                 Event counter n. Value of event counter n, where n is the
                                                                     number of this register and is a number from 0 to 30. */
#else
		uint64_t data                        : 32;
		uint64_t reserved_32_63              : 32;
#endif
	} s;
	/* struct bdk_pmux_pmevcntrx_el0_s    cn85xx; */
	/* struct bdk_pmux_pmevcntrx_el0_s    cn88xx; */
	/* struct bdk_pmux_pmevcntrx_el0_s    cn88xxp1; */
} bdk_pmux_pmevcntrx_el0_t;

static inline uint64_t BDK_PMUX_PMEVCNTRX_EL0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMEVCNTRX_EL0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 47)) && ((param2 <= 5)))
		return 0x000087A008020000ull + (param1 & 63) * 0x80000ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_PMUX_PMEVCNTRX_EL0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMEVCNTRX_EL0(...) bdk_pmux_pmevcntrx_el0_t
#define bustype_BDK_PMUX_PMEVCNTRX_EL0(...) BDK_CSR_TYPE_DAB
#define busnum_BDK_PMUX_PMEVCNTRX_EL0(p1,p2) (p1)
#define arguments_BDK_PMUX_PMEVCNTRX_EL0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_PMUX_PMEVCNTRX_EL0(...) "PMUX_PMEVCNTRX_EL0"


/**
 * DAB32b - pmu#_pmevtyper#_el0
 *
 * Configures event counter n, where n is 0 to 30.
 *
 */
typedef union bdk_pmux_pmevtyperx_el0 {
	uint32_t u;
	struct bdk_pmux_pmevtyperx_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t p                           : 1;  /**< R/W - EL1 modes filtering bit. Controls counting in EL1. If EL3 is
                                                                     implemented, then counting in Non-secure EL1 is further
                                                                     controlled by the NSK bit. The possible values of this bit
                                                                     are:
                                                                 0 = Count events in EL1.
                                                                 1 = Do not count events in EL1. */
		uint32_t u                           : 1;  /**< R/W - EL0 filtering bit. Controls counting in EL0. If EL3 is
                                                                     implemented, then counting in Non-secure EL0 is further
                                                                     controlled by the NSU bit. The possible values of this bit
                                                                     are:
                                                                 0 = Count events in EL0.
                                                                 1 = Do not count events in EL0. */
		uint32_t nsk                         : 1;  /**< R/W - Non-secure kernel modes filtering bit. Controls counting in
                                                                     Non-secure EL1. If EL3 is not implemented, this bit is RES0.
                                                                 If the value of this bit is equal to the value of P, events in
                                                                     Non-secure EL1 are counted.
                                                                 Otherwise, events in Non-secure EL1 are not counted. */
		uint32_t nsu                         : 1;  /**< R/W - Non-secure user modes filtering bit. Controls counting in Non-
                                                                     secure EL0. If EL3 is not implemented, this bit is RES0.
                                                                 If the value of this bit is equal to the value of U, events in
                                                                     Non-secure EL0 are counted.
                                                                 Otherwise, events in Non-secure EL0 are not counted. */
		uint32_t nsh                         : 1;  /**< R/W - Non-secure Hyp modes filtering bit. Controls counting in Non-
                                                                     secure EL2. If EL2 is not implemented, this bit is RES0.
                                                                 0 = Do not count events in EL2.
                                                                 1 = Count events in EL2. */
		uint32_t m                           : 1;  /**< R/W - Secure EL3 filtering bit. Most applications can ignore this
                                                                     bit and set the value to zero. If EL3 is not implemented, this
                                                                     bit is RES0.
                                                                 If the value of this bit is equal to the value of P, events in
                                                                     Secure EL3 are counted.
                                                                 Otherwise, events in Secure EL3 are not counted. */
		uint32_t reserved_10_25              : 16;
		uint32_t evtcount                    : 10; /**< R/W - Event to count. The event number of the event that is counted
                                                                     by event counter PMEVCNTR\<n\>_EL0.
                                                                 Enumerated by PMU_PERF_E.

                                                                 Software must program this field with an event defined by the
                                                                     processor or a common event defined by the architecture.
                                                                 If evtCount is programmed to an event that is reserved or not
                                                                     implemented, the behavior depends on the event type.
                                                                 For common architectural and microarchitectural events:
                                                                  No events are counted.
                                                                  The value read back on evtCount is the value written.
                                                                 For implementation defined events:
                                                                  It is UNPREDICTABLE what event, if any, is counted.
                                                                     UNPREDICTABLE in this case means the event must not expose
                                                                     privileged information.
                                                                  The value read back on evtCount is an UNKNOWN value with the
                                                                     same effect.
                                                                 ARM recommends that the behavior across a family of
                                                                     implementations is defined such that if a given implementation
                                                                     does not include an event from a set of common implementation
                                                                     defined events, then no event is counted and the value read
                                                                     back on evtCount is the value written. */
#else
		uint32_t evtcount                    : 10;
		uint32_t reserved_10_25              : 16;
		uint32_t m                           : 1;
		uint32_t nsh                         : 1;
		uint32_t nsu                         : 1;
		uint32_t nsk                         : 1;
		uint32_t u                           : 1;
		uint32_t p                           : 1;
#endif
	} s;
	/* struct bdk_pmux_pmevtyperx_el0_s   cn85xx; */
	/* struct bdk_pmux_pmevtyperx_el0_s   cn88xx; */
	/* struct bdk_pmux_pmevtyperx_el0_s   cn88xxp1; */
} bdk_pmux_pmevtyperx_el0_t;

static inline uint64_t BDK_PMUX_PMEVTYPERX_EL0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMEVTYPERX_EL0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 47)) && ((param2 <= 5)))
		return 0x000087A008020400ull + (param1 & 63) * 0x80000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_PMUX_PMEVTYPERX_EL0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMEVTYPERX_EL0(...) bdk_pmux_pmevtyperx_el0_t
#define bustype_BDK_PMUX_PMEVTYPERX_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMEVTYPERX_EL0(p1,p2) (p1)
#define arguments_BDK_PMUX_PMEVTYPERX_EL0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_PMUX_PMEVTYPERX_EL0(...) "PMUX_PMEVTYPERX_EL0"


/**
 * DAB32b - pmu#_pmintenclr_el1
 *
 * Disables the generation of interrupt requests on overflows
 * from the Cycle Count Register, PMU()_PMCCNTR_EL0, and the event
 * counters PMEVCNTR\<n\>_EL0. Reading the register shows which
 * overflow interrupt requests are enabled.
 */
typedef union bdk_pmux_pmintenclr_el1 {
	uint32_t u;
	struct bdk_pmux_pmintenclr_el1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 overflow interrupt request disable bit. Possible
                                                                     values are:
                                                                 0 = When read, means the cycle counter overflow interrupt request
                                                                     is disabled. When written, has no effect.
                                                                 1 = When read, means the cycle counter overflow interrupt request
                                                                     is enabled. When written, disables the cycle count overflow
                                                                     interrupt request. */
		uint32_t p                           : 31; /**< R/W - Event counter overflow interrupt request disable bit for
                                                                     PMEVCNTR\<x\>_EL0.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values are:
                                                                 0 = When read, means that the PMEVCNTR\<x\>_EL0 event counter
                                                                     interrupt request is disabled. When written, has no effect.
                                                                 1 = When read, means that the PMEVCNTR\<x\>_EL0 event counter
                                                                     interrupt request is enabled. When written, disables the
                                                                     PMEVCNTR\<x\>_EL0 interrupt request. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmintenclr_el1_s   cn85xx; */
	/* struct bdk_pmux_pmintenclr_el1_s   cn88xx; */
	/* struct bdk_pmux_pmintenclr_el1_s   cn88xxp1; */
} bdk_pmux_pmintenclr_el1_t;

static inline uint64_t BDK_PMUX_PMINTENCLR_EL1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMINTENCLR_EL1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020C60ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMINTENCLR_EL1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMINTENCLR_EL1(...) bdk_pmux_pmintenclr_el1_t
#define bustype_BDK_PMUX_PMINTENCLR_EL1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMINTENCLR_EL1(p1) (p1)
#define arguments_BDK_PMUX_PMINTENCLR_EL1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMINTENCLR_EL1(...) "PMUX_PMINTENCLR_EL1"


/**
 * DAB32b - pmu#_pmintenset_el1
 *
 * Enables the generation of interrupt requests on overflows from
 * the Cycle Count Register, PMU()_PMCCNTR_EL0, and the event counters
 * PMEVCNTR\<n\>_EL0. Reading the register shows which overflow
 * interrupt requests are enabled.
 */
typedef union bdk_pmux_pmintenset_el1 {
	uint32_t u;
	struct bdk_pmux_pmintenset_el1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 overflow interrupt request enable bit. Possible
                                                                     values are:
                                                                 0 = When read, means the cycle counter overflow interrupt request
                                                                     is disabled. When written, has no effect.
                                                                 1 = When read, means the cycle counter overflow interrupt request
                                                                     is enabled. When written, enables the cycle count overflow
                                                                     interrupt request. */
		uint32_t p                           : 31; /**< R/W - Event counter overflow interrupt request enable bit for
                                                                     PMEVCNTR\<x\>_EL0.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values are:
                                                                 0 = When read, means that the PMEVCNTR\<x\>_EL0 event counter
                                                                     interrupt request is disabled. When written, has no effect.
                                                                 1 = When read, means that the PMEVCNTR\<x\>_EL0 event counter
                                                                     interrupt request is enabled. When written, enables the
                                                                     PMEVCNTR\<x\>_EL0 interrupt request. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmintenset_el1_s   cn85xx; */
	/* struct bdk_pmux_pmintenset_el1_s   cn88xx; */
	/* struct bdk_pmux_pmintenset_el1_s   cn88xxp1; */
} bdk_pmux_pmintenset_el1_t;

static inline uint64_t BDK_PMUX_PMINTENSET_EL1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMINTENSET_EL1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020C40ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMINTENSET_EL1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMINTENSET_EL1(...) bdk_pmux_pmintenset_el1_t
#define bustype_BDK_PMUX_PMINTENSET_EL1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMINTENSET_EL1(p1) (p1)
#define arguments_BDK_PMUX_PMINTENSET_EL1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMINTENSET_EL1(...) "PMUX_PMINTENSET_EL1"


/**
 * DAB32b - pmu#_pmitctrl
 *
 * Enables the Performance Monitors to switch from default mode
 * into integration mode, where test software can control
 * directly the inputs and outputs of the processor, for
 * integration testing or topology detection.
 */
typedef union bdk_pmux_pmitctrl {
	uint32_t u;
	struct bdk_pmux_pmitctrl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t ime                         : 1;  /**< RO - Integration mode enable. When IME == 1, the device reverts to
                                                                     an integration mode to enable integration testing or topology
                                                                     detection. The integration mode behavior is implementation
                                                                     defined.
                                                                 0 = Normal operation.
                                                                 1 = Integration mode enabled. */
#else
		uint32_t ime                         : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_pmux_pmitctrl_s         cn85xx; */
	/* struct bdk_pmux_pmitctrl_s         cn88xx; */
	/* struct bdk_pmux_pmitctrl_s         cn88xxp1; */
} bdk_pmux_pmitctrl_t;

static inline uint64_t BDK_PMUX_PMITCTRL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMITCTRL(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020F00ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMITCTRL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMITCTRL(...) bdk_pmux_pmitctrl_t
#define bustype_BDK_PMUX_PMITCTRL(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMITCTRL(p1) (p1)
#define arguments_BDK_PMUX_PMITCTRL(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMITCTRL(...) "PMUX_PMITCTRL"


/**
 * DAB32b - pmu#_pmlar
 *
 * Allows or disallows access to the Performance Monitors
 * registers through a memory-mapped interface.
 */
typedef union bdk_pmux_pmlar {
	uint32_t u;
	struct bdk_pmux_pmlar_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< WO - Lock access control. Writing the key value 0xC5ACCE55 unlocks the lock.
                                                                 Writing any other value to this register locks the lock, disabling write
                                                                 accesses to this component's registers through a memory mapped interface. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_pmux_pmlar_s            cn85xx; */
	/* struct bdk_pmux_pmlar_s            cn88xx; */
	/* struct bdk_pmux_pmlar_s            cn88xxp1; */
} bdk_pmux_pmlar_t;

static inline uint64_t BDK_PMUX_PMLAR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMLAR(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FB0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMLAR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMLAR(...) bdk_pmux_pmlar_t
#define bustype_BDK_PMUX_PMLAR(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMLAR(p1) (p1)
#define arguments_BDK_PMUX_PMLAR(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMLAR(...) "PMUX_PMLAR"


/**
 * DAB32b - pmu#_pmlsr
 *
 * Indicates the current status of the software lock for
 * Performance Monitors registers.
 */
typedef union bdk_pmux_pmlsr {
	uint32_t u;
	struct bdk_pmux_pmlsr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t ntt                         : 1;  /**< RO - Not thirty-two bit access required. RAZ. */
		uint32_t slk                         : 1;  /**< RO/H - Software lock status for this component. For an access to LSR
                                                                     that is not a memory-mapped access, or when the software lock
                                                                     is not implemented, this field is RES0.
                                                                 On External debug reset, the field resets to 1.
                                                                 For memory-mapped accesses when the software lock is
                                                                     implemented, possible values of this field are:
                                                                 0 = Lock clear. Writes are permitted to this component's
                                                                     registers.
                                                                 1 = Lock set. Writes to this component's registers are ignored,
                                                                     and reads have no side effects. */
		uint32_t sli                         : 1;  /**< RO - Software lock implemented. For an access to LSR that is not a
                                                                     memory-mapped access, this field is RAZ. For memory-mapped
                                                                     accesses, the value of this field is implementation defined.
                                                                     Permitted values are:
                                                                 0 = Software lock not implemented or not memory-mapped access.
                                                                 1 = Software lock implemented and memory-mapped access. */
#else
		uint32_t sli                         : 1;
		uint32_t slk                         : 1;
		uint32_t ntt                         : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_pmux_pmlsr_s            cn85xx; */
	/* struct bdk_pmux_pmlsr_s            cn88xx; */
	/* struct bdk_pmux_pmlsr_s            cn88xxp1; */
} bdk_pmux_pmlsr_t;

static inline uint64_t BDK_PMUX_PMLSR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMLSR(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FB4ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMLSR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMLSR(...) bdk_pmux_pmlsr_t
#define bustype_BDK_PMUX_PMLSR(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMLSR(p1) (p1)
#define arguments_BDK_PMUX_PMLSR(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMLSR(...) "PMUX_PMLSR"


/**
 * DAB32b - pmu#_pmovsclr_el0
 *
 * Contains the state of the overflow bit for the Cycle Count
 * Register, PMU()_PMCCNTR_EL0, and each of the implemented event
 * counters PMEVCNTR\<x\>. Writing to this register clears these
 * bits.
 */
typedef union bdk_pmux_pmovsclr_el0 {
	uint32_t u;
	struct bdk_pmux_pmovsclr_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 overflow bit. Possible values are:
                                                                 PMU()_PMCR_EL0[LC] is used to control from which bit of PMU()_PMCCNTR_EL0
                                                                     (bit 31 or bit 63) an overflow is detected.
                                                                 0 = When read, means the cycle counter has not overflowed. When
                                                                     written, has no effect.
                                                                 1 = When read, means the cycle counter has overflowed. When
                                                                     written, clears the overflow bit to 0. */
		uint32_t p                           : 31; /**< R/W - Event counter overflow clear bit for PMEVCNTR\<x\>.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values of each bit are:
                                                                 0 = When read, means that PMEVCNTR\<x\> has not overflowed. When
                                                                     written, has no effect.
                                                                 1 = When read, means that PMEVCNTR\<x\> has overflowed. When
                                                                     written, clears the PMEVCNTR\<x\> overflow bit to 0. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmovsclr_el0_s     cn85xx; */
	/* struct bdk_pmux_pmovsclr_el0_s     cn88xx; */
	/* struct bdk_pmux_pmovsclr_el0_s     cn88xxp1; */
} bdk_pmux_pmovsclr_el0_t;

static inline uint64_t BDK_PMUX_PMOVSCLR_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMOVSCLR_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020C80ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMOVSCLR_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMOVSCLR_EL0(...) bdk_pmux_pmovsclr_el0_t
#define bustype_BDK_PMUX_PMOVSCLR_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMOVSCLR_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMOVSCLR_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMOVSCLR_EL0(...) "PMUX_PMOVSCLR_EL0"


/**
 * DAB32b - pmu#_pmovsset_el0
 *
 * Sets the state of the overflow bit for the Cycle Count
 * Register, PMU()_PMCCNTR_EL0, and each of the implemented event
 * counters PMEVCNTR\<x\>.
 */
typedef union bdk_pmux_pmovsset_el0 {
	uint32_t u;
	struct bdk_pmux_pmovsset_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t c_set                       : 1;  /**< R/W - PMU()_PMCCNTR_EL0 overflow bit. Possible values are:
                                                                 0 = When read, means the cycle counter has not overflowed. When
                                                                     written, has no effect.
                                                                 1 = When read, means the cycle counter has overflowed. When
                                                                     written, sets the overflow bit to 1. */
		uint32_t p                           : 31; /**< R/W - Event counter overflow set bit for PMEVCNTR\<x\>.
                                                                 N is the value in PMU()_PMCR_EL0[N]. Bits [30:N] are RAZ/WI.
                                                                 Possible values are:
                                                                 0 = When read, means that PMEVCNTR\<x\> has not overflowed. When
                                                                     written, has no effect.
                                                                 1 = When read, means that PMEVCNTR\<x\> has overflowed. When
                                                                     written, sets the PMEVCNTR\<x\> overflow bit to 1. */
#else
		uint32_t p                           : 31;
		uint32_t c_set                       : 1;
#endif
	} s;
	/* struct bdk_pmux_pmovsset_el0_s     cn85xx; */
	/* struct bdk_pmux_pmovsset_el0_s     cn88xx; */
	/* struct bdk_pmux_pmovsset_el0_s     cn88xxp1; */
} bdk_pmux_pmovsset_el0_t;

static inline uint64_t BDK_PMUX_PMOVSSET_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMOVSSET_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020CC0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMOVSSET_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMOVSSET_EL0(...) bdk_pmux_pmovsset_el0_t
#define bustype_BDK_PMUX_PMOVSSET_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMOVSSET_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMOVSSET_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMOVSSET_EL0(...) "PMUX_PMOVSSET_EL0"


/**
 * DAB32b - pmu#_pmpidr0
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmpidr0 {
	uint32_t u;
	struct bdk_pmux_pmpidr0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t part_0                      : 8;  /**< RO - Part number \<7:0\>.  Indicates PCC_PIDR_PARTNUM0_E::PMU. */
#else
		uint32_t part_0                      : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmpidr0_s          cn85xx; */
	/* struct bdk_pmux_pmpidr0_s          cn88xx; */
	/* struct bdk_pmux_pmpidr0_s          cn88xxp1; */
} bdk_pmux_pmpidr0_t;

static inline uint64_t BDK_PMUX_PMPIDR0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FE0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR0(...) bdk_pmux_pmpidr0_t
#define bustype_BDK_PMUX_PMPIDR0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR0(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR0(...) "PMUX_PMPIDR0"


/**
 * DAB32b - pmu#_pmpidr1
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmpidr1 {
	uint32_t u;
	struct bdk_pmux_pmpidr1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t des_0                       : 4;  /**< RO - JEP106 identification code \<3:0\>. Cavium code is 0x4C. */
		uint32_t part_1                      : 4;  /**< RO - Part number \<11:8\>.  Indicates PCC_PIDR_PARTNUM1_E::COMP. */
#else
		uint32_t part_1                      : 4;
		uint32_t des_0                       : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmpidr1_s          cn85xx; */
	/* struct bdk_pmux_pmpidr1_s          cn88xx; */
	/* struct bdk_pmux_pmpidr1_s          cn88xxp1; */
} bdk_pmux_pmpidr1_t;

static inline uint64_t BDK_PMUX_PMPIDR1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR1(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FE4ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR1(...) bdk_pmux_pmpidr1_t
#define bustype_BDK_PMUX_PMPIDR1(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR1(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR1(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR1(...) "PMUX_PMPIDR1"


/**
 * DAB32b - pmu#_pmpidr2
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmpidr2 {
	uint32_t u;
	struct bdk_pmux_pmpidr2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t revision                    : 4;  /**< RO - Architectural revision, as assigned by ARM. */
		uint32_t jedec                       : 1;  /**< RO - JEDEC assigned. */
		uint32_t des_1                       : 3;  /**< RO - JEP106 identification code \<6:4\>. Cavium code is 0x4C. */
#else
		uint32_t des_1                       : 3;
		uint32_t jedec                       : 1;
		uint32_t revision                    : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmpidr2_s          cn85xx; */
	/* struct bdk_pmux_pmpidr2_s          cn88xx; */
	/* struct bdk_pmux_pmpidr2_s          cn88xxp1; */
} bdk_pmux_pmpidr2_t;

static inline uint64_t BDK_PMUX_PMPIDR2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR2(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FE8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR2(...) bdk_pmux_pmpidr2_t
#define bustype_BDK_PMUX_PMPIDR2(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR2(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR2(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR2(...) "PMUX_PMPIDR2"


/**
 * DAB32b - pmu#_pmpidr3
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmpidr3 {
	uint32_t u;
	struct bdk_pmux_pmpidr3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t revand                      : 4;  /**< RO - Manufacturer revision number. For CNXXXX always 0x0. */
		uint32_t cmod                        : 4;  /**< RO - Customer modified. 0x1 = Overall product information should be consulted for
                                                                 product, major and minor pass numbers. */
#else
		uint32_t cmod                        : 4;
		uint32_t revand                      : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmpidr3_s          cn85xx; */
	/* struct bdk_pmux_pmpidr3_s          cn88xx; */
	/* struct bdk_pmux_pmpidr3_s          cn88xxp1; */
} bdk_pmux_pmpidr3_t;

static inline uint64_t BDK_PMUX_PMPIDR3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR3(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FECull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR3(...) bdk_pmux_pmpidr3_t
#define bustype_BDK_PMUX_PMPIDR3(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR3(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR3(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR3(...) "PMUX_PMPIDR3"


/**
 * DAB32b - pmu#_pmpidr4
 *
 * Provides information to identify a Performance Monitor
 * component.
 */
typedef union bdk_pmux_pmpidr4 {
	uint32_t u;
	struct bdk_pmux_pmpidr4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t size                        : 4;  /**< RO - Size of the component. RAZ. Log2 of the number of
                                                                 4KB pages from the start of the component to the end of the
                                                                 component ID registers. */
		uint32_t des_2                       : 4;  /**< RO - JEP106 continuation code, least significant nibble. Indicates Cavium. */
#else
		uint32_t des_2                       : 4;
		uint32_t size                        : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_pmux_pmpidr4_s          cn85xx; */
	/* struct bdk_pmux_pmpidr4_s          cn88xx; */
	/* struct bdk_pmux_pmpidr4_s          cn88xxp1; */
} bdk_pmux_pmpidr4_t;

static inline uint64_t BDK_PMUX_PMPIDR4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR4(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FD0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR4(...) bdk_pmux_pmpidr4_t
#define bustype_BDK_PMUX_PMPIDR4(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR4(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR4(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR4(...) "PMUX_PMPIDR4"


/**
 * DAB32b - pmu#_pmpidr5
 */
typedef union bdk_pmux_pmpidr5 {
	uint32_t u;
	struct bdk_pmux_pmpidr5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_0_31               : 32;
#else
		uint32_t reserved_0_31               : 32;
#endif
	} s;
	/* struct bdk_pmux_pmpidr5_s          cn85xx; */
	/* struct bdk_pmux_pmpidr5_s          cn88xx; */
	/* struct bdk_pmux_pmpidr5_s          cn88xxp1; */
} bdk_pmux_pmpidr5_t;

static inline uint64_t BDK_PMUX_PMPIDR5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR5(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FD4ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR5(...) bdk_pmux_pmpidr5_t
#define bustype_BDK_PMUX_PMPIDR5(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR5(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR5(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR5(...) "PMUX_PMPIDR5"


/**
 * DAB32b - pmu#_pmpidr6
 */
typedef union bdk_pmux_pmpidr6 {
	uint32_t u;
	struct bdk_pmux_pmpidr6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_0_31               : 32;
#else
		uint32_t reserved_0_31               : 32;
#endif
	} s;
	/* struct bdk_pmux_pmpidr6_s          cn85xx; */
	/* struct bdk_pmux_pmpidr6_s          cn88xx; */
	/* struct bdk_pmux_pmpidr6_s          cn88xxp1; */
} bdk_pmux_pmpidr6_t;

static inline uint64_t BDK_PMUX_PMPIDR6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR6(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FD8ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR6(...) bdk_pmux_pmpidr6_t
#define bustype_BDK_PMUX_PMPIDR6(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR6(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR6(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR6(...) "PMUX_PMPIDR6"


/**
 * DAB32b - pmu#_pmpidr7
 */
typedef union bdk_pmux_pmpidr7 {
	uint32_t u;
	struct bdk_pmux_pmpidr7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_0_31               : 32;
#else
		uint32_t reserved_0_31               : 32;
#endif
	} s;
	/* struct bdk_pmux_pmpidr7_s          cn85xx; */
	/* struct bdk_pmux_pmpidr7_s          cn88xx; */
	/* struct bdk_pmux_pmpidr7_s          cn88xxp1; */
} bdk_pmux_pmpidr7_t;

static inline uint64_t BDK_PMUX_PMPIDR7(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMPIDR7(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020FDCull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMPIDR7", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMPIDR7(...) bdk_pmux_pmpidr7_t
#define bustype_BDK_PMUX_PMPIDR7(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMPIDR7(p1) (p1)
#define arguments_BDK_PMUX_PMPIDR7(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMPIDR7(...) "PMUX_PMPIDR7"


/**
 * DAB32b - pmu#_pmswinc_el0
 *
 * Increments a counter that is configured to count the Software
 * increment event, event0x00
 */
typedef union bdk_pmux_pmswinc_el0 {
	uint32_t u;
	struct bdk_pmux_pmswinc_el0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_31_31              : 1;
		uint32_t p                           : 31; /**< RO - Event counter software increment bit for PMEVCNTR\<x\>.
                                                                 P\<x\> is WI if x \>= PMU()_PMCR_EL0[N], the number of implemented
                                                                     counters.
                                                                 Otherwise, the effects of writing to this bit are:
                                                                 0 = No action. The write to this bit is ignored.
                                                                 1 = It is CONSTRAINED UNPREDICTABLE whether a SW_INCR event is
                                                                     generated for event counter x. */
#else
		uint32_t p                           : 31;
		uint32_t reserved_31_31              : 1;
#endif
	} s;
	/* struct bdk_pmux_pmswinc_el0_s      cn85xx; */
	/* struct bdk_pmux_pmswinc_el0_s      cn88xx; */
	/* struct bdk_pmux_pmswinc_el0_s      cn88xxp1; */
} bdk_pmux_pmswinc_el0_t;

static inline uint64_t BDK_PMUX_PMSWINC_EL0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_PMUX_PMSWINC_EL0(unsigned long param1)
{
	if (((param1 <= 47)))
		return 0x000087A008020CA0ull + (param1 & 63) * 0x80000ull;
	csr_fatal("BDK_PMUX_PMSWINC_EL0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_PMUX_PMSWINC_EL0(...) bdk_pmux_pmswinc_el0_t
#define bustype_BDK_PMUX_PMSWINC_EL0(...) BDK_CSR_TYPE_DAB32b
#define busnum_BDK_PMUX_PMSWINC_EL0(p1) (p1)
#define arguments_BDK_PMUX_PMSWINC_EL0(p1) (p1),-1,-1,-1
#define basename_BDK_PMUX_PMSWINC_EL0(...) "PMUX_PMSWINC_EL0"

#endif /* __BDK_CSRS_DAB_PMU__ */
