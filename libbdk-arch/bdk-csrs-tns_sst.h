#ifndef __BDK_CSRS_TNS_SST__
#define __BDK_CSRS_TNS_SST__
/* This file is auto-generated. Do not edit */

/***********************license start***************
 * Copyright (c) 2003-2015  Cavium Inc. (support@cavium.com). All rights
 * reserved.
 *
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *
 *   * Redistributions in binary form must reproduce the above
 *     copyright notice, this list of conditions and the following
 *     disclaimer in the documentation and/or other materials provided
 *     with the distribution.

 *   * Neither the name of Cavium Inc. nor the names of
 *     its contributors may be used to endorse or promote products
 *     derived from this software without specific prior written
 *     permission.

 * This Software, including technical data, may be subject to U.S. export  control
 * laws, including the U.S. Export Administration Act and its  associated
 * regulations, and may be subject to export or import  regulations in other
 * countries.

 * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
 * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO
 * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR
 * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM
 * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,
 * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF
 * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR
 * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR
 * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.
 ***********************license end**************************************/


/**
 * @file
 *
 * Configuration and status register (CSR) address and type definitions for
 * Cavium TNS_SST.
 *
 * This file is auto generated. Do not edit.
 *
 */

#include <stdint.h>

extern void csr_fatal(const char *name, int num_args, unsigned long arg1, unsigned long arg2, unsigned long arg3, unsigned long arg4) __attribute__ ((noreturn));




/**
 * NCB - tns_sde_cfg_spare
 *
 * Scratch register for SDE
 *
 */
typedef union bdk_tns_sde_cfg_spare {
	uint64_t u;
	struct bdk_tns_sde_cfg_spare_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t field                       : 64; /**< R/W - -- */
#else
		uint64_t field                       : 64;
#endif
	} s;
	/* struct bdk_tns_sde_cfg_spare_s     cn88xx; */
	/* struct bdk_tns_sde_cfg_spare_s     cn88xxp1; */
} bdk_tns_sde_cfg_spare_t;

#define BDK_TNS_SDE_CFG_SPARE BDK_TNS_SDE_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_SDE_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CFG_SPARE_FUNC(void)
{
	return 0x0000842060740000ull;
}
#define typedef_BDK_TNS_SDE_CFG_SPARE bdk_tns_sde_cfg_spare_t
#define bustype_BDK_TNS_SDE_CFG_SPARE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_CFG_SPARE 0
#define arguments_BDK_TNS_SDE_CFG_SPARE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CFG_SPARE "TNS_SDE_CFG_SPARE"


/**
 * NCB32b - tns_sde_cnt_bk#_bk_ecc_ctl#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_bk_ecc_ctlx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t cor_dis                     : 1;  /**< R/W - -- */
		uint32_t flip_sb_ecc                 : 3;  /**< R/W - -- */
		uint32_t flip_db_ecc                 : 3;  /**< R/W - -- */
#else
		uint32_t flip_db_ecc                 : 3;
		uint32_t flip_sb_ecc                 : 3;
		uint32_t cor_dis                     : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x00008420606100C0ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(...) bdk_tns_sde_cnt_bkx_bk_ecc_ctlx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_BK_ECC_CTLX(...) "TNS_SDE_CNT_BKX_BK_ECC_CTLX"


/**
 * NCB32b - tns_sde_cnt_bk#_ctr_ovfl_sta#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_ctr_ovfl_stax {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t fifo_usage                  : 5;  /**< R/W/H - -- */
		uint32_t ctr_id                      : 16; /**< R/W/H - -- */
		uint32_t ovfl_bmp                    : 3;  /**< R/W/H - -- */
#else
		uint32_t ovfl_bmp                    : 3;
		uint32_t ctr_id                      : 16;
		uint32_t fifo_usage                  : 5;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610030ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(...) bdk_tns_sde_cnt_bkx_ctr_ovfl_stax_t
#define bustype_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_CTR_OVFL_STAX(...) "TNS_SDE_CNT_BKX_CTR_OVFL_STAX"


/**
 * NCB32b - tns_sde_cnt_bk#_ecc_int_en_hi#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_ecc_int_en_hix {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_ecc_int_en_hix_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t sb_err                      : 3;  /**< R/W - -- */
		uint32_t db_err                      : 3;  /**< R/W - -- */
#else
		uint32_t db_err                      : 3;
		uint32_t sb_err                      : 3;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_en_hix_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_en_hix_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_ecc_int_en_hix_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610084ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(...) bdk_tns_sde_cnt_bkx_ecc_int_en_hix_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_HIX(...) "TNS_SDE_CNT_BKX_ECC_INT_EN_HIX"


/**
 * NCB32b - tns_sde_cnt_bk#_ecc_int_en_lo#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_ecc_int_en_lox {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_ecc_int_en_lox_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t sb_err                      : 3;  /**< R/W - -- */
		uint32_t db_err                      : 3;  /**< R/W - -- */
#else
		uint32_t db_err                      : 3;
		uint32_t sb_err                      : 3;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_en_lox_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_en_lox_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_ecc_int_en_lox_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610088ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(...) bdk_tns_sde_cnt_bkx_ecc_int_en_lox_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_EN_LOX(...) "TNS_SDE_CNT_BKX_ECC_INT_EN_LOX"


/**
 * NCB32b - tns_sde_cnt_bk#_ecc_int_frc#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_ecc_int_frcx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_ecc_int_frcx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t sb_err                      : 3;  /**< WO - -- */
		uint32_t db_err                      : 3;  /**< WO - -- */
#else
		uint32_t db_err                      : 3;
		uint32_t sb_err                      : 3;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_frcx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_frcx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_ecc_int_frcx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x000084206061008Cull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(...) bdk_tns_sde_cnt_bkx_ecc_int_frcx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_FRCX(...) "TNS_SDE_CNT_BKX_ECC_INT_FRCX"


/**
 * NCB32b - tns_sde_cnt_bk#_ecc_int_w1c#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_ecc_int_w1cx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_ecc_int_w1cx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t sb_err                      : 3;  /**< R/W1C/H - -- */
		uint32_t db_err                      : 3;  /**< R/W1C/H - -- */
#else
		uint32_t db_err                      : 3;
		uint32_t sb_err                      : 3;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_w1cx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_ecc_int_w1cx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_ecc_int_w1cx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610080ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(...) bdk_tns_sde_cnt_bkx_ecc_int_w1cx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_ECC_INT_W1CX(...) "TNS_SDE_CNT_BKX_ECC_INT_W1CX"


/**
 * NCB32b - tns_sde_cnt_bk#_fif_int_en_hi#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_fif_int_en_hix {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_fif_int_en_hix_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t fifo_full                   : 1;  /**< R/W - -- */
		uint32_t fifo_non_empty              : 1;  /**< R/W - -- */
#else
		uint32_t fifo_non_empty              : 1;
		uint32_t fifo_full                   : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_fif_int_en_hix_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_fif_int_en_hix_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_fif_int_en_hix_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610044ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(...) bdk_tns_sde_cnt_bkx_fif_int_en_hix_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_HIX(...) "TNS_SDE_CNT_BKX_FIF_INT_EN_HIX"


/**
 * NCB32b - tns_sde_cnt_bk#_fif_int_en_lo#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_fif_int_en_lox {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_fif_int_en_lox_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t fifo_full                   : 1;  /**< R/W - -- */
		uint32_t fifo_non_empty              : 1;  /**< R/W - -- */
#else
		uint32_t fifo_non_empty              : 1;
		uint32_t fifo_full                   : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_fif_int_en_lox_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_fif_int_en_lox_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_fif_int_en_lox_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610048ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(...) bdk_tns_sde_cnt_bkx_fif_int_en_lox_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_EN_LOX(...) "TNS_SDE_CNT_BKX_FIF_INT_EN_LOX"


/**
 * NCB32b - tns_sde_cnt_bk#_fif_int_frc#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_fif_int_frcx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_fif_int_frcx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t fifo_full                   : 1;  /**< WO - -- */
		uint32_t fifo_non_empty              : 1;  /**< WO - -- */
#else
		uint32_t fifo_non_empty              : 1;
		uint32_t fifo_full                   : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_fif_int_frcx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_fif_int_frcx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_fif_int_frcx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x000084206061004Cull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(...) bdk_tns_sde_cnt_bkx_fif_int_frcx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_FRCX(...) "TNS_SDE_CNT_BKX_FIF_INT_FRCX"


/**
 * NCB32b - tns_sde_cnt_bk#_fif_int_w1c#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_fif_int_w1cx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_fif_int_w1cx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t fifo_full                   : 1;  /**< R/W1C/H - -- */
		uint32_t fifo_non_empty              : 1;  /**< R/W1C/H - -- */
#else
		uint32_t fifo_non_empty              : 1;
		uint32_t fifo_full                   : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_fif_int_w1cx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_fif_int_w1cx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_fif_int_w1cx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610040ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(...) bdk_tns_sde_cnt_bkx_fif_int_w1cx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_FIF_INT_W1CX(...) "TNS_SDE_CNT_BKX_FIF_INT_W1CX"


/**
 * NCB32b - tns_sde_cnt_bk#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_cnt_bkx_lock {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_lock_s  cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_lock_s  cn88xxp1; */
} bdk_tns_sde_cnt_bkx_lock_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_LOCK(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x00008420606100D0ull + (param1 & 3) * 0x20000ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_LOCK(...) bdk_tns_sde_cnt_bkx_lock_t
#define bustype_BDK_TNS_SDE_CNT_BKX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_LOCK(...) "TNS_SDE_CNT_BKX_LOCK"


/**
 * NCB32b - tns_sde_cnt_bk#_mem#d#_w#
 *
 * --
 * Bits[31:16] in _W[8] are unused.
 * When writing, the MSBs (word 8) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_cnt_bkx_memxdx_wx {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_memxdx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_memxdx_wx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_memxdx_wx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_memxdx_wx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4)
{
	if (((param1 <= 3)) && ((param2 <= 3)) && ((param3 <= 255)) && ((param4 <= 8)))
		return 0x0000842060600000ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x4000ull + (param3 & 255) * 0x40ull + (param4 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_MEMXDX_WX", 4, param1, param2, param3, param4); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(...) bdk_tns_sde_cnt_bkx_memxdx_wx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(p1,p2,p3,p4) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(p1,p2,p3,p4) (p1),(p2),(p3),(p4)
#define basename_BDK_TNS_SDE_CNT_BKX_MEMXDX_WX(...) "TNS_SDE_CNT_BKX_MEMXDX_WX"


/**
 * NCB32b - tns_sde_cnt_bk#_mode#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_modex {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_modex_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t wrap_around                 : 1;  /**< R/W - -- */
		uint32_t clear_on_read               : 1;  /**< R/W - -- */
		uint32_t tile_rst                    : 1;  /**< R/W - -- */
		uint32_t mode                        : 4;  /**< R/W - -- */
		uint32_t ooo                         : 1;  /**< R/W - -- */
#else
		uint32_t ooo                         : 1;
		uint32_t mode                        : 4;
		uint32_t tile_rst                    : 1;
		uint32_t clear_on_read               : 1;
		uint32_t wrap_around                 : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_modex_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_modex_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_modex_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODEX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODEX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610000ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_MODEX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_MODEX(...) bdk_tns_sde_cnt_bkx_modex_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MODEX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_MODEX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_MODEX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_MODEX(...) "TNS_SDE_CNT_BKX_MODEX"


/**
 * NCB - tns_sde_cnt_bk#_mode_pol#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_bkx_mode_polx {
	uint64_t u;
	struct bdk_tns_sde_cnt_bkx_mode_polx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_46_63              : 18;
		uint64_t refr_en                     : 1;  /**< R/W - -- */
		uint64_t unit_time                   : 32; /**< R/W - -- */
		uint64_t refr_time_gran_expo         : 4;  /**< R/W - -- */
		uint64_t updt_weight                 : 8;  /**< R/W - -- */
		uint64_t billing_ctr_en              : 1;  /**< R/W - -- */
#else
		uint64_t billing_ctr_en              : 1;
		uint64_t updt_weight                 : 8;
		uint64_t refr_time_gran_expo         : 4;
		uint64_t unit_time                   : 32;
		uint64_t refr_en                     : 1;
		uint64_t reserved_46_63              : 18;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_mode_polx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_mode_polx_s cn88xxp1; */
} bdk_tns_sde_cnt_bkx_mode_polx_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODE_POLX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_MODE_POLX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 3)))
		return 0x0000842060610010ull + (param1 & 3) * 0x20000ull + (param2 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_MODE_POLX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_MODE_POLX(...) bdk_tns_sde_cnt_bkx_mode_polx_t
#define bustype_BDK_TNS_SDE_CNT_BKX_MODE_POLX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_CNT_BKX_MODE_POLX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_MODE_POLX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_MODE_POLX(...) "TNS_SDE_CNT_BKX_MODE_POLX"


/**
 * NCB32b - tns_sde_cnt_bk#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_cnt_bkx_spad {
	uint32_t u;
	struct bdk_tns_sde_cnt_bkx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_bkx_spad_s  cn88xx; */
	/* struct bdk_tns_sde_cnt_bkx_spad_s  cn88xxp1; */
} bdk_tns_sde_cnt_bkx_spad_t;

static inline uint64_t BDK_TNS_SDE_CNT_BKX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_BKX_SPAD(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x00008420606100D4ull + (param1 & 3) * 0x20000ull;
	csr_fatal("BDK_TNS_SDE_CNT_BKX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_BKX_SPAD(...) bdk_tns_sde_cnt_bkx_spad_t
#define bustype_BDK_TNS_SDE_CNT_BKX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_BKX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_CNT_BKX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_BKX_SPAD(...) "TNS_SDE_CNT_BKX_SPAD"


/**
 * NCB - tns_sde_cnt_cinf_bckt#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_cinf_bcktx {
	uint64_t u;
	struct bdk_tns_sde_cnt_cinf_bcktx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_55_63              : 9;
		uint64_t en                          : 1;  /**< R/W - -- */
		uint64_t a_a                         : 16; /**< R/W - -- */
		uint64_t b_b                         : 16; /**< R/W - -- */
		uint64_t n                           : 16; /**< R/W - -- */
		uint64_t gran_expo                   : 4;  /**< R/W - -- */
		uint64_t add_addr                    : 1;  /**< R/W - -- */
		uint64_t bkt_use_addr                : 1;  /**< R/W - -- */
#else
		uint64_t bkt_use_addr                : 1;
		uint64_t add_addr                    : 1;
		uint64_t gran_expo                   : 4;
		uint64_t n                           : 16;
		uint64_t b_b                         : 16;
		uint64_t a_a                         : 16;
		uint64_t en                          : 1;
		uint64_t reserved_55_63              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_cinf_bcktx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_cinf_bcktx_s cn88xxp1; */
} bdk_tns_sde_cnt_cinf_bcktx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CINF_BCKTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_BCKTX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842060681020ull + (param1 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_CNT_CINF_BCKTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_CINF_BCKTX(...) bdk_tns_sde_cnt_cinf_bcktx_t
#define bustype_BDK_TNS_SDE_CNT_CINF_BCKTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_CNT_CINF_BCKTX(p1) (p1)
#define arguments_BDK_TNS_SDE_CNT_CINF_BCKTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CINF_BCKTX(...) "TNS_SDE_CNT_CINF_BCKTX"


/**
 * NCB32b - tns_sde_cnt_cinf_int_ro
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_cinf_int_ro {
	uint32_t u;
	struct bdk_tns_sde_cnt_cinf_int_ro_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ctr_ovfl                    : 16; /**< RO/H - -- */
		uint32_t mem_err                     : 16; /**< RO/H - -- */
#else
		uint32_t mem_err                     : 16;
		uint32_t ctr_ovfl                    : 16;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_cinf_int_ro_s cn88xx; */
	/* struct bdk_tns_sde_cnt_cinf_int_ro_s cn88xxp1; */
} bdk_tns_sde_cnt_cinf_int_ro_t;

#define BDK_TNS_SDE_CNT_CINF_INT_RO BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INT_RO_FUNC(void)
{
	return 0x0000842060681060ull;
}
#define typedef_BDK_TNS_SDE_CNT_CINF_INT_RO bdk_tns_sde_cnt_cinf_int_ro_t
#define bustype_BDK_TNS_SDE_CNT_CINF_INT_RO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CINF_INT_RO 0
#define arguments_BDK_TNS_SDE_CNT_CINF_INT_RO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CINF_INT_RO "TNS_SDE_CNT_CINF_INT_RO"


/**
 * NCB32b - tns_sde_cnt_cinf_intf_tbl#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_cinf_intf_tblx {
	uint32_t u;
	struct bdk_tns_sde_cnt_cinf_intf_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_27_31              : 5;
		uint32_t mode                        : 4;  /**< R/W - -- */
		uint32_t bank_start                  : 6;  /**< R/W - -- */
		uint32_t bank_end                    : 6;  /**< R/W - -- */
		uint32_t entry_sel_sz                : 6;  /**< R/W - -- */
		uint32_t dual_bank                   : 1;  /**< R/W - -- */
		uint32_t count_offset                : 4;  /**< R/W - -- */
#else
		uint32_t count_offset                : 4;
		uint32_t dual_bank                   : 1;
		uint32_t entry_sel_sz                : 6;
		uint32_t bank_end                    : 6;
		uint32_t bank_start                  : 6;
		uint32_t mode                        : 4;
		uint32_t reserved_27_31              : 5;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_cinf_intf_tblx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_cinf_intf_tblx_s cn88xxp1; */
} bdk_tns_sde_cnt_cinf_intf_tblx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CINF_INTF_TBLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_INTF_TBLX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842060681000ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_CINF_INTF_TBLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(...) bdk_tns_sde_cnt_cinf_intf_tblx_t
#define bustype_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(p1) (p1)
#define arguments_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CINF_INTF_TBLX(...) "TNS_SDE_CNT_CINF_INTF_TBLX"


/**
 * NCB32b - tns_sde_cnt_cinf_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_cnt_cinf_lock {
	uint32_t u;
	struct bdk_tns_sde_cnt_cinf_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_cinf_lock_s cn88xx; */
	/* struct bdk_tns_sde_cnt_cinf_lock_s cn88xxp1; */
} bdk_tns_sde_cnt_cinf_lock_t;

#define BDK_TNS_SDE_CNT_CINF_LOCK BDK_TNS_SDE_CNT_CINF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_LOCK_FUNC(void)
{
	return 0x0000842060681064ull;
}
#define typedef_BDK_TNS_SDE_CNT_CINF_LOCK bdk_tns_sde_cnt_cinf_lock_t
#define bustype_BDK_TNS_SDE_CNT_CINF_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CINF_LOCK 0
#define arguments_BDK_TNS_SDE_CNT_CINF_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CINF_LOCK "TNS_SDE_CNT_CINF_LOCK"


/**
 * NCB32b - tns_sde_cnt_cinf_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_cnt_cinf_spad {
	uint32_t u;
	struct bdk_tns_sde_cnt_cinf_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_cinf_spad_s cn88xx; */
	/* struct bdk_tns_sde_cnt_cinf_spad_s cn88xxp1; */
} bdk_tns_sde_cnt_cinf_spad_t;

#define BDK_TNS_SDE_CNT_CINF_SPAD BDK_TNS_SDE_CNT_CINF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CINF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CINF_SPAD_FUNC(void)
{
	return 0x0000842060681068ull;
}
#define typedef_BDK_TNS_SDE_CNT_CINF_SPAD bdk_tns_sde_cnt_cinf_spad_t
#define bustype_BDK_TNS_SDE_CNT_CINF_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CINF_SPAD 0
#define arguments_BDK_TNS_SDE_CNT_CINF_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CINF_SPAD "TNS_SDE_CNT_CINF_SPAD"


/**
 * NCB32b - tns_sde_cnt_crsl_cnt_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_crsl_cnt_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_cnt_crsl_cnt_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_crsl_cnt_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_cnt_crsl_cnt_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_cnt_crsl_cnt_dbg_sel_t;

#define BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL_FUNC(void)
{
	return 0x0000842060680800ull;
}
#define typedef_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL bdk_tns_sde_cnt_crsl_cnt_dbg_sel_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CRSL_CNT_DBG_SEL "TNS_SDE_CNT_CRSL_CNT_DBG_SEL"


/**
 * NCB32b - tns_sde_cnt_crsl_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_cnt_crsl_lock {
	uint32_t u;
	struct bdk_tns_sde_cnt_crsl_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_crsl_lock_s cn88xx; */
	/* struct bdk_tns_sde_cnt_crsl_lock_s cn88xxp1; */
} bdk_tns_sde_cnt_crsl_lock_t;

#define BDK_TNS_SDE_CNT_CRSL_LOCK BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_LOCK_FUNC(void)
{
	return 0x000084206068080Cull;
}
#define typedef_BDK_TNS_SDE_CNT_CRSL_LOCK bdk_tns_sde_cnt_crsl_lock_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CRSL_LOCK 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CRSL_LOCK "TNS_SDE_CNT_CRSL_LOCK"


/**
 * NCB32b - tns_sde_cnt_crsl_pol_ecc_ctl#
 *
 * --
 *
 */
typedef union bdk_tns_sde_cnt_crsl_pol_ecc_ctlx {
	uint32_t u;
	struct bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t cor_dis                     : 1;  /**< R/W - -- */
		uint32_t flip_db_ecc                 : 1;  /**< R/W - -- */
		uint32_t flip_sb_ecc                 : 1;  /**< R/W - -- */
#else
		uint32_t flip_sb_ecc                 : 1;
		uint32_t flip_db_ecc                 : 1;
		uint32_t cor_dis                     : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_s cn88xxp1; */
} bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060680804ull + (param1 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(...) bdk_tns_sde_cnt_crsl_pol_ecc_ctlx_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(p1) (p1)
#define arguments_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CRSL_POL_ECC_CTLX(...) "TNS_SDE_CNT_CRSL_POL_ECC_CTLX"


/**
 * NCB - tns_sde_cnt_crsl_pol_prm#d#
 *
 * This memory is only applicable to request interface 0, 4, 8, ... 44
 *
 */
typedef union bdk_tns_sde_cnt_crsl_pol_prmxdx {
	uint64_t u;
	struct bdk_tns_sde_cnt_crsl_pol_prmxdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_57_63              : 7;
		uint64_t data                        : 57; /**< R/W - -- */
#else
		uint64_t data                        : 57;
		uint64_t reserved_57_63              : 7;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_crsl_pol_prmxdx_s cn88xx; */
	/* struct bdk_tns_sde_cnt_crsl_pol_prmxdx_s cn88xxp1; */
} bdk_tns_sde_cnt_crsl_pol_prmxdx_t;

static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 101)))
		return 0x0000842060680000ull + (param1 & 1) * 0x330ull + (param2 & 127) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(...) bdk_tns_sde_cnt_crsl_pol_prmxdx_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_CNT_CRSL_POL_PRMXDX(...) "TNS_SDE_CNT_CRSL_POL_PRMXDX"


/**
 * NCB32b - tns_sde_cnt_crsl_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_cnt_crsl_spad {
	uint32_t u;
	struct bdk_tns_sde_cnt_crsl_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_cnt_crsl_spad_s cn88xx; */
	/* struct bdk_tns_sde_cnt_crsl_spad_s cn88xxp1; */
} bdk_tns_sde_cnt_crsl_spad_t;

#define BDK_TNS_SDE_CNT_CRSL_SPAD BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_CNT_CRSL_SPAD_FUNC(void)
{
	return 0x0000842060680810ull;
}
#define typedef_BDK_TNS_SDE_CNT_CRSL_SPAD bdk_tns_sde_cnt_crsl_spad_t
#define bustype_BDK_TNS_SDE_CNT_CRSL_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_CNT_CRSL_SPAD 0
#define arguments_BDK_TNS_SDE_CNT_CRSL_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_CNT_CRSL_SPAD "TNS_SDE_CNT_CRSL_SPAD"


/**
 * NCB32b - tns_sde_hdbf_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_hdbf_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_dbg_sel_s  cn88xxp1; */
} bdk_tns_sde_hdbf_dbg_sel_t;

#define BDK_TNS_SDE_HDBF_DBG_SEL BDK_TNS_SDE_HDBF_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_DBG_SEL_FUNC(void)
{
	return 0x0000842060780800ull;
}
#define typedef_BDK_TNS_SDE_HDBF_DBG_SEL bdk_tns_sde_hdbf_dbg_sel_t
#define bustype_BDK_TNS_SDE_HDBF_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_DBG_SEL 0
#define arguments_BDK_TNS_SDE_HDBF_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_DBG_SEL "TNS_SDE_HDBF_DBG_SEL"


/**
 * NCB32b - tns_sde_hdbf_ecc_ctl
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_ecc_ctl {
	uint32_t u;
	struct bdk_tns_sde_hdbf_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_17_31              : 15;
		uint32_t fl_cor_dis                  : 1;  /**< R/W - -- */
		uint32_t main_cor_dis                : 1;  /**< R/W - -- */
		uint32_t ctx_cor_dis                 : 1;  /**< R/W - -- */
		uint32_t fl_flip_db_ecc              : 1;  /**< R/W - -- */
		uint32_t fl_flip_sb_ecc              : 1;  /**< R/W - -- */
		uint32_t main_flip_db_ecc            : 4;  /**< R/W - -- */
		uint32_t main_flip_sb_ecc            : 4;  /**< R/W - -- */
		uint32_t ctx_flip_db_ecc             : 2;  /**< R/W - -- */
		uint32_t ctx_flip_sb_ecc             : 2;  /**< R/W - -- */
#else
		uint32_t ctx_flip_sb_ecc             : 2;
		uint32_t ctx_flip_db_ecc             : 2;
		uint32_t main_flip_sb_ecc            : 4;
		uint32_t main_flip_db_ecc            : 4;
		uint32_t fl_flip_sb_ecc              : 1;
		uint32_t fl_flip_db_ecc              : 1;
		uint32_t ctx_cor_dis                 : 1;
		uint32_t main_cor_dis                : 1;
		uint32_t fl_cor_dis                  : 1;
		uint32_t reserved_17_31              : 15;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_ecc_ctl_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_ecc_ctl_s  cn88xxp1; */
} bdk_tns_sde_hdbf_ecc_ctl_t;

#define BDK_TNS_SDE_HDBF_ECC_CTL BDK_TNS_SDE_HDBF_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_ECC_CTL_FUNC(void)
{
	return 0x0000842060780808ull;
}
#define typedef_BDK_TNS_SDE_HDBF_ECC_CTL bdk_tns_sde_hdbf_ecc_ctl_t
#define bustype_BDK_TNS_SDE_HDBF_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_ECC_CTL 0
#define arguments_BDK_TNS_SDE_HDBF_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_ECC_CTL "TNS_SDE_HDBF_ECC_CTL"


/**
 * NCB32b - tns_sde_hdbf_fl_mon
 *
 * These registers control monitoring of the free list for lost
 * pages.  Free list monitoring has two controls, a sample target
 * and a window size.
 * Monitoring of the list is accomplished by picking a particular
 * page number, and then setting the monitoring window size.  The
 * window size is in multipels of 256 page returns.  For good sampling
 * the monitoring period should be at least 4x the expected
 * lifetime of a page.
 * At the end of each monitoring period the four status registers
 * in fl_mon_status are updated with the number of times the
 * requested block was seen being returned to the free list FIFO.
 */
typedef union bdk_tns_sde_hdbf_fl_mon {
	uint32_t u;
	struct bdk_tns_sde_hdbf_fl_mon_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_17_31              : 15;
		uint32_t target                      : 9;  /**< R/W - Target page to monitor. */
		uint32_t window                      : 8;  /**< R/W - Monitoring window size, in units of 256 page returns. */
#else
		uint32_t window                      : 8;
		uint32_t target                      : 9;
		uint32_t reserved_17_31              : 15;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_fl_mon_s   cn88xx; */
	/* struct bdk_tns_sde_hdbf_fl_mon_s   cn88xxp1; */
} bdk_tns_sde_hdbf_fl_mon_t;

#define BDK_TNS_SDE_HDBF_FL_MON BDK_TNS_SDE_HDBF_FL_MON_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_FUNC(void)
{
	return 0x0000842060780884ull;
}
#define typedef_BDK_TNS_SDE_HDBF_FL_MON bdk_tns_sde_hdbf_fl_mon_t
#define bustype_BDK_TNS_SDE_HDBF_FL_MON BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_FL_MON 0
#define arguments_BDK_TNS_SDE_HDBF_FL_MON -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_FL_MON "TNS_SDE_HDBF_FL_MON"


/**
 * NCB32b - tns_sde_hdbf_fl_mon_sta
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_fl_mon_sta {
	uint32_t u;
	struct bdk_tns_sde_hdbf_fl_mon_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t returns0                    : 8;  /**< RO/H - Number of page returns for free list 0. */
#else
		uint32_t returns0                    : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_fl_mon_sta_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_fl_mon_sta_s cn88xxp1; */
} bdk_tns_sde_hdbf_fl_mon_sta_t;

#define BDK_TNS_SDE_HDBF_FL_MON_STA BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FL_MON_STA_FUNC(void)
{
	return 0x0000842060780888ull;
}
#define typedef_BDK_TNS_SDE_HDBF_FL_MON_STA bdk_tns_sde_hdbf_fl_mon_sta_t
#define bustype_BDK_TNS_SDE_HDBF_FL_MON_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_FL_MON_STA 0
#define arguments_BDK_TNS_SDE_HDBF_FL_MON_STA -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_FL_MON_STA "TNS_SDE_HDBF_FL_MON_STA"


/**
 * NCB32b - tns_sde_hdbf_flst_ctl
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_flst_ctl {
	uint32_t u;
	struct bdk_tns_sde_hdbf_flst_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t enqen                       : 1;  /**< R/W - Enqueue enable for freelist FIFOs. */
		uint32_t deqen                       : 1;  /**< R/W - Dequeue enable for freelist FIFOs. */
		uint32_t contenq                     : 1;  /**< R/W - -- */
		uint32_t contdeq                     : 1;  /**< R/W - -- */
#else
		uint32_t contdeq                     : 1;
		uint32_t contenq                     : 1;
		uint32_t deqen                       : 1;
		uint32_t enqen                       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_flst_ctl_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_flst_ctl_s cn88xxp1; */
} bdk_tns_sde_hdbf_flst_ctl_t;

#define BDK_TNS_SDE_HDBF_FLST_CTL BDK_TNS_SDE_HDBF_FLST_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_CTL_FUNC(void)
{
	return 0x000084206078088Cull;
}
#define typedef_BDK_TNS_SDE_HDBF_FLST_CTL bdk_tns_sde_hdbf_flst_ctl_t
#define bustype_BDK_TNS_SDE_HDBF_FLST_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_FLST_CTL 0
#define arguments_BDK_TNS_SDE_HDBF_FLST_CTL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_FLST_CTL "TNS_SDE_HDBF_FLST_CTL"


/**
 * NCB32b - tns_sde_hdbf_flst_dbg
 *
 * Free List debug access
 *
 */
typedef union bdk_tns_sde_hdbf_flst_dbg {
	uint32_t u;
	struct bdk_tns_sde_hdbf_flst_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t field                       : 18; /**< R/W/H - Freelist field debug access. TND_SDE_HDBF_GEN.channel_enable must be set before
                                                                 any read/write access is attempted. */
#else
		uint32_t field                       : 18;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_flst_dbg_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_flst_dbg_s cn88xxp1; */
} bdk_tns_sde_hdbf_flst_dbg_t;

#define BDK_TNS_SDE_HDBF_FLST_DBG BDK_TNS_SDE_HDBF_FLST_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FLST_DBG_FUNC(void)
{
	return 0x0000842060780890ull;
}
#define typedef_BDK_TNS_SDE_HDBF_FLST_DBG bdk_tns_sde_hdbf_flst_dbg_t
#define bustype_BDK_TNS_SDE_HDBF_FLST_DBG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_FLST_DBG 0
#define arguments_BDK_TNS_SDE_HDBF_FLST_DBG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_FLST_DBG "TNS_SDE_HDBF_FLST_DBG"


/**
 * NCB32b - tns_sde_hdbf_free_ct
 *
 * These fields show the current free list counts for each of the
 * four free list FIFOs.  In operation these FIFOs will show a
 * value of 253 when empty due to prefetching of free pages.
 */
typedef union bdk_tns_sde_hdbf_free_ct {
	uint32_t u;
	struct bdk_tns_sde_hdbf_free_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t free_bank0                  : 8;  /**< RO/H - Length of the free list FIFO for bank 0. */
#else
		uint32_t free_bank0                  : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_free_ct_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_free_ct_s  cn88xxp1; */
} bdk_tns_sde_hdbf_free_ct_t;

#define BDK_TNS_SDE_HDBF_FREE_CT BDK_TNS_SDE_HDBF_FREE_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_FREE_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_FREE_CT_FUNC(void)
{
	return 0x0000842060780880ull;
}
#define typedef_BDK_TNS_SDE_HDBF_FREE_CT bdk_tns_sde_hdbf_free_ct_t
#define bustype_BDK_TNS_SDE_HDBF_FREE_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_FREE_CT 0
#define arguments_BDK_TNS_SDE_HDBF_FREE_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_FREE_CT "TNS_SDE_HDBF_FREE_CT"


/**
 * NCB32b - tns_sde_hdbf_gen
 *
 * General configuration for header buffer
 *
 */
typedef union bdk_tns_sde_hdbf_gen {
	uint32_t u;
	struct bdk_tns_sde_hdbf_gen_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t channel_enable              : 1;  /**< R/W - When set to 0, the channel is disabled.  The free list is cleared and any
                                                                 returned
                                                                 pages will be ignored.
                                                                 When set to 1, the free list will be re-initialized based on the number
                                                                 of pages
                                                                 specified in the channel_page_size field.
                                                                 The parser and MRE must be disabled prior to free list initialization
                                                                 so that they
                                                                 are not holding slot requests when the free list is cleared. */
		uint32_t channel_page_size           : 1;  /**< R/W - This sets the page size for each channel.  0 means a page size of 4 lines
                                                                 (256B),
                                                                 1 sets page size to 2 lines (128B).  For correct operation this should
                                                                 only be
                                                                 set when channel_enable is 0 or concurrently with setting
                                                                 channel_enable to 0. */
		uint32_t channel_ct_mode             : 1;  /**< R/W - This sets the request count for each channel.  When set to 0, each channel
                                                                 counts
                                                                 the number of requests on each request line from Parser and MRE and
                                                                 attempts to
                                                                 provide them with that many pages.
                                                                 When set to 1, each channel has a page budget for both Parser and MRE.
                                                                 HDBF monitors
                                                                 writes to determine when a page has been consumed and allocates a new
                                                                 page. */
#else
		uint32_t channel_ct_mode             : 1;
		uint32_t channel_page_size           : 1;
		uint32_t channel_enable              : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_gen_s      cn88xx; */
	/* struct bdk_tns_sde_hdbf_gen_s      cn88xxp1; */
} bdk_tns_sde_hdbf_gen_t;

#define BDK_TNS_SDE_HDBF_GEN BDK_TNS_SDE_HDBF_GEN_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_GEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_GEN_FUNC(void)
{
	return 0x0000842060780804ull;
}
#define typedef_BDK_TNS_SDE_HDBF_GEN bdk_tns_sde_hdbf_gen_t
#define bustype_BDK_TNS_SDE_HDBF_GEN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_GEN 0
#define arguments_BDK_TNS_SDE_HDBF_GEN -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_GEN "TNS_SDE_HDBF_GEN"


/**
 * NCB32b - tns_sde_hdbf_int_en_hi
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_hdbf_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t fl_sb_err                   : 1;  /**< R/W - Single bit errors from free list memory. */
		uint32_t main_sb_err                 : 1;  /**< R/W - Single bit errors from main header memory. */
		uint32_t ctx_sb_err                  : 1;  /**< R/W - Single bit errors from context memory. */
		uint32_t fl_db_err                   : 1;  /**< R/W - Double bit errors from free list memory. */
		uint32_t main_db_err                 : 1;  /**< R/W - Double bit errors from main header memory. */
		uint32_t ctx_db_err                  : 1;  /**< R/W - Double bit errors from context memory. */
		uint32_t free_list_ovfl              : 1;  /**< R/W - Overflow indication from free list FIFO */
		uint32_t write_out_of_range          : 1;  /**< R/W - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
		uint32_t read_out_of_range           : 1;  /**< R/W - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else
		uint32_t read_out_of_range           : 1;
		uint32_t write_out_of_range          : 1;
		uint32_t free_list_ovfl              : 1;
		uint32_t ctx_db_err                  : 1;
		uint32_t main_db_err                 : 1;
		uint32_t fl_db_err                   : 1;
		uint32_t ctx_sb_err                  : 1;
		uint32_t main_sb_err                 : 1;
		uint32_t fl_sb_err                   : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_hdbf_int_en_hi_t;

#define BDK_TNS_SDE_HDBF_INT_EN_HI BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_HI_FUNC(void)
{
	return 0x0000842060780874ull;
}
#define typedef_BDK_TNS_SDE_HDBF_INT_EN_HI bdk_tns_sde_hdbf_int_en_hi_t
#define bustype_BDK_TNS_SDE_HDBF_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_HDBF_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_INT_EN_HI "TNS_SDE_HDBF_INT_EN_HI"


/**
 * NCB32b - tns_sde_hdbf_int_en_lo
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_hdbf_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t fl_sb_err                   : 1;  /**< R/W - Single bit errors from free list memory. */
		uint32_t main_sb_err                 : 1;  /**< R/W - Single bit errors from main header memory. */
		uint32_t ctx_sb_err                  : 1;  /**< R/W - Single bit errors from context memory. */
		uint32_t fl_db_err                   : 1;  /**< R/W - Double bit errors from free list memory. */
		uint32_t main_db_err                 : 1;  /**< R/W - Double bit errors from main header memory. */
		uint32_t ctx_db_err                  : 1;  /**< R/W - Double bit errors from context memory. */
		uint32_t free_list_ovfl              : 1;  /**< R/W - Overflow indication from free list FIFO */
		uint32_t write_out_of_range          : 1;  /**< R/W - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
		uint32_t read_out_of_range           : 1;  /**< R/W - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else
		uint32_t read_out_of_range           : 1;
		uint32_t write_out_of_range          : 1;
		uint32_t free_list_ovfl              : 1;
		uint32_t ctx_db_err                  : 1;
		uint32_t main_db_err                 : 1;
		uint32_t fl_db_err                   : 1;
		uint32_t ctx_sb_err                  : 1;
		uint32_t main_sb_err                 : 1;
		uint32_t fl_sb_err                   : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_hdbf_int_en_lo_t;

#define BDK_TNS_SDE_HDBF_INT_EN_LO BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_EN_LO_FUNC(void)
{
	return 0x0000842060780878ull;
}
#define typedef_BDK_TNS_SDE_HDBF_INT_EN_LO bdk_tns_sde_hdbf_int_en_lo_t
#define bustype_BDK_TNS_SDE_HDBF_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_HDBF_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_INT_EN_LO "TNS_SDE_HDBF_INT_EN_LO"


/**
 * NCB32b - tns_sde_hdbf_int_frc
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_int_frc {
	uint32_t u;
	struct bdk_tns_sde_hdbf_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t fl_sb_err                   : 1;  /**< WO - Single bit errors from free list memory. */
		uint32_t main_sb_err                 : 1;  /**< WO - Single bit errors from main header memory. */
		uint32_t ctx_sb_err                  : 1;  /**< WO - Single bit errors from context memory. */
		uint32_t fl_db_err                   : 1;  /**< WO - Double bit errors from free list memory. */
		uint32_t main_db_err                 : 1;  /**< WO - Double bit errors from main header memory. */
		uint32_t ctx_db_err                  : 1;  /**< WO - Double bit errors from context memory. */
		uint32_t free_list_ovfl              : 1;  /**< WO - Overflow indication from free list FIFO */
		uint32_t write_out_of_range          : 1;  /**< WO - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
		uint32_t read_out_of_range           : 1;  /**< WO - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else
		uint32_t read_out_of_range           : 1;
		uint32_t write_out_of_range          : 1;
		uint32_t free_list_ovfl              : 1;
		uint32_t ctx_db_err                  : 1;
		uint32_t main_db_err                 : 1;
		uint32_t fl_db_err                   : 1;
		uint32_t ctx_sb_err                  : 1;
		uint32_t main_sb_err                 : 1;
		uint32_t fl_sb_err                   : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_int_frc_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_int_frc_s  cn88xxp1; */
} bdk_tns_sde_hdbf_int_frc_t;

#define BDK_TNS_SDE_HDBF_INT_FRC BDK_TNS_SDE_HDBF_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_FRC_FUNC(void)
{
	return 0x000084206078087Cull;
}
#define typedef_BDK_TNS_SDE_HDBF_INT_FRC bdk_tns_sde_hdbf_int_frc_t
#define bustype_BDK_TNS_SDE_HDBF_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_INT_FRC 0
#define arguments_BDK_TNS_SDE_HDBF_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_INT_FRC "TNS_SDE_HDBF_INT_FRC"


/**
 * NCB32b - tns_sde_hdbf_int_w1c
 *
 * --
 *
 */
typedef union bdk_tns_sde_hdbf_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_hdbf_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t fl_sb_err                   : 1;  /**< R/W1C/H - Single bit errors from free list memory. */
		uint32_t main_sb_err                 : 1;  /**< R/W1C/H - Single bit errors from main header memory. */
		uint32_t ctx_sb_err                  : 1;  /**< R/W1C/H - Single bit errors from context memory. */
		uint32_t fl_db_err                   : 1;  /**< R/W1C/H - Double bit errors from free list memory. */
		uint32_t main_db_err                 : 1;  /**< R/W1C/H - Double bit errors from main header memory. */
		uint32_t ctx_db_err                  : 1;  /**< R/W1C/H - Double bit errors from context memory. */
		uint32_t free_list_ovfl              : 1;  /**< R/W1C/H - Overflow indication from free list FIFO */
		uint32_t write_out_of_range          : 1;  /**< R/W1C/H - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a write to lines 2-3 of the header. */
		uint32_t read_out_of_range           : 1;  /**< R/W1C/H - In 256 header mode, indicates an access to a page address \>= 256.
                                                                 In 512 header mode, indicates a read from lines 2-3 of the header. */
#else
		uint32_t read_out_of_range           : 1;
		uint32_t write_out_of_range          : 1;
		uint32_t free_list_ovfl              : 1;
		uint32_t ctx_db_err                  : 1;
		uint32_t main_db_err                 : 1;
		uint32_t fl_db_err                   : 1;
		uint32_t ctx_sb_err                  : 1;
		uint32_t main_sb_err                 : 1;
		uint32_t fl_sb_err                   : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_int_w1c_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_int_w1c_s  cn88xxp1; */
} bdk_tns_sde_hdbf_int_w1c_t;

#define BDK_TNS_SDE_HDBF_INT_W1C BDK_TNS_SDE_HDBF_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_INT_W1C_FUNC(void)
{
	return 0x0000842060780870ull;
}
#define typedef_BDK_TNS_SDE_HDBF_INT_W1C bdk_tns_sde_hdbf_int_w1c_t
#define bustype_BDK_TNS_SDE_HDBF_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_INT_W1C 0
#define arguments_BDK_TNS_SDE_HDBF_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_INT_W1C "TNS_SDE_HDBF_INT_W1C"


/**
 * NCB32b - tns_sde_hdbf_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_hdbf_lock {
	uint32_t u;
	struct bdk_tns_sde_hdbf_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_lock_s     cn88xx; */
	/* struct bdk_tns_sde_hdbf_lock_s     cn88xxp1; */
} bdk_tns_sde_hdbf_lock_t;

#define BDK_TNS_SDE_HDBF_LOCK BDK_TNS_SDE_HDBF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_LOCK_FUNC(void)
{
	return 0x000084206078089Cull;
}
#define typedef_BDK_TNS_SDE_HDBF_LOCK bdk_tns_sde_hdbf_lock_t
#define bustype_BDK_TNS_SDE_HDBF_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_LOCK 0
#define arguments_BDK_TNS_SDE_HDBF_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_LOCK "TNS_SDE_HDBF_LOCK"


/**
 * NCB32b - tns_sde_hdbf_memctx_adr
 *
 * Shared address value for indirect access to context memory bank.
 * Context memory is 512 words deep.
 */
typedef union bdk_tns_sde_hdbf_memctx_adr {
	uint32_t u;
	struct bdk_tns_sde_hdbf_memctx_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t field                       : 8;  /**< R/W - -- */
#else
		uint32_t field                       : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_memctx_adr_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_memctx_adr_s cn88xxp1; */
} bdk_tns_sde_hdbf_memctx_adr_t;

#define BDK_TNS_SDE_HDBF_MEMCTX_ADR BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_ADR_FUNC(void)
{
	return 0x0000842060780854ull;
}
#define typedef_BDK_TNS_SDE_HDBF_MEMCTX_ADR bdk_tns_sde_hdbf_memctx_adr_t
#define bustype_BDK_TNS_SDE_HDBF_MEMCTX_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_MEMCTX_ADR 0
#define arguments_BDK_TNS_SDE_HDBF_MEMCTX_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_MEMCTX_ADR "TNS_SDE_HDBF_MEMCTX_ADR"


/**
 * NCB - tns_sde_hdbf_memctx_w#
 *
 * Indirect access for header context bank
 * Bits 63..36 of registers ending in _W2 are unused.
 */
typedef union bdk_tns_sde_hdbf_memctx_wx {
	uint64_t u;
	struct bdk_tns_sde_hdbf_memctx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t field                       : 64; /**< R/W/H - -- */
#else
		uint64_t field                       : 64;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_memctx_wx_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_memctx_wx_s cn88xxp1; */
} bdk_tns_sde_hdbf_memctx_wx_t;

static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMCTX_WX(unsigned long param1)
{
	if (((param1 <= 2)))
		return 0x0000842060780858ull + (param1 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_HDBF_MEMCTX_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_HDBF_MEMCTX_WX(...) bdk_tns_sde_hdbf_memctx_wx_t
#define bustype_BDK_TNS_SDE_HDBF_MEMCTX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_HDBF_MEMCTX_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_HDBF_MEMCTX_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_MEMCTX_WX(...) "TNS_SDE_HDBF_MEMCTX_WX"


/**
 * NCB32b - tns_sde_hdbf_memmain_adr
 *
 * Shared address value for indirect access to main memory bank.  Main
 * memory is 1024 words deep.
 */
typedef union bdk_tns_sde_hdbf_memmain_adr {
	uint32_t u;
	struct bdk_tns_sde_hdbf_memmain_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t field                       : 10; /**< R/W - -- */
#else
		uint32_t field                       : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_memmain_adr_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_memmain_adr_s cn88xxp1; */
} bdk_tns_sde_hdbf_memmain_adr_t;

#define BDK_TNS_SDE_HDBF_MEMMAIN_ADR BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_ADR_FUNC(void)
{
	return 0x0000842060780810ull;
}
#define typedef_BDK_TNS_SDE_HDBF_MEMMAIN_ADR bdk_tns_sde_hdbf_memmain_adr_t
#define bustype_BDK_TNS_SDE_HDBF_MEMMAIN_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_MEMMAIN_ADR 0
#define arguments_BDK_TNS_SDE_HDBF_MEMMAIN_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_MEMMAIN_ADR "TNS_SDE_HDBF_MEMMAIN_ADR"


/**
 * NCB32b - tns_sde_hdbf_memmain_w#
 *
 * Indirect access for header main memory bank
 *
 */
typedef union bdk_tns_sde_hdbf_memmain_wx {
	uint32_t u;
	struct bdk_tns_sde_hdbf_memmain_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t field                       : 32; /**< R/W/H - -- */
#else
		uint32_t field                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_memmain_wx_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_memmain_wx_s cn88xxp1; */
} bdk_tns_sde_hdbf_memmain_wx_t;

static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MEMMAIN_WX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842060780814ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_HDBF_MEMMAIN_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_HDBF_MEMMAIN_WX(...) bdk_tns_sde_hdbf_memmain_wx_t
#define bustype_BDK_TNS_SDE_HDBF_MEMMAIN_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_MEMMAIN_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_HDBF_MEMMAIN_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_MEMMAIN_WX(...) "TNS_SDE_HDBF_MEMMAIN_WX"


/**
 * NCB32b - tns_sde_hdbf_mre_budget
 *
 * Page budget for each channel.  When channel_count_mode is 1, this sets the page
 * budget
 * for the channel.  When channel_count_mode is 0, this is the saturation
 * value for
 * the request counter.
 */
typedef union bdk_tns_sde_hdbf_mre_budget {
	uint32_t u;
	struct bdk_tns_sde_hdbf_mre_budget_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ch0_budget                  : 8;  /**< R/W - MRE channel 0 budget */
#else
		uint32_t ch0_budget                  : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_mre_budget_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_mre_budget_s cn88xxp1; */
} bdk_tns_sde_hdbf_mre_budget_t;

#define BDK_TNS_SDE_HDBF_MRE_BUDGET BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_MRE_BUDGET_FUNC(void)
{
	return 0x0000842060780898ull;
}
#define typedef_BDK_TNS_SDE_HDBF_MRE_BUDGET bdk_tns_sde_hdbf_mre_budget_t
#define bustype_BDK_TNS_SDE_HDBF_MRE_BUDGET BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_MRE_BUDGET 0
#define arguments_BDK_TNS_SDE_HDBF_MRE_BUDGET -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_MRE_BUDGET "TNS_SDE_HDBF_MRE_BUDGET"


/**
 * NCB32b - tns_sde_hdbf_parser_budget
 *
 * Page budget for each channel.  When channel_count_mode is 1, this sets the page
 * budget
 * for the channel.  When channel_count_mode is 0, this is the saturation
 * value for
 * the request counter.
 */
typedef union bdk_tns_sde_hdbf_parser_budget {
	uint32_t u;
	struct bdk_tns_sde_hdbf_parser_budget_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ch0_budget                  : 8;  /**< R/W - Parser channel 0 budget */
#else
		uint32_t ch0_budget                  : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_parser_budget_s cn88xx; */
	/* struct bdk_tns_sde_hdbf_parser_budget_s cn88xxp1; */
} bdk_tns_sde_hdbf_parser_budget_t;

#define BDK_TNS_SDE_HDBF_PARSER_BUDGET BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_PARSER_BUDGET_FUNC(void)
{
	return 0x0000842060780894ull;
}
#define typedef_BDK_TNS_SDE_HDBF_PARSER_BUDGET bdk_tns_sde_hdbf_parser_budget_t
#define bustype_BDK_TNS_SDE_HDBF_PARSER_BUDGET BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_PARSER_BUDGET 0
#define arguments_BDK_TNS_SDE_HDBF_PARSER_BUDGET -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_PARSER_BUDGET "TNS_SDE_HDBF_PARSER_BUDGET"


/**
 * NCB32b - tns_sde_hdbf_req_cts
 *
 * Status counters for each requestor
 *
 */
typedef union bdk_tns_sde_hdbf_req_cts {
	uint32_t u;
	struct bdk_tns_sde_hdbf_req_cts_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t mre_req0                    : 8;  /**< RO/H - Requests outstanding from MRE for channel 3 */
		uint32_t par_req0                    : 8;  /**< RO/H - Requests outstanding from Parser for channel 3 */
#else
		uint32_t par_req0                    : 8;
		uint32_t mre_req0                    : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_req_cts_s  cn88xx; */
	/* struct bdk_tns_sde_hdbf_req_cts_s  cn88xxp1; */
} bdk_tns_sde_hdbf_req_cts_t;

#define BDK_TNS_SDE_HDBF_REQ_CTS BDK_TNS_SDE_HDBF_REQ_CTS_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_REQ_CTS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_REQ_CTS_FUNC(void)
{
	return 0x000084206078080Cull;
}
#define typedef_BDK_TNS_SDE_HDBF_REQ_CTS bdk_tns_sde_hdbf_req_cts_t
#define bustype_BDK_TNS_SDE_HDBF_REQ_CTS BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_REQ_CTS 0
#define arguments_BDK_TNS_SDE_HDBF_REQ_CTS -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_REQ_CTS "TNS_SDE_HDBF_REQ_CTS"


/**
 * NCB32b - tns_sde_hdbf_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_hdbf_spad {
	uint32_t u;
	struct bdk_tns_sde_hdbf_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_hdbf_spad_s     cn88xx; */
	/* struct bdk_tns_sde_hdbf_spad_s     cn88xxp1; */
} bdk_tns_sde_hdbf_spad_t;

#define BDK_TNS_SDE_HDBF_SPAD BDK_TNS_SDE_HDBF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_HDBF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_HDBF_SPAD_FUNC(void)
{
	return 0x00008420607808A0ull;
}
#define typedef_BDK_TNS_SDE_HDBF_SPAD bdk_tns_sde_hdbf_spad_t
#define bustype_BDK_TNS_SDE_HDBF_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_HDBF_SPAD 0
#define arguments_BDK_TNS_SDE_HDBF_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_HDBF_SPAD "TNS_SDE_HDBF_SPAD"


/**
 * NCB32b - tns_sde_isme_cfg_lm_lde#
 *
 * Config key_length_mode, lookup_bypass option, 4-b hash function sel, 3-b
 * mem_tile offset for each LDE
 */
typedef union bdk_tns_sde_isme_cfg_lm_ldex {
	uint32_t u;
	struct bdk_tns_sde_isme_cfg_lm_ldex_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t key_length_mode             : 1;  /**< R/W - -- */
		uint32_t key_mask                    : 16; /**< R/W - -- */
		uint32_t left_hash_sel               : 4;  /**< R/W - -- */
		uint32_t right_hash_sel              : 4;  /**< R/W - -- */
		uint32_t tile_offset                 : 3;  /**< R/W - -- */
#else
		uint32_t tile_offset                 : 3;
		uint32_t right_hash_sel              : 4;
		uint32_t left_hash_sel               : 4;
		uint32_t key_mask                    : 16;
		uint32_t key_length_mode             : 1;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_sde_isme_cfg_lm_ldex_s cn88xx; */
	/* struct bdk_tns_sde_isme_cfg_lm_ldex_s cn88xxp1; */
} bdk_tns_sde_isme_cfg_lm_ldex_t;

static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_LDEX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_LDEX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x0000842060080008ull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_ISME_CFG_LM_LDEX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_CFG_LM_LDEX(...) bdk_tns_sde_isme_cfg_lm_ldex_t
#define bustype_BDK_TNS_SDE_ISME_CFG_LM_LDEX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_CFG_LM_LDEX(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_CFG_LM_LDEX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_CFG_LM_LDEX(...) "TNS_SDE_ISME_CFG_LM_LDEX"


/**
 * NCB32b - tns_sde_isme_cfg_lm_tile
 *
 * Config key_length_mode for each memory tile - THIS REGISTER IS NOT USED. ONLY
 * PRESENT FOR SW/ENV COMPATIBILITY
 */
typedef union bdk_tns_sde_isme_cfg_lm_tile {
	uint32_t u;
	struct bdk_tns_sde_isme_cfg_lm_tile_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t key_length_mode             : 1;  /**< R/W - -- */
		uint32_t lde_mask                    : 4;  /**< R/W - -- */
#else
		uint32_t lde_mask                    : 4;
		uint32_t key_length_mode             : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_isme_cfg_lm_tile_s cn88xx; */
	/* struct bdk_tns_sde_isme_cfg_lm_tile_s cn88xxp1; */
} bdk_tns_sde_isme_cfg_lm_tile_t;

#define BDK_TNS_SDE_ISME_CFG_LM_TILE BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_CFG_LM_TILE_FUNC(void)
{
	return 0x0000842060080018ull;
}
#define typedef_BDK_TNS_SDE_ISME_CFG_LM_TILE bdk_tns_sde_isme_cfg_lm_tile_t
#define bustype_BDK_TNS_SDE_ISME_CFG_LM_TILE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_CFG_LM_TILE 0
#define arguments_BDK_TNS_SDE_ISME_CFG_LM_TILE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_CFG_LM_TILE "TNS_SDE_ISME_CFG_LM_TILE"


/**
 * NCB32b - tns_sde_isme_ecc_ctl_cd
 *
 * --
 *
 */
typedef union bdk_tns_sde_isme_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_isme_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t left_mem                    : 1;  /**< R/W - -- */
		uint32_t right_mem                   : 1;  /**< R/W - -- */
#else
		uint32_t right_mem                   : 1;
		uint32_t left_mem                    : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_isme_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_isme_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_isme_ecc_ctl_cd_t;

#define BDK_TNS_SDE_ISME_ECC_CTL_CD BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_CD_FUNC(void)
{
	return 0x0000842060080000ull;
}
#define typedef_BDK_TNS_SDE_ISME_ECC_CTL_CD bdk_tns_sde_isme_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_ISME_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_ISME_ECC_CTL_CD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_ECC_CTL_CD "TNS_SDE_ISME_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_isme_ecc_ctl_flp
 *
 * --
 *
 */
typedef union bdk_tns_sde_isme_ecc_ctl_flp {
	uint32_t u;
	struct bdk_tns_sde_isme_ecc_ctl_flp_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t left_sb_ecc                 : 3;  /**< R/W - -- */
		uint32_t left_db_ecc                 : 3;  /**< R/W - -- */
		uint32_t right_sb_ecc                : 3;  /**< R/W - -- */
		uint32_t right_db_ecc                : 3;  /**< R/W - -- */
#else
		uint32_t right_db_ecc                : 3;
		uint32_t right_sb_ecc                : 3;
		uint32_t left_db_ecc                 : 3;
		uint32_t left_sb_ecc                 : 3;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_isme_ecc_ctl_flp_s cn88xx; */
	/* struct bdk_tns_sde_isme_ecc_ctl_flp_s cn88xxp1; */
} bdk_tns_sde_isme_ecc_ctl_flp_t;

#define BDK_TNS_SDE_ISME_ECC_CTL_FLP BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_ECC_CTL_FLP_FUNC(void)
{
	return 0x0000842060080004ull;
}
#define typedef_BDK_TNS_SDE_ISME_ECC_CTL_FLP bdk_tns_sde_isme_ecc_ctl_flp_t
#define bustype_BDK_TNS_SDE_ISME_ECC_CTL_FLP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_ECC_CTL_FLP 0
#define arguments_BDK_TNS_SDE_ISME_ECC_CTL_FLP -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_ECC_CTL_FLP "TNS_SDE_ISME_ECC_CTL_FLP"


/**
 * NCB - tns_sde_isme_lm_tile_lmem#_w0
 *
 * 8 left mems
 * Each entry of the left mem contains 2 keys and 2 data items.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w0 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_lmemx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t dataa_and_keya              : 64; /**< R/W - -- */
#else
		uint64_t dataa_and_keya              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w0_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w0_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_lmemx_w0_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060000000ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(...) bdk_tns_sde_isme_lm_tile_lmemx_w0_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W0(...) "TNS_SDE_ISME_LM_TILE_LMEMX_W0"


/**
 * NCB - tns_sde_isme_lm_tile_lmem#_w1
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w1 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_lmemx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t dataa_and_keya              : 64; /**< R/W - Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else
		uint64_t dataa_and_keya              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w1_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w1_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_lmemx_w1_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060000008ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(...) bdk_tns_sde_isme_lm_tile_lmemx_w1_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W1(...) "TNS_SDE_ISME_LM_TILE_LMEMX_W1"


/**
 * NCB - tns_sde_isme_lm_tile_lmem#_w2
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w2 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_lmemx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 32; /**< R/W - -- */
		uint64_t dataa_and_keya              : 32; /**< R/W - Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else
		uint64_t dataa_and_keya              : 32;
		uint64_t datab_and_keyb              : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w2_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w2_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_lmemx_w2_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060000010ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(...) bdk_tns_sde_isme_lm_tile_lmemx_w2_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W2(...) "TNS_SDE_ISME_LM_TILE_LMEMX_W2"


/**
 * NCB - tns_sde_isme_lm_tile_lmem#_w3
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w3 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_lmemx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 64; /**< R/W - Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else
		uint64_t datab_and_keyb              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w3_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w3_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_lmemx_w3_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060000018ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(...) bdk_tns_sde_isme_lm_tile_lmemx_w3_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W3(...) "TNS_SDE_ISME_LM_TILE_LMEMX_W3"


/**
 * NCB - tns_sde_isme_lm_tile_lmem#_w4
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_LMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_lmemx_w4 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_lmemx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 64; /**< R/W - Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else
		uint64_t datab_and_keyb              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w4_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_lmemx_w4_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_lmemx_w4_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060000020ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(...) bdk_tns_sde_isme_lm_tile_lmemx_w4_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_LMEMX_W4(...) "TNS_SDE_ISME_LM_TILE_LMEMX_W4"


/**
 * NCB - tns_sde_isme_lm_tile_rmem#_w0
 *
 * 8 right mems
 * Each entry of the right mem contains 2 keys and 2 data items.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w0 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_rmemx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t dataa_and_keya              : 64; /**< R/W - -- */
#else
		uint64_t dataa_and_keya              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w0_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w0_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_rmemx_w0_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060040000ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(...) bdk_tns_sde_isme_lm_tile_rmemx_w0_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W0(...) "TNS_SDE_ISME_LM_TILE_RMEMX_W0"


/**
 * NCB - tns_sde_isme_lm_tile_rmem#_w1
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w1 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_rmemx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t dataa_and_keya              : 64; /**< R/W - Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else
		uint64_t dataa_and_keya              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w1_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w1_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_rmemx_w1_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060040008ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(...) bdk_tns_sde_isme_lm_tile_rmemx_w1_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W1(...) "TNS_SDE_ISME_LM_TILE_RMEMX_W1"


/**
 * NCB - tns_sde_isme_lm_tile_rmem#_w2
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w2 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_rmemx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 32; /**< R/W - -- */
		uint64_t dataa_and_keya              : 32; /**< R/W - Continuation of MSBs of field DATAA_AND_KEYA from previous word. */
#else
		uint64_t dataa_and_keya              : 32;
		uint64_t datab_and_keyb              : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w2_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w2_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_rmemx_w2_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060040010ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(...) bdk_tns_sde_isme_lm_tile_rmemx_w2_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W2(...) "TNS_SDE_ISME_LM_TILE_RMEMX_W2"


/**
 * NCB - tns_sde_isme_lm_tile_rmem#_w3
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w3 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_rmemx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 64; /**< R/W - Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else
		uint64_t datab_and_keyb              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w3_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w3_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_rmemx_w3_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060040018ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(...) bdk_tns_sde_isme_lm_tile_rmemx_w3_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W3(...) "TNS_SDE_ISME_LM_TILE_RMEMX_W3"


/**
 * NCB - tns_sde_isme_lm_tile_rmem#_w4
 *
 * Continuation of structure defined in TNS_SDE_ISME_LM_TILE_RMEM(0..4095)_W0
 *
 */
typedef union bdk_tns_sde_isme_lm_tile_rmemx_w4 {
	uint64_t u;
	struct bdk_tns_sde_isme_lm_tile_rmemx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t datab_and_keyb              : 64; /**< R/W - Continuation of MSBs of field DATAB_AND_KEYB from previous word. */
#else
		uint64_t datab_and_keyb              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w4_s cn88xx; */
	/* struct bdk_tns_sde_isme_lm_tile_rmemx_w4_s cn88xxp1; */
} bdk_tns_sde_isme_lm_tile_rmemx_w4_t;

static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(unsigned long param1)
{
	if (((param1 <= 4095)))
		return 0x0000842060040020ull + (param1 & 4095) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(...) bdk_tns_sde_isme_lm_tile_rmemx_w4_t
#define bustype_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LM_TILE_RMEMX_W4(...) "TNS_SDE_ISME_LM_TILE_RMEMX_W4"


/**
 * NCB32b - tns_sde_isme_lmkl_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_isme_lmkl_lock {
	uint32_t u;
	struct bdk_tns_sde_isme_lmkl_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_lmkl_lock_s cn88xx; */
	/* struct bdk_tns_sde_isme_lmkl_lock_s cn88xxp1; */
} bdk_tns_sde_isme_lmkl_lock_t;

#define BDK_TNS_SDE_ISME_LMKL_LOCK BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_LMKL_LOCK_FUNC(void)
{
	return 0x000084206008002Cull;
}
#define typedef_BDK_TNS_SDE_ISME_LMKL_LOCK bdk_tns_sde_isme_lmkl_lock_t
#define bustype_BDK_TNS_SDE_ISME_LMKL_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_LMKL_LOCK 0
#define arguments_BDK_TNS_SDE_ISME_LMKL_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_LMKL_LOCK "TNS_SDE_ISME_LMKL_LOCK"


/**
 * NCB32b - tns_sde_isme_rt_cfg_dbg_sel
 *
 * Select debug data for isme__dbg_data_out to the top
 *
 */
typedef union bdk_tns_sde_isme_rt_cfg_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_cfg_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - -- */
		uint32_t field_b                     : 8;  /**< R/W - -- */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_cfg_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_cfg_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_isme_rt_cfg_dbg_sel_t;

#define BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL_FUNC(void)
{
	return 0x0000842060100044ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL bdk_tns_sde_isme_rt_cfg_dbg_sel_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL 0
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_CFG_DBG_SEL "TNS_SDE_ISME_RT_CFG_DBG_SEL"


/**
 * NCB32b - tns_sde_isme_rt_cfg_mtrt#
 *
 * 1 shared MTRT for all input lanes.
 * The MTRT has 4 entries; each entry has 8 bit engine_id, a 2-bit output
 * link mask
 * representing the two LDEs, plus two lm_sel fields, one for each of the
 * LDEs. This field is used to select the local memory configuration to
 * be used for each of the lookups.
 */
typedef union bdk_tns_sde_isme_rt_cfg_mtrtx {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_cfg_mtrtx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t engine_id                   : 8;  /**< R/W - -- */
		uint32_t output_link_mask            : 2;  /**< R/W - -- */
		uint32_t lm_sel0                     : 2;  /**< R/W - -- */
		uint32_t lm_sel1                     : 2;  /**< R/W - -- */
#else
		uint32_t lm_sel1                     : 2;
		uint32_t lm_sel0                     : 2;
		uint32_t output_link_mask            : 2;
		uint32_t engine_id                   : 8;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_cfg_mtrtx_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_cfg_mtrtx_s cn88xxp1; */
} bdk_tns_sde_isme_rt_cfg_mtrtx_t;

static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_MTRTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_MTRTX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x0000842060100020ull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_ISME_RT_CFG_MTRTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(...) bdk_tns_sde_isme_rt_cfg_mtrtx_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_CFG_MTRTX(...) "TNS_SDE_ISME_RT_CFG_MTRTX"


/**
 * NCB32b - tns_sde_isme_rt_cfg_utrt#
 *
 * --
 *
 */
typedef union bdk_tns_sde_isme_rt_cfg_utrtx {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_cfg_utrtx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t engine_id                   : 8;  /**< R/W - -- */
		uint32_t link_id                     : 2;  /**< R/W - -- */
		uint32_t lm_sel                      : 2;  /**< R/W - -- */
#else
		uint32_t lm_sel                      : 2;
		uint32_t link_id                     : 2;
		uint32_t engine_id                   : 8;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_cfg_utrtx_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_cfg_utrtx_s cn88xxp1; */
} bdk_tns_sde_isme_rt_cfg_utrtx_t;

static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_UTRTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_CFG_UTRTX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842060100000ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_ISME_RT_CFG_UTRTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(...) bdk_tns_sde_isme_rt_cfg_utrtx_t
#define bustype_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(p1) (p1)
#define arguments_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_CFG_UTRTX(...) "TNS_SDE_ISME_RT_CFG_UTRTX"


/**
 * NCB32b - tns_sde_isme_rt_dbg_cptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_isme_rt_dbg_cptr {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_dbg_cptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_dbg_cptr_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_dbg_cptr_s cn88xxp1; */
} bdk_tns_sde_isme_rt_dbg_cptr_t;

#define BDK_TNS_SDE_ISME_RT_DBG_CPTR BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DBG_CPTR_FUNC(void)
{
	return 0x0000842060100048ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_DBG_CPTR bdk_tns_sde_isme_rt_dbg_cptr_t
#define bustype_BDK_TNS_SDE_ISME_RT_DBG_CPTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_DBG_CPTR 0
#define arguments_BDK_TNS_SDE_ISME_RT_DBG_CPTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_DBG_CPTR "TNS_SDE_ISME_RT_DBG_CPTR"


/**
 * NCB32b - tns_sde_isme_rt_dr_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_rt_dr_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_dr_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;  /**< R/W - -- */
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;  /**< R/W - -- */
#else
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_dr_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_dr_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_isme_rt_dr_int_en_hi_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI_FUNC(void)
{
	return 0x0000842060100038ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI bdk_tns_sde_isme_rt_dr_int_en_hi_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_EN_HI "TNS_SDE_ISME_RT_DR_INT_EN_HI"


/**
 * NCB32b - tns_sde_isme_rt_dr_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_rt_dr_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_dr_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;  /**< R/W - -- */
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;  /**< R/W - -- */
#else
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_dr_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_dr_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_isme_rt_dr_int_en_lo_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO_FUNC(void)
{
	return 0x000084206010003Cull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO bdk_tns_sde_isme_rt_dr_int_en_lo_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_EN_LO "TNS_SDE_ISME_RT_DR_INT_EN_LO"


/**
 * NCB32b - tns_sde_isme_rt_dr_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_rt_dr_int_frc {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_dr_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;  /**< WO - -- */
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;  /**< WO - -- */
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;  /**< WO - -- */
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;  /**< WO - -- */
#else
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_dr_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_dr_int_frc_s cn88xxp1; */
} bdk_tns_sde_isme_rt_dr_int_frc_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_FRC BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_FRC_FUNC(void)
{
	return 0x0000842060100040ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_FRC bdk_tns_sde_isme_rt_dr_int_frc_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_FRC 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_FRC "TNS_SDE_ISME_RT_DR_INT_FRC"


/**
 * NCB32b - tns_sde_isme_rt_dr_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_rt_dr_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_dr_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;  /**< R/W1C/H - -- */
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;  /**< R/W1C/H - -- */
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;  /**< R/W1C/H - -- */
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;  /**< R/W1C/H - -- */
#else
		uint32_t ismep0_isme_ln0_dfc_rx_ovfl : 1;
		uint32_t ismep1_isme_ch0_dfc_rx_ovfl : 1;
		uint32_t lde0_isme_dfc_rx_ovfl       : 1;
		uint32_t lde1_isme_dfc_rx_ovfl       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_dr_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_dr_int_w1c_s cn88xxp1; */
} bdk_tns_sde_isme_rt_dr_int_w1c_t;

#define BDK_TNS_SDE_ISME_RT_DR_INT_W1C BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_DR_INT_W1C_FUNC(void)
{
	return 0x0000842060100034ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_DR_INT_W1C bdk_tns_sde_isme_rt_dr_int_w1c_t
#define bustype_BDK_TNS_SDE_ISME_RT_DR_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_DR_INT_W1C 0
#define arguments_BDK_TNS_SDE_ISME_RT_DR_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_DR_INT_W1C "TNS_SDE_ISME_RT_DR_INT_W1C"


/**
 * NCB32b - tns_sde_isme_rt_fw_mode
 *
 * --
 *
 */
typedef union bdk_tns_sde_isme_rt_fw_mode {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_fw_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_fw_mode_s cn88xx; */
	/* struct bdk_tns_sde_isme_rt_fw_mode_s cn88xxp1; */
} bdk_tns_sde_isme_rt_fw_mode_t;

#define BDK_TNS_SDE_ISME_RT_FW_MODE BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_FW_MODE_FUNC(void)
{
	return 0x0000842060100030ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_FW_MODE bdk_tns_sde_isme_rt_fw_mode_t
#define bustype_BDK_TNS_SDE_ISME_RT_FW_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_FW_MODE 0
#define arguments_BDK_TNS_SDE_ISME_RT_FW_MODE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_FW_MODE "TNS_SDE_ISME_RT_FW_MODE"


/**
 * NCB32b - tns_sde_isme_rt_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_isme_rt_lock {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_lock_s  cn88xx; */
	/* struct bdk_tns_sde_isme_rt_lock_s  cn88xxp1; */
} bdk_tns_sde_isme_rt_lock_t;

#define BDK_TNS_SDE_ISME_RT_LOCK BDK_TNS_SDE_ISME_RT_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_LOCK_FUNC(void)
{
	return 0x000084206010004Cull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_LOCK bdk_tns_sde_isme_rt_lock_t
#define bustype_BDK_TNS_SDE_ISME_RT_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_LOCK 0
#define arguments_BDK_TNS_SDE_ISME_RT_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_LOCK "TNS_SDE_ISME_RT_LOCK"


/**
 * NCB32b - tns_sde_isme_rt_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_isme_rt_spad {
	uint32_t u;
	struct bdk_tns_sde_isme_rt_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_rt_spad_s  cn88xx; */
	/* struct bdk_tns_sde_isme_rt_spad_s  cn88xxp1; */
} bdk_tns_sde_isme_rt_spad_t;

#define BDK_TNS_SDE_ISME_RT_SPAD BDK_TNS_SDE_ISME_RT_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_RT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_RT_SPAD_FUNC(void)
{
	return 0x0000842060100050ull;
}
#define typedef_BDK_TNS_SDE_ISME_RT_SPAD bdk_tns_sde_isme_rt_spad_t
#define bustype_BDK_TNS_SDE_ISME_RT_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_RT_SPAD 0
#define arguments_BDK_TNS_SDE_ISME_RT_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_RT_SPAD "TNS_SDE_ISME_RT_SPAD"


/**
 * NCB32b - tns_sde_isme_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_isme_spad {
	uint32_t u;
	struct bdk_tns_sde_isme_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_isme_spad_s     cn88xx; */
	/* struct bdk_tns_sde_isme_spad_s     cn88xxp1; */
} bdk_tns_sde_isme_spad_t;

#define BDK_TNS_SDE_ISME_SPAD BDK_TNS_SDE_ISME_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_SPAD_FUNC(void)
{
	return 0x0000842060080030ull;
}
#define typedef_BDK_TNS_SDE_ISME_SPAD bdk_tns_sde_isme_spad_t
#define bustype_BDK_TNS_SDE_ISME_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_SPAD 0
#define arguments_BDK_TNS_SDE_ISME_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_SPAD "TNS_SDE_ISME_SPAD"


/**
 * NCB32b - tns_sde_isme_tile_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_tile_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_isme_tile_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t left_mem_ecc_sb_err0        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_db_err0        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_sb_err1        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_db_err1        : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_sb_err0       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_db_err0       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_sb_err1       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_db_err1       : 3;  /**< R/W - -- */
#else
		uint32_t right_mem_ecc_db_err1       : 3;
		uint32_t right_mem_ecc_sb_err1       : 3;
		uint32_t right_mem_ecc_db_err0       : 3;
		uint32_t right_mem_ecc_sb_err0       : 3;
		uint32_t left_mem_ecc_db_err1        : 3;
		uint32_t left_mem_ecc_sb_err1        : 3;
		uint32_t left_mem_ecc_db_err0        : 3;
		uint32_t left_mem_ecc_sb_err0        : 3;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_isme_tile_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_isme_tile_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_isme_tile_int_en_hi_t;

#define BDK_TNS_SDE_ISME_TILE_INT_EN_HI BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_HI_FUNC(void)
{
	return 0x0000842060080020ull;
}
#define typedef_BDK_TNS_SDE_ISME_TILE_INT_EN_HI bdk_tns_sde_isme_tile_int_en_hi_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_TILE_INT_EN_HI "TNS_SDE_ISME_TILE_INT_EN_HI"


/**
 * NCB32b - tns_sde_isme_tile_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_tile_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_isme_tile_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t left_mem_ecc_sb_err0        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_db_err0        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_sb_err1        : 3;  /**< R/W - -- */
		uint32_t left_mem_ecc_db_err1        : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_sb_err0       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_db_err0       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_sb_err1       : 3;  /**< R/W - -- */
		uint32_t right_mem_ecc_db_err1       : 3;  /**< R/W - -- */
#else
		uint32_t right_mem_ecc_db_err1       : 3;
		uint32_t right_mem_ecc_sb_err1       : 3;
		uint32_t right_mem_ecc_db_err0       : 3;
		uint32_t right_mem_ecc_sb_err0       : 3;
		uint32_t left_mem_ecc_db_err1        : 3;
		uint32_t left_mem_ecc_sb_err1        : 3;
		uint32_t left_mem_ecc_db_err0        : 3;
		uint32_t left_mem_ecc_sb_err0        : 3;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_isme_tile_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_isme_tile_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_isme_tile_int_en_lo_t;

#define BDK_TNS_SDE_ISME_TILE_INT_EN_LO BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_EN_LO_FUNC(void)
{
	return 0x0000842060080024ull;
}
#define typedef_BDK_TNS_SDE_ISME_TILE_INT_EN_LO bdk_tns_sde_isme_tile_int_en_lo_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_TILE_INT_EN_LO "TNS_SDE_ISME_TILE_INT_EN_LO"


/**
 * NCB32b - tns_sde_isme_tile_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_tile_int_frc {
	uint32_t u;
	struct bdk_tns_sde_isme_tile_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t left_mem_ecc_sb_err0        : 3;  /**< WO - -- */
		uint32_t left_mem_ecc_db_err0        : 3;  /**< WO - -- */
		uint32_t left_mem_ecc_sb_err1        : 3;  /**< WO - -- */
		uint32_t left_mem_ecc_db_err1        : 3;  /**< WO - -- */
		uint32_t right_mem_ecc_sb_err0       : 3;  /**< WO - -- */
		uint32_t right_mem_ecc_db_err0       : 3;  /**< WO - -- */
		uint32_t right_mem_ecc_sb_err1       : 3;  /**< WO - -- */
		uint32_t right_mem_ecc_db_err1       : 3;  /**< WO - -- */
#else
		uint32_t right_mem_ecc_db_err1       : 3;
		uint32_t right_mem_ecc_sb_err1       : 3;
		uint32_t right_mem_ecc_db_err0       : 3;
		uint32_t right_mem_ecc_sb_err0       : 3;
		uint32_t left_mem_ecc_db_err1        : 3;
		uint32_t left_mem_ecc_sb_err1        : 3;
		uint32_t left_mem_ecc_db_err0        : 3;
		uint32_t left_mem_ecc_sb_err0        : 3;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_isme_tile_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_isme_tile_int_frc_s cn88xxp1; */
} bdk_tns_sde_isme_tile_int_frc_t;

#define BDK_TNS_SDE_ISME_TILE_INT_FRC BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_FRC_FUNC(void)
{
	return 0x0000842060080028ull;
}
#define typedef_BDK_TNS_SDE_ISME_TILE_INT_FRC bdk_tns_sde_isme_tile_int_frc_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_FRC 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_TILE_INT_FRC "TNS_SDE_ISME_TILE_INT_FRC"


/**
 * NCB32b - tns_sde_isme_tile_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_isme_tile_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_isme_tile_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t left_mem_ecc_sb_err0        : 3;  /**< R/W1C/H - -- */
		uint32_t left_mem_ecc_db_err0        : 3;  /**< R/W1C/H - -- */
		uint32_t left_mem_ecc_sb_err1        : 3;  /**< R/W1C/H - -- */
		uint32_t left_mem_ecc_db_err1        : 3;  /**< R/W1C/H - -- */
		uint32_t right_mem_ecc_sb_err0       : 3;  /**< R/W1C/H - -- */
		uint32_t right_mem_ecc_db_err0       : 3;  /**< R/W1C/H - -- */
		uint32_t right_mem_ecc_sb_err1       : 3;  /**< R/W1C/H - -- */
		uint32_t right_mem_ecc_db_err1       : 3;  /**< R/W1C/H - -- */
#else
		uint32_t right_mem_ecc_db_err1       : 3;
		uint32_t right_mem_ecc_sb_err1       : 3;
		uint32_t right_mem_ecc_db_err0       : 3;
		uint32_t right_mem_ecc_sb_err0       : 3;
		uint32_t left_mem_ecc_db_err1        : 3;
		uint32_t left_mem_ecc_sb_err1        : 3;
		uint32_t left_mem_ecc_db_err0        : 3;
		uint32_t left_mem_ecc_sb_err0        : 3;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_isme_tile_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_isme_tile_int_w1c_s cn88xxp1; */
} bdk_tns_sde_isme_tile_int_w1c_t;

#define BDK_TNS_SDE_ISME_TILE_INT_W1C BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_ISME_TILE_INT_W1C_FUNC(void)
{
	return 0x000084206008001Cull;
}
#define typedef_BDK_TNS_SDE_ISME_TILE_INT_W1C bdk_tns_sde_isme_tile_int_w1c_t
#define bustype_BDK_TNS_SDE_ISME_TILE_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_ISME_TILE_INT_W1C 0
#define arguments_BDK_TNS_SDE_ISME_TILE_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_ISME_TILE_INT_W1C "TNS_SDE_ISME_TILE_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_acmrh_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_acmrh_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_acmrh_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t merge_timeout               : 1;  /**< R/W - -- */
#else
		uint32_t merge_timeout               : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_acmrh_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_acmrh_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_acmrh_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207298ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(...) bdk_tns_sde_ldex_acmrh_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_HI(...) "TNS_SDE_LDEX_ACMRH_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_acmrh_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_acmrh_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_acmrh_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t merge_timeout               : 1;  /**< R/W - -- */
#else
		uint32_t merge_timeout               : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_acmrh_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_acmrh_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_acmrh_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020729Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(...) bdk_tns_sde_ldex_acmrh_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_EN_LO(...) "TNS_SDE_LDEX_ACMRH_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_acmrh_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_acmrh_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_acmrh_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t merge_timeout               : 1;  /**< WO - -- */
#else
		uint32_t merge_timeout               : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_acmrh_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_acmrh_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_acmrh_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072A0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_ACMRH_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(...) bdk_tns_sde_ldex_acmrh_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_FRC(...) "TNS_SDE_LDEX_ACMRH_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_acmrh_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_acmrh_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_acmrh_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t merge_timeout               : 1;  /**< R/W1C/H - -- */
#else
		uint32_t merge_timeout               : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_acmrh_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_acmrh_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_acmrh_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207294ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_ACMRH_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(...) bdk_tns_sde_ldex_acmrh_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_ACMRH_INT_W1C(...) "TNS_SDE_LDEX_ACMRH_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_bp_mode
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_bp_mode {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_bp_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_bp_mode_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_bp_mode_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_bp_mode_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207224ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(...) bdk_tns_sde_ldex_cfg_acm_bp_mode_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_BP_MODE(...) "TNS_SDE_LDEX_CFG_ACM_BP_MODE"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fmbm_en
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fmbm_en {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fmbm_en_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fmbm_en_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fmbm_en_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fmbm_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207228ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(...) bdk_tns_sde_ldex_cfg_acm_fmbm_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_EN(...) "TNS_SDE_LDEX_CFG_ACM_FMBM_EN"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fmbm_idx
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fmbm_idx {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fmbm_idx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t field                       : 4;  /**< R/W - -- */
#else
		uint32_t field                       : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fmbm_idx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fmbm_idx_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fmbm_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020722Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(...) bdk_tns_sde_ldex_cfg_acm_fmbm_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FMBM_IDX(...) "TNS_SDE_LDEX_CFG_ACM_FMBM_IDX"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fneng
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fneng {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fneng_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t field                       : 8;  /**< R/W - -- */
#else
		uint32_t field                       : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fneng_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fneng_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fneng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207244ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FNENG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(...) bdk_tns_sde_ldex_cfg_acm_fneng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FNENG(...) "TNS_SDE_LDEX_CFG_ACM_FNENG"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fpcmd_cp
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_cp {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207238ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(...) bdk_tns_sde_ldex_cfg_acm_fpcmd_cp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_CP(...) "TNS_SDE_LDEX_CFG_ACM_FPCMD_CP"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fpcmd_dp
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_dp {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207230ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(...) bdk_tns_sde_ldex_cfg_acm_fpcmd_dp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_DP(...) "TNS_SDE_LDEX_CFG_ACM_FPCMD_DP"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fpcmd_fw
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_fw {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207234ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(...) bdk_tns_sde_ldex_cfg_acm_fpcmd_fw_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_FW(...) "TNS_SDE_LDEX_CFG_ACM_FPCMD_FW"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_fpcmd_tr
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_fpcmd_tr {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020723Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(...) bdk_tns_sde_ldex_cfg_acm_fpcmd_tr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FPCMD_TR(...) "TNS_SDE_LDEX_CFG_ACM_FPCMD_TR"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_frcod
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_frcod {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_frcod_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t field                       : 10; /**< R/W - -- */
#else
		uint32_t field                       : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_frcod_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_frcod_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_frcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207240ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(...) bdk_tns_sde_ldex_cfg_acm_frcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_FRCOD(...) "TNS_SDE_LDEX_CFG_ACM_FRCOD"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_lane#
 *
 * ACM lane types: null, counting, policing or sampling
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_lanex {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_lanex_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t req_type                    : 2;  /**< R/W - -- */
#else
		uint32_t req_type                    : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_lanex_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_lanex_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_lanex_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 3)))
		return 0x0000842060207214ull + (param1 & 1) * 0x8000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_LANEX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(...) bdk_tns_sde_ldex_cfg_acm_lanex_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_LANEX(...) "TNS_SDE_LDEX_CFG_ACM_LANEX"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_to_cy
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_to_cy {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_to_cy_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field                       : 16; /**< R/W - -- */
#else
		uint32_t field                       : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_to_cy_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_to_cy_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_to_cy_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020720Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(...) bdk_tns_sde_ldex_cfg_acm_to_cy_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_TO_CY(...) "TNS_SDE_LDEX_CFG_ACM_TO_CY"


/**
 * NCB32b - tns_sde_lde#_cfg_acm_to_fw_en
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_acm_to_fw_en {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_acm_to_fw_en_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_acm_to_fw_en_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_acm_to_fw_en_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_acm_to_fw_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207210ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(...) bdk_tns_sde_ldex_cfg_acm_to_fw_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_ACM_TO_FW_EN(...) "TNS_SDE_LDEX_CFG_ACM_TO_FW_EN"


/**
 * NCB - tns_sde_lde#_cfg_kfit0#_w0
 *
 * KFIT_0
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit0x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit0x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206000ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(...) bdk_tns_sde_ldex_cfg_kfit0x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W0(...) "TNS_SDE_LDEX_CFG_KFIT0X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit0#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT0(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit0x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit0x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206008ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(...) bdk_tns_sde_ldex_cfg_kfit0x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W1(...) "TNS_SDE_LDEX_CFG_KFIT0X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit0#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT0(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit0x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit0x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit0x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit0x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206010ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(...) bdk_tns_sde_ldex_cfg_kfit0x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT0X_W2(...) "TNS_SDE_LDEX_CFG_KFIT0X_W2"


/**
 * NCB - tns_sde_lde#_cfg_kfit1#_w0
 *
 * KFIT_1
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit1x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit1x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206200ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(...) bdk_tns_sde_ldex_cfg_kfit1x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W0(...) "TNS_SDE_LDEX_CFG_KFIT1X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit1#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT1(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit1x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit1x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206208ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(...) bdk_tns_sde_ldex_cfg_kfit1x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W1(...) "TNS_SDE_LDEX_CFG_KFIT1X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit1#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT1(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit1x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit1x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit1x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit1x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206210ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(...) bdk_tns_sde_ldex_cfg_kfit1x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT1X_W2(...) "TNS_SDE_LDEX_CFG_KFIT1X_W2"


/**
 * NCB - tns_sde_lde#_cfg_kfit2#_w0
 *
 * KFIT_2
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit2x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit2x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206400ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(...) bdk_tns_sde_ldex_cfg_kfit2x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W0(...) "TNS_SDE_LDEX_CFG_KFIT2X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit2#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT2(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit2x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit2x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206408ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(...) bdk_tns_sde_ldex_cfg_kfit2x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W1(...) "TNS_SDE_LDEX_CFG_KFIT2X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit2#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT2(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit2x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit2x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit2x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit2x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206410ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(...) bdk_tns_sde_ldex_cfg_kfit2x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT2X_W2(...) "TNS_SDE_LDEX_CFG_KFIT2X_W2"


/**
 * NCB - tns_sde_lde#_cfg_kfit3#_w0
 *
 * KFIT_3
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit3x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit3x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206600ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(...) bdk_tns_sde_ldex_cfg_kfit3x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W0(...) "TNS_SDE_LDEX_CFG_KFIT3X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit3#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT3(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit3x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit3x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206608ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(...) bdk_tns_sde_ldex_cfg_kfit3x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W1(...) "TNS_SDE_LDEX_CFG_KFIT3X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit3#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT3(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit3x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit3x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit3x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit3x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206610ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(...) bdk_tns_sde_ldex_cfg_kfit3x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT3X_W2(...) "TNS_SDE_LDEX_CFG_KFIT3X_W2"


/**
 * NCB - tns_sde_lde#_cfg_kfit4#_w0
 *
 * KFIT_4
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit4x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit4x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206800ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(...) bdk_tns_sde_ldex_cfg_kfit4x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W0(...) "TNS_SDE_LDEX_CFG_KFIT4X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit4#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT4(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit4x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit4x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206808ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(...) bdk_tns_sde_ldex_cfg_kfit4x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W1(...) "TNS_SDE_LDEX_CFG_KFIT4X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit4#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT4(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit4x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit4x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit4x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit4x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206810ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(...) bdk_tns_sde_ldex_cfg_kfit4x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT4X_W2(...) "TNS_SDE_LDEX_CFG_KFIT4X_W2"


/**
 * NCB - tns_sde_lde#_cfg_kfit5#_w0
 *
 * KFIT_5
 * Bits[63:40] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit5x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst1           : 22; /**< R/W - -- */
		uint64_t se_superkey_inst0           : 42; /**< R/W - -- */
#else
		uint64_t se_superkey_inst0           : 42;
		uint64_t se_superkey_inst1           : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit5x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206A00ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(...) bdk_tns_sde_ldex_cfg_kfit5x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W0(...) "TNS_SDE_LDEX_CFG_KFIT5X_W0"


/**
 * NCB - tns_sde_lde#_cfg_kfit5#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT5(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit5x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_superkey_inst3           : 2;  /**< R/W - -- */
		uint64_t se_superkey_inst2           : 42; /**< R/W - -- */
		uint64_t se_superkey_inst1           : 20; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST1 from previous word. */
#else
		uint64_t se_superkey_inst1           : 20;
		uint64_t se_superkey_inst2           : 42;
		uint64_t se_superkey_inst3           : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit5x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206A08ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(...) bdk_tns_sde_ldex_cfg_kfit5x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W1(...) "TNS_SDE_LDEX_CFG_KFIT5X_W1"


/**
 * NCB - tns_sde_lde#_cfg_kfit5#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_KFIT5(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit5x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_kfit5x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t se_superkey_inst3           : 40; /**< R/W - Continuation of MSBs of field SE_SUPERKEY_INST3 from previous word. */
#else
		uint64_t se_superkey_inst3           : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit5x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit5x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206A10ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(...) bdk_tns_sde_ldex_cfg_kfit5x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT5X_W2(...) "TNS_SDE_LDEX_CFG_KFIT5X_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_kfit6#
 *
 * KFIT_6
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfit6x {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_kfit6x_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t se_profileid_inst           : 4;  /**< R/W - -- */
		uint32_t se_cmd_envec_inst           : 5;  /**< R/W - -- */
#else
		uint32_t se_cmd_envec_inst           : 5;
		uint32_t se_profileid_inst           : 4;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfit6x_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfit6x_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfit6x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT6X(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFIT6X(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060206C00ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFIT6X", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFIT6X(...) bdk_tns_sde_ldex_cfg_kfit6x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFIT6X(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFIT6X(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFIT6X(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFIT6X(...) "TNS_SDE_LDEX_CFG_KFIT6X"


/**
 * NCB32b - tns_sde_lde#_cfg_kfits_idx
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_kfits_idx {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_kfits_idx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_kfits_idx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_kfits_idx_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_kfits_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060206C40ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_KFITS_IDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(...) bdk_tns_sde_ldex_cfg_kfits_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_KFITS_IDX(...) "TNS_SDE_LDEX_CFG_KFITS_IDX"


/**
 * NCB32b - tns_sde_lde#_cfg_lde_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_lde_adr {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_lde_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t field                       : 8;  /**< R/W - -- */
#else
		uint32_t field                       : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_lde_adr_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_lde_adr_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_lde_adr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_ADR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_ADR(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207204ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_LDE_ADR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(...) bdk_tns_sde_ldex_cfg_lde_adr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_LDE_ADR(...) "TNS_SDE_LDEX_CFG_LDE_ADR"


/**
 * NCB32b - tns_sde_lde#_cfg_lde_type
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_lde_type {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_lde_type_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_lde_type_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_lde_type_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_lde_type_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207200ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_LDE_TYPE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(...) bdk_tns_sde_ldex_cfg_lde_type_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_LDE_TYPE(...) "TNS_SDE_LDEX_CFG_LDE_TYPE"


/**
 * NCB32b - tns_sde_lde#_cfg_ldea_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ldea_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ldea_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ldea_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ldea_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ldea_dbg_sel_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205044ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(...) bdk_tns_sde_ldex_cfg_ldea_dbg_sel_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_LDEA_DBG_SEL(...) "TNS_SDE_LDEX_CFG_LDEA_DBG_SEL"


/**
 * NCB32b - tns_sde_lde#_cfg_ldeb_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ldeb_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072C4ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(...) bdk_tns_sde_ldex_cfg_ldeb_dbg_sel_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_LDEB_DBG_SEL(...) "TNS_SDE_LDEX_CFG_LDEB_DBG_SEL"


/**
 * NCB32b - tns_sde_lde#_cfg_max_acm_reqs
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_max_acm_reqs {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_max_acm_reqs_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t field                       : 5;  /**< R/W - -- */
#else
		uint32_t field                       : 5;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_max_acm_reqs_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_max_acm_reqs_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_max_acm_reqs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207208ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(...) bdk_tns_sde_ldex_cfg_max_acm_reqs_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_MAX_ACM_REQS(...) "TNS_SDE_LDEX_CFG_MAX_ACM_REQS"


/**
 * NCB32b - tns_sde_lde#_cfg_max_se_reqs
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_max_se_reqs {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_max_se_reqs_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t field                       : 7;  /**< R/W - -- */
#else
		uint32_t field                       : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_max_se_reqs_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_max_se_reqs_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_max_se_reqs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205004ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(...) bdk_tns_sde_ldex_cfg_max_se_reqs_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_MAX_SE_REQS(...) "TNS_SDE_LDEX_CFG_MAX_SE_REQS"


/**
 * NCB32b - tns_sde_lde#_cfg_merge_mode
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_merge_mode {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_merge_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_merge_mode_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_merge_mode_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_merge_mode_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205000ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_MERGE_MODE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(...) bdk_tns_sde_ldex_cfg_merge_mode_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_MERGE_MODE(...) "TNS_SDE_LDEX_CFG_MERGE_MODE"


/**
 * NCB - tns_sde_lde#_cfg_ofit0#_w0
 *
 * OFIT_0
 * Bits[63:36] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit0x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_reasoncode_inst       : 3;  /**< R/W - -- */
		uint64_t token_filtergrpnumber_inst  : 20; /**< R/W - -- */
		uint64_t token_txq_sel_inst          : 28; /**< R/W - -- */
		uint64_t token_nextengine_inst       : 9;  /**< R/W - -- */
		uint64_t token_slavelanesel_inst     : 4;  /**< R/W - -- */
#else
		uint64_t token_slavelanesel_inst     : 4;
		uint64_t token_nextengine_inst       : 9;
		uint64_t token_txq_sel_inst          : 28;
		uint64_t token_filtergrpnumber_inst  : 20;
		uint64_t token_reasoncode_inst       : 3;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit0x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200800ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(...) bdk_tns_sde_ldex_cfg_ofit0x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W0(...) "TNS_SDE_LDEX_CFG_OFIT0X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit0#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT0(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit0x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_egressvif_inst        : 10; /**< R/W - -- */
		uint64_t token_ecmpsize_inst         : 24; /**< R/W - -- */
		uint64_t token_reasoncode_inst       : 30; /**< R/W - Continuation of MSBs of field TOKEN_REASONCODE_INST from previous word. */
#else
		uint64_t token_reasoncode_inst       : 30;
		uint64_t token_ecmpsize_inst         : 24;
		uint64_t token_egressvif_inst        : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit0x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200808ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(...) bdk_tns_sde_ldex_cfg_ofit0x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W1(...) "TNS_SDE_LDEX_CFG_OFIT0X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit0#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT0(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit0x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit0x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t token_pktcmd_inst           : 14; /**< R/W - -- */
		uint64_t token_egressvif_inst        : 22; /**< R/W - Continuation of MSBs of field TOKEN_EGRESSVIF_INST from previous word. */
#else
		uint64_t token_egressvif_inst        : 22;
		uint64_t token_pktcmd_inst           : 14;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit0x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit0x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200810ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(...) bdk_tns_sde_ldex_cfg_ofit0x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT0X_W2(...) "TNS_SDE_LDEX_CFG_OFIT0X_W2"


/**
 * NCB - tns_sde_lde#_cfg_ofit1#
 *
 * OFIT_1
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit1x {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit1x_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_52_63              : 12;
		uint64_t token_ingressvif_inst       : 32; /**< R/W - -- */
		uint64_t token_firstvldlayer_inst    : 16; /**< R/W - -- */
		uint64_t token_hashselect_inst       : 2;  /**< R/W - -- */
		uint64_t token_tt_inst               : 2;  /**< R/W - -- */
#else
		uint64_t token_tt_inst               : 2;
		uint64_t token_hashselect_inst       : 2;
		uint64_t token_firstvldlayer_inst    : 16;
		uint64_t token_ingressvif_inst       : 32;
		uint64_t reserved_52_63              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit1x_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit1x_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit1x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT1X(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT1X(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060202000ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT1X", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT1X(...) bdk_tns_sde_ldex_cfg_ofit1x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT1X(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT1X(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT1X(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT1X(...) "TNS_SDE_LDEX_CFG_OFIT1X"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit2#
 *
 * OFIT_2
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit2x {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit2x_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t token_mir_bm_inst           : 18; /**< R/W - -- */
#else
		uint32_t token_mir_bm_inst           : 18;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit2x_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit2x_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit2x_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT2X(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT2X(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060202100ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT2X", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT2X(...) bdk_tns_sde_ldex_cfg_ofit2x_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT2X(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT2X(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT2X(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT2X(...) "TNS_SDE_LDEX_CFG_OFIT2X"


/**
 * NCB - tns_sde_lde#_cfg_ofit3#_w0
 *
 * OFIT_3
 * Bits[63:39] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit3x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit3x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_pcp_inst              : 12; /**< R/W - -- */
		uint64_t token_dei_inst              : 15; /**< R/W - -- */
		uint64_t token_dscp_inst             : 20; /**< R/W - -- */
		uint64_t token_exp_inst              : 17; /**< R/W - -- */
#else
		uint64_t token_exp_inst              : 17;
		uint64_t token_dscp_inst             : 20;
		uint64_t token_dei_inst              : 15;
		uint64_t token_pcp_inst              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit3x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit3x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit3x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201C00ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(...) bdk_tns_sde_ldex_cfg_ofit3x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W0(...) "TNS_SDE_LDEX_CFG_OFIT3X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit3#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT3(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit3x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit3x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_39_63              : 25;
		uint64_t token_dp_inst               : 16; /**< R/W - -- */
		uint64_t token_tc_inst               : 18; /**< R/W - -- */
		uint64_t token_pcp_inst              : 5;  /**< R/W - Continuation of MSBs of field TOKEN_PCP_INST from previous word. */
#else
		uint64_t token_pcp_inst              : 5;
		uint64_t token_tc_inst               : 18;
		uint64_t token_dp_inst               : 16;
		uint64_t reserved_39_63              : 25;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit3x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit3x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit3x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201C08ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(...) bdk_tns_sde_ldex_cfg_ofit3x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT3X_W1(...) "TNS_SDE_LDEX_CFG_OFIT3X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit4#_w0
 *
 * OFIT_4
 * Bits[63:53] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit4x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_rewrptr3_inst         : 4;  /**< R/W - -- */
		uint64_t token_rewrptr2_inst         : 20; /**< R/W - -- */
		uint64_t token_rewrptr1_inst         : 20; /**< R/W - -- */
		uint64_t token_rewrptr0_inst         : 20; /**< R/W - -- */
#else
		uint64_t token_rewrptr0_inst         : 20;
		uint64_t token_rewrptr1_inst         : 20;
		uint64_t token_rewrptr2_inst         : 20;
		uint64_t token_rewrptr3_inst         : 4;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit4x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200C00ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(...) bdk_tns_sde_ldex_cfg_ofit4x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W0(...) "TNS_SDE_LDEX_CFG_OFIT4X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit4#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT4(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit4x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_rewrptr6_inst         : 8;  /**< R/W - -- */
		uint64_t token_rewrptr5_inst         : 20; /**< R/W - -- */
		uint64_t token_rewrptr4_inst         : 20; /**< R/W - -- */
		uint64_t token_rewrptr3_inst         : 16; /**< R/W - Continuation of MSBs of field TOKEN_REWRITEPTR3_INST from previous word. */
#else
		uint64_t token_rewrptr3_inst         : 16;
		uint64_t token_rewrptr4_inst         : 20;
		uint64_t token_rewrptr5_inst         : 20;
		uint64_t token_rewrptr6_inst         : 8;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit4x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200C08ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(...) bdk_tns_sde_ldex_cfg_ofit4x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W1(...) "TNS_SDE_LDEX_CFG_OFIT4X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit4#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT4(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit4x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit4x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_53_63              : 11;
		uint64_t token_rewritept6isins_inst  : 2;  /**< R/W - -- */
		uint64_t token_insertptr22_16_inst   : 19; /**< R/W - -- */
		uint64_t token_rewrptr7_inst         : 20; /**< R/W - -- */
		uint64_t token_rewrptr6_inst         : 12; /**< R/W - Continuation of MSBs of field TOKEN_REWRITEPTR6_INST from previous word. */
#else
		uint64_t token_rewrptr6_inst         : 12;
		uint64_t token_rewrptr7_inst         : 20;
		uint64_t token_insertptr22_16_inst   : 19;
		uint64_t token_rewritept6isins_inst  : 2;
		uint64_t reserved_53_63              : 11;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit4x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit4x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200C10ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(...) bdk_tns_sde_ldex_cfg_ofit4x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT4X_W2(...) "TNS_SDE_LDEX_CFG_OFIT4X_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w0
 *
 * OFIT_5
 * Bits[31:8] in _W[10] are unused.
 * When writing, the MSBs (word 10) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst0      : 32; /**< R/W - -- */
#else
		uint32_t token_scratchpad_inst0      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200000ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(...) bdk_tns_sde_ldex_cfg_ofit5x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W0(...) "TNS_SDE_LDEX_CFG_OFIT5X_W0"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst1      : 2;  /**< R/W - -- */
		uint32_t token_scratchpad_inst0      : 30; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST0 from previous word. */
#else
		uint32_t token_scratchpad_inst0      : 30;
		uint32_t token_scratchpad_inst1      : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200004ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(...) bdk_tns_sde_ldex_cfg_ofit5x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W1(...) "TNS_SDE_LDEX_CFG_OFIT5X_W1"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w10
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w10 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w10_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t token_scratchpad_inst7      : 8;  /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST7 from previous word. */
#else
		uint32_t token_scratchpad_inst7      : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w10_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w10_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w10_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200028ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(...) bdk_tns_sde_ldex_cfg_ofit5x_w10_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W10(...) "TNS_SDE_LDEX_CFG_OFIT5X_W10"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst1      : 32; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
#else
		uint32_t token_scratchpad_inst1      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200008ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(...) bdk_tns_sde_ldex_cfg_ofit5x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W2(...) "TNS_SDE_LDEX_CFG_OFIT5X_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w3
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w3 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst2      : 28; /**< R/W - -- */
		uint32_t token_scratchpad_inst1      : 4;  /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST1 from previous word. */
#else
		uint32_t token_scratchpad_inst1      : 4;
		uint32_t token_scratchpad_inst2      : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w3_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w3_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x000084206020000Cull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(...) bdk_tns_sde_ldex_cfg_ofit5x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W3(...) "TNS_SDE_LDEX_CFG_OFIT5X_W3"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w4
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w4 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst3      : 22; /**< R/W - -- */
		uint32_t token_scratchpad_inst2      : 10; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST2 from previous word. */
#else
		uint32_t token_scratchpad_inst2      : 10;
		uint32_t token_scratchpad_inst3      : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w4_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w4_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200010ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(...) bdk_tns_sde_ldex_cfg_ofit5x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W4(...) "TNS_SDE_LDEX_CFG_OFIT5X_W4"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w5
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w5 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst4      : 16; /**< R/W - -- */
		uint32_t token_scratchpad_inst3      : 16; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST3 from previous word. */
#else
		uint32_t token_scratchpad_inst3      : 16;
		uint32_t token_scratchpad_inst4      : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w5_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w5_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w5_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200014ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(...) bdk_tns_sde_ldex_cfg_ofit5x_w5_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W5(...) "TNS_SDE_LDEX_CFG_OFIT5X_W5"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w6
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w6 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst5      : 10; /**< R/W - -- */
		uint32_t token_scratchpad_inst4      : 22; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST4 from previous word. */
#else
		uint32_t token_scratchpad_inst4      : 22;
		uint32_t token_scratchpad_inst5      : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w6_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w6_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w6_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200018ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(...) bdk_tns_sde_ldex_cfg_ofit5x_w6_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W6(...) "TNS_SDE_LDEX_CFG_OFIT5X_W6"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w7
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w7 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst6      : 4;  /**< R/W - -- */
		uint32_t token_scratchpad_inst5      : 28; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST5 from previous word. */
#else
		uint32_t token_scratchpad_inst5      : 28;
		uint32_t token_scratchpad_inst6      : 4;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w7_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w7_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w7_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x000084206020001Cull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(...) bdk_tns_sde_ldex_cfg_ofit5x_w7_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W7(...) "TNS_SDE_LDEX_CFG_OFIT5X_W7"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w8
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w8 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w8_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst6      : 32; /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
#else
		uint32_t token_scratchpad_inst6      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w8_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w8_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w8_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200020ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(...) bdk_tns_sde_ldex_cfg_ofit5x_w8_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W8(...) "TNS_SDE_LDEX_CFG_OFIT5X_W8"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit5#_w9
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT5(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit5x_w9 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit5x_w9_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_scratchpad_inst7      : 30; /**< R/W - -- */
		uint32_t token_scratchpad_inst6      : 2;  /**< R/W - Continuation of MSBs of field TOKEN_SCRATCHPAD_INST6 from previous word. */
#else
		uint32_t token_scratchpad_inst6      : 2;
		uint32_t token_scratchpad_inst7      : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w9_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit5x_w9_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit5x_w9_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060200024ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(...) bdk_tns_sde_ldex_cfg_ofit5x_w9_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT5X_W9(...) "TNS_SDE_LDEX_CFG_OFIT5X_W9"


/**
 * NCB - tns_sde_lde#_cfg_ofit6#_w0
 *
 * OFIT_6
 * Bits[63:48] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit6x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_layers_inst1          : 20; /**< R/W - -- */
		uint64_t token_layers_inst0          : 44; /**< R/W - -- */
#else
		uint64_t token_layers_inst0          : 44;
		uint64_t token_layers_inst1          : 20;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit6x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201000ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(...) bdk_tns_sde_ldex_cfg_ofit6x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W0(...) "TNS_SDE_LDEX_CFG_OFIT6X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit6#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT6(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit6x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_layers_inst2          : 40; /**< R/W - -- */
		uint64_t token_layers_inst1          : 24; /**< R/W - Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
#else
		uint64_t token_layers_inst1          : 24;
		uint64_t token_layers_inst2          : 40;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit6x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201008ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(...) bdk_tns_sde_ldex_cfg_ofit6x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W1(...) "TNS_SDE_LDEX_CFG_OFIT6X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit6#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT6(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit6x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit6x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_48_63              : 16;
		uint64_t token_layers_inst3          : 44; /**< R/W - -- */
		uint64_t token_layers_inst2          : 4;  /**< R/W - Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
#else
		uint64_t token_layers_inst2          : 4;
		uint64_t token_layers_inst3          : 44;
		uint64_t reserved_48_63              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit6x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit6x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201010ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(...) bdk_tns_sde_ldex_cfg_ofit6x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT6X_W2(...) "TNS_SDE_LDEX_CFG_OFIT6X_W2"


/**
 * NCB - tns_sde_lde#_cfg_ofit7#_w0
 *
 * OFIT_7
 * Bits[63:48] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit7x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_layers_inst1          : 20; /**< R/W - -- */
		uint64_t token_layers_inst0          : 44; /**< R/W - -- */
#else
		uint64_t token_layers_inst0          : 44;
		uint64_t token_layers_inst1          : 20;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit7x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201400ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(...) bdk_tns_sde_ldex_cfg_ofit7x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W0(...) "TNS_SDE_LDEX_CFG_OFIT7X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit7#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT7(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit7x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token_layers_inst2          : 40; /**< R/W - -- */
		uint64_t token_layers_inst1          : 24; /**< R/W - Continuation of MSBs of field TOKEN_LAYERS_INST1 from previous word. */
#else
		uint64_t token_layers_inst1          : 24;
		uint64_t token_layers_inst2          : 40;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit7x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201408ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(...) bdk_tns_sde_ldex_cfg_ofit7x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W1(...) "TNS_SDE_LDEX_CFG_OFIT7X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit7#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT7(0..31)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit7x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit7x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_48_63              : 16;
		uint64_t token_layers_inst3          : 44; /**< R/W - -- */
		uint64_t token_layers_inst2          : 4;  /**< R/W - Continuation of MSBs of field TOKEN_LAYERS_INST2 from previous word. */
#else
		uint64_t token_layers_inst2          : 4;
		uint64_t token_layers_inst3          : 44;
		uint64_t reserved_48_63              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit7x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit7x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842060201410ull + (param1 & 1) * 0x8000ull + (param2 & 31) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(...) bdk_tns_sde_ldex_cfg_ofit7x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT7X_W2(...) "TNS_SDE_LDEX_CFG_OFIT7X_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit8#_w0
 *
 * OFIT_8
 * Bits[31:28] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit8x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t acm_req_addr_inst0          : 32; /**< R/W - -- */
#else
		uint32_t acm_req_addr_inst0          : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit8x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201E00ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(...) bdk_tns_sde_ldex_cfg_ofit8x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W0(...) "TNS_SDE_LDEX_CFG_OFIT8X_W0"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit8#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit8x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t acm_req_addr_inst1          : 25; /**< R/W - -- */
		uint32_t acm_req_cmd_inst0           : 2;  /**< R/W - -- */
		uint32_t acm_req_addr_inst0          : 5;  /**< R/W - Continuation of MSBs of field ACM_REQ_ADDR_INST0 from previous word. */
#else
		uint32_t acm_req_addr_inst0          : 5;
		uint32_t acm_req_cmd_inst0           : 2;
		uint32_t acm_req_addr_inst1          : 25;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit8x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201E04ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(...) bdk_tns_sde_ldex_cfg_ofit8x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W1(...) "TNS_SDE_LDEX_CFG_OFIT8X_W1"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit8#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit8x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t acm_req_addr_inst2          : 18; /**< R/W - -- */
		uint32_t acm_req_cmd_inst1           : 2;  /**< R/W - -- */
		uint32_t acm_req_addr_inst1          : 12; /**< R/W - Continuation of MSBs of field ACM_REQ_ADDR_INST1 from previous word. */
#else
		uint32_t acm_req_addr_inst1          : 12;
		uint32_t acm_req_cmd_inst1           : 2;
		uint32_t acm_req_addr_inst2          : 18;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit8x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201E08ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(...) bdk_tns_sde_ldex_cfg_ofit8x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W2(...) "TNS_SDE_LDEX_CFG_OFIT8X_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit8#_w3
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w3 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit8x_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t acm_req_addr_inst3          : 11; /**< R/W - -- */
		uint32_t acm_req_cmd_inst2           : 2;  /**< R/W - -- */
		uint32_t acm_req_addr_inst2          : 19; /**< R/W - Continuation of MSBs of field ACM_REQ_ADDR_INST2 from previous word. */
#else
		uint32_t acm_req_addr_inst2          : 19;
		uint32_t acm_req_cmd_inst2           : 2;
		uint32_t acm_req_addr_inst3          : 11;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w3_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w3_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit8x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201E0Cull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(...) bdk_tns_sde_ldex_cfg_ofit8x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W3(...) "TNS_SDE_LDEX_CFG_OFIT8X_W3"


/**
 * NCB32b - tns_sde_lde#_cfg_ofit8#_w4
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT8(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit8x_w4 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofit8x_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t acm_req_cmd_inst3           : 2;  /**< R/W - -- */
		uint32_t acm_req_addr_inst3          : 26; /**< R/W - Continuation of MSBs of field ACM_REQ_ADDR_INST3 from previous word. */
#else
		uint32_t acm_req_addr_inst3          : 26;
		uint32_t acm_req_cmd_inst3           : 2;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w4_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit8x_w4_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit8x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201E10ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(...) bdk_tns_sde_ldex_cfg_ofit8x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT8X_W4(...) "TNS_SDE_LDEX_CFG_OFIT8X_W4"


/**
 * NCB - tns_sde_lde#_cfg_ofit9#_w0
 *
 * OFIT_9
 * Bits[63:50] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit9x_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lm_req_key_inst1            : 26; /**< R/W - -- */
		uint64_t lm_req_key_inst0            : 38; /**< R/W - -- */
#else
		uint64_t lm_req_key_inst0            : 38;
		uint64_t lm_req_key_inst1            : 26;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit9x_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201800ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(...) bdk_tns_sde_ldex_cfg_ofit9x_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W0(...) "TNS_SDE_LDEX_CFG_OFIT9X_W0"


/**
 * NCB - tns_sde_lde#_cfg_ofit9#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit9x_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lm_req_key_inst3            : 14; /**< R/W - -- */
		uint64_t lm_req_key_inst2            : 38; /**< R/W - -- */
		uint64_t lm_req_key_inst1            : 12; /**< R/W - Continuation of MSBs of field LM_REQ_KEY_INST1 from previous word. */
#else
		uint64_t lm_req_key_inst1            : 12;
		uint64_t lm_req_key_inst2            : 38;
		uint64_t lm_req_key_inst3            : 14;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit9x_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201808ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(...) bdk_tns_sde_ldex_cfg_ofit9x_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W1(...) "TNS_SDE_LDEX_CFG_OFIT9X_W1"


/**
 * NCB - tns_sde_lde#_cfg_ofit9#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w2 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit9x_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lm_req_key_inst5            : 2;  /**< R/W - -- */
		uint64_t lm_req_key_inst4            : 38; /**< R/W - -- */
		uint64_t lm_req_key_inst3            : 24; /**< R/W - Continuation of MSBs of field LM_REQ_KEY_INST3 from previous word. */
#else
		uint64_t lm_req_key_inst3            : 24;
		uint64_t lm_req_key_inst4            : 38;
		uint64_t lm_req_key_inst5            : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit9x_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201810ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(...) bdk_tns_sde_ldex_cfg_ofit9x_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W2(...) "TNS_SDE_LDEX_CFG_OFIT9X_W2"


/**
 * NCB - tns_sde_lde#_cfg_ofit9#_w3
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w3 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit9x_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lm_req_key_inst6            : 28; /**< R/W - -- */
		uint64_t lm_req_key_inst5            : 36; /**< R/W - Continuation of MSBs of field LM_REQ_KEY_INST5 from previous word. */
#else
		uint64_t lm_req_key_inst5            : 36;
		uint64_t lm_req_key_inst6            : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w3_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w3_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit9x_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201818ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(...) bdk_tns_sde_ldex_cfg_ofit9x_w3_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W3(...) "TNS_SDE_LDEX_CFG_OFIT9X_W3"


/**
 * NCB - tns_sde_lde#_cfg_ofit9#_w4
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_OFIT9(0..15)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofit9x_w4 {
	uint64_t u;
	struct bdk_tns_sde_ldex_cfg_ofit9x_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_50_63              : 14;
		uint64_t lm_req_cmd_inst             : 2;  /**< R/W - -- */
		uint64_t lm_req_key_inst7            : 38; /**< R/W - -- */
		uint64_t lm_req_key_inst6            : 10; /**< R/W - Continuation of MSBs of field LM_REQ_KEY_INST6 from previous word. */
#else
		uint64_t lm_req_key_inst6            : 10;
		uint64_t lm_req_key_inst7            : 38;
		uint64_t lm_req_cmd_inst             : 2;
		uint64_t reserved_50_63              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w4_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofit9x_w4_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofit9x_w4_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 15)))
		return 0x0000842060201820ull + (param1 & 1) * 0x8000ull + (param2 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(...) bdk_tns_sde_ldex_cfg_ofit9x_w4_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFIT9X_W4(...) "TNS_SDE_LDEX_CFG_OFIT9X_W4"


/**
 * NCB32b - tns_sde_lde#_cfg_ofits_idx
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ofits_idx {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ofits_idx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ofits_idx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ofits_idx_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ofits_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060202180ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_OFITS_IDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(...) bdk_tns_sde_ldex_cfg_ofits_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_OFITS_IDX(...) "TNS_SDE_LDEX_CFG_OFITS_IDX"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dmbm_en
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dmbm_en {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dmbm_en_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dmbm_en_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dmbm_en_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dmbm_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207248ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(...) bdk_tns_sde_ldex_cfg_pol_dmbm_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_EN(...) "TNS_SDE_LDEX_CFG_POL_DMBM_EN"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dmbm_idx
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dmbm_idx {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dmbm_idx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t field                       : 4;  /**< R/W - -- */
#else
		uint32_t field                       : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dmbm_idx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dmbm_idx_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dmbm_idx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020724Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(...) bdk_tns_sde_ldex_cfg_pol_dmbm_idx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DMBM_IDX(...) "TNS_SDE_LDEX_CFG_POL_DMBM_IDX"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dneng
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dneng {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dneng_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t field                       : 8;  /**< R/W - -- */
#else
		uint32_t field                       : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dneng_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dneng_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dneng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DNENG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DNENG(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207264ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DNENG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(...) bdk_tns_sde_ldex_cfg_pol_dneng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DNENG(...) "TNS_SDE_LDEX_CFG_POL_DNENG"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dpcmd_cp
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_cp {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207258ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(...) bdk_tns_sde_ldex_cfg_pol_dpcmd_cp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_CP(...) "TNS_SDE_LDEX_CFG_POL_DPCMD_CP"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dpcmd_dp
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_dp {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207250ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(...) bdk_tns_sde_ldex_cfg_pol_dpcmd_dp_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_DP(...) "TNS_SDE_LDEX_CFG_POL_DPCMD_DP"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dpcmd_fw
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_fw {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207254ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(...) bdk_tns_sde_ldex_cfg_pol_dpcmd_fw_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_FW(...) "TNS_SDE_LDEX_CFG_POL_DPCMD_FW"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_dpcmd_tr
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_dpcmd_tr {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020725Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(...) bdk_tns_sde_ldex_cfg_pol_dpcmd_tr_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DPCMD_TR(...) "TNS_SDE_LDEX_CFG_POL_DPCMD_TR"


/**
 * NCB32b - tns_sde_lde#_cfg_pol_drcod
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_pol_drcod {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_pol_drcod_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t field                       : 10; /**< R/W - -- */
#else
		uint32_t field                       : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_pol_drcod_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_pol_drcod_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_pol_drcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207260ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_POL_DRCOD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(...) bdk_tns_sde_ldex_cfg_pol_drcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_POL_DRCOD(...) "TNS_SDE_LDEX_CFG_POL_DRCOD"


/**
 * NCB32b - tns_sde_lde#_cfg_prfl_tbl#
 *
 * ProfileID Table
 *
 */
typedef union bdk_tns_sde_ldex_cfg_prfl_tblx {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_prfl_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t se_cmd3_rslt_lane_bitmap    : 8;  /**< R/W - -- */
		uint32_t se_cmd2_rslt_lane_bitmap    : 8;  /**< R/W - -- */
		uint32_t se_cmd1_rslt_lane_bitmap    : 8;  /**< R/W - -- */
		uint32_t se_cmd0_rslt_lane_bitmap    : 8;  /**< R/W - -- */
#else
		uint32_t se_cmd0_rslt_lane_bitmap    : 8;
		uint32_t se_cmd1_rslt_lane_bitmap    : 8;
		uint32_t se_cmd2_rslt_lane_bitmap    : 8;
		uint32_t se_cmd3_rslt_lane_bitmap    : 8;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_prfl_tblx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_prfl_tblx_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_prfl_tblx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 7)))
		return 0x0000842060207300ull + (param1 & 1) * 0x8000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(...) bdk_tns_sde_ldex_cfg_prfl_tblx_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_PRFL_TBLX(...) "TNS_SDE_LDEX_CFG_PRFL_TBLX"


/**
 * NCB32b - tns_sde_lde#_cfg_se_to_cy
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_se_to_cy {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_se_to_cy_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field                       : 16; /**< R/W - -- */
#else
		uint32_t field                       : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_se_to_cy_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_se_to_cy_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_se_to_cy_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207320ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_SE_TO_CY", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(...) bdk_tns_sde_ldex_cfg_se_to_cy_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_SE_TO_CY(...) "TNS_SDE_LDEX_CFG_SE_TO_CY"


/**
 * NCB32b - tns_sde_lde#_cfg_se_to_fw_en
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_se_to_fw_en {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_se_to_fw_en_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_se_to_fw_en_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_se_to_fw_en_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_se_to_fw_en_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207324ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(...) bdk_tns_sde_ldex_cfg_se_to_fw_en_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_SE_TO_FW_EN(...) "TNS_SDE_LDEX_CFG_SE_TO_FW_EN"


/**
 * NCB32b - tns_sde_lde#_cfg_smp_lane#
 *
 * 4 sampling indexes for 4 rslt lanes
 *
 */
typedef union bdk_tns_sde_ldex_cfg_smp_lanex {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_smp_lanex_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mirrorbitmask_index         : 4;  /**< R/W - -- */
#else
		uint32_t mirrorbitmask_index         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_smp_lanex_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_smp_lanex_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_smp_lanex_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 3)))
		return 0x0000842060207268ull + (param1 & 1) * 0x8000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_SMP_LANEX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(...) bdk_tns_sde_ldex_cfg_smp_lanex_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_SMP_LANEX(...) "TNS_SDE_LDEX_CFG_SMP_LANEX"


/**
 * NCB32b - tns_sde_lde#_cfg_tpl_tbl#_w0
 *
 * TemplateID Table
 * Bits[31:30] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_tpl_tblx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t metadata                    : 32; /**< R/W - -- */
#else
		uint32_t metadata                    : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_tpl_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 255)))
		return 0x0000842060204000ull + (param1 & 1) * 0x8000ull + (param2 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(...) bdk_tns_sde_ldex_cfg_tpl_tblx_w0_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W0(...) "TNS_SDE_LDEX_CFG_TPL_TBLX_W0"


/**
 * NCB32b - tns_sde_lde#_cfg_tpl_tbl#_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_TPL_TBL(0..255)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_tpl_tblx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t layer4_offset               : 4;  /**< R/W - -- */
		uint32_t layer3_offset               : 7;  /**< R/W - -- */
		uint32_t layer2_offset               : 7;  /**< R/W - -- */
		uint32_t layer1_offset               : 7;  /**< R/W - -- */
		uint32_t layer0_offset               : 7;  /**< R/W - -- */
#else
		uint32_t layer0_offset               : 7;
		uint32_t layer1_offset               : 7;
		uint32_t layer2_offset               : 7;
		uint32_t layer3_offset               : 7;
		uint32_t layer4_offset               : 4;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_tpl_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 255)))
		return 0x0000842060204004ull + (param1 & 1) * 0x8000ull + (param2 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(...) bdk_tns_sde_ldex_cfg_tpl_tblx_w1_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W1(...) "TNS_SDE_LDEX_CFG_TPL_TBLX_W1"


/**
 * NCB32b - tns_sde_lde#_cfg_tpl_tbl#_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_CFG_TPL_TBL(0..255)_W0
 *
 */
typedef union bdk_tns_sde_ldex_cfg_tpl_tblx_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_tpl_tblx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t fstint_lid1                 : 3;  /**< R/W - -- */
		uint32_t fstint_lid0                 : 3;  /**< R/W - -- */
		uint32_t layer7_offset               : 7;  /**< R/W - -- */
		uint32_t layer6_offset               : 7;  /**< R/W - -- */
		uint32_t layer5_offset               : 7;  /**< R/W - -- */
		uint32_t layer4_offset               : 3;  /**< R/W - Continuation of MSBs of field LAYER4_OFFSET from previous word. */
#else
		uint32_t layer4_offset               : 3;
		uint32_t layer5_offset               : 7;
		uint32_t layer6_offset               : 7;
		uint32_t layer7_offset               : 7;
		uint32_t fstint_lid0                 : 3;
		uint32_t fstint_lid1                 : 3;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_tpl_tblx_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_tpl_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 255)))
		return 0x0000842060204008ull + (param1 & 1) * 0x8000ull + (param2 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(...) bdk_tns_sde_ldex_cfg_tpl_tblx_w2_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TPL_TBLX_W2(...) "TNS_SDE_LDEX_CFG_TPL_TBLX_W2"


/**
 * NCB32b - tns_sde_lde#_cfg_ttl_fl_neng
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_neng {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ttl_fl_neng_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t field                       : 8;  /**< R/W - -- */
#else
		uint32_t field                       : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_neng_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_neng_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ttl_fl_neng_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207280ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(...) bdk_tns_sde_ldex_cfg_ttl_fl_neng_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_NENG(...) "TNS_SDE_LDEX_CFG_TTL_FL_NENG"


/**
 * NCB32b - tns_sde_lde#_cfg_ttl_fl_pcmd
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_pcmd {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t field                       : 2;  /**< R/W - -- */
#else
		uint32_t field                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207278ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(...) bdk_tns_sde_ldex_cfg_ttl_fl_pcmd_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_PCMD(...) "TNS_SDE_LDEX_CFG_TTL_FL_PCMD"


/**
 * NCB32b - tns_sde_lde#_cfg_ttl_fl_rcod
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_cfg_ttl_fl_rcod {
	uint32_t u;
	struct bdk_tns_sde_ldex_cfg_ttl_fl_rcod_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t field                       : 10; /**< R/W - -- */
#else
		uint32_t field                       : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_rcod_s cn88xx; */
	/* struct bdk_tns_sde_ldex_cfg_ttl_fl_rcod_s cn88xxp1; */
} bdk_tns_sde_ldex_cfg_ttl_fl_rcod_t;

static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020727Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(...) bdk_tns_sde_ldex_cfg_ttl_fl_rcod_t
#define bustype_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_CFG_TTL_FL_RCOD(...) "TNS_SDE_LDEX_CFG_TTL_FL_RCOD"


/**
 * NCB32b - tns_sde_lde#_dbg_acmrh_w0
 *
 * Capture acmrh info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_acmrh_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_acmrh_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t probe_acm_rslt_exp_vector   : 2;  /**< R/W/H - -- */
		uint32_t probe_acm_rslt_valid_vector : 4;  /**< R/W/H - -- */
		uint32_t output_arbiter_req_vector   : 2;  /**< R/W/H - -- */
		uint32_t output_arbiter_grant_vector : 2;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_pktcmd                  : 2;  /**< R/W/H - -- */
		uint32_t out_reasoncode              : 10; /**< R/W/H - -- */
		uint32_t out_nxtengine               : 8;  /**< R/W/H - -- */
#else
		uint32_t out_nxtengine               : 8;
		uint32_t out_reasoncode              : 10;
		uint32_t out_pktcmd                  : 2;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t output_arbiter_grant_vector : 2;
		uint32_t output_arbiter_req_vector   : 2;
		uint32_t probe_acm_rslt_valid_vector : 4;
		uint32_t probe_acm_rslt_exp_vector   : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_acmrh_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072D4ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_ACMRH_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(...) bdk_tns_sde_ldex_dbg_acmrh_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W0(...) "TNS_SDE_LDEX_DBG_ACMRH_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_acmrh_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_acmrh_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_acmrh_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t acm_rslt_ln0_in_drdy        : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_ln0_in_reqid       : 4;  /**< R/W/H - -- */
		uint32_t acm_rslt_ln0_in_smp_event   : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_ln0_in_drop        : 1;  /**< R/W/H - -- */
		uint32_t probe_srdy                  : 1;  /**< R/W/H - -- */
		uint32_t probe_drdy                  : 1;  /**< R/W/H - -- */
		uint32_t probe_acm_reqid             : 4;  /**< R/W/H - -- */
		uint32_t probe_waiting_time          : 16; /**< R/W/H - -- */
		uint32_t probe_timeout               : 1;  /**< R/W/H - -- */
		uint32_t probe_acm_rslt_exp_vector   : 2;  /**< R/W/H - Continuation of MSBs of field PROBE_ACM_RSLT_EXPECTED_VECTOR from previous
                                                                 word. */
#else
		uint32_t probe_acm_rslt_exp_vector   : 2;
		uint32_t probe_timeout               : 1;
		uint32_t probe_waiting_time          : 16;
		uint32_t probe_acm_reqid             : 4;
		uint32_t probe_drdy                  : 1;
		uint32_t probe_srdy                  : 1;
		uint32_t acm_rslt_ln0_in_drop        : 1;
		uint32_t acm_rslt_ln0_in_smp_event   : 1;
		uint32_t acm_rslt_ln0_in_reqid       : 4;
		uint32_t acm_rslt_ln0_in_drdy        : 1;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_acmrh_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072D8ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_ACMRH_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(...) bdk_tns_sde_ldex_dbg_acmrh_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W1(...) "TNS_SDE_LDEX_DBG_ACMRH_W1"


/**
 * NCB32b - tns_sde_lde#_dbg_acmrh_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_acmrh_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_acmrh_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t input_buf_usage             : 5;  /**< R/W/H - -- */
		uint32_t bypass_buf_in_srdy          : 1;  /**< R/W/H - -- */
		uint32_t bypass_buf_in_drdy          : 1;  /**< R/W/H - -- */
		uint32_t bypass_buf_usage            : 3;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane3_in_srdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane3_in_drdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane3_in_reqid     : 4;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane3_in_smp_event : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane2_in_srdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane2_in_drdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane2_in_reqid     : 4;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane2_in_smp_event : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane1_in_srdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane1_in_drdy      : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane1_in_reqid     : 4;  /**< R/W/H - -- */
		uint32_t acm_rslt_lane1_in_smp_event : 1;  /**< R/W/H - -- */
		uint32_t acm_rslt_ln0_in_srdy        : 1;  /**< R/W/H - -- */
#else
		uint32_t acm_rslt_ln0_in_srdy        : 1;
		uint32_t acm_rslt_lane1_in_smp_event : 1;
		uint32_t acm_rslt_lane1_in_reqid     : 4;
		uint32_t acm_rslt_lane1_in_drdy      : 1;
		uint32_t acm_rslt_lane1_in_srdy      : 1;
		uint32_t acm_rslt_lane2_in_smp_event : 1;
		uint32_t acm_rslt_lane2_in_reqid     : 4;
		uint32_t acm_rslt_lane2_in_drdy      : 1;
		uint32_t acm_rslt_lane2_in_srdy      : 1;
		uint32_t acm_rslt_lane3_in_smp_event : 1;
		uint32_t acm_rslt_lane3_in_reqid     : 4;
		uint32_t acm_rslt_lane3_in_drdy      : 1;
		uint32_t acm_rslt_lane3_in_srdy      : 1;
		uint32_t bypass_buf_usage            : 3;
		uint32_t bypass_buf_in_drdy          : 1;
		uint32_t bypass_buf_in_srdy          : 1;
		uint32_t input_buf_usage             : 5;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_acmrh_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072DCull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_ACMRH_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(...) bdk_tns_sde_ldex_dbg_acmrh_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W2(...) "TNS_SDE_LDEX_DBG_ACMRH_W2"


/**
 * NCB32b - tns_sde_lde#_dbg_acmrh_w3
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_ACMRH_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_acmrh_w3 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_acmrh_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t input_buf_in_srdy           : 1;  /**< R/W/H - -- */
		uint32_t input_buf_in_drdy           : 1;  /**< R/W/H - -- */
		uint32_t in_acm_reqid                : 4;  /**< R/W/H - -- */
#else
		uint32_t in_acm_reqid                : 4;
		uint32_t input_buf_in_drdy           : 1;
		uint32_t input_buf_in_srdy           : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w3_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_acmrh_w3_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_acmrh_w3_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072E0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_ACMRH_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(...) bdk_tns_sde_ldex_dbg_acmrh_w3_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_ACMRH_W3(...) "TNS_SDE_LDEX_DBG_ACMRH_W3"


/**
 * NCB32b - tns_sde_lde#_dbg_ifif
 *
 * Capture input_fifo info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ifif {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ifif_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t fifo_usage                  : 2;  /**< R/W/H - -- */
#else
		uint32_t fifo_usage                  : 2;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ifif_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ifif_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ifif_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_IFIF(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_IFIF(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020504Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_IFIF", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_IFIF(...) bdk_tns_sde_ldex_dbg_ifif_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_IFIF(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_IFIF(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_IFIF(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_IFIF(...) "TNS_SDE_LDEX_DBG_IFIF"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_bits_w0
 *
 * Capture kfcp_bits_extract info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_bits_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t out_logicallayer3_8lsbs     : 8;  /**< R/W/H - -- */
		uint32_t out_logicallayer2_8lsbs     : 8;  /**< R/W/H - -- */
		uint32_t out_logicallayer1_8lsbs     : 8;  /**< R/W/H - -- */
		uint32_t out_logicallayer0_8lsbs     : 8;  /**< R/W/H - -- */
#else
		uint32_t out_logicallayer0_8lsbs     : 8;
		uint32_t out_logicallayer1_8lsbs     : 8;
		uint32_t out_logicallayer2_8lsbs     : 8;
		uint32_t out_logicallayer3_8lsbs     : 8;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_bits_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207038ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(...) bdk_tns_sde_ldex_dbg_kfcp_bits_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W0(...) "TNS_SDE_LDEX_DBG_KFCP_BITS_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_bits_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_BITS_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_bits_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t out_lmdata_8lsbs            : 7;  /**< R/W/H - -- */
		uint32_t out_lmhit                   : 1;  /**< R/W/H - -- */
		uint32_t out_nextengine              : 8;  /**< R/W/H - -- */
		uint32_t out_token_scratchpad_8lsbs  : 8;  /**< R/W/H - -- */
		uint32_t out_token_common_bits       : 8;  /**< R/W/H - -- */
#else
		uint32_t out_token_common_bits       : 8;
		uint32_t out_token_scratchpad_8lsbs  : 8;
		uint32_t out_nextengine              : 8;
		uint32_t out_lmhit                   : 1;
		uint32_t out_lmdata_8lsbs            : 7;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_bits_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020703Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(...) bdk_tns_sde_ldex_dbg_kfcp_bits_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W1(...) "TNS_SDE_LDEX_DBG_KFCP_BITS_W1"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_bits_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_BITS_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_bits_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_bits_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_metadata_8lsbs          : 8;  /**< R/W/H - -- */
		uint32_t out_lmdata_8lsbs            : 1;  /**< R/W/H - Continuation of MSBs of field OUT_LMDATA_8LSBS from previous word. */
#else
		uint32_t out_lmdata_8lsbs            : 1;
		uint32_t out_metadata_8lsbs          : 8;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_bits_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_bits_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207040ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(...) bdk_tns_sde_ldex_dbg_kfcp_bits_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_BITS_W2(...) "TNS_SDE_LDEX_DBG_KFCP_BITS_W2"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_kfit
 *
 * Capture kfcp_kfit info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_kfit {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_kfit_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_22_31              : 10;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_kfit6_se_profileid_inst : 4;  /**< R/W/H - -- */
		uint32_t out_kfit6_se_cmd_envec_inst : 5;  /**< R/W/H - -- */
		uint32_t out_kfit0_1st_inst_8lsbs    : 8;  /**< R/W/H - -- */
#else
		uint32_t out_kfit0_1st_inst_8lsbs    : 8;
		uint32_t out_kfit6_se_cmd_envec_inst : 5;
		uint32_t out_kfit6_se_profileid_inst : 4;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_22_31              : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_kfit_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_kfit_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_kfit_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060206C44ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(...) bdk_tns_sde_ldex_dbg_kfcp_kfit_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_KFIT(...) "TNS_SDE_LDEX_DBG_KFCP_KFIT"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_mlcd_w0
 *
 * Capture kfcp_muxlut_cloud info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t stg1_out_data_8lsbs         : 2;  /**< R/W/H - -- */
		uint32_t stg2_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg2_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg2_out_data               : 28; /**< R/W/H - -- */
#else
		uint32_t stg2_out_data               : 28;
		uint32_t stg2_out_drdy               : 1;
		uint32_t stg2_out_srdy               : 1;
		uint32_t stg1_out_data_8lsbs         : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207044ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(...) bdk_tns_sde_ldex_dbg_kfcp_mlcd_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W0(...) "TNS_SDE_LDEX_DBG_KFCP_MLCD_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_kfcp_mlcd_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_KFCP_MLCD_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_21_31              : 11;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_data_8lsbs         : 8;  /**< R/W/H - -- */
		uint32_t stg1_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg1_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg1_out_data_8lsbs         : 6;  /**< R/W/H - Continuation of MSBs of field STAGE1_OUT_DATA_8LSBS from previous word. */
#else
		uint32_t stg1_out_data_8lsbs         : 6;
		uint32_t stg1_out_drdy               : 1;
		uint32_t stg1_out_srdy               : 1;
		uint32_t stg0_out_data_8lsbs         : 8;
		uint32_t stg0_out_drdy               : 1;
		uint32_t stg0_out_srdy               : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_21_31              : 11;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207048ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(...) bdk_tns_sde_ldex_dbg_kfcp_mlcd_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFCP_MLCD_W1(...) "TNS_SDE_LDEX_DBG_KFCP_MLCD_W1"


/**
 * NCB32b - tns_sde_lde#_dbg_kfdp_core
 *
 * Capture kfdp_core info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfdp_core {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfdp_core_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_se_profileid            : 3;  /**< R/W/H - -- */
		uint32_t out_se_cmd_envec            : 4;  /**< R/W/H - -- */
#else
		uint32_t out_se_cmd_envec            : 4;
		uint32_t out_se_profileid            : 3;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfdp_core_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfdp_core_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfdp_core_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205058ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFDP_CORE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(...) bdk_tns_sde_ldex_dbg_kfdp_core_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFDP_CORE(...) "TNS_SDE_LDEX_DBG_KFDP_CORE"


/**
 * NCB32b - tns_sde_lde#_dbg_kfdp_ridg
 *
 * Capture kfdp_reqid_gen info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_kfdp_ridg {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_kfdp_ridg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_25_31              : 7;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_se_reqid                : 6;  /**< R/W/H - -- */
		uint32_t outstanding_se_reqs_cnt     : 7;  /**< R/W/H - -- */
		uint32_t se_merge_done_valid         : 1;  /**< R/W/H - -- */
		uint32_t se_merge_done_reqid         : 6;  /**< R/W/H - -- */
#else
		uint32_t se_merge_done_reqid         : 6;
		uint32_t se_merge_done_valid         : 1;
		uint32_t outstanding_se_reqs_cnt     : 7;
		uint32_t out_se_reqid                : 6;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_25_31              : 7;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_kfdp_ridg_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_kfdp_ridg_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_kfdp_ridg_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020505Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(...) bdk_tns_sde_ldex_dbg_kfdp_ridg_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_KFDP_RIDG(...) "TNS_SDE_LDEX_DBG_KFDP_RIDG"


/**
 * NCB - tns_sde_lde#_dbg_mgr_info_w0
 *
 * Capture merger info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_mgr_info_w0 {
	uint64_t u;
	struct bdk_tns_sde_ldex_dbg_mgr_info_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t se_rslt_lane1_in_sorry      : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane1_in_hit        : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_srdy         : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_drdy         : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_reqid        : 6;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_dualid       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_sorry        : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_ln0_in_hit          : 1;  /**< R/W/H - -- */
		uint64_t probe_srdy                  : 1;  /**< R/W/H - -- */
		uint64_t probe_drdy                  : 1;  /**< R/W/H - -- */
		uint64_t probe_se_reqid              : 6;  /**< R/W/H - -- */
		uint64_t probe_waiting_time          : 16; /**< R/W/H - -- */
		uint64_t probe_timeout               : 1;  /**< R/W/H - -- */
		uint64_t probe_se_rslt_exp_vector    : 8;  /**< R/W/H - -- */
		uint64_t probe_se_rslt_valid_vector  : 8;  /**< R/W/H - -- */
		uint64_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_se_rslt_sorry_vector    : 4;  /**< R/W/H - -- */
		uint64_t out_se_rslt_hit_vector      : 4;  /**< R/W/H - -- */
#else
		uint64_t out_se_rslt_hit_vector      : 4;
		uint64_t out_se_rslt_sorry_vector    : 4;
		uint64_t out_drdy                    : 1;
		uint64_t out_srdy                    : 1;
		uint64_t probe_se_rslt_valid_vector  : 8;
		uint64_t probe_se_rslt_exp_vector    : 8;
		uint64_t probe_timeout               : 1;
		uint64_t probe_waiting_time          : 16;
		uint64_t probe_se_reqid              : 6;
		uint64_t probe_drdy                  : 1;
		uint64_t probe_srdy                  : 1;
		uint64_t se_rslt_ln0_in_hit          : 1;
		uint64_t se_rslt_ln0_in_sorry        : 1;
		uint64_t se_rslt_ln0_in_dualid       : 1;
		uint64_t se_rslt_ln0_in_reqid        : 6;
		uint64_t se_rslt_ln0_in_drdy         : 1;
		uint64_t se_rslt_ln0_in_srdy         : 1;
		uint64_t se_rslt_lane1_in_hit        : 1;
		uint64_t se_rslt_lane1_in_sorry      : 1;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_mgr_info_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_mgr_info_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_mgr_info_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207358ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(...) bdk_tns_sde_ldex_dbg_mgr_info_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W0(...) "TNS_SDE_LDEX_DBG_MGR_INFO_W0"


/**
 * NCB - tns_sde_lde#_dbg_mgr_info_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_MGR_INFO_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_mgr_info_w1 {
	uint64_t u;
	struct bdk_tns_sde_ldex_dbg_mgr_info_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_54_63              : 10;
		uint64_t locked                      : 1;  /**< R/W/H - -- */
		uint64_t token_buf_in_srdy           : 1;  /**< R/W/H - -- */
		uint64_t token_buf_in_drdy           : 1;  /**< R/W/H - -- */
		uint64_t in_se_profileid             : 3;  /**< R/W/H - -- */
		uint64_t in_se_cmd_envec             : 4;  /**< R/W/H - -- */
		uint64_t in_se_reqid                 : 6;  /**< R/W/H - -- */
		uint64_t token_buf_usage             : 7;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_srdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_drdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_reqid      : 6;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_dualid     : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_sorry      : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane3_in_hit        : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_srdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_drdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_reqid      : 6;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_dualid     : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_sorry      : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane2_in_hit        : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane1_in_srdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane1_in_drdy       : 1;  /**< R/W/H - -- */
		uint64_t se_rslt_lane1_in_reqid      : 6;  /**< R/W/H - -- */
		uint64_t se_rslt_lane1_in_dualid     : 1;  /**< R/W/H - -- */
#else
		uint64_t se_rslt_lane1_in_dualid     : 1;
		uint64_t se_rslt_lane1_in_reqid      : 6;
		uint64_t se_rslt_lane1_in_drdy       : 1;
		uint64_t se_rslt_lane1_in_srdy       : 1;
		uint64_t se_rslt_lane2_in_hit        : 1;
		uint64_t se_rslt_lane2_in_sorry      : 1;
		uint64_t se_rslt_lane2_in_dualid     : 1;
		uint64_t se_rslt_lane2_in_reqid      : 6;
		uint64_t se_rslt_lane2_in_drdy       : 1;
		uint64_t se_rslt_lane2_in_srdy       : 1;
		uint64_t se_rslt_lane3_in_hit        : 1;
		uint64_t se_rslt_lane3_in_sorry      : 1;
		uint64_t se_rslt_lane3_in_dualid     : 1;
		uint64_t se_rslt_lane3_in_reqid      : 6;
		uint64_t se_rslt_lane3_in_drdy       : 1;
		uint64_t se_rslt_lane3_in_srdy       : 1;
		uint64_t token_buf_usage             : 7;
		uint64_t in_se_reqid                 : 6;
		uint64_t in_se_cmd_envec             : 4;
		uint64_t in_se_profileid             : 3;
		uint64_t token_buf_in_drdy           : 1;
		uint64_t token_buf_in_srdy           : 1;
		uint64_t locked                      : 1;
		uint64_t reserved_54_63              : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_mgr_info_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_mgr_info_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_mgr_info_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207360ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(...) bdk_tns_sde_ldex_dbg_mgr_info_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_MGR_INFO_W1(...) "TNS_SDE_LDEX_DBG_MGR_INFO_W1"


/**
 * NCB - tns_sde_lde#_dbg_ofcp_bits
 *
 * Capture ofcp_bits_extracted info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_bits {
	uint64_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_bits_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_45_63              : 19;
		uint64_t locked                      : 1;  /**< R/W/H - -- */
		uint64_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint64_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint64_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_subtoken0_8lsbs         : 8;  /**< R/W/H - -- */
		uint64_t out_subtoken0_valid         : 1;  /**< R/W/H - -- */
		uint64_t out_se_rslt_8lsbs           : 8;  /**< R/W/H - -- */
		uint64_t out_se_rslt_hit_vector      : 4;  /**< R/W/H - -- */
		uint64_t out_se_rslt_sorry_vector    : 4;  /**< R/W/H - -- */
		uint64_t out_profileid               : 3;  /**< R/W/H - -- */
		uint64_t out_cmd_envec               : 4;  /**< R/W/H - -- */
		uint64_t out_muxxor_bits             : 8;  /**< R/W/H - -- */
#else
		uint64_t out_muxxor_bits             : 8;
		uint64_t out_cmd_envec               : 4;
		uint64_t out_profileid               : 3;
		uint64_t out_se_rslt_sorry_vector    : 4;
		uint64_t out_se_rslt_hit_vector      : 4;
		uint64_t out_se_rslt_8lsbs           : 8;
		uint64_t out_subtoken0_valid         : 1;
		uint64_t out_subtoken0_8lsbs         : 8;
		uint64_t out_drdy                    : 1;
		uint64_t out_srdy                    : 1;
		uint64_t in_drdy                     : 1;
		uint64_t in_srdy                     : 1;
		uint64_t locked                      : 1;
		uint64_t reserved_45_63              : 19;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_bits_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_bits_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_bits_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207168ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_BITS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(...) bdk_tns_sde_ldex_dbg_ofcp_bits_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_BITS(...) "TNS_SDE_LDEX_DBG_OFCP_BITS"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_mlcd_w0
 *
 * Capture ofcp_muxlut_cloud info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t stg4_out_data               : 32; /**< R/W/H - -- */
#else
		uint32_t stg4_out_data               : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207174ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(...) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W0(...) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_mlcd_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_MLCD_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t stg2_out_data_8lsbs         : 4;  /**< R/W/H - -- */
		uint32_t stg3_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg3_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg3_out_data_8lsbs         : 8;  /**< R/W/H - -- */
		uint32_t stg4_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg4_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg4_out_data               : 16; /**< R/W/H - Continuation of MSBs of field STAGE4_OUT_DATA from previous word. */
#else
		uint32_t stg4_out_data               : 16;
		uint32_t stg4_out_drdy               : 1;
		uint32_t stg4_out_srdy               : 1;
		uint32_t stg3_out_data_8lsbs         : 8;
		uint32_t stg3_out_drdy               : 1;
		uint32_t stg3_out_srdy               : 1;
		uint32_t stg2_out_data_8lsbs         : 4;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207178ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(...) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W1(...) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W1"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_mlcd_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_MLCD_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_29_31              : 3;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg0_out_data_8lsbs         : 8;  /**< R/W/H - -- */
		uint32_t stg1_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg1_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg1_out_data_8lsbs         : 8;  /**< R/W/H - -- */
		uint32_t stg2_out_srdy               : 1;  /**< R/W/H - -- */
		uint32_t stg2_out_drdy               : 1;  /**< R/W/H - -- */
		uint32_t stg2_out_data_8lsbs         : 4;  /**< R/W/H - Continuation of MSBs of field STAGE2_OUT_DATA_8LSBS from previous word. */
#else
		uint32_t stg2_out_data_8lsbs         : 4;
		uint32_t stg2_out_drdy               : 1;
		uint32_t stg2_out_srdy               : 1;
		uint32_t stg1_out_data_8lsbs         : 8;
		uint32_t stg1_out_drdy               : 1;
		uint32_t stg1_out_srdy               : 1;
		uint32_t stg0_out_data_8lsbs         : 8;
		uint32_t stg0_out_drdy               : 1;
		uint32_t stg0_out_srdy               : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_29_31              : 3;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020717Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(...) bdk_tns_sde_ldex_dbg_ofcp_mlcd_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MLCD_W2(...) "TNS_SDE_LDEX_DBG_OFCP_MLCD_W2"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_mxcd
 *
 * Capture ofcp_muxxor_cloud info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_mxcd {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_mxcd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_muxxor_bits             : 8;  /**< R/W/H - -- */
#else
		uint32_t out_muxxor_bits             : 8;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mxcd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_mxcd_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_mxcd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207170ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(...) bdk_tns_sde_ldex_dbg_ofcp_mxcd_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_MXCD(...) "TNS_SDE_LDEX_DBG_OFCP_MXCD"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_ofit_w0
 *
 * Capture ofcp_ofit info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t out_ofit3_exp_inst_8lsbs    : 7;  /**< R/W/H - -- */
		uint32_t out_ofit2_mir_bm_inst_8lsbs : 8;  /**< R/W/H - -- */
		uint32_t out_ofit1_hashsel_inst      : 2;  /**< R/W/H - -- */
		uint32_t out_ofit1_tt_inst           : 2;  /**< R/W/H - -- */
		uint32_t out_ofit0_nextengine_inst   : 9;  /**< R/W/H - -- */
		uint32_t out_ofit0_slavelanesel_inst : 4;  /**< R/W/H - -- */
#else
		uint32_t out_ofit0_slavelanesel_inst : 4;
		uint32_t out_ofit0_nextengine_inst   : 9;
		uint32_t out_ofit1_tt_inst           : 2;
		uint32_t out_ofit1_hashsel_inst      : 2;
		uint32_t out_ofit2_mir_bm_inst_8lsbs : 8;
		uint32_t out_ofit3_exp_inst_8lsbs    : 7;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060202184ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(...) bdk_tns_sde_ldex_dbg_ofcp_ofit_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W0(...) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_ofit_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_OFIT_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t out_ofit8_1st_inst_8lsbs    : 5;  /**< R/W/H - -- */
		uint32_t out_ofit6_1st_inst_8lsbs    : 8;  /**< R/W/H - -- */
		uint32_t out_ofit5_1st_inst_8lsbs    : 8;  /**< R/W/H - -- */
		uint32_t out_ofit4_rewrptr6inins_inst : 2; /**< R/W/H - -- */
		uint32_t out_ofit4_rewrptr0_inst_8lsbs : 8;/**< R/W/H - -- */
		uint32_t out_ofit3_exp_inst_8lsbs    : 1;  /**< R/W/H - Continuation of MSBs of field OUT_OFIT3_EXP_INST_8LSBS from previous word. */
#else
		uint32_t out_ofit3_exp_inst_8lsbs    : 1;
		uint32_t out_ofit4_rewrptr0_inst_8lsbs : 8;
		uint32_t out_ofit4_rewrptr6inins_inst : 2;
		uint32_t out_ofit5_1st_inst_8lsbs    : 8;
		uint32_t out_ofit6_1st_inst_8lsbs    : 8;
		uint32_t out_ofit8_1st_inst_8lsbs    : 5;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060202188ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(...) bdk_tns_sde_ldex_dbg_ofcp_ofit_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W1(...) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W1"


/**
 * NCB32b - tns_sde_lde#_dbg_ofcp_ofit_w2
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_OFCP_OFIT_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofcp_ofit_w2 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_ofit9_lm_cmd_inst       : 2;  /**< R/W/H - -- */
		uint32_t out_ofit9_1st_inst_8lsbs    : 8;  /**< R/W/H - -- */
		uint32_t out_ofit8_second_inst       : 2;  /**< R/W/H - -- */
		uint32_t out_ofit8_1st_inst_8lsbs    : 3;  /**< R/W/H - Continuation of MSBs of field OUT_OFIT8_FIRST_INST_8LSBS from previous word. */
#else
		uint32_t out_ofit8_1st_inst_8lsbs    : 3;
		uint32_t out_ofit8_second_inst       : 2;
		uint32_t out_ofit9_1st_inst_8lsbs    : 8;
		uint32_t out_ofit9_lm_cmd_inst       : 2;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020218Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(...) bdk_tns_sde_ldex_dbg_ofcp_ofit_w2_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFCP_OFIT_W2(...) "TNS_SDE_LDEX_DBG_OFCP_OFIT_W2"


/**
 * NCB32b - tns_sde_lde#_dbg_ofdp_acmridg
 *
 * Capture odfp_acm_reqid_gen info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofdp_acmridg {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofdp_acmridg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_to_acmrh_in_buf_srdy    : 1;  /**< R/W/H - -- */
		uint32_t out_to_acmrh_in_buf_drdy    : 1;  /**< R/W/H - -- */
		uint32_t out_to_acmrh_in_buf_reqid   : 4;  /**< R/W/H - -- */
		uint32_t out_to_acmrh_in_buf_cmd_envec : 4;/**< R/W/H - -- */
		uint32_t out_to_acmrh_byp_buf_srdy   : 1;  /**< R/W/H - -- */
		uint32_t out_to_acmrh_byp_buf_drdy   : 1;  /**< R/W/H - -- */
		uint32_t bypass_en                   : 1;  /**< R/W/H - -- */
		uint32_t outstanding_acm_reqs_cnt    : 5;  /**< R/W/H - -- */
		uint32_t acm_merge_done_valid        : 1;  /**< R/W/H - -- */
		uint32_t acm_merge_done_reqid        : 4;  /**< R/W/H - -- */
#else
		uint32_t acm_merge_done_reqid        : 4;
		uint32_t acm_merge_done_valid        : 1;
		uint32_t outstanding_acm_reqs_cnt    : 5;
		uint32_t bypass_en                   : 1;
		uint32_t out_to_acmrh_byp_buf_drdy   : 1;
		uint32_t out_to_acmrh_byp_buf_srdy   : 1;
		uint32_t out_to_acmrh_in_buf_cmd_envec : 4;
		uint32_t out_to_acmrh_in_buf_reqid   : 4;
		uint32_t out_to_acmrh_in_buf_drdy    : 1;
		uint32_t out_to_acmrh_in_buf_srdy    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofdp_acmridg_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofdp_acmridg_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofdp_acmridg_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072D0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(...) bdk_tns_sde_ldex_dbg_ofdp_acmridg_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFDP_ACMRIDG(...) "TNS_SDE_LDEX_DBG_OFDP_ACMRIDG"


/**
 * NCB32b - tns_sde_lde#_dbg_ofdp_core
 *
 * Capture odfp_core info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ofdp_core {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ofdp_core_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_lm_req_cmd              : 1;  /**< R/W/H - -- */
		uint32_t out_lm_req_key_8lsbs        : 8;  /**< R/W/H - -- */
		uint32_t out_acm_req_cmd_envec       : 4;  /**< R/W/H - -- */
		uint32_t out_acm_req_ln0_addr_8lsbs  : 8;  /**< R/W/H - -- */
#else
		uint32_t out_acm_req_ln0_addr_8lsbs  : 8;
		uint32_t out_acm_req_cmd_envec       : 4;
		uint32_t out_lm_req_key_8lsbs        : 8;
		uint32_t out_lm_req_cmd              : 1;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ofdp_core_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ofdp_core_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ofdp_core_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072CCull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_OFDP_CORE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(...) bdk_tns_sde_ldex_dbg_ofdp_core_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_OFDP_CORE(...) "TNS_SDE_LDEX_DBG_OFDP_CORE"


/**
 * NCB - tns_sde_lde#_dbg_tmp_tbl
 *
 * Capture templateid lookup info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_tmp_tbl {
	uint64_t u;
	struct bdk_tns_sde_ldex_dbg_tmp_tbl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_54_63              : 10;
		uint64_t locked                      : 1;  /**< R/W/H - -- */
		uint64_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint64_t in_drdy                     : 1;  /**< R/W/H - -- */
		uint64_t in_template_id              : 8;  /**< R/W/H - -- */
		uint64_t in_tt                       : 1;  /**< R/W/H - -- */
		uint64_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint64_t out_metadata_8lsbs          : 8;  /**< R/W/H - -- */
		uint64_t out_logical_offset3         : 7;  /**< R/W/H - -- */
		uint64_t out_logical_offset2         : 7;  /**< R/W/H - -- */
		uint64_t out_logical_offset1         : 7;  /**< R/W/H - -- */
		uint64_t out_logical_offset0         : 7;  /**< R/W/H - -- */
		uint64_t out_valid_layers_cnt        : 4;  /**< R/W/H - -- */
#else
		uint64_t out_valid_layers_cnt        : 4;
		uint64_t out_logical_offset0         : 7;
		uint64_t out_logical_offset1         : 7;
		uint64_t out_logical_offset2         : 7;
		uint64_t out_logical_offset3         : 7;
		uint64_t out_metadata_8lsbs          : 8;
		uint64_t out_drdy                    : 1;
		uint64_t out_srdy                    : 1;
		uint64_t in_tt                       : 1;
		uint64_t in_template_id              : 8;
		uint64_t in_drdy                     : 1;
		uint64_t in_srdy                     : 1;
		uint64_t locked                      : 1;
		uint64_t reserved_54_63              : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_tmp_tbl_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_tmp_tbl_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_tmp_tbl_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TMP_TBL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TMP_TBL(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205050ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_TMP_TBL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(...) bdk_tns_sde_ldex_dbg_tmp_tbl_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_TMP_TBL(...) "TNS_SDE_LDEX_DBG_TMP_TBL"


/**
 * NCB32b - tns_sde_lde#_dbg_ttl_lb_w0
 *
 * Capture ttl and loopback info for debug
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ttl_lb_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ttl_lb_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t in_ttl                      : 6;  /**< R/W/H - -- */
		uint32_t in_nextengine               : 8;  /**< R/W/H - -- */
		uint32_t out_srdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_drdy                    : 1;  /**< R/W/H - -- */
		uint32_t out_ttl                     : 6;  /**< R/W/H - -- */
		uint32_t out_nextengine              : 8;  /**< R/W/H - -- */
		uint32_t out_is_ttl_fail             : 1;  /**< R/W/H - -- */
		uint32_t out_is_loopback             : 1;  /**< R/W/H - -- */
#else
		uint32_t out_is_loopback             : 1;
		uint32_t out_is_ttl_fail             : 1;
		uint32_t out_nextengine              : 8;
		uint32_t out_ttl                     : 6;
		uint32_t out_drdy                    : 1;
		uint32_t out_srdy                    : 1;
		uint32_t in_nextengine               : 8;
		uint32_t in_ttl                      : 6;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ttl_lb_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ttl_lb_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ttl_lb_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072E4ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(...) bdk_tns_sde_ldex_dbg_ttl_lb_w0_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W0(...) "TNS_SDE_LDEX_DBG_TTL_LB_W0"


/**
 * NCB32b - tns_sde_lde#_dbg_ttl_lb_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_DBG_TTL_LB_W0
 *
 */
typedef union bdk_tns_sde_ldex_dbg_ttl_lb_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_dbg_ttl_lb_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t locked                      : 1;  /**< R/W/H - -- */
		uint32_t in_srdy                     : 1;  /**< R/W/H - -- */
		uint32_t in_drdy                     : 1;  /**< R/W/H - -- */
#else
		uint32_t in_drdy                     : 1;
		uint32_t in_srdy                     : 1;
		uint32_t locked                      : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_dbg_ttl_lb_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_dbg_ttl_lb_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_dbg_ttl_lb_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072E8ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(...) bdk_tns_sde_ldex_dbg_ttl_lb_w1_t
#define bustype_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_DBG_TTL_LB_W1(...) "TNS_SDE_LDEX_DBG_TTL_LB_W1"


/**
 * NCB32b - tns_sde_lde#_kfcp0_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage0_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp0_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp0_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t mux_sel                     : 9;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 9;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp0_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp0_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp0_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207010ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(...) bdk_tns_sde_ldex_kfcp0_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP0_BYPM_DMUX(...) "TNS_SDE_LDEX_KFCP0_BYPM_DMUX"


/**
 * NCB - tns_sde_lde#_kfcp0_ml_dlut
 *
 * A dynamic register for configuring all luts in all kfcp_stage0_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp0_ml_dlut {
	uint64_t u;
	struct bdk_tns_sde_ldex_kfcp0_ml_dlut_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lut                         : 64; /**< R/W/H - -- */
#else
		uint64_t lut                         : 64;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp0_ml_dlut_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp0_ml_dlut_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp0_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207008ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(...) bdk_tns_sde_ldex_kfcp0_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP0_ML_DLUT(...) "TNS_SDE_LDEX_KFCP0_ML_DLUT"


/**
 * NCB - tns_sde_lde#_kfcp0_ml_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage0_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp0_ml_dmux {
	uint64_t u;
	struct bdk_tns_sde_ldex_kfcp0_ml_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_54_63              : 10;
		uint64_t mux5_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux4_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux3_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux2_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux1_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux0_sel                    : 9;  /**< R/W/H - -- */
#else
		uint64_t mux0_sel                    : 9;
		uint64_t mux1_sel                    : 9;
		uint64_t mux2_sel                    : 9;
		uint64_t mux3_sel                    : 9;
		uint64_t mux4_sel                    : 9;
		uint64_t mux5_sel                    : 9;
		uint64_t reserved_54_63              : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp0_ml_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp0_ml_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp0_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207000ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(...) bdk_tns_sde_ldex_kfcp0_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP0_ML_DMUX(...) "TNS_SDE_LDEX_KFCP0_ML_DMUX"


/**
 * NCB32b - tns_sde_lde#_kfcp1_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage1_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp1_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp1_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t mux_sel                     : 6;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp1_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp1_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp1_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207024ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(...) bdk_tns_sde_ldex_kfcp1_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP1_BYPM_DMUX(...) "TNS_SDE_LDEX_KFCP1_BYPM_DMUX"


/**
 * NCB32b - tns_sde_lde#_kfcp1_ml_dlut_w#
 *
 * A dynamic register for configuring all luts in all kfcp_stage1_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp1_ml_dlut_wx {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lut                         : 32; /**< R/W/H - -- */
#else
		uint32_t lut                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 1)))
		return 0x000084206020701Cull + (param1 & 1) * 0x8000ull + (param2 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(...) bdk_tns_sde_ldex_kfcp1_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DLUT_WX(...) "TNS_SDE_LDEX_KFCP1_ML_DLUT_WX"


/**
 * NCB32b - tns_sde_lde#_kfcp1_ml_dmux_w0
 *
 * A dynamic register for configuring all muxes in all kfcp_stage1_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_kfcp1_ml_dmux_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mux5_sel                    : 2;  /**< R/W/H - -- */
		uint32_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint32_t mux0_sel                    : 6;
		uint32_t mux1_sel                    : 6;
		uint32_t mux2_sel                    : 6;
		uint32_t mux3_sel                    : 6;
		uint32_t mux4_sel                    : 6;
		uint32_t mux5_sel                    : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207014ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(...) bdk_tns_sde_ldex_kfcp1_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W0(...) "TNS_SDE_LDEX_KFCP1_ML_DMUX_W0"


/**
 * NCB32b - tns_sde_lde#_kfcp1_ml_dmux_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_KFCP1_ML_DMUX_W0
 *
 */
typedef union bdk_tns_sde_ldex_kfcp1_ml_dmux_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mux5_sel                    : 4;  /**< R/W/H - Continuation of MSBs of field MUX5_SEL from previous word. */
#else
		uint32_t mux5_sel                    : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207018ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(...) bdk_tns_sde_ldex_kfcp1_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP1_ML_DMUX_W1(...) "TNS_SDE_LDEX_KFCP1_ML_DMUX_W1"


/**
 * NCB - tns_sde_lde#_kfcp2_ml_dlut
 *
 * A dynamic register for configuring all luts in all kfcp_stage2_muxlut cells -
 * 28 cells
 */
typedef union bdk_tns_sde_ldex_kfcp2_ml_dlut {
	uint64_t u;
	struct bdk_tns_sde_ldex_kfcp2_ml_dlut_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lut                         : 64; /**< R/W/H - -- */
#else
		uint64_t lut                         : 64;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp2_ml_dlut_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp2_ml_dlut_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp2_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207030ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(...) bdk_tns_sde_ldex_kfcp2_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP2_ML_DLUT(...) "TNS_SDE_LDEX_KFCP2_ML_DLUT"


/**
 * NCB - tns_sde_lde#_kfcp2_ml_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage2_muxlut cells -
 * 28 cells
 */
typedef union bdk_tns_sde_ldex_kfcp2_ml_dmux {
	uint64_t u;
	struct bdk_tns_sde_ldex_kfcp2_ml_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t mux5_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint64_t mux0_sel                    : 6;
		uint64_t mux1_sel                    : 6;
		uint64_t mux2_sel                    : 6;
		uint64_t mux3_sel                    : 6;
		uint64_t mux4_sel                    : 6;
		uint64_t mux5_sel                    : 6;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp2_ml_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp2_ml_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp2_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207028ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(...) bdk_tns_sde_ldex_kfcp2_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP2_ML_DMUX(...) "TNS_SDE_LDEX_KFCP2_ML_DMUX"


/**
 * NCB32b - tns_sde_lde#_kfcp_cloud_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_kfcp_cloud_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_cloud_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_cloud_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_cloud_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_cloud_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020705Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(...) bdk_tns_sde_ldex_kfcp_cloud_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_CLOUD_LOCK(...) "TNS_SDE_LDEX_KFCP_CLOUD_LOCK"


/**
 * NCB32b - tns_sde_lde#_kfcp_cloud_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_kfcp_cloud_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_cloud_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_cloud_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_cloud_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_cloud_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207060ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(...) bdk_tns_sde_ldex_kfcp_cloud_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_CLOUD_SPAD(...) "TNS_SDE_LDEX_KFCP_CLOUD_SPAD"


/**
 * NCB32b - tns_sde_lde#_kfcp_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfcp_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
#else
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207050ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(...) bdk_tns_sde_ldex_kfcp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_EN_HI(...) "TNS_SDE_LDEX_KFCP_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_kfcp_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfcp_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
#else
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207054ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(...) bdk_tns_sde_ldex_kfcp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_EN_LO(...) "TNS_SDE_LDEX_KFCP_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_kfcp_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfcp_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
#else
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207058ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(...) bdk_tns_sde_ldex_kfcp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_FRC(...) "TNS_SDE_LDEX_KFCP_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_kfcp_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfcp_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfcp_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
#else
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfcp_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfcp_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_kfcp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFCP_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020704Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFCP_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(...) bdk_tns_sde_ldex_kfcp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFCP_INT_W1C(...) "TNS_SDE_LDEX_KFCP_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_kfdp_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfdp_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfdp_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t se_outstd_req_cnt_reaches_max : 1;/**< R/W - -- */
		uint32_t se_reqid_out_unexpected     : 1;  /**< R/W - -- */
#else
		uint32_t se_reqid_out_unexpected     : 1;
		uint32_t se_outstd_req_cnt_reaches_max : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfdp_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfdp_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_kfdp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205028ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(...) bdk_tns_sde_ldex_kfdp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_EN_HI(...) "TNS_SDE_LDEX_KFDP_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_kfdp_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfdp_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfdp_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t se_outstd_req_cnt_reaches_max : 1;/**< R/W - -- */
		uint32_t se_reqid_out_unexpected     : 1;  /**< R/W - -- */
#else
		uint32_t se_reqid_out_unexpected     : 1;
		uint32_t se_outstd_req_cnt_reaches_max : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfdp_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfdp_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_kfdp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020502Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(...) bdk_tns_sde_ldex_kfdp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_EN_LO(...) "TNS_SDE_LDEX_KFDP_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_kfdp_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfdp_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfdp_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t se_outstd_req_cnt_reaches_max : 1;/**< WO - -- */
		uint32_t se_reqid_out_unexpected     : 1;  /**< WO - -- */
#else
		uint32_t se_reqid_out_unexpected     : 1;
		uint32_t se_outstd_req_cnt_reaches_max : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfdp_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfdp_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_kfdp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205030ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFDP_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(...) bdk_tns_sde_ldex_kfdp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_FRC(...) "TNS_SDE_LDEX_KFDP_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_kfdp_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_kfdp_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfdp_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t se_outstd_req_cnt_reaches_max : 1;/**< R/W1C/H - -- */
		uint32_t se_reqid_out_unexpected     : 1;  /**< R/W1C/H - -- */
#else
		uint32_t se_reqid_out_unexpected     : 1;
		uint32_t se_outstd_req_cnt_reaches_max : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfdp_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfdp_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_kfdp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFDP_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205024ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFDP_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(...) bdk_tns_sde_ldex_kfdp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFDP_INT_W1C(...) "TNS_SDE_LDEX_KFDP_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_kfit_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_kfit_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfit_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfit_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfit_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_kfit_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060206C48ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFIT_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFIT_LOCK(...) bdk_tns_sde_ldex_kfit_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFIT_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFIT_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFIT_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFIT_LOCK(...) "TNS_SDE_LDEX_KFIT_LOCK"


/**
 * NCB32b - tns_sde_lde#_kfit_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_kfit_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfit_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfit_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfit_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_kfit_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFIT_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060206C4Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFIT_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFIT_SPAD(...) bdk_tns_sde_ldex_kfit_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFIT_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFIT_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFIT_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFIT_SPAD(...) "TNS_SDE_LDEX_KFIT_SPAD"


/**
 * NCB32b - tns_sde_lde#_kfm_ecc_ctl_cd
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfm_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t tpl_table                   : 1;  /**< R/W - -- */
#else
		uint32_t tpl_table                   : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_ldex_kfm_ecc_ctl_cd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205010ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(...) bdk_tns_sde_ldex_kfm_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_CD(...) "TNS_SDE_LDEX_KFM_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_lde#_kfm_ecc_ctl_fd
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_fd {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfm_ecc_ctl_fd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t tpl_table                   : 1;  /**< R/W - -- */
#else
		uint32_t tpl_table                   : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fd_s cn88xxp1; */
} bdk_tns_sde_ldex_kfm_ecc_ctl_fd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020500Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(...) bdk_tns_sde_ldex_kfm_ecc_ctl_fd_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FD(...) "TNS_SDE_LDEX_KFM_ECC_CTL_FD"


/**
 * NCB32b - tns_sde_lde#_kfm_ecc_ctl_fs
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_kfm_ecc_ctl_fs {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfm_ecc_ctl_fs_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t tpl_table                   : 1;  /**< R/W - -- */
#else
		uint32_t tpl_table                   : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fs_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfm_ecc_ctl_fs_s cn88xxp1; */
} bdk_tns_sde_ldex_kfm_ecc_ctl_fs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205008ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(...) bdk_tns_sde_ldex_kfm_ecc_ctl_fs_t
#define bustype_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFM_ECC_CTL_FS(...) "TNS_SDE_LDEX_KFM_ECC_CTL_FS"


/**
 * NCB32b - tns_sde_lde#_kfmisc_dbg_cptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_kfmisc_dbg_cptr {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfmisc_dbg_cptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfmisc_dbg_cptr_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfmisc_dbg_cptr_s cn88xxp1; */
} bdk_tns_sde_ldex_kfmisc_dbg_cptr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205048ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(...) bdk_tns_sde_ldex_kfmisc_dbg_cptr_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFMISC_DBG_CPTR(...) "TNS_SDE_LDEX_KFMISC_DBG_CPTR"


/**
 * NCB32b - tns_sde_lde#_kfmisc_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_kfmisc_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfmisc_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfmisc_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfmisc_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_kfmisc_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205060ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFMISC_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFMISC_LOCK(...) bdk_tns_sde_ldex_kfmisc_lock_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFMISC_LOCK(...) "TNS_SDE_LDEX_KFMISC_LOCK"


/**
 * NCB32b - tns_sde_lde#_kfmisc_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_kfmisc_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_kfmisc_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_kfmisc_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_kfmisc_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_kfmisc_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_KFMISC_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205064ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_KFMISC_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_KFMISC_SPAD(...) bdk_tns_sde_ldex_kfmisc_spad_t
#define bustype_BDK_TNS_SDE_LDEX_KFMISC_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_KFMISC_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_KFMISC_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_KFMISC_SPAD(...) "TNS_SDE_LDEX_KFMISC_SPAD"


/**
 * NCB32b - tns_sde_lde#_ldea_int_en_hi
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_ldea_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldea_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;  /**< R/W - -- */
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W - -- */
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< R/W - -- */
#else
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldea_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldea_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_ldea_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205038ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(...) bdk_tns_sde_ldex_ldea_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_EN_HI(...) "TNS_SDE_LDEX_LDEA_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_ldea_int_en_lo
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_ldea_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldea_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;  /**< R/W - -- */
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W - -- */
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< R/W - -- */
#else
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldea_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldea_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_ldea_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020503Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(...) bdk_tns_sde_ldex_ldea_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_EN_LO(...) "TNS_SDE_LDEX_LDEA_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_ldea_int_frc
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_ldea_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldea_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;  /**< WO - -- */
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1; /**< WO - -- */
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< WO - -- */
#else
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldea_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldea_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_ldea_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205040ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEA_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(...) bdk_tns_sde_ldex_ldea_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_FRC(...) "TNS_SDE_LDEX_LDEA_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_ldea_int_w1c
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_ldea_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldea_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;  /**< R/W1C/H - -- */
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W1C/H - -- */
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;/**< R/W1C/H - -- */
#else
		uint32_t ldeb_ldea_loopback_dfc_rx_ovfl : 1;
		uint32_t ldea_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t isme_lde_lanem_dfc_rx_ovfl  : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldea_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldea_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_ldea_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEA_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205034ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEA_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(...) bdk_tns_sde_ldex_ldea_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEA_INT_W1C(...) "TNS_SDE_LDEX_LDEA_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_ldeb_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ldeb_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldeb_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W - -- */
#else
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldeb_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldeb_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_ldeb_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072B8ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(...) bdk_tns_sde_ldex_ldeb_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_EN_HI(...) "TNS_SDE_LDEX_LDEB_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_ldeb_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ldeb_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldeb_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;  /**< R/W - -- */
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W - -- */
#else
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldeb_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldeb_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_ldeb_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072BCull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(...) bdk_tns_sde_ldex_ldeb_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_EN_LO(...) "TNS_SDE_LDEX_LDEB_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_ldeb_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ldeb_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldeb_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;  /**< WO - -- */
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1; /**< WO - -- */
#else
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldeb_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldeb_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_ldeb_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072C0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEB_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(...) bdk_tns_sde_ldex_ldeb_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_FRC(...) "TNS_SDE_LDEX_LDEB_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_ldeb_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ldeb_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_ldeb_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;  /**< R/W1C/H - -- */
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1; /**< R/W1C/H - -- */
#else
		uint32_t ldeb_i_cfg_chain_dfc_rx_ovfl : 1;
		uint32_t ldea_ldeb_dfc_rx_ovfl       : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ldeb_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ldeb_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_ldeb_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_LDEB_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072B4ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_LDEB_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(...) bdk_tns_sde_ldex_ldeb_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_LDEB_INT_W1C(...) "TNS_SDE_LDEX_LDEB_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_mgr_ecc_ctl_cd
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t input_storage               : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer7             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer6             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer5             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer4             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer3             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer2             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer1             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer0             : 1;  /**< R/W - -- */
#else
		uint32_t se_rslt_buffer0             : 1;
		uint32_t se_rslt_buffer1             : 1;
		uint32_t se_rslt_buffer2             : 1;
		uint32_t se_rslt_buffer3             : 1;
		uint32_t se_rslt_buffer4             : 1;
		uint32_t se_rslt_buffer5             : 1;
		uint32_t se_rslt_buffer6             : 1;
		uint32_t se_rslt_buffer7             : 1;
		uint32_t input_storage               : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_ecc_ctl_cd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207334ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(...) bdk_tns_sde_ldex_mgr_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_CD(...) "TNS_SDE_LDEX_MGR_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_lde#_mgr_ecc_ctl_fd
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_fd {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_ecc_ctl_fd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t input_storage               : 12; /**< R/W - -- */
		uint32_t se_rslt_buffer7             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer6             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer5             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer4             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer3             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer2             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer1             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer0             : 1;  /**< R/W - -- */
#else
		uint32_t se_rslt_buffer0             : 1;
		uint32_t se_rslt_buffer1             : 1;
		uint32_t se_rslt_buffer2             : 1;
		uint32_t se_rslt_buffer3             : 1;
		uint32_t se_rslt_buffer4             : 1;
		uint32_t se_rslt_buffer5             : 1;
		uint32_t se_rslt_buffer6             : 1;
		uint32_t se_rslt_buffer7             : 1;
		uint32_t input_storage               : 12;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fd_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fd_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_ecc_ctl_fd_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207330ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(...) bdk_tns_sde_ldex_mgr_ecc_ctl_fd_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FD(...) "TNS_SDE_LDEX_MGR_ECC_CTL_FD"


/**
 * NCB32b - tns_sde_lde#_mgr_ecc_ctl_fs
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_mgr_ecc_ctl_fs {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_ecc_ctl_fs_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t input_storage               : 12; /**< R/W - -- */
		uint32_t se_rslt_buffer7             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer6             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer5             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer4             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer3             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer2             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer1             : 1;  /**< R/W - -- */
		uint32_t se_rslt_buffer0             : 1;  /**< R/W - -- */
#else
		uint32_t se_rslt_buffer0             : 1;
		uint32_t se_rslt_buffer1             : 1;
		uint32_t se_rslt_buffer2             : 1;
		uint32_t se_rslt_buffer3             : 1;
		uint32_t se_rslt_buffer4             : 1;
		uint32_t se_rslt_buffer5             : 1;
		uint32_t se_rslt_buffer6             : 1;
		uint32_t se_rslt_buffer7             : 1;
		uint32_t input_storage               : 12;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fs_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_ecc_ctl_fs_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_ecc_ctl_fs_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020732Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(...) bdk_tns_sde_ldex_mgr_ecc_ctl_fs_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_ECC_CTL_FS(...) "TNS_SDE_LDEX_MGR_ECC_CTL_FS"


/**
 * NCB - tns_sde_lde#_mgr_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_mgr_int_en_hi {
	uint64_t u;
	struct bdk_tns_sde_ldex_mgr_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t merge_timeout               : 1;  /**< R/W - -- */
		uint64_t token_buf_ecc_sb_err        : 12; /**< R/W - -- */
		uint64_t token_buf_ecc_db_err        : 12; /**< R/W - -- */
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;  /**< R/W - -- */
#else
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;
		uint64_t token_buf_ecc_db_err        : 12;
		uint64_t token_buf_ecc_sb_err        : 12;
		uint64_t merge_timeout               : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207340ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(...) bdk_tns_sde_ldex_mgr_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_EN_HI(...) "TNS_SDE_LDEX_MGR_INT_EN_HI"


/**
 * NCB - tns_sde_lde#_mgr_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_mgr_int_en_lo {
	uint64_t u;
	struct bdk_tns_sde_ldex_mgr_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t merge_timeout               : 1;  /**< R/W - -- */
		uint64_t token_buf_ecc_sb_err        : 12; /**< R/W - -- */
		uint64_t token_buf_ecc_db_err        : 12; /**< R/W - -- */
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;  /**< R/W - -- */
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;  /**< R/W - -- */
#else
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;
		uint64_t token_buf_ecc_db_err        : 12;
		uint64_t token_buf_ecc_sb_err        : 12;
		uint64_t merge_timeout               : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207348ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(...) bdk_tns_sde_ldex_mgr_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_EN_LO(...) "TNS_SDE_LDEX_MGR_INT_EN_LO"


/**
 * NCB - tns_sde_lde#_mgr_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_mgr_int_frc {
	uint64_t u;
	struct bdk_tns_sde_ldex_mgr_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t merge_timeout               : 1;  /**< WO - -- */
		uint64_t token_buf_ecc_sb_err        : 12; /**< WO - -- */
		uint64_t token_buf_ecc_db_err        : 12; /**< WO - -- */
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;  /**< WO - -- */
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;  /**< WO - -- */
#else
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;
		uint64_t token_buf_ecc_db_err        : 12;
		uint64_t token_buf_ecc_sb_err        : 12;
		uint64_t merge_timeout               : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207350ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_FRC(...) bdk_tns_sde_ldex_mgr_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_FRC(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_FRC(...) "TNS_SDE_LDEX_MGR_INT_FRC"


/**
 * NCB - tns_sde_lde#_mgr_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_mgr_int_w1c {
	uint64_t u;
	struct bdk_tns_sde_ldex_mgr_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t merge_timeout               : 1;  /**< R/W1C/H - -- */
		uint64_t token_buf_ecc_sb_err        : 12; /**< R/W1C/H - -- */
		uint64_t token_buf_ecc_db_err        : 12; /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;  /**< R/W1C/H - -- */
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;  /**< R/W1C/H - -- */
#else
		uint64_t se_rslt_buffer0_ecc_db_err  : 1;
		uint64_t se_rslt_buffer0_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer1_ecc_db_err  : 1;
		uint64_t se_rslt_buffer1_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer2_ecc_db_err  : 1;
		uint64_t se_rslt_buffer2_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer3_ecc_db_err  : 1;
		uint64_t se_rslt_buffer3_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer4_ecc_db_err  : 1;
		uint64_t se_rslt_buffer4_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer5_ecc_db_err  : 1;
		uint64_t se_rslt_buffer5_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer6_ecc_db_err  : 1;
		uint64_t se_rslt_buffer6_ecc_sb_err  : 1;
		uint64_t se_rslt_buffer7_ecc_db_err  : 1;
		uint64_t se_rslt_buffer7_ecc_sb_err  : 1;
		uint64_t token_buf_ecc_db_err        : 12;
		uint64_t token_buf_ecc_sb_err        : 12;
		uint64_t merge_timeout               : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207338ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_INT_W1C(...) bdk_tns_sde_ldex_mgr_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_INT_W1C(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_MGR_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_INT_W1C(...) "TNS_SDE_LDEX_MGR_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_mgr_lde_type
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_mgr_lde_type {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_lde_type_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_lde_type_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_lde_type_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_lde_type_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207328ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_LDE_TYPE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(...) bdk_tns_sde_ldex_mgr_lde_type_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_LDE_TYPE(...) "TNS_SDE_LDEX_MGR_LDE_TYPE"


/**
 * NCB32b - tns_sde_lde#_mgr_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_mgr_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207368ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_LOCK(...) bdk_tns_sde_ldex_mgr_lock_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_LOCK(...) "TNS_SDE_LDEX_MGR_LOCK"


/**
 * NCB32b - tns_sde_lde#_mgr_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_mgr_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_mgr_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_mgr_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_mgr_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_mgr_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_MGR_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_MGR_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020736Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_MGR_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_MGR_SPAD(...) bdk_tns_sde_ldex_mgr_spad_t
#define bustype_BDK_TNS_SDE_LDEX_MGR_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_MGR_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_MGR_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_MGR_SPAD(...) "TNS_SDE_LDEX_MGR_SPAD"


/**
 * NCB32b - tns_sde_lde#_ofcp0_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage0_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp0_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp0_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t mux_sel                     : 9;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 9;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp0_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp0_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp0_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207118ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(...) bdk_tns_sde_ldex_ofcp0_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP0_BYPM_DMUX(...) "TNS_SDE_LDEX_OFCP0_BYPM_DMUX"


/**
 * NCB - tns_sde_lde#_ofcp0_ml_dlut
 *
 * A dynamic register for configuring all luts in all ofcp_stage0_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp0_ml_dlut {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp0_ml_dlut_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lut                         : 64; /**< R/W/H - -- */
#else
		uint64_t lut                         : 64;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp0_ml_dlut_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp0_ml_dlut_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp0_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207110ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(...) bdk_tns_sde_ldex_ofcp0_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP0_ML_DLUT(...) "TNS_SDE_LDEX_OFCP0_ML_DLUT"


/**
 * NCB - tns_sde_lde#_ofcp0_ml_dmux
 *
 * A dynamic register for configuring all muxes in all ofcp_stage0_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp0_ml_dmux {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp0_ml_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_54_63              : 10;
		uint64_t mux5_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux4_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux3_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux2_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux1_sel                    : 9;  /**< R/W/H - -- */
		uint64_t mux0_sel                    : 9;  /**< R/W/H - -- */
#else
		uint64_t mux0_sel                    : 9;
		uint64_t mux1_sel                    : 9;
		uint64_t mux2_sel                    : 9;
		uint64_t mux3_sel                    : 9;
		uint64_t mux4_sel                    : 9;
		uint64_t mux5_sel                    : 9;
		uint64_t reserved_54_63              : 10;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp0_ml_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp0_ml_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp0_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207108ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(...) bdk_tns_sde_ldex_ofcp0_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP0_ML_DMUX(...) "TNS_SDE_LDEX_OFCP0_ML_DMUX"


/**
 * NCB32b - tns_sde_lde#_ofcp1_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage1_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp1_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp1_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t mux_sel                     : 6;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp1_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp1_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp1_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020712Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(...) bdk_tns_sde_ldex_ofcp1_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP1_BYPM_DMUX(...) "TNS_SDE_LDEX_OFCP1_BYPM_DMUX"


/**
 * NCB32b - tns_sde_lde#_ofcp1_ml_dlut_w#
 *
 * A dynamic register for configuring all luts in all ofcp_stage1_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp1_ml_dlut_wx {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lut                         : 32; /**< R/W/H - -- */
#else
		uint32_t lut                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 1)))
		return 0x0000842060207124ull + (param1 & 1) * 0x8000ull + (param2 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(...) bdk_tns_sde_ldex_ofcp1_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DLUT_WX(...) "TNS_SDE_LDEX_OFCP1_ML_DLUT_WX"


/**
 * NCB32b - tns_sde_lde#_ofcp1_ml_dmux_w0
 *
 * A dynamic register for configuring all muxes in all ofcp_stage1_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp1_ml_dmux_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mux5_sel                    : 2;  /**< R/W/H - -- */
		uint32_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint32_t mux0_sel                    : 6;
		uint32_t mux1_sel                    : 6;
		uint32_t mux2_sel                    : 6;
		uint32_t mux3_sel                    : 6;
		uint32_t mux4_sel                    : 6;
		uint32_t mux5_sel                    : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020711Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(...) bdk_tns_sde_ldex_ofcp1_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W0(...) "TNS_SDE_LDEX_OFCP1_ML_DMUX_W0"


/**
 * NCB32b - tns_sde_lde#_ofcp1_ml_dmux_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_OFCP1_ML_DMUX_W0
 *
 */
typedef union bdk_tns_sde_ldex_ofcp1_ml_dmux_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mux5_sel                    : 4;  /**< R/W/H - Continuation of MSBs of field MUX5_SEL from previous word. */
#else
		uint32_t mux5_sel                    : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207120ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(...) bdk_tns_sde_ldex_ofcp1_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP1_ML_DMUX_W1(...) "TNS_SDE_LDEX_OFCP1_ML_DMUX_W1"


/**
 * NCB32b - tns_sde_lde#_ofcp2_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage2_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp2_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp2_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t mux_sel                     : 6;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp2_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp2_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp2_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207140ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(...) bdk_tns_sde_ldex_ofcp2_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP2_BYPM_DMUX(...) "TNS_SDE_LDEX_OFCP2_BYPM_DMUX"


/**
 * NCB - tns_sde_lde#_ofcp2_ml_dlut
 *
 * A dynamic register for configuring all luts in all ofcp_stage2_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp2_ml_dlut {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp2_ml_dlut_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lut                         : 64; /**< R/W/H - -- */
#else
		uint64_t lut                         : 64;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp2_ml_dlut_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp2_ml_dlut_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp2_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207138ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(...) bdk_tns_sde_ldex_ofcp2_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP2_ML_DLUT(...) "TNS_SDE_LDEX_OFCP2_ML_DLUT"


/**
 * NCB - tns_sde_lde#_ofcp2_ml_dmux
 *
 * A dynamic register for configuring all muxes in all ofcp_stage2_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp2_ml_dmux {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp2_ml_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t mux5_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint64_t mux0_sel                    : 6;
		uint64_t mux1_sel                    : 6;
		uint64_t mux2_sel                    : 6;
		uint64_t mux3_sel                    : 6;
		uint64_t mux4_sel                    : 6;
		uint64_t mux5_sel                    : 6;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp2_ml_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp2_ml_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp2_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207130ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(...) bdk_tns_sde_ldex_ofcp2_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP2_ML_DMUX(...) "TNS_SDE_LDEX_OFCP2_ML_DMUX"


/**
 * NCB32b - tns_sde_lde#_ofcp3_bypm_dmux
 *
 * A dynamic register for configuring all muxes in all kfcp_stage3_bypassmux cells
 * - 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp3_bypm_dmux {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp3_bypm_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t mux_sel                     : 6;  /**< R/W/H - -- */
#else
		uint32_t mux_sel                     : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp3_bypm_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp3_bypm_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp3_bypm_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207154ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(...) bdk_tns_sde_ldex_ofcp3_bypm_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP3_BYPM_DMUX(...) "TNS_SDE_LDEX_OFCP3_BYPM_DMUX"


/**
 * NCB32b - tns_sde_lde#_ofcp3_ml_dlut_w#
 *
 * A dynamic register for configuring all luts in all ofcp_stage3_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp3_ml_dlut_wx {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lut                         : 32; /**< R/W/H - -- */
#else
		uint32_t lut                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 1)))
		return 0x000084206020714Cull + (param1 & 1) * 0x8000ull + (param2 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(...) bdk_tns_sde_ldex_ofcp3_ml_dlut_wx_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DLUT_WX(...) "TNS_SDE_LDEX_OFCP3_ML_DLUT_WX"


/**
 * NCB32b - tns_sde_lde#_ofcp3_ml_dmux_w0
 *
 * A dynamic register for configuring all muxes in all ofcp_stage3_muxlut cells -
 * 32 cells
 */
typedef union bdk_tns_sde_ldex_ofcp3_ml_dmux_w0 {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mux5_sel                    : 2;  /**< R/W/H - -- */
		uint32_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint32_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint32_t mux0_sel                    : 6;
		uint32_t mux1_sel                    : 6;
		uint32_t mux2_sel                    : 6;
		uint32_t mux3_sel                    : 6;
		uint32_t mux4_sel                    : 6;
		uint32_t mux5_sel                    : 2;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207144ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(...) bdk_tns_sde_ldex_ofcp3_ml_dmux_w0_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W0(...) "TNS_SDE_LDEX_OFCP3_ML_DMUX_W0"


/**
 * NCB32b - tns_sde_lde#_ofcp3_ml_dmux_w1
 *
 * Continuation of structure defined in TNS_SDE_LDE(0..1)_OFCP3_ML_DMUX_W0
 *
 */
typedef union bdk_tns_sde_ldex_ofcp3_ml_dmux_w1 {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mux5_sel                    : 4;  /**< R/W/H - Continuation of MSBs of field MUX5_SEL from previous word. */
#else
		uint32_t mux5_sel                    : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207148ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(...) bdk_tns_sde_ldex_ofcp3_ml_dmux_w1_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP3_ML_DMUX_W1(...) "TNS_SDE_LDEX_OFCP3_ML_DMUX_W1"


/**
 * NCB - tns_sde_lde#_ofcp4_ml_dlut
 *
 * A dynamic register for configuring all luts in all ofcp_stage4_muxlut cells -
 * 48 cells
 */
typedef union bdk_tns_sde_ldex_ofcp4_ml_dlut {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp4_ml_dlut_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lut                         : 64; /**< R/W/H - -- */
#else
		uint64_t lut                         : 64;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp4_ml_dlut_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp4_ml_dlut_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp4_ml_dlut_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207160ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(...) bdk_tns_sde_ldex_ofcp4_ml_dlut_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP4_ML_DLUT(...) "TNS_SDE_LDEX_OFCP4_ML_DLUT"


/**
 * NCB - tns_sde_lde#_ofcp4_ml_dmux
 *
 * A dynamic register for configuring all muxes in all ofcp_stage4_muxlut cells -
 * 48 cells
 */
typedef union bdk_tns_sde_ldex_ofcp4_ml_dmux {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp4_ml_dmux_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t mux5_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux4_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux3_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux2_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux1_sel                    : 6;  /**< R/W/H - -- */
		uint64_t mux0_sel                    : 6;  /**< R/W/H - -- */
#else
		uint64_t mux0_sel                    : 6;
		uint64_t mux1_sel                    : 6;
		uint64_t mux2_sel                    : 6;
		uint64_t mux3_sel                    : 6;
		uint64_t mux4_sel                    : 6;
		uint64_t mux5_sel                    : 6;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp4_ml_dmux_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp4_ml_dmux_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp4_ml_dmux_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207158ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(...) bdk_tns_sde_ldex_ofcp4_ml_dmux_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP4_ML_DMUX(...) "TNS_SDE_LDEX_OFCP4_ML_DMUX"


/**
 * NCB32b - tns_sde_lde#_ofcp_cloud_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_ofcp_cloud_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_cloud_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_cloud_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_cloud_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_cloud_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207190ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(...) bdk_tns_sde_ldex_ofcp_cloud_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_CLOUD_LOCK(...) "TNS_SDE_LDEX_OFCP_CLOUD_LOCK"


/**
 * NCB32b - tns_sde_lde#_ofcp_cloud_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_ofcp_cloud_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_cloud_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_cloud_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_cloud_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_cloud_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207194ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(...) bdk_tns_sde_ldex_ofcp_cloud_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_CLOUD_SPAD(...) "TNS_SDE_LDEX_OFCP_CLOUD_SPAD"


/**
 * NCB32b - tns_sde_lde#_ofcp_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofcp_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;  /**< R/W - -- */
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
#else
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207184ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(...) bdk_tns_sde_ldex_ofcp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_EN_HI(...) "TNS_SDE_LDEX_OFCP_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_ofcp_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofcp_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;  /**< R/W - -- */
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W - -- */
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W - -- */
#else
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207188ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(...) bdk_tns_sde_ldex_ofcp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_EN_LO(...) "TNS_SDE_LDEX_OFCP_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_ofcp_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofcp_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;  /**< WO - -- */
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< WO - -- */
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< WO - -- */
#else
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020718Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(...) bdk_tns_sde_ldex_ofcp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_FRC(...) "TNS_SDE_LDEX_OFCP_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_ofcp_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofcp_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofcp_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;  /**< R/W1C/H - -- */
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;/**< R/W1C/H - -- */
#else
		uint32_t stg4_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg4_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg3_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg2_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg1_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_bpmx_mux_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_lut_dsy_chn_cfg_perr : 1;
		uint32_t stg0_mxlt_mux_dsy_chn_cfg_perr : 1;
		uint32_t muxxor_dsy_chn_cfg_perr     : 1;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207180ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(...) bdk_tns_sde_ldex_ofcp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_INT_W1C(...) "TNS_SDE_LDEX_OFCP_INT_W1C"


/**
 * NCB - tns_sde_lde#_ofcp_mxxr_dyn
 *
 * A dynamic register for configuring all cfg_ofcp_muxxor cells - 8 cells
 *
 */
typedef union bdk_tns_sde_ldex_ofcp_mxxr_dyn {
	uint64_t u;
	struct bdk_tns_sde_ldex_ofcp_mxxr_dyn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t muxa_srcid                  : 4;  /**< R/W/H - -- */
		uint64_t muxa_bytestartposn          : 7;  /**< R/W/H - -- */
		uint64_t muxa_shiftby                : 3;  /**< R/W/H - -- */
		uint64_t muxa_shiftdir               : 1;  /**< R/W/H - -- */
		uint64_t muxa_bitmask                : 16; /**< R/W/H - -- */
		uint64_t muxb_srcid                  : 4;  /**< R/W/H - -- */
		uint64_t muxb_bytestartposn          : 7;  /**< R/W/H - -- */
		uint64_t muxb_bitmask                : 16; /**< R/W/H - -- */
#else
		uint64_t muxb_bitmask                : 16;
		uint64_t muxb_bytestartposn          : 7;
		uint64_t muxb_srcid                  : 4;
		uint64_t muxa_bitmask                : 16;
		uint64_t muxa_shiftdir               : 1;
		uint64_t muxa_shiftby                : 3;
		uint64_t muxa_bytestartposn          : 7;
		uint64_t muxa_srcid                  : 4;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofcp_mxxr_dyn_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofcp_mxxr_dyn_s cn88xxp1; */
} bdk_tns_sde_ldex_ofcp_mxxr_dyn_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207100ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(...) bdk_tns_sde_ldex_ofcp_mxxr_dyn_t
#define bustype_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFCP_MXXR_DYN(...) "TNS_SDE_LDEX_OFCP_MXXR_DYN"


/**
 * NCB32b - tns_sde_lde#_ofdp_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofdp_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofdp_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t acm_req_token_bypass        : 1;  /**< R/W - -- */
		uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< R/W - -- */
		uint32_t acm_reqid_out_unexpected    : 1;  /**< R/W - -- */
#else
		uint32_t acm_reqid_out_unexpected    : 1;
		uint32_t acm_outstd_req_cnt_reaches_max : 1;
		uint32_t acm_req_token_bypass        : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofdp_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofdp_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_ofdp_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207288ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(...) bdk_tns_sde_ldex_ofdp_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_EN_HI(...) "TNS_SDE_LDEX_OFDP_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_ofdp_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofdp_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofdp_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t acm_req_token_bypass        : 1;  /**< R/W - -- */
		uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< R/W - -- */
		uint32_t acm_reqid_out_unexpected    : 1;  /**< R/W - -- */
#else
		uint32_t acm_reqid_out_unexpected    : 1;
		uint32_t acm_outstd_req_cnt_reaches_max : 1;
		uint32_t acm_req_token_bypass        : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofdp_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofdp_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_ofdp_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020728Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(...) bdk_tns_sde_ldex_ofdp_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_EN_LO(...) "TNS_SDE_LDEX_OFDP_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_ofdp_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofdp_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofdp_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t acm_req_token_bypass        : 1;  /**< WO - -- */
		uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< WO - -- */
		uint32_t acm_reqid_out_unexpected    : 1;  /**< WO - -- */
#else
		uint32_t acm_reqid_out_unexpected    : 1;
		uint32_t acm_outstd_req_cnt_reaches_max : 1;
		uint32_t acm_req_token_bypass        : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofdp_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofdp_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_ofdp_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207290ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFDP_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(...) bdk_tns_sde_ldex_ofdp_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_FRC(...) "TNS_SDE_LDEX_OFDP_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_ofdp_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ofdp_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofdp_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t acm_req_token_bypass        : 1;  /**< R/W1C/H - -- */
		uint32_t acm_outstd_req_cnt_reaches_max : 1;/**< R/W1C/H - -- */
		uint32_t acm_reqid_out_unexpected    : 1;  /**< R/W1C/H - -- */
#else
		uint32_t acm_reqid_out_unexpected    : 1;
		uint32_t acm_outstd_req_cnt_reaches_max : 1;
		uint32_t acm_req_token_bypass        : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofdp_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofdp_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_ofdp_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFDP_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060207284ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFDP_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(...) bdk_tns_sde_ldex_ofdp_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFDP_INT_W1C(...) "TNS_SDE_LDEX_OFDP_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_ofit_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_ofit_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofit_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofit_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofit_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_ofit_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060202190ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFIT_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFIT_LOCK(...) bdk_tns_sde_ldex_ofit_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFIT_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFIT_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFIT_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFIT_LOCK(...) "TNS_SDE_LDEX_OFIT_LOCK"


/**
 * NCB32b - tns_sde_lde#_ofit_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_ofit_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofit_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofit_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofit_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_ofit_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFIT_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060202194ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFIT_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFIT_SPAD(...) bdk_tns_sde_ldex_ofit_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFIT_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFIT_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFIT_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFIT_SPAD(...) "TNS_SDE_LDEX_OFIT_SPAD"


/**
 * NCB32b - tns_sde_lde#_ofmisc_dbg_cptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_ldex_ofmisc_dbg_cptr {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofmisc_dbg_cptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t field                       : 1;  /**< R/W - -- */
#else
		uint32_t field                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofmisc_dbg_cptr_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofmisc_dbg_cptr_s cn88xxp1; */
} bdk_tns_sde_ldex_ofmisc_dbg_cptr_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072C8ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(...) bdk_tns_sde_ldex_ofmisc_dbg_cptr_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFMISC_DBG_CPTR(...) "TNS_SDE_LDEX_OFMISC_DBG_CPTR"


/**
 * NCB32b - tns_sde_lde#_ofmisc_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_ldex_ofmisc_lock {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofmisc_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofmisc_lock_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofmisc_lock_s cn88xxp1; */
} bdk_tns_sde_ldex_ofmisc_lock_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072ECull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFMISC_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFMISC_LOCK(...) bdk_tns_sde_ldex_ofmisc_lock_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFMISC_LOCK(...) "TNS_SDE_LDEX_OFMISC_LOCK"


/**
 * NCB32b - tns_sde_lde#_ofmisc_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_ldex_ofmisc_spad {
	uint32_t u;
	struct bdk_tns_sde_ldex_ofmisc_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ofmisc_spad_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ofmisc_spad_s cn88xxp1; */
} bdk_tns_sde_ldex_ofmisc_spad_t;

static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_OFMISC_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072F0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_OFMISC_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_OFMISC_SPAD(...) bdk_tns_sde_ldex_ofmisc_spad_t
#define bustype_BDK_TNS_SDE_LDEX_OFMISC_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_OFMISC_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_OFMISC_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_OFMISC_SPAD(...) "TNS_SDE_LDEX_OFMISC_SPAD"


/**
 * NCB32b - tns_sde_lde#_tlom_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_tlom_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_tlom_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t template_table_ecc_sb_err   : 1;  /**< R/W - -- */
		uint32_t template_table_ecc_db_err   : 1;  /**< R/W - -- */
		uint32_t valid_layer_cnt_less_than_4 : 1;  /**< R/W - -- */
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;  /**< R/W - -- */
		uint32_t layer_offset_out_of_range   : 1;  /**< R/W - -- */
#else
		uint32_t layer_offset_out_of_range   : 1;
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;
		uint32_t valid_layer_cnt_less_than_4 : 1;
		uint32_t template_table_ecc_db_err   : 1;
		uint32_t template_table_ecc_sb_err   : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_tlom_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_tlom_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_tlom_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205018ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(...) bdk_tns_sde_ldex_tlom_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_EN_HI(...) "TNS_SDE_LDEX_TLOM_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_tlom_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_tlom_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_tlom_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t template_table_ecc_sb_err   : 1;  /**< R/W - -- */
		uint32_t template_table_ecc_db_err   : 1;  /**< R/W - -- */
		uint32_t valid_layer_cnt_less_than_4 : 1;  /**< R/W - -- */
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;  /**< R/W - -- */
		uint32_t layer_offset_out_of_range   : 1;  /**< R/W - -- */
#else
		uint32_t layer_offset_out_of_range   : 1;
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;
		uint32_t valid_layer_cnt_less_than_4 : 1;
		uint32_t template_table_ecc_db_err   : 1;
		uint32_t template_table_ecc_sb_err   : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_tlom_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_tlom_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_tlom_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206020501Cull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(...) bdk_tns_sde_ldex_tlom_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_EN_LO(...) "TNS_SDE_LDEX_TLOM_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_tlom_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_tlom_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_tlom_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t template_table_ecc_sb_err   : 1;  /**< WO - -- */
		uint32_t template_table_ecc_db_err   : 1;  /**< WO - -- */
		uint32_t valid_layer_cnt_less_than_4 : 1;  /**< WO - -- */
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;  /**< WO - -- */
		uint32_t layer_offset_out_of_range   : 1;  /**< WO - -- */
#else
		uint32_t layer_offset_out_of_range   : 1;
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;
		uint32_t valid_layer_cnt_less_than_4 : 1;
		uint32_t template_table_ecc_db_err   : 1;
		uint32_t template_table_ecc_sb_err   : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_tlom_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_tlom_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_tlom_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205020ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TLOM_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(...) bdk_tns_sde_ldex_tlom_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_FRC(...) "TNS_SDE_LDEX_TLOM_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_tlom_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_tlom_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_tlom_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t template_table_ecc_sb_err   : 1;  /**< R/W1C/H - -- */
		uint32_t template_table_ecc_db_err   : 1;  /**< R/W1C/H - -- */
		uint32_t valid_layer_cnt_less_than_4 : 1;  /**< R/W1C/H - -- */
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;  /**< R/W1C/H - -- */
		uint32_t layer_offset_out_of_range   : 1;  /**< R/W1C/H - -- */
#else
		uint32_t layer_offset_out_of_range   : 1;
		uint32_t fstint_lid0_gt_fstint_lid1  : 1;
		uint32_t valid_layer_cnt_less_than_4 : 1;
		uint32_t template_table_ecc_db_err   : 1;
		uint32_t template_table_ecc_sb_err   : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_tlom_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_tlom_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_tlom_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TLOM_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842060205014ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TLOM_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(...) bdk_tns_sde_ldex_tlom_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TLOM_INT_W1C(...) "TNS_SDE_LDEX_TLOM_INT_W1C"


/**
 * NCB32b - tns_sde_lde#_ttl_int_en_hi
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ttl_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_ldex_ttl_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ttl_fail                    : 1;  /**< R/W - -- */
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;  /**< R/W - -- */
#else
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;
		uint32_t ttl_fail                    : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ttl_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ttl_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_ldex_ttl_int_en_hi_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072A8ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TTL_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(...) bdk_tns_sde_ldex_ttl_int_en_hi_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_EN_HI(...) "TNS_SDE_LDEX_TTL_INT_EN_HI"


/**
 * NCB32b - tns_sde_lde#_ttl_int_en_lo
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ttl_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_ldex_ttl_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ttl_fail                    : 1;  /**< R/W - -- */
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;  /**< R/W - -- */
#else
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;
		uint32_t ttl_fail                    : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ttl_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ttl_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_ldex_ttl_int_en_lo_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072ACull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TTL_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(...) bdk_tns_sde_ldex_ttl_int_en_lo_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_EN_LO(...) "TNS_SDE_LDEX_TTL_INT_EN_LO"


/**
 * NCB32b - tns_sde_lde#_ttl_int_frc
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ttl_int_frc {
	uint32_t u;
	struct bdk_tns_sde_ldex_ttl_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ttl_fail                    : 1;  /**< WO - -- */
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;  /**< WO - -- */
#else
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;
		uint32_t ttl_fail                    : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ttl_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ttl_int_frc_s cn88xxp1; */
} bdk_tns_sde_ldex_ttl_int_frc_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_FRC(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072B0ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TTL_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_FRC(...) bdk_tns_sde_ldex_ttl_int_frc_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_FRC(...) "TNS_SDE_LDEX_TTL_INT_FRC"


/**
 * NCB32b - tns_sde_lde#_ttl_int_w1c
 *
 * Just 1 single interrupt is sent out;
 * but each interrupt type has one status bit stored in the config block
 * so the CPU can come to read it.
 */
typedef union bdk_tns_sde_ldex_ttl_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_ldex_ttl_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t ttl_fail                    : 1;  /**< R/W1C/H - -- */
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;  /**< R/W1C/H - -- */
#else
		uint32_t cfg_ttl_fail_nxt_eng_inval  : 1;
		uint32_t ttl_fail                    : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_ldex_ttl_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_ldex_ttl_int_w1c_s cn88xxp1; */
} bdk_tns_sde_ldex_ttl_int_w1c_t;

static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_LDEX_TTL_INT_W1C(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x00008420602072A4ull + (param1 & 1) * 0x8000ull;
	csr_fatal("BDK_TNS_SDE_LDEX_TTL_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_LDEX_TTL_INT_W1C(...) bdk_tns_sde_ldex_ttl_int_w1c_t
#define bustype_BDK_TNS_SDE_LDEX_TTL_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_LDEX_TTL_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SDE_LDEX_TTL_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_LDEX_TTL_INT_W1C(...) "TNS_SDE_LDEX_TTL_INT_W1C"


/**
 * NCB32b - tns_sde_mreb_arb_out_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_arb_out_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_arb_out_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of tokens leaving the arbiter */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_arb_out_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_arb_out_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_arb_out_ct_t;

#define BDK_TNS_SDE_MREB_ARB_OUT_CT BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_CT_FUNC(void)
{
	return 0x00008420607804C4ull;
}
#define typedef_BDK_TNS_SDE_MREB_ARB_OUT_CT bdk_tns_sde_mreb_arb_out_ct_t
#define bustype_BDK_TNS_SDE_MREB_ARB_OUT_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_ARB_OUT_CT 0
#define arguments_BDK_TNS_SDE_MREB_ARB_OUT_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_ARB_OUT_CT "TNS_SDE_MREB_ARB_OUT_CT"


/**
 * NCB32b - tns_sde_mreb_arb_out_stepper
 *
 * Controls the single stepper debug logic on the output of the arbiter.
 *
 */
typedef union bdk_tns_sde_mreb_arb_out_stepper {
	uint32_t u;
	struct bdk_tns_sde_mreb_arb_out_stepper_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t gap                         : 8;  /**< R/W - If 0, step function is enabled. If !=0, this is the minimum gap intruduced
                                                                 between requests leaving the arbiter. */
		uint32_t en                          : 1;  /**< R/W - Enables the single step feature. When enabled a single entry will be popped
                                                                 from the page fifos every time step transitions from 0 to 1 */
		uint32_t step                        : 1;  /**< R/W - Step. When changed from 0 to 1, a single entry will be popped from the fifos
                                                                 and admitted to the MRE processing pipeline */
#else
		uint32_t step                        : 1;
		uint32_t en                          : 1;
		uint32_t gap                         : 8;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_arb_out_stepper_s cn88xx; */
	/* struct bdk_tns_sde_mreb_arb_out_stepper_s cn88xxp1; */
} bdk_tns_sde_mreb_arb_out_stepper_t;

#define BDK_TNS_SDE_MREB_ARB_OUT_STEPPER BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARB_OUT_STEPPER_FUNC(void)
{
	return 0x0000842060780404ull;
}
#define typedef_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER bdk_tns_sde_mreb_arb_out_stepper_t
#define bustype_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER 0
#define arguments_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_ARB_OUT_STEPPER "TNS_SDE_MREB_ARB_OUT_STEPPER"


/**
 * NCB32b - tns_sde_mreb_arbiter_sta
 *
 * Indicates the next winner of the arbitration. The address indicates the page in
 * the token and header memory that will be read.
 */
typedef union bdk_tns_sde_mreb_arbiter_sta {
	uint32_t u;
	struct bdk_tns_sde_mreb_arbiter_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t bank                        : 2;  /**< RO/H - Winning bank. */
		uint32_t addr                        : 7;  /**< RO/H - Address of the winning token. */
#else
		uint32_t addr                        : 7;
		uint32_t bank                        : 2;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_arbiter_sta_s cn88xx; */
	/* struct bdk_tns_sde_mreb_arbiter_sta_s cn88xxp1; */
} bdk_tns_sde_mreb_arbiter_sta_t;

#define BDK_TNS_SDE_MREB_ARBITER_STA BDK_TNS_SDE_MREB_ARBITER_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_ARBITER_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_ARBITER_STA_FUNC(void)
{
	return 0x00008420607804C0ull;
}
#define typedef_BDK_TNS_SDE_MREB_ARBITER_STA bdk_tns_sde_mreb_arbiter_sta_t
#define bustype_BDK_TNS_SDE_MREB_ARBITER_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_ARBITER_STA 0
#define arguments_BDK_TNS_SDE_MREB_ARBITER_STA -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_ARBITER_STA "TNS_SDE_MREB_ARBITER_STA"


/**
 * NCB32b - tns_sde_mreb_copies_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_copies_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_copies_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of copies not suppressed by MRE. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_copies_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_copies_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_copies_ct_t;

#define BDK_TNS_SDE_MREB_COPIES_CT BDK_TNS_SDE_MREB_COPIES_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_COPIES_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_COPIES_CT_FUNC(void)
{
	return 0x00008420607804D8ull;
}
#define typedef_BDK_TNS_SDE_MREB_COPIES_CT bdk_tns_sde_mreb_copies_ct_t
#define bustype_BDK_TNS_SDE_MREB_COPIES_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_COPIES_CT 0
#define arguments_BDK_TNS_SDE_MREB_COPIES_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_COPIES_CT "TNS_SDE_MREB_COPIES_CT"


/**
 * NCB32b - tns_sde_mreb_drp_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_drp_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_drp_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of copies issued but marked as 'drop' by MRE. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_drp_ct_s   cn88xx; */
	/* struct bdk_tns_sde_mreb_drp_ct_s   cn88xxp1; */
} bdk_tns_sde_mreb_drp_ct_t;

#define BDK_TNS_SDE_MREB_DRP_CT BDK_TNS_SDE_MREB_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_DRP_CT_FUNC(void)
{
	return 0x00008420607804DCull;
}
#define typedef_BDK_TNS_SDE_MREB_DRP_CT bdk_tns_sde_mreb_drp_ct_t
#define bustype_BDK_TNS_SDE_MREB_DRP_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_DRP_CT 0
#define arguments_BDK_TNS_SDE_MREB_DRP_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_DRP_CT "TNS_SDE_MREB_DRP_CT"


/**
 * NCB32b - tns_sde_mreb_feedback_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_feedback_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_feedback_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of times a response from SE caused another request to be issued. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_feedback_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_feedback_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_feedback_ct_t;

#define BDK_TNS_SDE_MREB_FEEDBACK_CT BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_FEEDBACK_CT_FUNC(void)
{
	return 0x00008420607804E0ull;
}
#define typedef_BDK_TNS_SDE_MREB_FEEDBACK_CT bdk_tns_sde_mreb_feedback_ct_t
#define bustype_BDK_TNS_SDE_MREB_FEEDBACK_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_FEEDBACK_CT 0
#define arguments_BDK_TNS_SDE_MREB_FEEDBACK_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_FEEDBACK_CT "TNS_SDE_MREB_FEEDBACK_CT"


/**
 * NCB32b - tns_sde_mreb_filter_cfg
 *
 * Configures the Filter feature. The filter feature may select any contiguous 3
 * bytes from the Scratchpad, or the IVif. The selcted data is masked
 * (based on this register) and matched against a 24 bit field in the MDT
 * table.
 */
typedef union bdk_tns_sde_mreb_filter_cfg {
	uint32_t u;
	struct bdk_tns_sde_mreb_filter_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_27_31              : 5;
		uint32_t mask                        : 24; /**< R/W - Mask to apply to the data */
		uint32_t sel                         : 3;  /**< R/W - '"Selects the field in the token to use: \n
                                                                 0 - scratchpad bytes 2, 1, 0 \n
                                                                 1 - scratchpad bytes 3, 2, 1 \n
                                                                 2 - scratchpad bytes 4, 3, 2 \n
                                                                 3 - scratchpad bytes 5, 4, 3 \n
                                                                 4 - scratchpad bytes 6, 5, 4 \n
                                                                 5 - scratchpad bytes 7, 6, 5 \n
                                                                 6 - reserved \n
                                                                 7 - IVIF' */
#else
		uint32_t sel                         : 3;
		uint32_t mask                        : 24;
		uint32_t reserved_27_31              : 5;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_filter_cfg_s cn88xx; */
	/* struct bdk_tns_sde_mreb_filter_cfg_s cn88xxp1; */
} bdk_tns_sde_mreb_filter_cfg_t;

#define BDK_TNS_SDE_MREB_FILTER_CFG BDK_TNS_SDE_MREB_FILTER_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_FILTER_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_FILTER_CFG_FUNC(void)
{
	return 0x0000842060780400ull;
}
#define typedef_BDK_TNS_SDE_MREB_FILTER_CFG bdk_tns_sde_mreb_filter_cfg_t
#define bustype_BDK_TNS_SDE_MREB_FILTER_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_FILTER_CFG 0
#define arguments_BDK_TNS_SDE_MREB_FILTER_CFG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_FILTER_CFG "TNS_SDE_MREB_FILTER_CFG"


/**
 * NCB32b - tns_sde_mreb_hbuf_cyc_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_hbuf_cyc_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_hbuf_cyc_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of cycles written to header buffer. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_hbuf_cyc_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_hbuf_cyc_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_hbuf_cyc_ct_t;

#define BDK_TNS_SDE_MREB_HBUF_CYC_CT BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_CYC_CT_FUNC(void)
{
	return 0x00008420607804E4ull;
}
#define typedef_BDK_TNS_SDE_MREB_HBUF_CYC_CT bdk_tns_sde_mreb_hbuf_cyc_ct_t
#define bustype_BDK_TNS_SDE_MREB_HBUF_CYC_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_HBUF_CYC_CT 0
#define arguments_BDK_TNS_SDE_MREB_HBUF_CYC_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_HBUF_CYC_CT "TNS_SDE_MREB_HBUF_CYC_CT"


/**
 * NCB32b - tns_sde_mreb_hbuf_pkt_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_hbuf_pkt_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_hbuf_pkt_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of packets written to header buffer. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_hbuf_pkt_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_hbuf_pkt_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_hbuf_pkt_ct_t;

#define BDK_TNS_SDE_MREB_HBUF_PKT_CT BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HBUF_PKT_CT_FUNC(void)
{
	return 0x00008420607804E8ull;
}
#define typedef_BDK_TNS_SDE_MREB_HBUF_PKT_CT bdk_tns_sde_mreb_hbuf_pkt_ct_t
#define bustype_BDK_TNS_SDE_MREB_HBUF_PKT_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_HBUF_PKT_CT 0
#define arguments_BDK_TNS_SDE_MREB_HBUF_PKT_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_HBUF_PKT_CT "TNS_SDE_MREB_HBUF_PKT_CT"


/**
 * NCB32b - tns_sde_mreb_hmem_free_inst
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_hmem_free_inst {
	uint32_t u;
	struct bdk_tns_sde_mreb_hmem_free_inst_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of operations issued instructing the hdr memory to return the page to
                                                                 the free pool. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_hmem_free_inst_s cn88xx; */
	/* struct bdk_tns_sde_mreb_hmem_free_inst_s cn88xxp1; */
} bdk_tns_sde_mreb_hmem_free_inst_t;

#define BDK_TNS_SDE_MREB_HMEM_FREE_INST BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_HMEM_FREE_INST_FUNC(void)
{
	return 0x00008420607804ECull;
}
#define typedef_BDK_TNS_SDE_MREB_HMEM_FREE_INST bdk_tns_sde_mreb_hmem_free_inst_t
#define bustype_BDK_TNS_SDE_MREB_HMEM_FREE_INST BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_HMEM_FREE_INST 0
#define arguments_BDK_TNS_SDE_MREB_HMEM_FREE_INST -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_HMEM_FREE_INST "TNS_SDE_MREB_HMEM_FREE_INST"


/**
 * NCB32b - tns_sde_mreb_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_mreb_lock {
	uint32_t u;
	struct bdk_tns_sde_mreb_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_lock_s     cn88xx; */
	/* struct bdk_tns_sde_mreb_lock_s     cn88xxp1; */
} bdk_tns_sde_mreb_lock_t;

#define BDK_TNS_SDE_MREB_LOCK BDK_TNS_SDE_MREB_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_LOCK_FUNC(void)
{
	return 0x00008420607804F4ull;
}
#define typedef_BDK_TNS_SDE_MREB_LOCK bdk_tns_sde_mreb_lock_t
#define bustype_BDK_TNS_SDE_MREB_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_LOCK 0
#define arguments_BDK_TNS_SDE_MREB_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_LOCK "TNS_SDE_MREB_LOCK"


/**
 * NCB32b - tns_sde_mreb_pipegrid_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_pipegrid_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_pipegrid_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of tokens sent to pipegrid. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_pipegrid_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_pipegrid_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_pipegrid_ct_t;

#define BDK_TNS_SDE_MREB_PIPEGRID_CT BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_PIPEGRID_CT_FUNC(void)
{
	return 0x00008420607804F0ull;
}
#define typedef_BDK_TNS_SDE_MREB_PIPEGRID_CT bdk_tns_sde_mreb_pipegrid_ct_t
#define bustype_BDK_TNS_SDE_MREB_PIPEGRID_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_PIPEGRID_CT 0
#define arguments_BDK_TNS_SDE_MREB_PIPEGRID_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_PIPEGRID_CT "TNS_SDE_MREB_PIPEGRID_CT"


/**
 * NCB - tns_sde_mreb_rcv
 *
 * Valid vector for each of the two receive stores. The receive store contains the
 * data returned from
 * SE requests.
 */
typedef union bdk_tns_sde_mreb_rcv {
	uint64_t u;
	struct bdk_tns_sde_mreb_rcv_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t store_0_vld                 : 32; /**< RO/H - -- */
		uint64_t store_1_vld                 : 32; /**< RO/H - -- */
#else
		uint64_t store_1_vld                 : 32;
		uint64_t store_0_vld                 : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_rcv_s      cn88xx; */
	/* struct bdk_tns_sde_mreb_rcv_s      cn88xxp1; */
} bdk_tns_sde_mreb_rcv_t;

#define BDK_TNS_SDE_MREB_RCV BDK_TNS_SDE_MREB_RCV_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_RCV_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_RCV_FUNC(void)
{
	return 0x00008420607804B0ull;
}
#define typedef_BDK_TNS_SDE_MREB_RCV bdk_tns_sde_mreb_rcv_t
#define bustype_BDK_TNS_SDE_MREB_RCV BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MREB_RCV 0
#define arguments_BDK_TNS_SDE_MREB_RCV -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_RCV "TNS_SDE_MREB_RCV"


/**
 * NCB32b - tns_sde_mreb_req
 *
 * Current value of the req counter. Counts outstanding requests to SE MRE is
 * waiting for.
 */
typedef union bdk_tns_sde_mreb_req {
	uint32_t u;
	struct bdk_tns_sde_mreb_req_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t counter                     : 8;  /**< RO/H - -- */
#else
		uint32_t counter                     : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_req_s      cn88xx; */
	/* struct bdk_tns_sde_mreb_req_s      cn88xxp1; */
} bdk_tns_sde_mreb_req_t;

#define BDK_TNS_SDE_MREB_REQ BDK_TNS_SDE_MREB_REQ_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_REQ_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_REQ_FUNC(void)
{
	return 0x00008420607804B8ull;
}
#define typedef_BDK_TNS_SDE_MREB_REQ bdk_tns_sde_mreb_req_t
#define bustype_BDK_TNS_SDE_MREB_REQ BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_REQ 0
#define arguments_BDK_TNS_SDE_MREB_REQ -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_REQ "TNS_SDE_MREB_REQ"


/**
 * NCB32b - tns_sde_mreb_se_req_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_se_req_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_se_req_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of requests issued to SE. (At input of DFC module). */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_se_req_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_se_req_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_se_req_ct_t;

#define BDK_TNS_SDE_MREB_SE_REQ_CT BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_REQ_CT_FUNC(void)
{
	return 0x00008420607804C8ull;
}
#define typedef_BDK_TNS_SDE_MREB_SE_REQ_CT bdk_tns_sde_mreb_se_req_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_REQ_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_SE_REQ_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_REQ_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_SE_REQ_CT "TNS_SDE_MREB_SE_REQ_CT"


/**
 * NCB32b - tns_sde_mreb_se_resp0_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_se_resp0_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_se_resp0_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of responses received from SE on lane 0. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_se_resp0_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_se_resp0_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_se_resp0_ct_t;

#define BDK_TNS_SDE_MREB_SE_RESP0_CT BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP0_CT_FUNC(void)
{
	return 0x00008420607804CCull;
}
#define typedef_BDK_TNS_SDE_MREB_SE_RESP0_CT bdk_tns_sde_mreb_se_resp0_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_RESP0_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_SE_RESP0_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_RESP0_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_SE_RESP0_CT "TNS_SDE_MREB_SE_RESP0_CT"


/**
 * NCB32b - tns_sde_mreb_se_resp1_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_se_resp1_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_se_resp1_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of responses received from SE on lane 1. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_se_resp1_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_se_resp1_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_se_resp1_ct_t;

#define BDK_TNS_SDE_MREB_SE_RESP1_CT BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SE_RESP1_CT_FUNC(void)
{
	return 0x00008420607804D0ull;
}
#define typedef_BDK_TNS_SDE_MREB_SE_RESP1_CT bdk_tns_sde_mreb_se_resp1_ct_t
#define bustype_BDK_TNS_SDE_MREB_SE_RESP1_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_SE_RESP1_CT 0
#define arguments_BDK_TNS_SDE_MREB_SE_RESP1_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_SE_RESP1_CT "TNS_SDE_MREB_SE_RESP1_CT"


/**
 * NCB32b - tns_sde_mreb_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_mreb_spad {
	uint32_t u;
	struct bdk_tns_sde_mreb_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_spad_s     cn88xx; */
	/* struct bdk_tns_sde_mreb_spad_s     cn88xxp1; */
} bdk_tns_sde_mreb_spad_t;

#define BDK_TNS_SDE_MREB_SPAD BDK_TNS_SDE_MREB_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SPAD_FUNC(void)
{
	return 0x00008420607804F8ull;
}
#define typedef_BDK_TNS_SDE_MREB_SPAD bdk_tns_sde_mreb_spad_t
#define bustype_BDK_TNS_SDE_MREB_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_SPAD 0
#define arguments_BDK_TNS_SDE_MREB_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_SPAD "TNS_SDE_MREB_SPAD"


/**
 * NCB32b - tns_sde_mreb_sprsd_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_sprsd_ct {
	uint32_t u;
	struct bdk_tns_sde_mreb_sprsd_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of copies suppressed by MRE. */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_sprsd_ct_s cn88xx; */
	/* struct bdk_tns_sde_mreb_sprsd_ct_s cn88xxp1; */
} bdk_tns_sde_mreb_sprsd_ct_t;

#define BDK_TNS_SDE_MREB_SPRSD_CT BDK_TNS_SDE_MREB_SPRSD_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_SPRSD_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_SPRSD_CT_FUNC(void)
{
	return 0x00008420607804D4ull;
}
#define typedef_BDK_TNS_SDE_MREB_SPRSD_CT bdk_tns_sde_mreb_sprsd_ct_t
#define bustype_BDK_TNS_SDE_MREB_SPRSD_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_SPRSD_CT 0
#define arguments_BDK_TNS_SDE_MREB_SPRSD_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_SPRSD_CT "TNS_SDE_MREB_SPRSD_CT"


/**
 * NCB32b - tns_sde_mreb_tkn_mem_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_tkn_mem_adr {
	uint32_t u;
	struct bdk_tns_sde_mreb_tkn_mem_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t page                        : 7;  /**< R/W - -- */
#else
		uint32_t page                        : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_tkn_mem_adr_s cn88xx; */
	/* struct bdk_tns_sde_mreb_tkn_mem_adr_s cn88xxp1; */
} bdk_tns_sde_mreb_tkn_mem_adr_t;

#define BDK_TNS_SDE_MREB_TKN_MEM_ADR BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ADR_FUNC(void)
{
	return 0x0000842060780408ull;
}
#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_ADR bdk_tns_sde_mreb_tkn_mem_adr_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_ADR 0
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_ADR "TNS_SDE_MREB_TKN_MEM_ADR"


/**
 * NCB32b - tns_sde_mreb_tkn_mem_dat_w#
 *
 * Bits 31..20 of registers ending in _W40 are unused.
 *
 */
typedef union bdk_tns_sde_mreb_tkn_mem_dat_wx {
	uint32_t u;
	struct bdk_tns_sde_mreb_tkn_mem_dat_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_data                  : 32; /**< R/W/H - -- */
#else
		uint32_t token_data                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_tkn_mem_dat_wx_s cn88xx; */
	/* struct bdk_tns_sde_mreb_tkn_mem_dat_wx_s cn88xxp1; */
} bdk_tns_sde_mreb_tkn_mem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(unsigned long param1)
{
	if (((param1 <= 40)))
		return 0x000084206078040Cull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(...) bdk_tns_sde_mreb_tkn_mem_dat_wx_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_DAT_WX(...) "TNS_SDE_MREB_TKN_MEM_DAT_WX"


/**
 * NCB32b - tns_sde_mreb_tkn_mem_ecc_err
 *
 * --
 *
 */
typedef union bdk_tns_sde_mreb_tkn_mem_ecc_err {
	uint32_t u;
	struct bdk_tns_sde_mreb_tkn_mem_ecc_err_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t log                         : 28; /**< R/W/H - Data logged is defined as {captured, token_mem_db_err[9:0],
                                                                 token_mem_sb_err[9:0], token_mem_rd_addr_d[6:0]} */
#else
		uint32_t log                         : 28;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_sde_mreb_tkn_mem_ecc_err_s cn88xx; */
	/* struct bdk_tns_sde_mreb_tkn_mem_ecc_err_s cn88xxp1; */
} bdk_tns_sde_mreb_tkn_mem_ecc_err_t;

#define BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR_FUNC(void)
{
	return 0x00008420607804BCull;
}
#define typedef_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR bdk_tns_sde_mreb_tkn_mem_ecc_err_t
#define bustype_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MREB_TKN_MEM_ECC_ERR "TNS_SDE_MREB_TKN_MEM_ECC_ERR"


/**
 * NCB32b - tns_sde_mret_arbiter_cfg_w0
 *
 * Controls the behaviour of the arbiter in the MRE.
 *
 */
typedef union bdk_tns_sde_mret_arbiter_cfg_w0 {
	uint32_t u;
	struct bdk_tns_sde_mret_arbiter_cfg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t wrr_weight2                 : 8;  /**< R/W - Weight to be used for priority 1, if part of the WRR arbitration */
		uint32_t wrr_weight1                 : 12; /**< R/W - Weight to be used for priority 2, if part of the WRR arbitration */
		uint32_t wrr_weight0                 : 12; /**< R/W - Weight to be used for priority 3, if part of the WRR arbitration */
#else
		uint32_t wrr_weight0                 : 12;
		uint32_t wrr_weight1                 : 12;
		uint32_t wrr_weight2                 : 8;
#endif
	} s;
	/* struct bdk_tns_sde_mret_arbiter_cfg_w0_s cn88xx; */
	/* struct bdk_tns_sde_mret_arbiter_cfg_w0_s cn88xxp1; */
} bdk_tns_sde_mret_arbiter_cfg_w0_t;

#define BDK_TNS_SDE_MRET_ARBITER_CFG_W0 BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W0_FUNC(void)
{
	return 0x0000842060780034ull;
}
#define typedef_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 bdk_tns_sde_mret_arbiter_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_ARBITER_CFG_W0 "TNS_SDE_MRET_ARBITER_CFG_W0"


/**
 * NCB32b - tns_sde_mret_arbiter_cfg_w1
 *
 * Continuation of structure defined in TNS_SDE_MRET_ARBITER_CFG_W0
 *
 */
typedef union bdk_tns_sde_mret_arbiter_cfg_w1 {
	uint32_t u;
	struct bdk_tns_sde_mret_arbiter_cfg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t wrr_bypass                  : 4;  /**< R/W - Indicates which priorities should bypass the WRR portion of the arbiter and
                                                                 directly pass on to the strict priority arbiter. */
		uint32_t wrr_weight3                 : 12; /**< R/W - Weight to be used for priority 0, if part of the WRR arbitration */
		uint32_t wrr_weight2                 : 4;  /**< R/W - Continuation of MSBs of field WRR_WEIGHT2 from previous word. */
#else
		uint32_t wrr_weight2                 : 4;
		uint32_t wrr_weight3                 : 12;
		uint32_t wrr_bypass                  : 4;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_mret_arbiter_cfg_w1_s cn88xx; */
	/* struct bdk_tns_sde_mret_arbiter_cfg_w1_s cn88xxp1; */
} bdk_tns_sde_mret_arbiter_cfg_w1_t;

#define BDK_TNS_SDE_MRET_ARBITER_CFG_W1 BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ARBITER_CFG_W1_FUNC(void)
{
	return 0x0000842060780038ull;
}
#define typedef_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 bdk_tns_sde_mret_arbiter_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_ARBITER_CFG_W1 "TNS_SDE_MRET_ARBITER_CFG_W1"


/**
 * NCB - tns_sde_mret_cfg2
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_cfg2 {
	uint64_t u;
	struct bdk_tns_sde_mret_cfg2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_42_63              : 22;
		uint64_t page_fifo_prio3_flip_sb_ecc : 1;  /**< R/W - Force single bit ecc error. */
		uint64_t page_fifo_prio3_flip_db_ecc : 1;  /**< R/W - Force dual bit ecc error. */
		uint64_t page_fifo_prio2_flip_sb_ecc : 1;  /**< R/W - Force single bit ecc error. */
		uint64_t page_fifo_prio2_flip_db_ecc : 1;  /**< R/W - Force dual bit ecc error. */
		uint64_t page_fifo_prio1_flip_sb_ecc : 1;  /**< R/W - Force single bit ecc error. */
		uint64_t page_fifo_prio1_flip_db_ecc : 1;  /**< R/W - Force dual bit ecc error. */
		uint64_t page_fifo_prio0_flip_sb_ecc : 1;  /**< R/W - Force single bit ecc error. */
		uint64_t page_fifo_prio0_flip_db_ecc : 1;  /**< R/W - Force dual bit ecc error. */
		uint64_t token_mem_bank_flip_sb_ecc  : 10; /**< R/W - Force single bit ecc error. */
		uint64_t token_mem_bank_flip_db_ecc  : 10; /**< R/W - Force dual bit ecc error. */
		uint64_t freelist_flip_sb_ecc        : 1;  /**< R/W - Force single bit ecc error. */
		uint64_t freelist_flip_db_ecc        : 1;  /**< R/W - Force dual bit ecc error. */
		uint64_t hdr_mem_flip_sb_ecc         : 4;  /**< R/W - Force single bit ecc error. */
		uint64_t hdr_mem_flip_db_ecc         : 4;  /**< R/W - Force dual bit ecc error. */
		uint64_t cntx_mem_flip_sb_ecc        : 2;  /**< R/W - Force single bit ecc error. */
		uint64_t cntx_mem_flip_db_ecc        : 2;  /**< R/W - Force dual bit ecc error. */
#else
		uint64_t cntx_mem_flip_db_ecc        : 2;
		uint64_t cntx_mem_flip_sb_ecc        : 2;
		uint64_t hdr_mem_flip_db_ecc         : 4;
		uint64_t hdr_mem_flip_sb_ecc         : 4;
		uint64_t freelist_flip_db_ecc        : 1;
		uint64_t freelist_flip_sb_ecc        : 1;
		uint64_t token_mem_bank_flip_db_ecc  : 10;
		uint64_t token_mem_bank_flip_sb_ecc  : 10;
		uint64_t page_fifo_prio0_flip_db_ecc : 1;
		uint64_t page_fifo_prio0_flip_sb_ecc : 1;
		uint64_t page_fifo_prio1_flip_db_ecc : 1;
		uint64_t page_fifo_prio1_flip_sb_ecc : 1;
		uint64_t page_fifo_prio2_flip_db_ecc : 1;
		uint64_t page_fifo_prio2_flip_sb_ecc : 1;
		uint64_t page_fifo_prio3_flip_db_ecc : 1;
		uint64_t page_fifo_prio3_flip_sb_ecc : 1;
		uint64_t reserved_42_63              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_mret_cfg2_s     cn88xx; */
	/* struct bdk_tns_sde_mret_cfg2_s     cn88xxp1; */
} bdk_tns_sde_mret_cfg2_t;

#define BDK_TNS_SDE_MRET_CFG2 BDK_TNS_SDE_MRET_CFG2_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG2_FUNC(void)
{
	return 0x0000842060780020ull;
}
#define typedef_BDK_TNS_SDE_MRET_CFG2 bdk_tns_sde_mret_cfg2_t
#define bustype_BDK_TNS_SDE_MRET_CFG2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_CFG2 0
#define arguments_BDK_TNS_SDE_MRET_CFG2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CFG2 "TNS_SDE_MRET_CFG2"


/**
 * NCB32b - tns_sde_mret_cfg_null_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_cfg_null_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_cfg_null_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t value                       : 18; /**< R/W - Value to be used as NULL pointer in the MDT table. */
#else
		uint32_t value                       : 18;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_mret_cfg_null_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_cfg_null_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_cfg_null_ptr_t;

#define BDK_TNS_SDE_MRET_CFG_NULL_PTR BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_NULL_PTR_FUNC(void)
{
	return 0x0000842060780008ull;
}
#define typedef_BDK_TNS_SDE_MRET_CFG_NULL_PTR bdk_tns_sde_mret_cfg_null_ptr_t
#define bustype_BDK_TNS_SDE_MRET_CFG_NULL_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_CFG_NULL_PTR 0
#define arguments_BDK_TNS_SDE_MRET_CFG_NULL_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CFG_NULL_PTR "TNS_SDE_MRET_CFG_NULL_PTR"


/**
 * NCB - tns_sde_mret_cfg_rcod
 *
 * Stores the reason code used for various conditions for which the MRE would send
 * out a token with packet command = DROP.
 */
typedef union bdk_tns_sde_mret_cfg_rcod {
	uint64_t u;
	struct bdk_tns_sde_mret_cfg_rcod_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t ttl_fail                    : 10; /**< R/W - The tokens internal TTL expired, and this copy was not entirely suppressed. */
		uint64_t first_live_fail             : 10; /**< R/W - The node in the tree was first_live entry and the first live check did not
                                                                 pass. */
		uint64_t mirror_fail                 : 10; /**< R/W - The node in the tree was a mirror entry and the mirror check did not pass. */
		uint64_t filter                      : 10; /**< R/W - The token was filtered using the filter feature. */
#else
		uint64_t filter                      : 10;
		uint64_t mirror_fail                 : 10;
		uint64_t first_live_fail             : 10;
		uint64_t ttl_fail                    : 10;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_cfg_rcod_s cn88xx; */
	/* struct bdk_tns_sde_mret_cfg_rcod_s cn88xxp1; */
} bdk_tns_sde_mret_cfg_rcod_t;

#define BDK_TNS_SDE_MRET_CFG_RCOD BDK_TNS_SDE_MRET_CFG_RCOD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_RCOD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_RCOD_FUNC(void)
{
	return 0x0000842060780018ull;
}
#define typedef_BDK_TNS_SDE_MRET_CFG_RCOD bdk_tns_sde_mret_cfg_rcod_t
#define bustype_BDK_TNS_SDE_MRET_CFG_RCOD BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_CFG_RCOD 0
#define arguments_BDK_TNS_SDE_MRET_CFG_RCOD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CFG_RCOD "TNS_SDE_MRET_CFG_RCOD"


/**
 * NCB32b - tns_sde_mret_cfg_w0
 *
 * General Config for MRE
 *
 */
typedef union bdk_tns_sde_mret_cfg_w0 {
	uint32_t u;
	struct bdk_tns_sde_mret_cfg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pkt_cmd_for_drop            : 2;  /**< R/W - Packet Command value be used when MRE decides to suppress the copy */
		uint32_t mre_en                      : 1;  /**< R/W - -- */
		uint32_t memwr_cntrl_fl_init         : 1;  /**< R/W - A transition from 0 to 1 on each of these signals
                                                                 triggers the freelist initialization of the corresponding
                                                                 MemWrCntrl module. */
		uint32_t hdr_mem_read_req_thr        : 4;  /**< R/W - Number of outstanding requests issued to the header memory.
                                                                 Should be set equal to the read latency to the memory. */
		uint32_t mre_output_shp_timebase     : 8;  /**< R/W - -- */
		uint32_t mre_output_shp_allowed      : 8;  /**< R/W - MRE will be allowed a maximum number of mre_output_shaper_allowed Tokens
                                                                 to be injected into the PipeGrid, every mre_output_shaper_timebase
                                                                 clock cycles. */
		uint32_t freelist_usage_threshold    : 8;  /**< R/W - Usage threshold for the freelist. When the level of entries in the freelist
                                                                 drops below this level,
                                                                 FC will be asserted for all priorities in the channel. */
#else
		uint32_t freelist_usage_threshold    : 8;
		uint32_t mre_output_shp_allowed      : 8;
		uint32_t mre_output_shp_timebase     : 8;
		uint32_t hdr_mem_read_req_thr        : 4;
		uint32_t memwr_cntrl_fl_init         : 1;
		uint32_t mre_en                      : 1;
		uint32_t pkt_cmd_for_drop            : 2;
#endif
	} s;
	/* struct bdk_tns_sde_mret_cfg_w0_s   cn88xx; */
	/* struct bdk_tns_sde_mret_cfg_w0_s   cn88xxp1; */
} bdk_tns_sde_mret_cfg_w0_t;

#define BDK_TNS_SDE_MRET_CFG_W0 BDK_TNS_SDE_MRET_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W0_FUNC(void)
{
	return 0x000084206078000Cull;
}
#define typedef_BDK_TNS_SDE_MRET_CFG_W0 bdk_tns_sde_mret_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_CFG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_CFG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CFG_W0 "TNS_SDE_MRET_CFG_W0"


/**
 * NCB32b - tns_sde_mret_cfg_w1
 *
 * Continuation of structure defined in TNS_SDE_MRET_CFG_W0
 *
 */
typedef union bdk_tns_sde_mret_cfg_w1 {
	uint32_t u;
	struct bdk_tns_sde_mret_cfg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t freecache_rst               : 4;  /**< R/W - Resets the cache of prefetched free entries received from HDBF. 1 bit per
                                                                 channel. */
		uint32_t suppress_en                 : 1;  /**< R/W - If cleared, all packets that should be suppressed are dropped instead. */
		uint32_t nxt_engine_urw              : 8;  /**< R/W - Nxt_engine code for the URW module. This will be used for any packets dropped
                                                                 by MRE." */
		uint32_t hdbf_freepage_cache_thr     : 4;  /**< R/W - Number of unused free entry requests queued by MRE */
		uint32_t freepage_return_en          : 1;  /**< R/W - Enables returning entries to the freelist */
#else
		uint32_t freepage_return_en          : 1;
		uint32_t hdbf_freepage_cache_thr     : 4;
		uint32_t nxt_engine_urw              : 8;
		uint32_t suppress_en                 : 1;
		uint32_t freecache_rst               : 4;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_mret_cfg_w1_s   cn88xx; */
	/* struct bdk_tns_sde_mret_cfg_w1_s   cn88xxp1; */
} bdk_tns_sde_mret_cfg_w1_t;

#define BDK_TNS_SDE_MRET_CFG_W1 BDK_TNS_SDE_MRET_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CFG_W1_FUNC(void)
{
	return 0x0000842060780010ull;
}
#define typedef_BDK_TNS_SDE_MRET_CFG_W1 bdk_tns_sde_mret_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_CFG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_CFG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CFG_W1 "TNS_SDE_MRET_CFG_W1"


/**
 * NCB32b - tns_sde_mret_ctx_mem_ecc_err
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_ctx_mem_ecc_err {
	uint32_t u;
	struct bdk_tns_sde_mret_ctx_mem_ecc_err_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t log                         : 12; /**< R/W/H - Data logged is defined as {captured, cntx_mem_db_err[1:0],
                                                                 cntx_mem_sb_err[1:0], cntx_mem_rd_addr_d[6:0]} */
#else
		uint32_t log                         : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_mret_ctx_mem_ecc_err_s cn88xx; */
	/* struct bdk_tns_sde_mret_ctx_mem_ecc_err_s cn88xxp1; */
} bdk_tns_sde_mret_ctx_mem_ecc_err_t;

#define BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR_FUNC(void)
{
	return 0x00008420607800FCull;
}
#define typedef_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR bdk_tns_sde_mret_ctx_mem_ecc_err_t
#define bustype_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CTX_MEM_ECC_ERR "TNS_SDE_MRET_CTX_MEM_ECC_ERR"


/**
 * NCB32b - tns_sde_mret_ctxt_mem_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_ctxt_mem_adr {
	uint32_t u;
	struct bdk_tns_sde_mret_ctxt_mem_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t page                        : 7;  /**< R/W - -- */
#else
		uint32_t page                        : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_mret_ctxt_mem_adr_s cn88xx; */
	/* struct bdk_tns_sde_mret_ctxt_mem_adr_s cn88xxp1; */
} bdk_tns_sde_mret_ctxt_mem_adr_t;

#define BDK_TNS_SDE_MRET_CTXT_MEM_ADR BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_ADR_FUNC(void)
{
	return 0x000084206078009Cull;
}
#define typedef_BDK_TNS_SDE_MRET_CTXT_MEM_ADR bdk_tns_sde_mret_ctxt_mem_adr_t
#define bustype_BDK_TNS_SDE_MRET_CTXT_MEM_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_CTXT_MEM_ADR 0
#define arguments_BDK_TNS_SDE_MRET_CTXT_MEM_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CTXT_MEM_ADR "TNS_SDE_MRET_CTXT_MEM_ADR"


/**
 * NCB - tns_sde_mret_ctxt_mem_dat_w#
 *
 * Bits 63..40 of registers ending in _W2 are unused.
 *
 */
typedef union bdk_tns_sde_mret_ctxt_mem_dat_wx {
	uint64_t u;
	struct bdk_tns_sde_mret_ctxt_mem_dat_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cntxt_mem_data              : 64; /**< R/W/H - -- */
#else
		uint64_t cntxt_mem_data              : 64;
#endif
	} s;
	/* struct bdk_tns_sde_mret_ctxt_mem_dat_wx_s cn88xx; */
	/* struct bdk_tns_sde_mret_ctxt_mem_dat_wx_s cn88xxp1; */
} bdk_tns_sde_mret_ctxt_mem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(unsigned long param1)
{
	if (((param1 <= 2)))
		return 0x00008420607800A0ull + (param1 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(...) bdk_tns_sde_mret_ctxt_mem_dat_wx_t
#define bustype_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_CTXT_MEM_DAT_WX(...) "TNS_SDE_MRET_CTXT_MEM_DAT_WX"


/**
 * NCB32b - tns_sde_mret_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_mret_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_sde_mret_dbg_sel_s  cn88xxp1; */
} bdk_tns_sde_mret_dbg_sel_t;

#define BDK_TNS_SDE_MRET_DBG_SEL BDK_TNS_SDE_MRET_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_DBG_SEL_FUNC(void)
{
	return 0x0000842060780004ull;
}
#define typedef_BDK_TNS_SDE_MRET_DBG_SEL bdk_tns_sde_mret_dbg_sel_t
#define bustype_BDK_TNS_SDE_MRET_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_DBG_SEL 0
#define arguments_BDK_TNS_SDE_MRET_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_DBG_SEL "TNS_SDE_MRET_DBG_SEL"


/**
 * NCB32b - tns_sde_mret_ecc_ctl_cd
 *
 * If set each bit disables ECC correction for the corresponding memory.
 *
 */
typedef union bdk_tns_sde_mret_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_mret_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t hdr_mem                     : 1;  /**< R/W - -- */
		uint32_t cntx_mem                    : 1;  /**< R/W - -- */
		uint32_t token_mem                   : 1;  /**< R/W - -- */
		uint32_t freelist                    : 1;  /**< R/W - -- */
		uint32_t page_fifo                   : 4;  /**< R/W - -- */
#else
		uint32_t page_fifo                   : 4;
		uint32_t freelist                    : 1;
		uint32_t token_mem                   : 1;
		uint32_t cntx_mem                    : 1;
		uint32_t hdr_mem                     : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_mret_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_mret_ecc_ctl_cd_t;

#define BDK_TNS_SDE_MRET_ECC_CTL_CD BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_ECC_CTL_CD_FUNC(void)
{
	return 0x0000842060780014ull;
}
#define typedef_BDK_TNS_SDE_MRET_ECC_CTL_CD bdk_tns_sde_mret_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_MRET_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_MRET_ECC_CTL_CD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_ECC_CTL_CD "TNS_SDE_MRET_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_mret_feature_en
 *
 * Allows enabling or disabling individual MRE features.
 *
 */
typedef union bdk_tns_sde_mret_feature_en {
	uint32_t u;
	struct bdk_tns_sde_mret_feature_en_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t use_alt_evif                : 1;  /**< R/W - When enabled token.common_static.sde_control.reserved_0[0] will be set to
                                                                 mdt_table_data.set_use_alt_evif */
		uint32_t l3_ptr                      : 1;  /**< R/W - When enabled a two-tier linked list structure is possible. When disabled the
                                                                 corresponding 18 bits in the MDT are reserved. */
		uint32_t last_entry                  : 1;  /**< R/W - Enables the last entry feature globally for MRE. If disabled, the corresponding
                                                                 bit in the MDT is reserved, and mre_last_copy
                                                                 will be set when the end of the tree has been reached. If enabled, the
                                                                 mre_last_copy bit is set from the the
                                                                 mdt_table.last_entry bit. */
		uint32_t first_live                  : 1;  /**< R/W - Enables the first Live feature globally for MRE. If disabled, the 2
                                                                 corresponding bits in the MDT are reserved. */
		uint32_t mirror_filter               : 1;  /**< R/W - Enables the mirror filter feature globally for MRE. If disabled, the 5
                                                                 corresponding bits in the MDT are reserved. */
		uint32_t evif_mod                    : 1;  /**< R/W - Enables eVif modification globally for MRE. If disabled, the 21 corresponding
                                                                 bits in the MDT are reserved. */
		uint32_t nxt_engine                  : 1;  /**< R/W - Enables the nxt_engine in the MDT globally for MRE. If disabled, the 8
                                                                 corresponding bits in the MDT are reserved. */
		uint32_t filter                      : 1;  /**< R/W - Enables the filter feature in the MDT globally for MRE. If disabled, the 25
                                                                 corresponding bits in the MDT are reserved. */
		uint32_t ttl_check                   : 1;  /**< R/W - Enables the internal TTL check. */
		uint32_t ttl_dec                     : 1;  /**< R/W - Enables the internal TTL decrement. */
#else
		uint32_t ttl_dec                     : 1;
		uint32_t ttl_check                   : 1;
		uint32_t filter                      : 1;
		uint32_t nxt_engine                  : 1;
		uint32_t evif_mod                    : 1;
		uint32_t mirror_filter               : 1;
		uint32_t first_live                  : 1;
		uint32_t last_entry                  : 1;
		uint32_t l3_ptr                      : 1;
		uint32_t use_alt_evif                : 1;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_mret_feature_en_s cn88xx; */
	/* struct bdk_tns_sde_mret_feature_en_s cn88xxp1; */
} bdk_tns_sde_mret_feature_en_t;

#define BDK_TNS_SDE_MRET_FEATURE_EN BDK_TNS_SDE_MRET_FEATURE_EN_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FEATURE_EN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FEATURE_EN_FUNC(void)
{
	return 0x0000842060780028ull;
}
#define typedef_BDK_TNS_SDE_MRET_FEATURE_EN bdk_tns_sde_mret_feature_en_t
#define bustype_BDK_TNS_SDE_MRET_FEATURE_EN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FEATURE_EN 0
#define arguments_BDK_TNS_SDE_MRET_FEATURE_EN -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FEATURE_EN "TNS_SDE_MRET_FEATURE_EN"


/**
 * NCB32b - tns_sde_mret_fl0_fif_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_fl0_fif_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_fl0_fif_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t wrptr                       : 7;  /**< R/W/H - The write pointer of the freelist fifo." */
		uint32_t rdptr                       : 7;  /**< R/W/H - The read pointer of the freelist fifo." */
		uint32_t full                        : 1;  /**< R/W/H - Fifo full indication" */
		uint32_t empty                       : 1;  /**< R/W/H - Fifo empty indication" */
#else
		uint32_t empty                       : 1;
		uint32_t full                        : 1;
		uint32_t rdptr                       : 7;
		uint32_t wrptr                       : 7;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_fl0_fif_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_fl0_fif_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_fl0_fif_ptr_t;

#define BDK_TNS_SDE_MRET_FL0_FIF_PTR BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FL0_FIF_PTR_FUNC(void)
{
	return 0x00008420607800E0ull;
}
#define typedef_BDK_TNS_SDE_MRET_FL0_FIF_PTR bdk_tns_sde_mret_fl0_fif_ptr_t
#define bustype_BDK_TNS_SDE_MRET_FL0_FIF_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FL0_FIF_PTR 0
#define arguments_BDK_TNS_SDE_MRET_FL0_FIF_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FL0_FIF_PTR "TNS_SDE_MRET_FL0_FIF_PTR"


/**
 * NCB32b - tns_sde_mret_flst_bk0_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_flst_bk0_adr {
	uint32_t u;
	struct bdk_tns_sde_mret_flst_bk0_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t line                        : 8;  /**< R/W - -- */
#else
		uint32_t line                        : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_flst_bk0_adr_s cn88xx; */
	/* struct bdk_tns_sde_mret_flst_bk0_adr_s cn88xxp1; */
} bdk_tns_sde_mret_flst_bk0_adr_t;

#define BDK_TNS_SDE_MRET_FLST_BK0_ADR BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_ADR_FUNC(void)
{
	return 0x000084206078004Cull;
}
#define typedef_BDK_TNS_SDE_MRET_FLST_BK0_ADR bdk_tns_sde_mret_flst_bk0_adr_t
#define bustype_BDK_TNS_SDE_MRET_FLST_BK0_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FLST_BK0_ADR 0
#define arguments_BDK_TNS_SDE_MRET_FLST_BK0_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FLST_BK0_ADR "TNS_SDE_MRET_FLST_BK0_ADR"


/**
 * NCB32b - tns_sde_mret_flst_bk0_dat
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_flst_bk0_dat {
	uint32_t u;
	struct bdk_tns_sde_mret_flst_bk0_dat_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t data                        : 8;  /**< R/W/H - -- */
#else
		uint32_t data                        : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_flst_bk0_dat_s cn88xx; */
	/* struct bdk_tns_sde_mret_flst_bk0_dat_s cn88xxp1; */
} bdk_tns_sde_mret_flst_bk0_dat_t;

#define BDK_TNS_SDE_MRET_FLST_BK0_DAT BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_BK0_DAT_FUNC(void)
{
	return 0x0000842060780050ull;
}
#define typedef_BDK_TNS_SDE_MRET_FLST_BK0_DAT bdk_tns_sde_mret_flst_bk0_dat_t
#define bustype_BDK_TNS_SDE_MRET_FLST_BK0_DAT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FLST_BK0_DAT 0
#define arguments_BDK_TNS_SDE_MRET_FLST_BK0_DAT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FLST_BK0_DAT "TNS_SDE_MRET_FLST_BK0_DAT"


/**
 * NCB32b - tns_sde_mret_flst_dbg_cfg
 *
 * This register should not be modified from its default values, unless you know
 * what you are doing.
 */
typedef union bdk_tns_sde_mret_flst_dbg_cfg {
	uint32_t u;
	struct bdk_tns_sde_mret_flst_dbg_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t ch0_enqen                   : 1;  /**< R/W - -- */
		uint32_t ch0_deqen                   : 1;  /**< R/W - -- */
		uint32_t ch0_contenq                 : 1;  /**< R/W - -- */
		uint32_t ch0_contdeq                 : 1;  /**< R/W - -- */
#else
		uint32_t ch0_contdeq                 : 1;
		uint32_t ch0_contenq                 : 1;
		uint32_t ch0_deqen                   : 1;
		uint32_t ch0_enqen                   : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_mret_flst_dbg_cfg_s cn88xx; */
	/* struct bdk_tns_sde_mret_flst_dbg_cfg_s cn88xxp1; */
} bdk_tns_sde_mret_flst_dbg_cfg_t;

#define BDK_TNS_SDE_MRET_FLST_DBG_CFG BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_DBG_CFG_FUNC(void)
{
	return 0x00008420607800DCull;
}
#define typedef_BDK_TNS_SDE_MRET_FLST_DBG_CFG bdk_tns_sde_mret_flst_dbg_cfg_t
#define bustype_BDK_TNS_SDE_MRET_FLST_DBG_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FLST_DBG_CFG 0
#define arguments_BDK_TNS_SDE_MRET_FLST_DBG_CFG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FLST_DBG_CFG "TNS_SDE_MRET_FLST_DBG_CFG"


/**
 * NCB32b - tns_sde_mret_flst_sta
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_flst_sta {
	uint32_t u;
	struct bdk_tns_sde_mret_flst_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t ch0_full                    : 1;  /**< RO/H - Indicates there are no outstanding entries. */
		uint32_t ch0_usage                   : 8;  /**< RO/H - Number of entries in the freelist. */
#else
		uint32_t ch0_usage                   : 8;
		uint32_t ch0_full                    : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_mret_flst_sta_s cn88xx; */
	/* struct bdk_tns_sde_mret_flst_sta_s cn88xxp1; */
} bdk_tns_sde_mret_flst_sta_t;

#define BDK_TNS_SDE_MRET_FLST_STA BDK_TNS_SDE_MRET_FLST_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_FLST_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_FLST_STA_FUNC(void)
{
	return 0x00008420607800D8ull;
}
#define typedef_BDK_TNS_SDE_MRET_FLST_STA bdk_tns_sde_mret_flst_sta_t
#define bustype_BDK_TNS_SDE_MRET_FLST_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_FLST_STA 0
#define arguments_BDK_TNS_SDE_MRET_FLST_STA -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_FLST_STA "TNS_SDE_MRET_FLST_STA"


/**
 * NCB32b - tns_sde_mret_hdrcyc_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_hdrcyc_ct {
	uint32_t u;
	struct bdk_tns_sde_mret_hdrcyc_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of cycles of data received on channel 0 */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_hdrcyc_ct_s cn88xx; */
	/* struct bdk_tns_sde_mret_hdrcyc_ct_s cn88xxp1; */
} bdk_tns_sde_mret_hdrcyc_ct_t;

#define BDK_TNS_SDE_MRET_HDRCYC_CT BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HDRCYC_CT_FUNC(void)
{
	return 0x0000842060780100ull;
}
#define typedef_BDK_TNS_SDE_MRET_HDRCYC_CT bdk_tns_sde_mret_hdrcyc_ct_t
#define bustype_BDK_TNS_SDE_MRET_HDRCYC_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_HDRCYC_CT 0
#define arguments_BDK_TNS_SDE_MRET_HDRCYC_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_HDRCYC_CT "TNS_SDE_MRET_HDRCYC_CT"


/**
 * NCB32b - tns_sde_mret_hmem_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_hmem_adr {
	uint32_t u;
	struct bdk_tns_sde_mret_hmem_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t line                        : 2;  /**< R/W - -- */
		uint32_t page                        : 7;  /**< R/W - -- */
#else
		uint32_t page                        : 7;
		uint32_t line                        : 2;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_mret_hmem_adr_s cn88xx; */
	/* struct bdk_tns_sde_mret_hmem_adr_s cn88xxp1; */
} bdk_tns_sde_mret_hmem_adr_t;

#define BDK_TNS_SDE_MRET_HMEM_ADR BDK_TNS_SDE_MRET_HMEM_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ADR_FUNC(void)
{
	return 0x0000842060780054ull;
}
#define typedef_BDK_TNS_SDE_MRET_HMEM_ADR bdk_tns_sde_mret_hmem_adr_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_HMEM_ADR 0
#define arguments_BDK_TNS_SDE_MRET_HMEM_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_HMEM_ADR "TNS_SDE_MRET_HMEM_ADR"


/**
 * NCB32b - tns_sde_mret_hmem_dat_w#
 *
 * Bits 31..2 of registers ending in _W16 are unused.
 *
 */
typedef union bdk_tns_sde_mret_hmem_dat_wx {
	uint32_t u;
	struct bdk_tns_sde_mret_hmem_dat_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t hdr_mem_data                : 32; /**< R/W/H - -- */
#else
		uint32_t hdr_mem_data                : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mret_hmem_dat_wx_s cn88xx; */
	/* struct bdk_tns_sde_mret_hmem_dat_wx_s cn88xxp1; */
} bdk_tns_sde_mret_hmem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_MRET_HMEM_DAT_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_DAT_WX(unsigned long param1)
{
	if (((param1 <= 16)))
		return 0x0000842060780058ull + (param1 & 31) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_MRET_HMEM_DAT_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_MRET_HMEM_DAT_WX(...) bdk_tns_sde_mret_hmem_dat_wx_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_DAT_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_HMEM_DAT_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_MRET_HMEM_DAT_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_HMEM_DAT_WX(...) "TNS_SDE_MRET_HMEM_DAT_WX"


/**
 * NCB32b - tns_sde_mret_hmem_ecc_err
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_hmem_ecc_err {
	uint32_t u;
	struct bdk_tns_sde_mret_hmem_ecc_err_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t log                         : 18; /**< R/W/H - Data logged is defined as {locked, hdr_mem_db_err[3:0], hdr_mem_sb_err[3:0],
                                                                 hdr_mem_rd_addr_d[8:0]} */
#else
		uint32_t log                         : 18;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_mret_hmem_ecc_err_s cn88xx; */
	/* struct bdk_tns_sde_mret_hmem_ecc_err_s cn88xxp1; */
} bdk_tns_sde_mret_hmem_ecc_err_t;

#define BDK_TNS_SDE_MRET_HMEM_ECC_ERR BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_HMEM_ECC_ERR_FUNC(void)
{
	return 0x00008420607800F8ull;
}
#define typedef_BDK_TNS_SDE_MRET_HMEM_ECC_ERR bdk_tns_sde_mret_hmem_ecc_err_t
#define bustype_BDK_TNS_SDE_MRET_HMEM_ECC_ERR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_HMEM_ECC_ERR 0
#define arguments_BDK_TNS_SDE_MRET_HMEM_ECC_ERR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_HMEM_ECC_ERR "TNS_SDE_MRET_HMEM_ECC_ERR"


/**
 * NCB - tns_sde_mret_int_en_hi
 *
 * Interrupts for the MRE module
 *
 */
typedef union bdk_tns_sde_mret_int_en_hi {
	uint64_t u;
	struct bdk_tns_sde_mret_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t page_fifo0_prio3_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio3_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio2_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio2_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio1_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio1_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio0_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio0_sb_err     : 1;  /**< R/W - -- */
		uint64_t cntx_mem_db_err             : 2;  /**< R/W - Indicates a two-bit error was detected in the context RAM. */
		uint64_t cntx_mem_sb_err             : 2;  /**< R/W - Indicates a single-bit error was detected in the context RAM. */
		uint64_t hdr_mem_db_err              : 4;  /**< R/W - Indicates a two-bit error was detected in the header RAM. */
		uint64_t hdr_mem_sb_err              : 4;  /**< R/W - Indicates a single-bit error was detected in the header RAM. */
		uint64_t token_mem_db_err            : 10; /**< R/W - Indicates a two-bit error was detected in the token RAM. */
		uint64_t token_mem_sb_err            : 10; /**< R/W - Indicates a single-bit error was detected in the token RAM. */
		uint64_t freelist_fifo_undr          : 1;  /**< R/W - Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
		uint64_t page_fifo_ovfl              : 1;  /**< R/W - Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
		uint64_t freelist_fifo_db_err        : 1;  /**< R/W - Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
		uint64_t freelist_fifo_sb_err        : 1;  /**< R/W - Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
		uint64_t page_fifo_fsm_error         : 1;  /**< R/W - Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
		uint64_t req_ct_ovfl                 : 1;  /**< R/W - Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_undr                 : 1;  /**< R/W - Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_thr_xcd              : 1;  /**< R/W - Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
		uint64_t freecache_cnt_undrn_int     : 1;  /**< R/W - Indicates one of the freecache counters has underrun. This should never happen. */
		uint64_t freecache_cnt_ovfl_int      : 1;  /**< R/W - Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
		uint64_t freecache_ovfl_int          : 1;  /**< R/W - Indicates one of the freecaches has overflown. This should never happen. */
		uint64_t rcv_store_0_wr2vld_intr     : 1;  /**< R/W - Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_1_wr2vld_intr     : 1;  /**< R/W - Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_0_rd_wr_same_intr : 1;  /**< R/W - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t rcv_store_1_rd_wr_same_intr : 1;  /**< R/W - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t se_data_incorrect_intr      : 1;  /**< R/W - Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
		uint64_t ctx_store_rd_timeout_intr   : 1;  /**< R/W - Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
		uint64_t arbiter_token_fifo_ovfl_intr : 1; /**< R/W - Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else
		uint64_t arbiter_token_fifo_ovfl_intr : 1;
		uint64_t ctx_store_rd_timeout_intr   : 1;
		uint64_t se_data_incorrect_intr      : 1;
		uint64_t rcv_store_1_rd_wr_same_intr : 1;
		uint64_t rcv_store_0_rd_wr_same_intr : 1;
		uint64_t rcv_store_1_wr2vld_intr     : 1;
		uint64_t rcv_store_0_wr2vld_intr     : 1;
		uint64_t freecache_ovfl_int          : 1;
		uint64_t freecache_cnt_ovfl_int      : 1;
		uint64_t freecache_cnt_undrn_int     : 1;
		uint64_t req_ct_thr_xcd              : 1;
		uint64_t req_ct_undr                 : 1;
		uint64_t req_ct_ovfl                 : 1;
		uint64_t page_fifo_fsm_error         : 1;
		uint64_t freelist_fifo_sb_err        : 1;
		uint64_t freelist_fifo_db_err        : 1;
		uint64_t page_fifo_ovfl              : 1;
		uint64_t freelist_fifo_undr          : 1;
		uint64_t token_mem_sb_err            : 10;
		uint64_t token_mem_db_err            : 10;
		uint64_t hdr_mem_sb_err              : 4;
		uint64_t hdr_mem_db_err              : 4;
		uint64_t cntx_mem_sb_err             : 2;
		uint64_t cntx_mem_db_err             : 2;
		uint64_t page_fifo0_prio0_sb_err     : 1;
		uint64_t page_fifo0_prio0_db_err     : 1;
		uint64_t page_fifo0_prio1_sb_err     : 1;
		uint64_t page_fifo0_prio1_db_err     : 1;
		uint64_t page_fifo0_prio2_sb_err     : 1;
		uint64_t page_fifo0_prio2_db_err     : 1;
		uint64_t page_fifo0_prio3_sb_err     : 1;
		uint64_t page_fifo0_prio3_db_err     : 1;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_mret_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_mret_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_mret_int_en_hi_t;

#define BDK_TNS_SDE_MRET_INT_EN_HI BDK_TNS_SDE_MRET_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_HI_FUNC(void)
{
	return 0x00008420607800C0ull;
}
#define typedef_BDK_TNS_SDE_MRET_INT_EN_HI bdk_tns_sde_mret_int_en_hi_t
#define bustype_BDK_TNS_SDE_MRET_INT_EN_HI BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_MRET_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_INT_EN_HI "TNS_SDE_MRET_INT_EN_HI"


/**
 * NCB - tns_sde_mret_int_en_lo
 *
 * Interrupts for the MRE module
 *
 */
typedef union bdk_tns_sde_mret_int_en_lo {
	uint64_t u;
	struct bdk_tns_sde_mret_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t page_fifo0_prio3_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio3_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio2_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio2_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio1_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio1_sb_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio0_db_err     : 1;  /**< R/W - -- */
		uint64_t page_fifo0_prio0_sb_err     : 1;  /**< R/W - -- */
		uint64_t cntx_mem_db_err             : 2;  /**< R/W - Indicates a two-bit error was detected in the context RAM. */
		uint64_t cntx_mem_sb_err             : 2;  /**< R/W - Indicates a single-bit error was detected in the context RAM. */
		uint64_t hdr_mem_db_err              : 4;  /**< R/W - Indicates a two-bit error was detected in the header RAM. */
		uint64_t hdr_mem_sb_err              : 4;  /**< R/W - Indicates a single-bit error was detected in the header RAM. */
		uint64_t token_mem_db_err            : 10; /**< R/W - Indicates a two-bit error was detected in the token RAM. */
		uint64_t token_mem_sb_err            : 10; /**< R/W - Indicates a single-bit error was detected in the token RAM. */
		uint64_t freelist_fifo_undr          : 1;  /**< R/W - Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
		uint64_t page_fifo_ovfl              : 1;  /**< R/W - Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
		uint64_t freelist_fifo_db_err        : 1;  /**< R/W - Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
		uint64_t freelist_fifo_sb_err        : 1;  /**< R/W - Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
		uint64_t page_fifo_fsm_error         : 1;  /**< R/W - Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
		uint64_t req_ct_ovfl                 : 1;  /**< R/W - Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_undr                 : 1;  /**< R/W - Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_thr_xcd              : 1;  /**< R/W - Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
		uint64_t freecache_cnt_undrn_int     : 1;  /**< R/W - Indicates one of the freecache counters has underrun. This should never happen. */
		uint64_t freecache_cnt_ovfl_int      : 1;  /**< R/W - Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
		uint64_t freecache_ovfl_int          : 1;  /**< R/W - Indicates one of the freecaches has overflown. This should never happen. */
		uint64_t rcv_store_0_wr2vld_intr     : 1;  /**< R/W - Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_1_wr2vld_intr     : 1;  /**< R/W - Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_0_rd_wr_same_intr : 1;  /**< R/W - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t rcv_store_1_rd_wr_same_intr : 1;  /**< R/W - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t se_data_incorrect_intr      : 1;  /**< R/W - Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
		uint64_t ctx_store_rd_timeout_intr   : 1;  /**< R/W - Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
		uint64_t arbiter_token_fifo_ovfl_intr : 1; /**< R/W - Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else
		uint64_t arbiter_token_fifo_ovfl_intr : 1;
		uint64_t ctx_store_rd_timeout_intr   : 1;
		uint64_t se_data_incorrect_intr      : 1;
		uint64_t rcv_store_1_rd_wr_same_intr : 1;
		uint64_t rcv_store_0_rd_wr_same_intr : 1;
		uint64_t rcv_store_1_wr2vld_intr     : 1;
		uint64_t rcv_store_0_wr2vld_intr     : 1;
		uint64_t freecache_ovfl_int          : 1;
		uint64_t freecache_cnt_ovfl_int      : 1;
		uint64_t freecache_cnt_undrn_int     : 1;
		uint64_t req_ct_thr_xcd              : 1;
		uint64_t req_ct_undr                 : 1;
		uint64_t req_ct_ovfl                 : 1;
		uint64_t page_fifo_fsm_error         : 1;
		uint64_t freelist_fifo_sb_err        : 1;
		uint64_t freelist_fifo_db_err        : 1;
		uint64_t page_fifo_ovfl              : 1;
		uint64_t freelist_fifo_undr          : 1;
		uint64_t token_mem_sb_err            : 10;
		uint64_t token_mem_db_err            : 10;
		uint64_t hdr_mem_sb_err              : 4;
		uint64_t hdr_mem_db_err              : 4;
		uint64_t cntx_mem_sb_err             : 2;
		uint64_t cntx_mem_db_err             : 2;
		uint64_t page_fifo0_prio0_sb_err     : 1;
		uint64_t page_fifo0_prio0_db_err     : 1;
		uint64_t page_fifo0_prio1_sb_err     : 1;
		uint64_t page_fifo0_prio1_db_err     : 1;
		uint64_t page_fifo0_prio2_sb_err     : 1;
		uint64_t page_fifo0_prio2_db_err     : 1;
		uint64_t page_fifo0_prio3_sb_err     : 1;
		uint64_t page_fifo0_prio3_db_err     : 1;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_mret_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_mret_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_mret_int_en_lo_t;

#define BDK_TNS_SDE_MRET_INT_EN_LO BDK_TNS_SDE_MRET_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_EN_LO_FUNC(void)
{
	return 0x00008420607800C8ull;
}
#define typedef_BDK_TNS_SDE_MRET_INT_EN_LO bdk_tns_sde_mret_int_en_lo_t
#define bustype_BDK_TNS_SDE_MRET_INT_EN_LO BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_MRET_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_INT_EN_LO "TNS_SDE_MRET_INT_EN_LO"


/**
 * NCB - tns_sde_mret_int_frc
 *
 * Interrupts for the MRE module
 *
 */
typedef union bdk_tns_sde_mret_int_frc {
	uint64_t u;
	struct bdk_tns_sde_mret_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t page_fifo0_prio3_db_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio3_sb_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio2_db_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio2_sb_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio1_db_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio1_sb_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio0_db_err     : 1;  /**< WO - -- */
		uint64_t page_fifo0_prio0_sb_err     : 1;  /**< WO - -- */
		uint64_t cntx_mem_db_err             : 2;  /**< WO - Indicates a two-bit error was detected in the context RAM. */
		uint64_t cntx_mem_sb_err             : 2;  /**< WO - Indicates a single-bit error was detected in the context RAM. */
		uint64_t hdr_mem_db_err              : 4;  /**< WO - Indicates a two-bit error was detected in the header RAM. */
		uint64_t hdr_mem_sb_err              : 4;  /**< WO - Indicates a single-bit error was detected in the header RAM. */
		uint64_t token_mem_db_err            : 10; /**< WO - Indicates a two-bit error was detected in the token RAM. */
		uint64_t token_mem_sb_err            : 10; /**< WO - Indicates a single-bit error was detected in the token RAM. */
		uint64_t freelist_fifo_undr          : 1;  /**< WO - Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
		uint64_t page_fifo_ovfl              : 1;  /**< WO - Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
		uint64_t freelist_fifo_db_err        : 1;  /**< WO - Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
		uint64_t freelist_fifo_sb_err        : 1;  /**< WO - Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
		uint64_t page_fifo_fsm_error         : 1;  /**< WO - Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
		uint64_t req_ct_ovfl                 : 1;  /**< WO - Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_undr                 : 1;  /**< WO - Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_thr_xcd              : 1;  /**< WO - Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
		uint64_t freecache_cnt_undrn_int     : 1;  /**< WO - Indicates one of the freecache counters has underrun. This should never happen. */
		uint64_t freecache_cnt_ovfl_int      : 1;  /**< WO - Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
		uint64_t freecache_ovfl_int          : 1;  /**< WO - Indicates one of the freecaches has overflown. This should never happen. */
		uint64_t rcv_store_0_wr2vld_intr     : 1;  /**< WO - Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_1_wr2vld_intr     : 1;  /**< WO - Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_0_rd_wr_same_intr : 1;  /**< WO - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t rcv_store_1_rd_wr_same_intr : 1;  /**< WO - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t se_data_incorrect_intr      : 1;  /**< WO - Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
		uint64_t ctx_store_rd_timeout_intr   : 1;  /**< WO - Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
		uint64_t arbiter_token_fifo_ovfl_intr : 1; /**< WO - Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else
		uint64_t arbiter_token_fifo_ovfl_intr : 1;
		uint64_t ctx_store_rd_timeout_intr   : 1;
		uint64_t se_data_incorrect_intr      : 1;
		uint64_t rcv_store_1_rd_wr_same_intr : 1;
		uint64_t rcv_store_0_rd_wr_same_intr : 1;
		uint64_t rcv_store_1_wr2vld_intr     : 1;
		uint64_t rcv_store_0_wr2vld_intr     : 1;
		uint64_t freecache_ovfl_int          : 1;
		uint64_t freecache_cnt_ovfl_int      : 1;
		uint64_t freecache_cnt_undrn_int     : 1;
		uint64_t req_ct_thr_xcd              : 1;
		uint64_t req_ct_undr                 : 1;
		uint64_t req_ct_ovfl                 : 1;
		uint64_t page_fifo_fsm_error         : 1;
		uint64_t freelist_fifo_sb_err        : 1;
		uint64_t freelist_fifo_db_err        : 1;
		uint64_t page_fifo_ovfl              : 1;
		uint64_t freelist_fifo_undr          : 1;
		uint64_t token_mem_sb_err            : 10;
		uint64_t token_mem_db_err            : 10;
		uint64_t hdr_mem_sb_err              : 4;
		uint64_t hdr_mem_db_err              : 4;
		uint64_t cntx_mem_sb_err             : 2;
		uint64_t cntx_mem_db_err             : 2;
		uint64_t page_fifo0_prio0_sb_err     : 1;
		uint64_t page_fifo0_prio0_db_err     : 1;
		uint64_t page_fifo0_prio1_sb_err     : 1;
		uint64_t page_fifo0_prio1_db_err     : 1;
		uint64_t page_fifo0_prio2_sb_err     : 1;
		uint64_t page_fifo0_prio2_db_err     : 1;
		uint64_t page_fifo0_prio3_sb_err     : 1;
		uint64_t page_fifo0_prio3_db_err     : 1;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_mret_int_frc_s  cn88xx; */
	/* struct bdk_tns_sde_mret_int_frc_s  cn88xxp1; */
} bdk_tns_sde_mret_int_frc_t;

#define BDK_TNS_SDE_MRET_INT_FRC BDK_TNS_SDE_MRET_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_FRC_FUNC(void)
{
	return 0x00008420607800D0ull;
}
#define typedef_BDK_TNS_SDE_MRET_INT_FRC bdk_tns_sde_mret_int_frc_t
#define bustype_BDK_TNS_SDE_MRET_INT_FRC BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_INT_FRC 0
#define arguments_BDK_TNS_SDE_MRET_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_INT_FRC "TNS_SDE_MRET_INT_FRC"


/**
 * NCB - tns_sde_mret_int_w1c
 *
 * Interrupts for the MRE module
 *
 */
typedef union bdk_tns_sde_mret_int_w1c {
	uint64_t u;
	struct bdk_tns_sde_mret_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t page_fifo0_prio3_db_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio3_sb_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio2_db_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio2_sb_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio1_db_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio1_sb_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio0_db_err     : 1;  /**< R/W1C/H - -- */
		uint64_t page_fifo0_prio0_sb_err     : 1;  /**< R/W1C/H - -- */
		uint64_t cntx_mem_db_err             : 2;  /**< R/W1C/H - Indicates a two-bit error was detected in the context RAM. */
		uint64_t cntx_mem_sb_err             : 2;  /**< R/W1C/H - Indicates a single-bit error was detected in the context RAM. */
		uint64_t hdr_mem_db_err              : 4;  /**< R/W1C/H - Indicates a two-bit error was detected in the header RAM. */
		uint64_t hdr_mem_sb_err              : 4;  /**< R/W1C/H - Indicates a single-bit error was detected in the header RAM. */
		uint64_t token_mem_db_err            : 10; /**< R/W1C/H - Indicates a two-bit error was detected in the token RAM. */
		uint64_t token_mem_sb_err            : 10; /**< R/W1C/H - Indicates a single-bit error was detected in the token RAM. */
		uint64_t freelist_fifo_undr          : 1;  /**< R/W1C/H - Indicates that the freelist was read when empty.
                                                                 This interrupt is catastrophic. */
		uint64_t page_fifo_ovfl              : 1;  /**< R/W1C/H - Indicates the page fifo was full when a write was attempted.
                                                                 This interrupt is catastrophic, and indicates incorrect programming of
                                                                 the page_fifo thresholds." */
		uint64_t freelist_fifo_db_err        : 1;  /**< R/W1C/H - Indicates a two-bit error was detected on the freelist. This interrupt is
                                                                 catastrophic." */
		uint64_t freelist_fifo_sb_err        : 1;  /**< R/W1C/H - Indicates a single bit error was detected on the freelist. This interrupt is
                                                                 for informational purposes only. The error is self correcting." */
		uint64_t page_fifo_fsm_error         : 1;  /**< R/W1C/H - Indicates an error occurred in the page fifo FSM. This error is unrecoverable." */
		uint64_t req_ct_ovfl                 : 1;  /**< R/W1C/H - Indicates an attempt was made to increment the request counter while it was at
                                                                 its maximum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_undr                 : 1;  /**< R/W1C/H - Indicates an attempt was made to decrement the request counter while it was at
                                                                 its minimum value. The outstanding request counter is now no longer accurate. */
		uint64_t req_ct_thr_xcd              : 1;  /**< R/W1C/H - Indicates the request counter has reached its configured threshold, and the
                                                                 pipe has therefor been flowcontrolled */
		uint64_t freecache_cnt_undrn_int     : 1;  /**< R/W1C/H - Indicates one of the freecache counters has underrun. This should never happen. */
		uint64_t freecache_cnt_ovfl_int      : 1;  /**< R/W1C/H - Indicates one of the freecache counters has overflown. This should never
                                                                 happen. */
		uint64_t freecache_ovfl_int          : 1;  /**< R/W1C/H - Indicates one of the freecaches has overflown. This should never happen. */
		uint64_t rcv_store_0_wr2vld_intr     : 1;  /**< R/W1C/H - Indicates the rcv store 0 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_1_wr2vld_intr     : 1;  /**< R/W1C/H - Indicates the rcv store 1 was written at a valid location. This should never
                                                                 happen. */
		uint64_t rcv_store_0_rd_wr_same_intr : 1;  /**< R/W1C/H - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t rcv_store_1_rd_wr_same_intr : 1;  /**< R/W1C/H - Indicates the rcv store was written and read at the same location. This should
                                                                 never happen. */
		uint64_t se_data_incorrect_intr      : 1;  /**< R/W1C/H - Indicates the data from SE is not correct: either one of the hit bits is not
                                                                 set or the sorry bit is set, or the token_id bit is set. This should never
                                                                 happen. */
		uint64_t ctx_store_rd_timeout_intr   : 1;  /**< R/W1C/H - Indicates the ctx_store has data to read and for a number of clock cycles
                                                                 exceeding the cfg.ctx_store_read_timeout has not been read. This should never
                                                                 happen." */
		uint64_t arbiter_token_fifo_ovfl_intr : 1; /**< R/W1C/H - Indicates an attempt was made to write to the arbiter token fifo when it was
                                                                 full. This should never happen. */
#else
		uint64_t arbiter_token_fifo_ovfl_intr : 1;
		uint64_t ctx_store_rd_timeout_intr   : 1;
		uint64_t se_data_incorrect_intr      : 1;
		uint64_t rcv_store_1_rd_wr_same_intr : 1;
		uint64_t rcv_store_0_rd_wr_same_intr : 1;
		uint64_t rcv_store_1_wr2vld_intr     : 1;
		uint64_t rcv_store_0_wr2vld_intr     : 1;
		uint64_t freecache_ovfl_int          : 1;
		uint64_t freecache_cnt_ovfl_int      : 1;
		uint64_t freecache_cnt_undrn_int     : 1;
		uint64_t req_ct_thr_xcd              : 1;
		uint64_t req_ct_undr                 : 1;
		uint64_t req_ct_ovfl                 : 1;
		uint64_t page_fifo_fsm_error         : 1;
		uint64_t freelist_fifo_sb_err        : 1;
		uint64_t freelist_fifo_db_err        : 1;
		uint64_t page_fifo_ovfl              : 1;
		uint64_t freelist_fifo_undr          : 1;
		uint64_t token_mem_sb_err            : 10;
		uint64_t token_mem_db_err            : 10;
		uint64_t hdr_mem_sb_err              : 4;
		uint64_t hdr_mem_db_err              : 4;
		uint64_t cntx_mem_sb_err             : 2;
		uint64_t cntx_mem_db_err             : 2;
		uint64_t page_fifo0_prio0_sb_err     : 1;
		uint64_t page_fifo0_prio0_db_err     : 1;
		uint64_t page_fifo0_prio1_sb_err     : 1;
		uint64_t page_fifo0_prio1_db_err     : 1;
		uint64_t page_fifo0_prio2_sb_err     : 1;
		uint64_t page_fifo0_prio2_db_err     : 1;
		uint64_t page_fifo0_prio3_sb_err     : 1;
		uint64_t page_fifo0_prio3_db_err     : 1;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_mret_int_w1c_s  cn88xx; */
	/* struct bdk_tns_sde_mret_int_w1c_s  cn88xxp1; */
} bdk_tns_sde_mret_int_w1c_t;

#define BDK_TNS_SDE_MRET_INT_W1C BDK_TNS_SDE_MRET_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_INT_W1C_FUNC(void)
{
	return 0x00008420607800B8ull;
}
#define typedef_BDK_TNS_SDE_MRET_INT_W1C bdk_tns_sde_mret_int_w1c_t
#define bustype_BDK_TNS_SDE_MRET_INT_W1C BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_MRET_INT_W1C 0
#define arguments_BDK_TNS_SDE_MRET_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_INT_W1C "TNS_SDE_MRET_INT_W1C"


/**
 * NCB32b - tns_sde_mret_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_mret_lock {
	uint32_t u;
	struct bdk_tns_sde_mret_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mret_lock_s     cn88xx; */
	/* struct bdk_tns_sde_mret_lock_s     cn88xxp1; */
} bdk_tns_sde_mret_lock_t;

#define BDK_TNS_SDE_MRET_LOCK BDK_TNS_SDE_MRET_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_LOCK_FUNC(void)
{
	return 0x0000842060780108ull;
}
#define typedef_BDK_TNS_SDE_MRET_LOCK bdk_tns_sde_mret_lock_t
#define bustype_BDK_TNS_SDE_MRET_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_LOCK 0
#define arguments_BDK_TNS_SDE_MRET_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_LOCK "TNS_SDE_MRET_LOCK"


/**
 * NCB32b - tns_sde_mret_mdt_req_cfg
 *
 * Controls the number and type of SE requests issued byt the MRE
 * module for the purpose of MDT traversal.
 */
typedef union bdk_tns_sde_mret_mdt_req_cfg {
	uint32_t u;
	struct bdk_tns_sde_mret_mdt_req_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_21_31              : 11;
		uint32_t mdt_prfl_id                 : 7;  /**< R/W - Profile ID used when issueing the MDT read request to SE. Note:
                                                                 the SE profile identified here MUST be programmed to use only
                                                                 the first table slot, and that tabel must be programmed to return
                                                                 64 bits of data only, and on lane 0. */
		uint32_t mdt_cmd_en                  : 4;  /**< R/W - CMD enable bit vector used when issueing the MDT read request.
                                                                 This should never be changed from its default value of 4'b0001. */
		uint32_t outstanding_mre_request_thr : 8;  /**< R/W - Number of outstanding MDT read requests the MRE issues before
                                                                 flowcontrolling the pipe. */
		uint32_t channel_select_mode         : 2;  /**< R/W - Defines the way the outgoing channel is assigned on the replicated Tokens:
                                                                 2'h0: Same as incoming token (default)
                                                                 2'h1: Round robin (based on incoming token: all tokens generated from a
                                                                 given token will be assigned the same value
                                                                 2'h2: From L3-ECMP hash [1:0]. If hash_select = 0, uses l3_ecmp_hash_a,
                                                                 else uses l3_ecmp_hash_b. */
#else
		uint32_t channel_select_mode         : 2;
		uint32_t outstanding_mre_request_thr : 8;
		uint32_t mdt_cmd_en                  : 4;
		uint32_t mdt_prfl_id                 : 7;
		uint32_t reserved_21_31              : 11;
#endif
	} s;
	/* struct bdk_tns_sde_mret_mdt_req_cfg_s cn88xx; */
	/* struct bdk_tns_sde_mret_mdt_req_cfg_s cn88xxp1; */
} bdk_tns_sde_mret_mdt_req_cfg_t;

#define BDK_TNS_SDE_MRET_MDT_REQ_CFG BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_MDT_REQ_CFG_FUNC(void)
{
	return 0x0000842060780030ull;
}
#define typedef_BDK_TNS_SDE_MRET_MDT_REQ_CFG bdk_tns_sde_mret_mdt_req_cfg_t
#define bustype_BDK_TNS_SDE_MRET_MDT_REQ_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_MDT_REQ_CFG 0
#define arguments_BDK_TNS_SDE_MRET_MDT_REQ_CFG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_MDT_REQ_CFG "TNS_SDE_MRET_MDT_REQ_CFG"


/**
 * NCB32b - tns_sde_mret_mdt_resp_cfg
 *
 * Controls behavior of the MRE related to the SE data reception.
 *
 */
typedef union bdk_tns_sde_mret_mdt_resp_cfg {
	uint32_t u;
	struct bdk_tns_sde_mret_mdt_resp_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t ctx_store_rd_timeout        : 16; /**< R/W - This controls the timeout value (in clock cycles) for the context store read.
                                                                 If data is available and the data is not read, the timeout counter is
                                                                 incremented. Else it is zeroed out. When the counter reaches this value, an
                                                                 interrupt is asserted. */
#else
		uint32_t ctx_store_rd_timeout        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_mdt_resp_cfg_s cn88xx; */
	/* struct bdk_tns_sde_mret_mdt_resp_cfg_s cn88xxp1; */
} bdk_tns_sde_mret_mdt_resp_cfg_t;

#define BDK_TNS_SDE_MRET_MDT_RESP_CFG BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_MDT_RESP_CFG_FUNC(void)
{
	return 0x000084206078002Cull;
}
#define typedef_BDK_TNS_SDE_MRET_MDT_RESP_CFG bdk_tns_sde_mret_mdt_resp_cfg_t
#define bustype_BDK_TNS_SDE_MRET_MDT_RESP_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_MDT_RESP_CFG 0
#define arguments_BDK_TNS_SDE_MRET_MDT_RESP_CFG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_MDT_RESP_CFG "TNS_SDE_MRET_MDT_RESP_CFG"


/**
 * NCB32b - tns_sde_mret_pg_fif0_adr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_adr {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_adr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t prio                        : 2;  /**< R/W - -- */
		uint32_t addr                        : 8;  /**< R/W - -- */
#else
		uint32_t addr                        : 8;
		uint32_t prio                        : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_adr_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_adr_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_adr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_ADR BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_ADR_FUNC(void)
{
	return 0x0000842060780044ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_ADR bdk_tns_sde_mret_pg_fif0_adr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_ADR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_ADR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_ADR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_ADR "TNS_SDE_MRET_PG_FIF0_ADR"


/**
 * NCB32b - tns_sde_mret_pg_fif0_dat
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_dat {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_dat_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t data                        : 8;  /**< R/W/H - -- */
#else
		uint32_t data                        : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_dat_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_dat_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_dat_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_DAT BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_DAT_FUNC(void)
{
	return 0x0000842060780048ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_DAT bdk_tns_sde_mret_pg_fif0_dat_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_DAT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_DAT 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_DAT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_DAT "TNS_SDE_MRET_PG_FIF0_DAT"


/**
 * NCB32b - tns_sde_mret_pg_fif0_pr0_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_pr0_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_pr0_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t wrptr                       : 7;  /**< R/W/H - The write pointer of the page fifo." */
		uint32_t rdptr                       : 7;  /**< R/W/H - The read pointer of the page fifo." */
		uint32_t full                        : 1;  /**< R/W/H - Fifo full indication" */
		uint32_t empty                       : 1;  /**< R/W/H - Fifo empty indication" */
#else
		uint32_t empty                       : 1;
		uint32_t full                        : 1;
		uint32_t rdptr                       : 7;
		uint32_t wrptr                       : 7;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_pr0_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_pr0_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_pr0_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR_FUNC(void)
{
	return 0x00008420607800E8ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR bdk_tns_sde_mret_pg_fif0_pr0_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR0_PTR "TNS_SDE_MRET_PG_FIF0_PR0_PTR"


/**
 * NCB32b - tns_sde_mret_pg_fif0_pr1_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_pr1_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_pr1_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t wrptr                       : 7;  /**< R/W/H - The write pointer of the page fifo." */
		uint32_t rdptr                       : 7;  /**< R/W/H - The read pointer of the page fifo." */
		uint32_t full                        : 1;  /**< R/W/H - Fifo full indication" */
		uint32_t empty                       : 1;  /**< R/W/H - Fifo empty indication" */
#else
		uint32_t empty                       : 1;
		uint32_t full                        : 1;
		uint32_t rdptr                       : 7;
		uint32_t wrptr                       : 7;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_pr1_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_pr1_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_pr1_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR_FUNC(void)
{
	return 0x00008420607800ECull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR bdk_tns_sde_mret_pg_fif0_pr1_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR1_PTR "TNS_SDE_MRET_PG_FIF0_PR1_PTR"


/**
 * NCB32b - tns_sde_mret_pg_fif0_pr2_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_pr2_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_pr2_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t wrptr                       : 7;  /**< R/W/H - The write pointer of the page fifo." */
		uint32_t rdptr                       : 7;  /**< R/W/H - The read pointer of the page fifo." */
		uint32_t full                        : 1;  /**< R/W/H - Fifo full indication" */
		uint32_t empty                       : 1;  /**< R/W/H - Fifo empty indication" */
#else
		uint32_t empty                       : 1;
		uint32_t full                        : 1;
		uint32_t rdptr                       : 7;
		uint32_t wrptr                       : 7;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_pr2_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_pr2_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_pr2_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR_FUNC(void)
{
	return 0x00008420607800F0ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR bdk_tns_sde_mret_pg_fif0_pr2_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR2_PTR "TNS_SDE_MRET_PG_FIF0_PR2_PTR"


/**
 * NCB32b - tns_sde_mret_pg_fif0_pr3_ptr
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_pg_fif0_pr3_ptr {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif0_pr3_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t wrptr                       : 7;  /**< R/W/H - The write pointer of the page fifo." */
		uint32_t rdptr                       : 7;  /**< R/W/H - The read pointer of the page fifo." */
		uint32_t full                        : 1;  /**< R/W/H - Fifo full indication" */
		uint32_t empty                       : 1;  /**< R/W/H - Fifo empty indication" */
#else
		uint32_t empty                       : 1;
		uint32_t full                        : 1;
		uint32_t rdptr                       : 7;
		uint32_t wrptr                       : 7;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif0_pr3_ptr_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif0_pr3_ptr_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif0_pr3_ptr_t;

#define BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR_FUNC(void)
{
	return 0x00008420607800F4ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR bdk_tns_sde_mret_pg_fif0_pr3_ptr_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF0_PR3_PTR "TNS_SDE_MRET_PG_FIF0_PR3_PTR"


/**
 * NCB32b - tns_sde_mret_pg_fif_cfg_w0
 *
 * Controls the thresholds of the page fifos for each bank
 *
 */
typedef union bdk_tns_sde_mret_pg_fif_cfg_w0 {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif_cfg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t prio_thr3                   : 8;  /**< R/W - Threshold for priority 0 */
		uint32_t prio_thr2                   : 8;  /**< R/W - Threshold for priority 1 */
		uint32_t prio_thr1                   : 8;  /**< R/W - Threshold for priority 2 */
		uint32_t prio_thr0                   : 8;  /**< R/W - Threshold for priority 3 */
#else
		uint32_t prio_thr0                   : 8;
		uint32_t prio_thr1                   : 8;
		uint32_t prio_thr2                   : 8;
		uint32_t prio_thr3                   : 8;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif_cfg_w0_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif_cfg_w0_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif_cfg_w0_t;

#define BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W0_FUNC(void)
{
	return 0x000084206078003Cull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 bdk_tns_sde_mret_pg_fif_cfg_w0_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF_CFG_W0 "TNS_SDE_MRET_PG_FIF_CFG_W0"


/**
 * NCB32b - tns_sde_mret_pg_fif_cfg_w1
 *
 * Continuation of structure defined in TNS_SDE_MRET_PG_FIF_CFG_W0
 *
 */
typedef union bdk_tns_sde_mret_pg_fif_cfg_w1 {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif_cfg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t bank_thr                    : 8;  /**< R/W - Total Threshold for the entire bank */
#else
		uint32_t bank_thr                    : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif_cfg_w1_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif_cfg_w1_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif_cfg_w1_t;

#define BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_CFG_W1_FUNC(void)
{
	return 0x0000842060780040ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 bdk_tns_sde_mret_pg_fif_cfg_w1_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF_CFG_W1 "TNS_SDE_MRET_PG_FIF_CFG_W1"


/**
 * NCB32b - tns_sde_mret_pg_fif_dbg_cfg
 *
 * This register should not be modified from its default values, unless you know
 * what you are doing.
 */
typedef union bdk_tns_sde_mret_pg_fif_dbg_cfg {
	uint32_t u;
	struct bdk_tns_sde_mret_pg_fif_dbg_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t fifo0_prio3_enqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio3_deqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio3_contenq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio3_contdeq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio2_enqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio2_deqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio2_contenq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio2_contdeq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio1_enqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio1_deqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio1_contenq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio1_contdeq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio0_enqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio0_deqen           : 1;  /**< R/W - -- */
		uint32_t fifo0_prio0_contenq         : 1;  /**< R/W - -- */
		uint32_t fifo0_prio0_contdeq         : 1;  /**< R/W - -- */
#else
		uint32_t fifo0_prio0_contdeq         : 1;
		uint32_t fifo0_prio0_contenq         : 1;
		uint32_t fifo0_prio0_deqen           : 1;
		uint32_t fifo0_prio0_enqen           : 1;
		uint32_t fifo0_prio1_contdeq         : 1;
		uint32_t fifo0_prio1_contenq         : 1;
		uint32_t fifo0_prio1_deqen           : 1;
		uint32_t fifo0_prio1_enqen           : 1;
		uint32_t fifo0_prio2_contdeq         : 1;
		uint32_t fifo0_prio2_contenq         : 1;
		uint32_t fifo0_prio2_deqen           : 1;
		uint32_t fifo0_prio2_enqen           : 1;
		uint32_t fifo0_prio3_contdeq         : 1;
		uint32_t fifo0_prio3_contenq         : 1;
		uint32_t fifo0_prio3_deqen           : 1;
		uint32_t fifo0_prio3_enqen           : 1;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_pg_fif_dbg_cfg_s cn88xx; */
	/* struct bdk_tns_sde_mret_pg_fif_dbg_cfg_s cn88xxp1; */
} bdk_tns_sde_mret_pg_fif_dbg_cfg_t;

#define BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG_FUNC(void)
{
	return 0x00008420607800E4ull;
}
#define typedef_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG bdk_tns_sde_mret_pg_fif_dbg_cfg_t
#define bustype_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG 0
#define arguments_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_PG_FIF_DBG_CFG "TNS_SDE_MRET_PG_FIF_DBG_CFG"


/**
 * NCB32b - tns_sde_mret_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_mret_spad {
	uint32_t u;
	struct bdk_tns_sde_mret_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_mret_spad_s     cn88xx; */
	/* struct bdk_tns_sde_mret_spad_s     cn88xxp1; */
} bdk_tns_sde_mret_spad_t;

#define BDK_TNS_SDE_MRET_SPAD BDK_TNS_SDE_MRET_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_SPAD_FUNC(void)
{
	return 0x000084206078010Cull;
}
#define typedef_BDK_TNS_SDE_MRET_SPAD bdk_tns_sde_mret_spad_t
#define bustype_BDK_TNS_SDE_MRET_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_SPAD 0
#define arguments_BDK_TNS_SDE_MRET_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_SPAD "TNS_SDE_MRET_SPAD"


/**
 * NCB32b - tns_sde_mret_sta
 *
 * Status register for general status of the MRE module
 *
 */
typedef union bdk_tns_sde_mret_sta {
	uint32_t u;
	struct bdk_tns_sde_mret_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t memwr_cntrl_fl_init_done    : 1;  /**< RO/H - Indicates the corresponding MemWrCntrl
                                                                 has completed its freelist initialization. */
#else
		uint32_t memwr_cntrl_fl_init_done    : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_mret_sta_s      cn88xx; */
	/* struct bdk_tns_sde_mret_sta_s      cn88xxp1; */
} bdk_tns_sde_mret_sta_t;

#define BDK_TNS_SDE_MRET_STA BDK_TNS_SDE_MRET_STA_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_STA_FUNC(void)
{
	return 0x0000842060780000ull;
}
#define typedef_BDK_TNS_SDE_MRET_STA bdk_tns_sde_mret_sta_t
#define bustype_BDK_TNS_SDE_MRET_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_STA 0
#define arguments_BDK_TNS_SDE_MRET_STA -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_STA "TNS_SDE_MRET_STA"


/**
 * NCB32b - tns_sde_mret_tkn_in_ct
 *
 * --
 *
 */
typedef union bdk_tns_sde_mret_tkn_in_ct {
	uint32_t u;
	struct bdk_tns_sde_mret_tkn_in_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W/H - Number of tokens received on channel 0 */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_mret_tkn_in_ct_s cn88xx; */
	/* struct bdk_tns_sde_mret_tkn_in_ct_s cn88xxp1; */
} bdk_tns_sde_mret_tkn_in_ct_t;

#define BDK_TNS_SDE_MRET_TKN_IN_CT BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC()
static inline uint64_t BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_MRET_TKN_IN_CT_FUNC(void)
{
	return 0x0000842060780104ull;
}
#define typedef_BDK_TNS_SDE_MRET_TKN_IN_CT bdk_tns_sde_mret_tkn_in_ct_t
#define bustype_BDK_TNS_SDE_MRET_TKN_IN_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_MRET_TKN_IN_CT 0
#define arguments_BDK_TNS_SDE_MRET_TKN_IN_CT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_MRET_TKN_IN_CT "TNS_SDE_MRET_TKN_IN_CT"


/**
 * NCB - tns_sde_parser_int_en_hi
 *
 * --
 *
 */
typedef union bdk_tns_sde_parser_int_en_hi {
	uint64_t u;
	struct bdk_tns_sde_parser_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_55_63              : 9;
		uint64_t info_mem_db_err             : 4;  /**< R/W - -- */
		uint64_t info_mem_sb_err             : 4;  /**< R/W - -- */
		uint64_t header_mem_db_err           : 4;  /**< R/W - -- */
		uint64_t header_mem_sb_err           : 4;  /**< R/W - -- */
		uint64_t tokencmd_mem_db_err         : 1;  /**< R/W - -- */
		uint64_t tokencmd_mem_sb_err         : 1;  /**< R/W - -- */
		uint64_t qos_mem_db_err              : 1;  /**< R/W - -- */
		uint64_t qos_mem_sb_err              : 1;  /**< R/W - -- */
		uint64_t nextengine_mem_db_err       : 1;  /**< R/W - -- */
		uint64_t nextengine_mem_sb_err       : 1;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_miss           : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_db_err         : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_sb_err         : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_sram_db_err         : 6;  /**< R/W - -- */
		uint64_t ch0_kpu_sram_sb_err         : 6;  /**< R/W - -- */
		uint64_t mac2router_miss             : 1;  /**< R/W - -- */
		uint64_t mac2router_db_err           : 1;  /**< R/W - -- */
		uint64_t mac2router_sb_err           : 1;  /**< R/W - -- */
		uint64_t templateid_miss             : 1;  /**< R/W - -- */
		uint64_t templateid_db_err           : 1;  /**< R/W - -- */
		uint64_t templateid_sb_err           : 1;  /**< R/W - -- */
#else
		uint64_t templateid_sb_err           : 1;
		uint64_t templateid_db_err           : 1;
		uint64_t templateid_miss             : 1;
		uint64_t mac2router_sb_err           : 1;
		uint64_t mac2router_db_err           : 1;
		uint64_t mac2router_miss             : 1;
		uint64_t ch0_kpu_sram_sb_err         : 6;
		uint64_t ch0_kpu_sram_db_err         : 6;
		uint64_t ch0_kpu_tcam_sb_err         : 5;
		uint64_t ch0_kpu_tcam_db_err         : 5;
		uint64_t ch0_kpu_tcam_miss           : 5;
		uint64_t nextengine_mem_sb_err       : 1;
		uint64_t nextengine_mem_db_err       : 1;
		uint64_t qos_mem_sb_err              : 1;
		uint64_t qos_mem_db_err              : 1;
		uint64_t tokencmd_mem_sb_err         : 1;
		uint64_t tokencmd_mem_db_err         : 1;
		uint64_t header_mem_sb_err           : 4;
		uint64_t header_mem_db_err           : 4;
		uint64_t info_mem_sb_err             : 4;
		uint64_t info_mem_db_err             : 4;
		uint64_t reserved_55_63              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_parser_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_parser_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_parser_int_en_hi_t;

#define BDK_TNS_SDE_PARSER_INT_EN_HI BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_HI_FUNC(void)
{
	return 0x0000842060740010ull;
}
#define typedef_BDK_TNS_SDE_PARSER_INT_EN_HI bdk_tns_sde_parser_int_en_hi_t
#define bustype_BDK_TNS_SDE_PARSER_INT_EN_HI BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PARSER_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_PARSER_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_INT_EN_HI "TNS_SDE_PARSER_INT_EN_HI"


/**
 * NCB - tns_sde_parser_int_en_lo
 *
 * --
 *
 */
typedef union bdk_tns_sde_parser_int_en_lo {
	uint64_t u;
	struct bdk_tns_sde_parser_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_55_63              : 9;
		uint64_t info_mem_db_err             : 4;  /**< R/W - -- */
		uint64_t info_mem_sb_err             : 4;  /**< R/W - -- */
		uint64_t header_mem_db_err           : 4;  /**< R/W - -- */
		uint64_t header_mem_sb_err           : 4;  /**< R/W - -- */
		uint64_t tokencmd_mem_db_err         : 1;  /**< R/W - -- */
		uint64_t tokencmd_mem_sb_err         : 1;  /**< R/W - -- */
		uint64_t qos_mem_db_err              : 1;  /**< R/W - -- */
		uint64_t qos_mem_sb_err              : 1;  /**< R/W - -- */
		uint64_t nextengine_mem_db_err       : 1;  /**< R/W - -- */
		uint64_t nextengine_mem_sb_err       : 1;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_miss           : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_db_err         : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_tcam_sb_err         : 5;  /**< R/W - -- */
		uint64_t ch0_kpu_sram_db_err         : 6;  /**< R/W - -- */
		uint64_t ch0_kpu_sram_sb_err         : 6;  /**< R/W - -- */
		uint64_t mac2router_miss             : 1;  /**< R/W - -- */
		uint64_t mac2router_db_err           : 1;  /**< R/W - -- */
		uint64_t mac2router_sb_err           : 1;  /**< R/W - -- */
		uint64_t templateid_miss             : 1;  /**< R/W - -- */
		uint64_t templateid_db_err           : 1;  /**< R/W - -- */
		uint64_t templateid_sb_err           : 1;  /**< R/W - -- */
#else
		uint64_t templateid_sb_err           : 1;
		uint64_t templateid_db_err           : 1;
		uint64_t templateid_miss             : 1;
		uint64_t mac2router_sb_err           : 1;
		uint64_t mac2router_db_err           : 1;
		uint64_t mac2router_miss             : 1;
		uint64_t ch0_kpu_sram_sb_err         : 6;
		uint64_t ch0_kpu_sram_db_err         : 6;
		uint64_t ch0_kpu_tcam_sb_err         : 5;
		uint64_t ch0_kpu_tcam_db_err         : 5;
		uint64_t ch0_kpu_tcam_miss           : 5;
		uint64_t nextengine_mem_sb_err       : 1;
		uint64_t nextengine_mem_db_err       : 1;
		uint64_t qos_mem_sb_err              : 1;
		uint64_t qos_mem_db_err              : 1;
		uint64_t tokencmd_mem_sb_err         : 1;
		uint64_t tokencmd_mem_db_err         : 1;
		uint64_t header_mem_sb_err           : 4;
		uint64_t header_mem_db_err           : 4;
		uint64_t info_mem_sb_err             : 4;
		uint64_t info_mem_db_err             : 4;
		uint64_t reserved_55_63              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_parser_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_parser_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_parser_int_en_lo_t;

#define BDK_TNS_SDE_PARSER_INT_EN_LO BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_EN_LO_FUNC(void)
{
	return 0x0000842060740018ull;
}
#define typedef_BDK_TNS_SDE_PARSER_INT_EN_LO bdk_tns_sde_parser_int_en_lo_t
#define bustype_BDK_TNS_SDE_PARSER_INT_EN_LO BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PARSER_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_PARSER_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_INT_EN_LO "TNS_SDE_PARSER_INT_EN_LO"


/**
 * NCB - tns_sde_parser_int_frc
 *
 * --
 *
 */
typedef union bdk_tns_sde_parser_int_frc {
	uint64_t u;
	struct bdk_tns_sde_parser_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_55_63              : 9;
		uint64_t info_mem_db_err             : 4;  /**< WO - -- */
		uint64_t info_mem_sb_err             : 4;  /**< WO - -- */
		uint64_t header_mem_db_err           : 4;  /**< WO - -- */
		uint64_t header_mem_sb_err           : 4;  /**< WO - -- */
		uint64_t tokencmd_mem_db_err         : 1;  /**< WO - -- */
		uint64_t tokencmd_mem_sb_err         : 1;  /**< WO - -- */
		uint64_t qos_mem_db_err              : 1;  /**< WO - -- */
		uint64_t qos_mem_sb_err              : 1;  /**< WO - -- */
		uint64_t nextengine_mem_db_err       : 1;  /**< WO - -- */
		uint64_t nextengine_mem_sb_err       : 1;  /**< WO - -- */
		uint64_t ch0_kpu_tcam_miss           : 5;  /**< WO - -- */
		uint64_t ch0_kpu_tcam_db_err         : 5;  /**< WO - -- */
		uint64_t ch0_kpu_tcam_sb_err         : 5;  /**< WO - -- */
		uint64_t ch0_kpu_sram_db_err         : 6;  /**< WO - -- */
		uint64_t ch0_kpu_sram_sb_err         : 6;  /**< WO - -- */
		uint64_t mac2router_miss             : 1;  /**< WO - -- */
		uint64_t mac2router_db_err           : 1;  /**< WO - -- */
		uint64_t mac2router_sb_err           : 1;  /**< WO - -- */
		uint64_t templateid_miss             : 1;  /**< WO - -- */
		uint64_t templateid_db_err           : 1;  /**< WO - -- */
		uint64_t templateid_sb_err           : 1;  /**< WO - -- */
#else
		uint64_t templateid_sb_err           : 1;
		uint64_t templateid_db_err           : 1;
		uint64_t templateid_miss             : 1;
		uint64_t mac2router_sb_err           : 1;
		uint64_t mac2router_db_err           : 1;
		uint64_t mac2router_miss             : 1;
		uint64_t ch0_kpu_sram_sb_err         : 6;
		uint64_t ch0_kpu_sram_db_err         : 6;
		uint64_t ch0_kpu_tcam_sb_err         : 5;
		uint64_t ch0_kpu_tcam_db_err         : 5;
		uint64_t ch0_kpu_tcam_miss           : 5;
		uint64_t nextengine_mem_sb_err       : 1;
		uint64_t nextengine_mem_db_err       : 1;
		uint64_t qos_mem_sb_err              : 1;
		uint64_t qos_mem_db_err              : 1;
		uint64_t tokencmd_mem_sb_err         : 1;
		uint64_t tokencmd_mem_db_err         : 1;
		uint64_t header_mem_sb_err           : 4;
		uint64_t header_mem_db_err           : 4;
		uint64_t info_mem_sb_err             : 4;
		uint64_t info_mem_db_err             : 4;
		uint64_t reserved_55_63              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_parser_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_parser_int_frc_s cn88xxp1; */
} bdk_tns_sde_parser_int_frc_t;

#define BDK_TNS_SDE_PARSER_INT_FRC BDK_TNS_SDE_PARSER_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_FRC_FUNC(void)
{
	return 0x0000842060740020ull;
}
#define typedef_BDK_TNS_SDE_PARSER_INT_FRC bdk_tns_sde_parser_int_frc_t
#define bustype_BDK_TNS_SDE_PARSER_INT_FRC BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PARSER_INT_FRC 0
#define arguments_BDK_TNS_SDE_PARSER_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_INT_FRC "TNS_SDE_PARSER_INT_FRC"


/**
 * NCB - tns_sde_parser_int_w1c
 *
 * --
 *
 */
typedef union bdk_tns_sde_parser_int_w1c {
	uint64_t u;
	struct bdk_tns_sde_parser_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_55_63              : 9;
		uint64_t info_mem_db_err             : 4;  /**< R/W1C/H - -- */
		uint64_t info_mem_sb_err             : 4;  /**< R/W1C/H - -- */
		uint64_t header_mem_db_err           : 4;  /**< R/W1C/H - -- */
		uint64_t header_mem_sb_err           : 4;  /**< R/W1C/H - -- */
		uint64_t tokencmd_mem_db_err         : 1;  /**< R/W1C/H - -- */
		uint64_t tokencmd_mem_sb_err         : 1;  /**< R/W1C/H - -- */
		uint64_t qos_mem_db_err              : 1;  /**< R/W1C/H - -- */
		uint64_t qos_mem_sb_err              : 1;  /**< R/W1C/H - -- */
		uint64_t nextengine_mem_db_err       : 1;  /**< R/W1C/H - -- */
		uint64_t nextengine_mem_sb_err       : 1;  /**< R/W1C/H - -- */
		uint64_t ch0_kpu_tcam_miss           : 5;  /**< R/W1C/H - -- */
		uint64_t ch0_kpu_tcam_db_err         : 5;  /**< R/W1C/H - -- */
		uint64_t ch0_kpu_tcam_sb_err         : 5;  /**< R/W1C/H - -- */
		uint64_t ch0_kpu_sram_db_err         : 6;  /**< R/W1C/H - -- */
		uint64_t ch0_kpu_sram_sb_err         : 6;  /**< R/W1C/H - -- */
		uint64_t mac2router_miss             : 1;  /**< R/W1C/H - -- */
		uint64_t mac2router_db_err           : 1;  /**< R/W1C/H - -- */
		uint64_t mac2router_sb_err           : 1;  /**< R/W1C/H - -- */
		uint64_t templateid_miss             : 1;  /**< R/W1C/H - -- */
		uint64_t templateid_db_err           : 1;  /**< R/W1C/H - -- */
		uint64_t templateid_sb_err           : 1;  /**< R/W1C/H - -- */
#else
		uint64_t templateid_sb_err           : 1;
		uint64_t templateid_db_err           : 1;
		uint64_t templateid_miss             : 1;
		uint64_t mac2router_sb_err           : 1;
		uint64_t mac2router_db_err           : 1;
		uint64_t mac2router_miss             : 1;
		uint64_t ch0_kpu_sram_sb_err         : 6;
		uint64_t ch0_kpu_sram_db_err         : 6;
		uint64_t ch0_kpu_tcam_sb_err         : 5;
		uint64_t ch0_kpu_tcam_db_err         : 5;
		uint64_t ch0_kpu_tcam_miss           : 5;
		uint64_t nextengine_mem_sb_err       : 1;
		uint64_t nextengine_mem_db_err       : 1;
		uint64_t qos_mem_sb_err              : 1;
		uint64_t qos_mem_db_err              : 1;
		uint64_t tokencmd_mem_sb_err         : 1;
		uint64_t tokencmd_mem_db_err         : 1;
		uint64_t header_mem_sb_err           : 4;
		uint64_t header_mem_db_err           : 4;
		uint64_t info_mem_sb_err             : 4;
		uint64_t info_mem_db_err             : 4;
		uint64_t reserved_55_63              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_parser_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_parser_int_w1c_s cn88xxp1; */
} bdk_tns_sde_parser_int_w1c_t;

#define BDK_TNS_SDE_PARSER_INT_W1C BDK_TNS_SDE_PARSER_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_INT_W1C_FUNC(void)
{
	return 0x0000842060740008ull;
}
#define typedef_BDK_TNS_SDE_PARSER_INT_W1C bdk_tns_sde_parser_int_w1c_t
#define bustype_BDK_TNS_SDE_PARSER_INT_W1C BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PARSER_INT_W1C 0
#define arguments_BDK_TNS_SDE_PARSER_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_INT_W1C "TNS_SDE_PARSER_INT_W1C"


/**
 * NCB32b - tns_sde_parser_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_parser_lock {
	uint32_t u;
	struct bdk_tns_sde_parser_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_parser_lock_s   cn88xx; */
	/* struct bdk_tns_sde_parser_lock_s   cn88xxp1; */
} bdk_tns_sde_parser_lock_t;

#define BDK_TNS_SDE_PARSER_LOCK BDK_TNS_SDE_PARSER_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_LOCK_FUNC(void)
{
	return 0x0000842060740028ull;
}
#define typedef_BDK_TNS_SDE_PARSER_LOCK bdk_tns_sde_parser_lock_t
#define bustype_BDK_TNS_SDE_PARSER_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PARSER_LOCK 0
#define arguments_BDK_TNS_SDE_PARSER_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_LOCK "TNS_SDE_PARSER_LOCK"


/**
 * NCB32b - tns_sde_parser_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_parser_spad {
	uint32_t u;
	struct bdk_tns_sde_parser_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_parser_spad_s   cn88xx; */
	/* struct bdk_tns_sde_parser_spad_s   cn88xxp1; */
} bdk_tns_sde_parser_spad_t;

#define BDK_TNS_SDE_PARSER_SPAD BDK_TNS_SDE_PARSER_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PARSER_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PARSER_SPAD_FUNC(void)
{
	return 0x000084206074002Cull;
}
#define typedef_BDK_TNS_SDE_PARSER_SPAD bdk_tns_sde_parser_spad_t
#define bustype_BDK_TNS_SDE_PARSER_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PARSER_SPAD 0
#define arguments_BDK_TNS_SDE_PARSER_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PARSER_SPAD "TNS_SDE_PARSER_SPAD"


/**
 * NCB32b - tns_sde_pe_kpu#_kpu_dbg_w0
 *
 * Provides debug information about last TCAM entry
 *
 */
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_kpu_dbg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 24; /**< R/W/H - -- */
		uint32_t hit                         : 1;  /**< R/W/H - -- */
		uint32_t addr                        : 7;  /**< R/W/H - -- */
#else
		uint32_t addr                        : 7;
		uint32_t hit                         : 1;
		uint32_t key                         : 24;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w0_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_dbg_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A004ull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(...) bdk_tns_sde_pe_kpux_kpu_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W0(...) "TNS_SDE_PE_KPUX_KPU_DBG_W0"


/**
 * NCB32b - tns_sde_pe_kpu#_kpu_dbg_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_kpu_dbg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w1_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_dbg_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A008ull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(...) bdk_tns_sde_pe_kpux_kpu_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W1(...) "TNS_SDE_PE_KPUX_KPU_DBG_W1"


/**
 * NCB32b - tns_sde_pe_kpu#_kpu_dbg_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_kpu_dbg_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_kpu_dbg_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t enable                      : 1;  /**< R/W/H - -- */
		uint32_t valid                       : 1;  /**< R/W/H - -- */
		uint32_t pindex                      : 5;  /**< R/W/H - If programmed to a value between 0 - 16 will capture only that ports entry */
#else
		uint32_t pindex                      : 5;
		uint32_t valid                       : 1;
		uint32_t enable                      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_dbg_w2_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_dbg_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A00Cull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(...) bdk_tns_sde_pe_kpux_kpu_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_DBG_W2(...) "TNS_SDE_PE_KPUX_KPU_DBG_W2"


/**
 * NCB32b - tns_sde_pe_kpu#_kpu_ecc_ctl
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_kpux_kpu_ecc_ctl {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_kpu_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t cor_dis                     : 1;  /**< R/W - -- */
		uint32_t flip_sb                     : 1;  /**< R/W - -- */
		uint32_t flip_db                     : 1;  /**< R/W - -- */
#else
		uint32_t flip_db                     : 1;
		uint32_t flip_sb                     : 1;
		uint32_t cor_dis                     : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_ecc_ctl_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_ecc_ctl_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A000ull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(...) bdk_tns_sde_pe_kpux_kpu_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_ECC_CTL(...) "TNS_SDE_PE_KPUX_KPU_ECC_CTL"


/**
 * NCB - tns_sde_pe_kpu#_kpu_sram#_w0
 *
 * KPU SRAM
 * Bits[63:56] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_kpux_kpu_sramx_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_kpux_kpu_sramx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata1                   : 17; /**< R/W - -- */
		uint64_t lyrptradvance0              : 6;  /**< R/W - -- */
		uint64_t lyrptradvance1              : 6;  /**< R/W - -- */
		uint64_t transitionid                : 4;  /**< R/W - -- */
		uint64_t push2stack                  : 2;  /**< R/W - -- */
		uint64_t parsedone                   : 1;  /**< R/W - -- */
		uint64_t layertype0                  : 5;  /**< R/W - -- */
		uint64_t layertype1                  : 5;  /**< R/W - -- */
		uint64_t offset0                     : 6;  /**< R/W - -- */
		uint64_t offset1                     : 6;  /**< R/W - -- */
		uint64_t offset2                     : 6;  /**< R/W - -- */
#else
		uint64_t offset2                     : 6;
		uint64_t offset1                     : 6;
		uint64_t offset0                     : 6;
		uint64_t layertype1                  : 5;
		uint64_t layertype0                  : 5;
		uint64_t parsedone                   : 1;
		uint64_t push2stack                  : 2;
		uint64_t transitionid                : 4;
		uint64_t lyrptradvance1              : 6;
		uint64_t lyrptradvance0              : 6;
		uint64_t metadata1                   : 17;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_sramx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_sramx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_sramx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060719000ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(...) bdk_tns_sde_pe_kpux_kpu_sramx_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W0(...) "TNS_SDE_PE_KPUX_KPU_SRAMX_W0"


/**
 * NCB - tns_sde_pe_kpu#_kpu_sram#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_KPU_SRAM(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_kpu_sramx_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_kpux_kpu_sramx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_56_63              : 8;
		uint64_t innereth                    : 1;  /**< R/W - -- */
		uint64_t state                       : 8;  /**< R/W - -- */
		uint64_t metadata0                   : 32; /**< R/W - -- */
		uint64_t metadata1                   : 15; /**< R/W - Continuation of MSBs of field METADATA1 from previous word. */
#else
		uint64_t metadata1                   : 15;
		uint64_t metadata0                   : 32;
		uint64_t state                       : 8;
		uint64_t innereth                    : 1;
		uint64_t reserved_56_63              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_kpu_sramx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_kpu_sramx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_kpu_sramx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060719008ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(...) bdk_tns_sde_pe_kpux_kpu_sramx_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_KPU_SRAMX_W1(...) "TNS_SDE_PE_KPUX_KPU_SRAMX_W1"


/**
 * NCB32b - tns_sde_pe_kpu#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_pe_kpux_lock {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_lock_s  cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_lock_s  cn88xxp1; */
} bdk_tns_sde_pe_kpux_lock_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_LOCK(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A010ull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_LOCK(...) bdk_tns_sde_pe_kpux_lock_t
#define bustype_BDK_TNS_SDE_PE_KPUX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_LOCK(...) "TNS_SDE_PE_KPUX_LOCK"


/**
 * NCB32b - tns_sde_pe_kpu#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_pe_kpux_spad {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_spad_s  cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_spad_s  cn88xxp1; */
} bdk_tns_sde_pe_kpux_spad_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_SPAD(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206071A014ull + (param1 & 3) * 0x4000ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_SPAD(...) bdk_tns_sde_pe_kpux_spad_t
#define bustype_BDK_TNS_SDE_PE_KPUX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_SPAD(...) "TNS_SDE_PE_KPUX_SPAD"


/**
 * NCB - tns_sde_pe_kpu#_tcam_dat#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_datx {
	uint64_t u;
	struct bdk_tns_sde_pe_kpux_tcam_datx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_57_63              : 7;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t currentstate                : 8;  /**< R/W - -- */
		uint64_t decpoint0                   : 16; /**< R/W - -- */
		uint64_t decpoint1                   : 16; /**< R/W - -- */
		uint64_t decpoint2                   : 16; /**< R/W - -- */
#else
		uint64_t decpoint2                   : 16;
		uint64_t decpoint1                   : 16;
		uint64_t decpoint0                   : 16;
		uint64_t currentstate                : 8;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_57_63              : 7;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_datx_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_datx_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DATX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DATX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060719800ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DATX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(...) bdk_tns_sde_pe_kpux_tcam_datx_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DATX(...) "TNS_SDE_PE_KPUX_TCAM_DATX"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w0
 *
 * This is used to access the actual KPU TCAM.
 * Bits[31:18] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - -- */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718000ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W0(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W0"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718004ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W1(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W1"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718008ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W2(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W2"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w3_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x000084206071800Cull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W3(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W3"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w4_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718010ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W4(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W4"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w5
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w5 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w5_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w5_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w5_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718014ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w5_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W5(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W5"


/**
 * NCB32b - tns_sde_pe_kpu#_tcam_dmsk#_w6
 *
 * Continuation of structure defined in TNS_SDE_PE_KPU(0..3)_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_dmskx_w6 {
	uint32_t u;
	struct bdk_tns_sde_pe_kpux_tcam_dmskx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t vmvalid                     : 2;  /**< R/W - -- */
		uint32_t vmdata                      : 16; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 16;
		uint32_t vmvalid                     : 2;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w6_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_dmskx_w6_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_dmskx_w6_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060718018ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(...) bdk_tns_sde_pe_kpux_tcam_dmskx_w6_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_DMSKX_W6(...) "TNS_SDE_PE_KPUX_TCAM_DMSKX_W6"


/**
 * NCB - tns_sde_pe_kpu#_tcam_mask#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_kpux_tcam_maskx {
	uint64_t u;
	struct bdk_tns_sde_pe_kpux_tcam_maskx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_57_63              : 7;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t currentstate                : 8;  /**< R/W - -- */
		uint64_t decpoint0                   : 16; /**< R/W - -- */
		uint64_t decpoint1                   : 16; /**< R/W - -- */
		uint64_t decpoint2                   : 16; /**< R/W - -- */
#else
		uint64_t decpoint2                   : 16;
		uint64_t decpoint1                   : 16;
		uint64_t decpoint0                   : 16;
		uint64_t currentstate                : 8;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_57_63              : 7;
#endif
	} s;
	/* struct bdk_tns_sde_pe_kpux_tcam_maskx_s cn88xx; */
	/* struct bdk_tns_sde_pe_kpux_tcam_maskx_s cn88xxp1; */
} bdk_tns_sde_pe_kpux_tcam_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 3)) && ((param2 <= 127)))
		return 0x0000842060719C00ull + (param1 & 3) * 0x4000ull + (param2 & 127) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_KPUX_TCAM_MASKX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(...) bdk_tns_sde_pe_kpux_tcam_maskx_t
#define bustype_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_PE_KPUX_TCAM_MASKX(...) "TNS_SDE_PE_KPUX_TCAM_MASKX"


/**
 * NCB - tns_sde_pe_lcmd_cmdinfo_w0
 *
 * Contains different values that are used during the token creation
 *
 */
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_cmdinfo_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t ismekey3mask                : 6;  /**< R/W - -- */
		uint64_t etagnxtengen                : 1;  /**< R/W - -- */
		uint64_t etagnxteng                  : 8;  /**< R/W - -- */
		uint64_t errreasoncode               : 10; /**< R/W - -- */
		uint64_t errpacketcmd                : 2;  /**< R/W - -- */
		uint64_t errnxteng                   : 8;  /**< R/W - Value of next engine for error packets. These packets will be marked with
                                                                 reason code as DROP */
		uint64_t pktbc                       : 14; /**< R/W - For cut through ports this is the value of pktBC assigned in the token */
		uint64_t ipv4layertype               : 5;  /**< R/W - Indicates the layer type used for IPv4 */
		uint64_t ipv6layertype               : 5;  /**< R/W - Indicates the layer type used for IPv6 */
		uint64_t mplslayertype               : 5;  /**< R/W - Indicates the layer type used for MPLS */
#else
		uint64_t mplslayertype               : 5;
		uint64_t ipv6layertype               : 5;
		uint64_t ipv4layertype               : 5;
		uint64_t pktbc                       : 14;
		uint64_t errnxteng                   : 8;
		uint64_t errpacketcmd                : 2;
		uint64_t errreasoncode               : 10;
		uint64_t etagnxteng                  : 8;
		uint64_t etagnxtengen                : 1;
		uint64_t ismekey3mask                : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_cmdinfo_w0_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W0_FUNC(void)
{
	return 0x000084206070ADD0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 bdk_tns_sde_pe_lcmd_cmdinfo_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W0 "TNS_SDE_PE_LCMD_CMDINFO_W0"


/**
 * NCB - tns_sde_pe_lcmd_cmdinfo_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_cmdinfo_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t ismekey2mask                : 38; /**< R/W - -- */
		uint64_t ismekey3mask                : 26; /**< R/W - Continuation of MSBs of field ISMEKEY3MASK from previous word. */
#else
		uint64_t ismekey3mask                : 26;
		uint64_t ismekey2mask                : 38;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_cmdinfo_w1_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W1_FUNC(void)
{
	return 0x000084206070ADD8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 bdk_tns_sde_pe_lcmd_cmdinfo_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W1 "TNS_SDE_PE_LCMD_CMDINFO_W1"


/**
 * NCB - tns_sde_pe_lcmd_cmdinfo_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w2 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_cmdinfo_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t ismekey1mask                : 38; /**< R/W - -- */
		uint64_t ismekey2mask                : 26; /**< R/W - Continuation of MSBs of field ISMEKEY2MASK from previous word. */
#else
		uint64_t ismekey2mask                : 26;
		uint64_t ismekey1mask                : 38;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_cmdinfo_w2_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W2_FUNC(void)
{
	return 0x000084206070ADE0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 bdk_tns_sde_pe_lcmd_cmdinfo_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W2 "TNS_SDE_PE_LCMD_CMDINFO_W2"


/**
 * NCB - tns_sde_pe_lcmd_cmdinfo_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CMDINFO_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_cmdinfo_w3 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_cmdinfo_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_58_63              : 6;
		uint64_t ismekey0mask                : 32; /**< R/W - -- */
		uint64_t ismekey1mask                : 26; /**< R/W - Continuation of MSBs of field ISMEKEY1MASK from previous word. */
#else
		uint64_t ismekey1mask                : 26;
		uint64_t ismekey0mask                : 32;
		uint64_t reserved_58_63              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_cmdinfo_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_cmdinfo_w3_t;

#define BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CMDINFO_W3_FUNC(void)
{
	return 0x000084206070ADE8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 bdk_tns_sde_pe_lcmd_cmdinfo_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CMDINFO_W3 "TNS_SDE_PE_LCMD_CMDINFO_W3"


/**
 * NCB - tns_sde_pe_lcmd_cnncmd#
 *
 * Contains canon commands for layers which match the stored layerType and
 * layerHash values
 */
typedef union bdk_tns_sde_pe_lcmd_cnncmdx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_cnncmdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t layertype                   : 5;  /**< R/W - -- */
		uint64_t layerhash                   : 4;  /**< R/W - -- */
		uint64_t contbytes                   : 8;  /**< R/W - -- */
		uint64_t bitvector                   : 24; /**< R/W - -- */
#else
		uint64_t bitvector                   : 24;
		uint64_t contbytes                   : 8;
		uint64_t layerhash                   : 4;
		uint64_t layertype                   : 5;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_cnncmdx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_cnncmdx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_cnncmdx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_CNNCMDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CNNCMDX(unsigned long param1)
{
	if (((param1 <= 35)))
		return 0x000084206070A000ull + (param1 & 63) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_CNNCMDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CNNCMDX(...) bdk_tns_sde_pe_lcmd_cnncmdx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CNNCMDX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_CNNCMDX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_CNNCMDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CNNCMDX(...) "TNS_SDE_PE_LCMD_CNNCMDX"


/**
 * NCB32b - tns_sde_pe_lcmd_ctl_w0
 *
 * This register is used for debug purpose only
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ctl_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ctl_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t info_mem_spare              : 20; /**< R/W - -- */
		uint32_t info_mem_addr               : 6;  /**< R/W - -- */
		uint32_t header_mem_addr             : 6;  /**< R/W - -- */
#else
		uint32_t header_mem_addr             : 6;
		uint32_t info_mem_addr               : 6;
		uint32_t info_mem_spare              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ctl_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ctl_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ctl_w0_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W0 BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W0_FUNC(void)
{
	return 0x000084206070AD24ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W0 bdk_tns_sde_pe_lcmd_ctl_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W0 "TNS_SDE_PE_LCMD_CTL_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_ctl_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CTL_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ctl_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ctl_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pindex_fifo_threshold       : 4;  /**< R/W - -- */
		uint32_t token_fifo_threshold        : 5;  /**< R/W - -- */
		uint32_t hdr_buff_fifo_threshold     : 4;  /**< R/W - -- */
		uint32_t pindex                      : 5;  /**< R/W - -- */
		uint32_t linklist_entry              : 6;  /**< R/W - -- */
		uint32_t info_mem_spare              : 8;  /**< R/W - Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
#else
		uint32_t info_mem_spare              : 8;
		uint32_t linklist_entry              : 6;
		uint32_t pindex                      : 5;
		uint32_t hdr_buff_fifo_threshold     : 4;
		uint32_t token_fifo_threshold        : 5;
		uint32_t pindex_fifo_threshold       : 4;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ctl_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ctl_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ctl_w1_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W1 BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W1_FUNC(void)
{
	return 0x000084206070AD28ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W1 bdk_tns_sde_pe_lcmd_ctl_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W1 "TNS_SDE_PE_LCMD_CTL_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_ctl_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_CTL_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ctl_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ctl_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t hdr_addr_fifo_threshold     : 5;  /**< R/W - -- */
		uint32_t pindex_fifo_threshold       : 3;  /**< R/W - Continuation of MSBs of field PINDEX_FIFO_THRESHOLD from previous word. */
#else
		uint32_t pindex_fifo_threshold       : 3;
		uint32_t hdr_addr_fifo_threshold     : 5;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ctl_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ctl_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ctl_w2_t;

#define BDK_TNS_SDE_PE_LCMD_CTL_W2 BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_CTL_W2_FUNC(void)
{
	return 0x000084206070AD2Cull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_CTL_W2 bdk_tns_sde_pe_lcmd_ctl_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_CTL_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_CTL_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_CTL_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_CTL_W2 "TNS_SDE_PE_LCMD_CTL_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_errorbodyptr
 *
 * Format for both mask and value is {body_ptr_vld, body_ptr[13:0]}. If
 * bit in mask is set, incoming bit is compared against corresponding value
 * bit.
 * If they match, the packet is considered to be received with an error.
 */
typedef union bdk_tns_sde_pe_lcmd_errorbodyptr {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_errorbodyptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t mask                        : 15; /**< R/W - -- */
		uint32_t value                       : 15; /**< R/W - -- */
#else
		uint32_t value                       : 15;
		uint32_t mask                        : 15;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_errorbodyptr_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_errorbodyptr_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_errorbodyptr_t;

#define BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR_FUNC(void)
{
	return 0x000084206070AE14ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR bdk_tns_sde_pe_lcmd_errorbodyptr_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR 0
#define arguments_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ERRORBODYPTR "TNS_SDE_PE_LCMD_ERRORBODYPTR"


/**
 * NCB32b - tns_sde_pe_lcmd_ethernetctrl#
 *
 * Contains the ether-type and vlan offset values that are used for etherent layer
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ethernetctrlx {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ethernetctrlx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t offset2                     : 6;  /**< R/W - -- */
		uint32_t offset1                     : 6;  /**< R/W - -- */
		uint32_t offset0                     : 6;  /**< R/W - -- */
		uint32_t etagen                      : 1;  /**< R/W - -- */
		uint32_t layertype                   : 5;  /**< R/W - -- */
#else
		uint32_t layertype                   : 5;
		uint32_t etagen                      : 1;
		uint32_t offset0                     : 6;
		uint32_t offset1                     : 6;
		uint32_t offset2                     : 6;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ethernetctrlx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ethernetctrlx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ethernetctrlx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(unsigned long param1)
{
	if (((param1 <= 2)))
		return 0x000084206070AD00ull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(...) bdk_tns_sde_pe_lcmd_ethernetctrlx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ETHERNETCTRLX(...) "TNS_SDE_PE_LCMD_ETHERNETCTRLX"


/**
 * NCB32b - tns_sde_pe_lcmd_hashcmds#_w0
 *
 * Contains commands to form the hash logic input. Each command can copy a max of
 * 4 bytes
 * Bits[31:4] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_hashcmdsx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t layeroffset1                : 3;  /**< R/W - -- */
		uint32_t fieldlen1                   : 3;  /**< R/W - -- */
		uint32_t hashmask1                   : 8;  /**< R/W - -- */
		uint32_t hashmaskmsb1                : 1;  /**< R/W - -- */
		uint32_t layeroffset0                : 5;  /**< R/W - -- */
		uint32_t fieldlen0                   : 3;  /**< R/W - -- */
		uint32_t hashmask0                   : 8;  /**< R/W - -- */
		uint32_t hashmaskmsb0                : 1;  /**< R/W - -- */
#else
		uint32_t hashmaskmsb0                : 1;
		uint32_t hashmask0                   : 8;
		uint32_t fieldlen0                   : 3;
		uint32_t layeroffset0                : 5;
		uint32_t hashmaskmsb1                : 1;
		uint32_t hashmask1                   : 8;
		uint32_t fieldlen1                   : 3;
		uint32_t layeroffset1                : 3;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hashcmdsx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A200ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(...) bdk_tns_sde_pe_lcmd_hashcmdsx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W0(...) "TNS_SDE_PE_LCMD_HASHCMDSX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_hashcmds#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCMDS(0..31)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_hashcmdsx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t layeroffset3                : 1;  /**< R/W - -- */
		uint32_t fieldlen3                   : 3;  /**< R/W - -- */
		uint32_t hashmask3                   : 8;  /**< R/W - -- */
		uint32_t hashmaskmsb3                : 1;  /**< R/W - -- */
		uint32_t layeroffset2                : 5;  /**< R/W - -- */
		uint32_t fieldlen2                   : 3;  /**< R/W - -- */
		uint32_t hashmask2                   : 8;  /**< R/W - -- */
		uint32_t hashmaskmsb2                : 1;  /**< R/W - -- */
		uint32_t layeroffset1                : 2;  /**< R/W - Continuation of MSBs of field LAYEROFFSET1 from previous word. */
#else
		uint32_t layeroffset1                : 2;
		uint32_t hashmaskmsb2                : 1;
		uint32_t hashmask2                   : 8;
		uint32_t fieldlen2                   : 3;
		uint32_t layeroffset2                : 5;
		uint32_t hashmaskmsb3                : 1;
		uint32_t hashmask3                   : 8;
		uint32_t fieldlen3                   : 3;
		uint32_t layeroffset3                : 1;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hashcmdsx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A204ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(...) bdk_tns_sde_pe_lcmd_hashcmdsx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W1(...) "TNS_SDE_PE_LCMD_HASHCMDSX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_hashcmds#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCMDS(0..31)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_hashcmdsx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_hashcmdsx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t layeroffset3                : 4;  /**< R/W - Continuation of MSBs of field LAYEROFFSET3 from previous word. */
#else
		uint32_t layeroffset3                : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hashcmdsx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hashcmdsx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A208ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(...) bdk_tns_sde_pe_lcmd_hashcmdsx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCMDSX_W2(...) "TNS_SDE_PE_LCMD_HASHCMDSX_W2"


/**
 * NCB - tns_sde_pe_lcmd_hashctrl_w0
 *
 * Controls which polynomial is used for which hash generation. The polynomials
 * used are: 0: 2011 1: 2415 2: 2461 3: 2745 4: 2431 5: 2707 6: 2055 7: 2157.
 * Polynomials for lag are 0: 435 1: 567 2: 763 3: 551
 */
typedef union bdk_tns_sde_pe_lcmd_hashctrl_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_hashctrl_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t seed4                       : 8;  /**< R/W - -- */
		uint64_t seed3                       : 10; /**< R/W - -- */
		uint64_t seed2                       : 10; /**< R/W - -- */
		uint64_t seed1                       : 10; /**< R/W - -- */
		uint64_t seed0                       : 10; /**< R/W - -- */
		uint64_t laghasha                    : 2;  /**< R/W - Indicates which hash function should be used for lag_hash_a */
		uint64_t laghashb                    : 2;  /**< R/W - Indicates which hash function should be used for lag_hash_b */
		uint64_t l2ecmphasha                 : 3;  /**< R/W - Indicates which hash function should be used for l2_ecmp_hash_a */
		uint64_t l2ecmphashb                 : 3;  /**< R/W - Indicates which hash function should be used for l2_ecmp_hash_b */
		uint64_t l3ecmphasha                 : 3;  /**< R/W - Indicates which hash function should be used for l3_ecmp_hash_a */
		uint64_t l3ecmphashb                 : 3;  /**< R/W - Indicates which hash function should be used for l3_ecmp_hash_b */
#else
		uint64_t l3ecmphashb                 : 3;
		uint64_t l3ecmphasha                 : 3;
		uint64_t l2ecmphashb                 : 3;
		uint64_t l2ecmphasha                 : 3;
		uint64_t laghashb                    : 2;
		uint64_t laghasha                    : 2;
		uint64_t seed0                       : 10;
		uint64_t seed1                       : 10;
		uint64_t seed2                       : 10;
		uint64_t seed3                       : 10;
		uint64_t seed4                       : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hashctrl_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hashctrl_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hashctrl_w0_t;

#define BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0_FUNC(void)
{
	return 0x000084206070ADF0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 bdk_tns_sde_pe_lcmd_hashctrl_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W0 "TNS_SDE_PE_LCMD_HASHCTRL_W0"


/**
 * NCB - tns_sde_pe_lcmd_hashctrl_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_HASHCTRL_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_hashctrl_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_hashctrl_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t seed8_3                     : 8;  /**< R/W - -- */
		uint64_t seed8_2                     : 8;  /**< R/W - -- */
		uint64_t seed8_1                     : 8;  /**< R/W - -- */
		uint64_t seed8_0                     : 8;  /**< R/W - -- */
		uint64_t seed7                       : 10; /**< R/W - -- */
		uint64_t seed6                       : 10; /**< R/W - -- */
		uint64_t seed5                       : 10; /**< R/W - -- */
		uint64_t seed4                       : 2;  /**< R/W - Continuation of MSBs of field SEED4 from previous word. */
#else
		uint64_t seed4                       : 2;
		uint64_t seed5                       : 10;
		uint64_t seed6                       : 10;
		uint64_t seed7                       : 10;
		uint64_t seed8_0                     : 8;
		uint64_t seed8_1                     : 8;
		uint64_t seed8_2                     : 8;
		uint64_t seed8_3                     : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hashctrl_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hashctrl_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hashctrl_w1_t;

#define BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1_FUNC(void)
{
	return 0x000084206070ADF8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 bdk_tns_sde_pe_lcmd_hashctrl_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HASHCTRL_W1 "TNS_SDE_PE_LCMD_HASHCTRL_W1"


/**
 * NCB - tns_sde_pe_lcmd_hmem_dat_w#
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_hmem_dat_wx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_hmem_dat_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W/H - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_hmem_dat_wx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_hmem_dat_wx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_hmem_dat_wx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084206070AD30ull + (param1 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(...) bdk_tns_sde_pe_lcmd_hmem_dat_wx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_HMEM_DAT_WX(...) "TNS_SDE_PE_LCMD_HMEM_DAT_WX"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t timestamp                   : 64; /**< R/W/H - -- */
#else
		uint64_t timestamp                   : 64;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w0_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0_FUNC(void)
{
	return 0x000084206070AD70ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 bdk_tns_sde_pe_lcmd_imem_dat_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W0 "TNS_SDE_PE_LCMD_IMEM_DAT_W0"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata6                   : 22; /**< R/W/H - -- */
		uint64_t metadata7                   : 32; /**< R/W/H - -- */
		uint64_t pkt_id                      : 10; /**< R/W/H - -- */
#else
		uint64_t pkt_id                      : 10;
		uint64_t metadata7                   : 32;
		uint64_t metadata6                   : 22;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w1_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1_FUNC(void)
{
	return 0x000084206070AD78ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 bdk_tns_sde_pe_lcmd_imem_dat_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W1 "TNS_SDE_PE_LCMD_IMEM_DAT_W1"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w2 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata4                   : 22; /**< R/W/H - -- */
		uint64_t metadata5                   : 32; /**< R/W/H - -- */
		uint64_t metadata6                   : 10; /**< R/W/H - Continuation of MSBs of field METADATA6 from previous word. */
#else
		uint64_t metadata6                   : 10;
		uint64_t metadata5                   : 32;
		uint64_t metadata4                   : 22;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w2_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2_FUNC(void)
{
	return 0x000084206070AD80ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 bdk_tns_sde_pe_lcmd_imem_dat_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W2 "TNS_SDE_PE_LCMD_IMEM_DAT_W2"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w3 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata2                   : 22; /**< R/W/H - -- */
		uint64_t metadata3                   : 32; /**< R/W/H - -- */
		uint64_t metadata4                   : 10; /**< R/W/H - Continuation of MSBs of field METADATA4 from previous word. */
#else
		uint64_t metadata4                   : 10;
		uint64_t metadata3                   : 32;
		uint64_t metadata2                   : 22;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w3_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3_FUNC(void)
{
	return 0x000084206070AD88ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 bdk_tns_sde_pe_lcmd_imem_dat_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W3 "TNS_SDE_PE_LCMD_IMEM_DAT_W3"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w4 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata0                   : 22; /**< R/W/H - -- */
		uint64_t metadata1                   : 32; /**< R/W/H - -- */
		uint64_t metadata2                   : 10; /**< R/W/H - Continuation of MSBs of field METADATA2 from previous word. */
#else
		uint64_t metadata2                   : 10;
		uint64_t metadata1                   : 32;
		uint64_t metadata0                   : 22;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w4_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w4_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4_FUNC(void)
{
	return 0x000084206070AD90ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 bdk_tns_sde_pe_lcmd_imem_dat_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W4 "TNS_SDE_PE_LCMD_IMEM_DAT_W4"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w5
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w5 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t layertype2                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash2                  : 4;  /**< R/W/H - -- */
		uint64_t layertype3                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash3                  : 4;  /**< R/W/H - -- */
		uint64_t layertype4                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash4                  : 4;  /**< R/W/H - -- */
		uint64_t layertype5                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash5                  : 4;  /**< R/W/H - -- */
		uint64_t layertype6                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash6                  : 4;  /**< R/W/H - -- */
		uint64_t layertype7                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash7                  : 4;  /**< R/W/H - -- */
		uint64_t metadata0                   : 10; /**< R/W/H - Continuation of MSBs of field METADATA0 from previous word. */
#else
		uint64_t metadata0                   : 10;
		uint64_t layerhash7                  : 4;
		uint64_t layertype7                  : 5;
		uint64_t layerhash6                  : 4;
		uint64_t layertype6                  : 5;
		uint64_t layerhash5                  : 4;
		uint64_t layertype5                  : 5;
		uint64_t layerhash4                  : 4;
		uint64_t layertype4                  : 5;
		uint64_t layerhash3                  : 4;
		uint64_t layertype3                  : 5;
		uint64_t layerhash2                  : 4;
		uint64_t layertype2                  : 5;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w5_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w5_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w5_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5_FUNC(void)
{
	return 0x000084206070AD98ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 bdk_tns_sde_pe_lcmd_imem_dat_w5_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W5 "TNS_SDE_PE_LCMD_IMEM_DAT_W5"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w6
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w6 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t layerendptr2                : 6;  /**< R/W/H - -- */
		uint64_t layerendptr3                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr4                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr5                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr6                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr7                : 8;  /**< R/W/H - -- */
		uint64_t layertype0                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash0                  : 4;  /**< R/W/H - -- */
		uint64_t layertype1                  : 5;  /**< R/W/H - -- */
		uint64_t layerhash1                  : 4;  /**< R/W/H - -- */
#else
		uint64_t layerhash1                  : 4;
		uint64_t layertype1                  : 5;
		uint64_t layerhash0                  : 4;
		uint64_t layertype0                  : 5;
		uint64_t layerendptr7                : 8;
		uint64_t layerendptr6                : 8;
		uint64_t layerendptr5                : 8;
		uint64_t layerendptr4                : 8;
		uint64_t layerendptr3                : 8;
		uint64_t layerendptr2                : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w6_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w6_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w6_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6_FUNC(void)
{
	return 0x000084206070ADA0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 bdk_tns_sde_pe_lcmd_imem_dat_w6_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W6 "TNS_SDE_PE_LCMD_IMEM_DAT_W6"


/**
 * NCB - tns_sde_pe_lcmd_imem_dat_w7
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_IMEM_DAT_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_imem_dat_w7 {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_imem_dat_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t xphexists                   : 1;  /**< R/W/H - -- */
		uint64_t hts_exists                  : 1;  /**< R/W/H - -- */
		uint64_t startptr                    : 8;  /**< R/W/H - -- */
		uint64_t pnum                        : 8;  /**< R/W/H - -- */
		uint64_t layerendptr0                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr1                : 8;  /**< R/W/H - -- */
		uint64_t layerendptr2                : 2;  /**< R/W/H - Continuation of MSBs of field LAYERENDPTR2 from previous word. */
#else
		uint64_t layerendptr2                : 2;
		uint64_t layerendptr1                : 8;
		uint64_t layerendptr0                : 8;
		uint64_t pnum                        : 8;
		uint64_t startptr                    : 8;
		uint64_t hts_exists                  : 1;
		uint64_t xphexists                   : 1;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w7_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_imem_dat_w7_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_imem_dat_w7_t;

#define BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7_FUNC(void)
{
	return 0x000084206070ADA8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 bdk_tns_sde_pe_lcmd_imem_dat_w7_t
#define bustype_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 0
#define arguments_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_IMEM_DAT_W7 "TNS_SDE_PE_LCMD_IMEM_DAT_W7"


/**
 * NCB32b - tns_sde_pe_lcmd_itt#_w0
 *
 * Initial Token Table contains fields that will be used in the token as is
 * Bits[31:25] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_ittx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ittx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 2;  /**< R/W - -- */
		uint32_t filter_grp_num              : 8;  /**< R/W - -- */
		uint32_t layer2qosen                 : 1;  /**< R/W - -- */
		uint32_t ip2qosen                    : 1;  /**< R/W - -- */
		uint32_t mpls2qosen                  : 1;  /**< R/W - -- */
		uint32_t porttrafficclass            : 4;  /**< R/W - -- */
		uint32_t portdropprecedence          : 2;  /**< R/W - -- */
		uint32_t portpcp                     : 3;  /**< R/W - -- */
		uint32_t portdei                     : 1;  /**< R/W - -- */
		uint32_t portdscp                    : 6;  /**< R/W - -- */
		uint32_t portexp                     : 3;  /**< R/W - -- */
#else
		uint32_t portexp                     : 3;
		uint32_t portdscp                    : 6;
		uint32_t portdei                     : 1;
		uint32_t portpcp                     : 3;
		uint32_t portdropprecedence          : 2;
		uint32_t porttrafficclass            : 4;
		uint32_t mpls2qosen                  : 1;
		uint32_t ip2qosen                    : 1;
		uint32_t layer2qosen                 : 1;
		uint32_t filter_grp_num              : 8;
		uint32_t scratchpad                  : 2;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ittx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ittx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ittx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W0(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060704000ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ITTX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W0(...) bdk_tns_sde_pe_lcmd_ittx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W0(...) "TNS_SDE_PE_LCMD_ITTX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_itt#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ittx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ittx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - Continuation of MSBs of field SCRATCHPAD from previous word. */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ittx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ittx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ittx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W1(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060704004ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ITTX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W1(...) bdk_tns_sde_pe_lcmd_ittx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W1(...) "TNS_SDE_PE_LCMD_ITTX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_itt#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ittx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ittx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mirrorbitmask               : 2;  /**< R/W - -- */
		uint32_t scratchpad                  : 30; /**< R/W - Continuation of MSBs of field SCRATCHPAD from previous word. */
#else
		uint32_t scratchpad                  : 30;
		uint32_t mirrorbitmask               : 2;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ittx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ittx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ittx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W2(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060704008ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ITTX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W2(...) bdk_tns_sde_pe_lcmd_ittx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W2(...) "TNS_SDE_PE_LCMD_ITTX_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_itt#_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ittx_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ittx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ingressvif                  : 18; /**< R/W - -- */
		uint32_t mirrorbitmask               : 14; /**< R/W - Continuation of MSBs of field MIRRORBITMASK from previous word. */
#else
		uint32_t mirrorbitmask               : 14;
		uint32_t ingressvif                  : 18;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ittx_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ittx_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ittx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W3(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x000084206070400Cull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ITTX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W3(...) bdk_tns_sde_pe_lcmd_ittx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W3(...) "TNS_SDE_PE_LCMD_ITTX_W3"


/**
 * NCB32b - tns_sde_pe_lcmd_itt#_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_ITT(0..136)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ittx_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ittx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_25_31              : 7;
		uint32_t etagexists                  : 1;  /**< R/W - -- */
		uint32_t l2qosprofile                : 3;  /**< R/W - -- */
		uint32_t ipqosprofile                : 3;  /**< R/W - -- */
		uint32_t mplsqosprofile              : 3;  /**< R/W - -- */
		uint32_t pvid                        : 12; /**< R/W - -- */
		uint32_t pvidmodeallpkt              : 1;  /**< R/W - -- */
		uint32_t ingressvif                  : 2;  /**< R/W - Continuation of MSBs of field INGRESSVIF from previous word. */
#else
		uint32_t ingressvif                  : 2;
		uint32_t pvidmodeallpkt              : 1;
		uint32_t pvid                        : 12;
		uint32_t mplsqosprofile              : 3;
		uint32_t ipqosprofile                : 3;
		uint32_t l2qosprofile                : 3;
		uint32_t etagexists                  : 1;
		uint32_t reserved_25_31              : 7;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ittx_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ittx_w4_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ittx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_ITTX_W4(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060704010ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_ITTX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_ITTX_W4(...) bdk_tns_sde_pe_lcmd_ittx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_ITTX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_ITTX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_ITTX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_ITTX_W4(...) "TNS_SDE_PE_LCMD_ITTX_W4"


/**
 * NCB32b - tns_sde_pe_lcmd_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_pe_lcmd_lock {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_lock_s  cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_lock_s  cn88xxp1; */
} bdk_tns_sde_pe_lcmd_lock_t;

#define BDK_TNS_SDE_PE_LCMD_LOCK BDK_TNS_SDE_PE_LCMD_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LOCK_FUNC(void)
{
	return 0x000084206070AE18ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_LOCK bdk_tns_sde_pe_lcmd_lock_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_LOCK 0
#define arguments_BDK_TNS_SDE_PE_LCMD_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_LOCK "TNS_SDE_PE_LCMD_LOCK"


/**
 * NCB32b - tns_sde_pe_lcmd_lsplitcmd#
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_lsplitcmdx {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_lsplitcmdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t layertype                   : 5;  /**< R/W - -- */
		uint32_t newlayertype                : 5;  /**< R/W - -- */
		uint32_t splitbytes                  : 6;  /**< R/W - -- */
#else
		uint32_t splitbytes                  : 6;
		uint32_t newlayertype                : 5;
		uint32_t layertype                   : 5;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_lsplitcmdx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_lsplitcmdx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_lsplitcmdx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206070AD10ull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_LSPLITCMDX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(...) bdk_tns_sde_pe_lcmd_lsplitcmdx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_LSPLITCMDX(...) "TNS_SDE_PE_LCMD_LSPLITCMDX"


/**
 * NCB32b - tns_sde_pe_lcmd_ltokencmd#_w0
 *
 * Contains commands that indicate how the layer portion in the token should be
 * build. Each cmd can copy a max of 8 bytes
 * Bits[31:9] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ltokencmdx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t fieldlen3                   : 2;  /**< R/W - -- */
		uint32_t layeroffset2                : 6;  /**< R/W - -- */
		uint32_t fieldlen2                   : 4;  /**< R/W - -- */
		uint32_t layeroffset1                : 6;  /**< R/W - -- */
		uint32_t fieldlen1                   : 4;  /**< R/W - -- */
		uint32_t layeroffset0                : 6;  /**< R/W - -- */
		uint32_t fieldlen0                   : 4;  /**< R/W - -- */
#else
		uint32_t fieldlen0                   : 4;
		uint32_t layeroffset0                : 6;
		uint32_t fieldlen1                   : 4;
		uint32_t layeroffset1                : 6;
		uint32_t fieldlen2                   : 4;
		uint32_t layeroffset2                : 6;
		uint32_t fieldlen3                   : 2;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ltokencmdx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A400ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(...) bdk_tns_sde_pe_lcmd_ltokencmdx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W0(...) "TNS_SDE_PE_LCMD_LTOKENCMDX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_ltokencmd#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_LTOKENCMD(0..31)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ltokencmdx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t fieldlen6                   : 4;  /**< R/W - -- */
		uint32_t layeroffset5                : 6;  /**< R/W - -- */
		uint32_t fieldlen5                   : 4;  /**< R/W - -- */
		uint32_t layeroffset4                : 6;  /**< R/W - -- */
		uint32_t fieldlen4                   : 4;  /**< R/W - -- */
		uint32_t layeroffset3                : 6;  /**< R/W - -- */
		uint32_t fieldlen3                   : 2;  /**< R/W - Continuation of MSBs of field FIELDLEN3 from previous word. */
#else
		uint32_t fieldlen3                   : 2;
		uint32_t layeroffset3                : 6;
		uint32_t fieldlen4                   : 4;
		uint32_t layeroffset4                : 6;
		uint32_t fieldlen5                   : 4;
		uint32_t layeroffset5                : 6;
		uint32_t fieldlen6                   : 4;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ltokencmdx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A404ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(...) bdk_tns_sde_pe_lcmd_ltokencmdx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W1(...) "TNS_SDE_PE_LCMD_LTOKENCMDX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_ltokencmd#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_LTOKENCMD(0..31)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_ltokencmdx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_ltokencmdx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t metalen                     : 3;  /**< R/W - This commands copies the meta-data, this cmd is also used for padding to make
                                                                 the total len of that layer 4B aligned. For a value of 5 1 bte padding is done */
		uint32_t layeroffset6                : 6;  /**< R/W - -- */
#else
		uint32_t layeroffset6                : 6;
		uint32_t metalen                     : 3;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_ltokencmdx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_ltokencmdx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206070A408ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(...) bdk_tns_sde_pe_lcmd_ltokencmdx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_LTOKENCMDX_W2(...) "TNS_SDE_PE_LCMD_LTOKENCMDX_W2"


/**
 * NCB - tns_sde_pe_lcmd_m2r_dat#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_datx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_datx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_61_63              : 3;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t vlan                        : 12; /**< R/W - -- */
		uint64_t macda                       : 48; /**< R/W - -- */
#else
		uint64_t macda                       : 48;
		uint64_t vlan                        : 12;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_61_63              : 3;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_datx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_datx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DATX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DATX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060708000ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DATX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DATX(...) bdk_tns_sde_pe_lcmd_m2r_datx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DATX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DATX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DATX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DATX(...) "TNS_SDE_PE_LCMD_M2R_DATX"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dbg_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dbg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 23; /**< R/W - -- */
		uint32_t hit                         : 1;  /**< R/W - -- */
		uint32_t addr                        : 8;  /**< R/W - -- */
#else
		uint32_t addr                        : 8;
		uint32_t hit                         : 1;
		uint32_t key                         : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dbg_w0_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0_FUNC(void)
{
	return 0x000084206070AE08ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 bdk_tns_sde_pe_lcmd_m2r_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W0 "TNS_SDE_PE_LCMD_M2R_DBG_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dbg_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dbg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dbg_w1_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1_FUNC(void)
{
	return 0x000084206070AE0Cull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 bdk_tns_sde_pe_lcmd_m2r_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W1 "TNS_SDE_PE_LCMD_M2R_DBG_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dbg_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dbg_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dbg_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t enable                      : 1;  /**< R/W - -- */
		uint32_t valid                       : 1;  /**< R/W - -- */
		uint32_t pindex                      : 5;  /**< R/W - If programmed to a value between 0 - 16 will capture only that ports entry. if
                                                                 programmed to value beyond this range this field will indicate for which pindex
                                                                 the debug info was captured */
		uint32_t key                         : 5;  /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 5;
		uint32_t pindex                      : 5;
		uint32_t valid                       : 1;
		uint32_t enable                      : 1;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dbg_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dbg_w2_t;

#define BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2_FUNC(void)
{
	return 0x000084206070AE10ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 bdk_tns_sde_pe_lcmd_m2r_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DBG_W2 "TNS_SDE_PE_LCMD_M2R_DBG_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dmsk#_w0
 *
 * This is used to access the actual KPU TCAM.
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - -- */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060702000ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(...) bdk_tns_sde_pe_lcmd_m2r_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W0(...) "TNS_SDE_PE_LCMD_M2R_DMSKX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dmsk#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060702004ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(...) bdk_tns_sde_pe_lcmd_m2r_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W1(...) "TNS_SDE_PE_LCMD_M2R_DMSKX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dmsk#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060702008ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(...) bdk_tns_sde_pe_lcmd_m2r_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W2(...) "TNS_SDE_PE_LCMD_M2R_DMSKX_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dmsk#_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084206070200Cull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(...) bdk_tns_sde_pe_lcmd_m2r_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W3(...) "TNS_SDE_PE_LCMD_M2R_DMSKX_W3"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_dmsk#_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_M2R_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_dmskx_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t vmvalid                     : 2;  /**< R/W - -- */
#else
		uint32_t vmvalid                     : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060702010ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(...) bdk_tns_sde_pe_lcmd_m2r_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_DMSKX_W4(...) "TNS_SDE_PE_LCMD_M2R_DMSKX_W4"


/**
 * NCB - tns_sde_pe_lcmd_m2r_mask#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_maskx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_maskx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_61_63              : 3;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t vlan                        : 12; /**< R/W - -- */
		uint64_t macda                       : 48; /**< R/W - -- */
#else
		uint64_t macda                       : 48;
		uint64_t vlan                        : 12;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_61_63              : 3;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_maskx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_maskx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MASKX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MASKX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060708800ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_MASKX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(...) bdk_tns_sde_pe_lcmd_m2r_maskx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_MASKX(...) "TNS_SDE_PE_LCMD_M2R_MASKX"


/**
 * NCB32b - tns_sde_pe_lcmd_m2r_mem#
 *
 * This memory is accessed based on hit address of mac2router TCAM. Each entry
 * maps to 4 consecutive addresses
 */
typedef union bdk_tns_sde_pe_lcmd_m2r_memx {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_m2r_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t value3                      : 4;  /**< R/W - -- */
		uint32_t value2                      : 4;  /**< R/W - -- */
		uint32_t value1                      : 4;  /**< R/W - -- */
		uint32_t value0                      : 4;  /**< R/W - -- */
#else
		uint32_t value0                      : 4;
		uint32_t value1                      : 4;
		uint32_t value2                      : 4;
		uint32_t value3                      : 4;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_m2r_memx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_m2r_memx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_m2r_memx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_M2R_MEMX(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x000084206070AC00ull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_M2R_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(...) bdk_tns_sde_pe_lcmd_m2r_memx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_M2R_MEMX(...) "TNS_SDE_PE_LCMD_M2R_MEMX"


/**
 * NCB32b - tns_sde_pe_lcmd_mem_ecc_ctl
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_mem_ecc_ctl {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_mem_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_27_31              : 5;
		uint32_t info_mem_cor_dis            : 1;  /**< R/W - -- */
		uint32_t info_mem_flip_sb            : 4;  /**< R/W - -- */
		uint32_t info_mem_flip_db            : 4;  /**< R/W - -- */
		uint32_t header_mem_cor_dis          : 1;  /**< R/W - -- */
		uint32_t header_mem_flip_sb          : 4;  /**< R/W - -- */
		uint32_t header_mem_flip_db          : 4;  /**< R/W - -- */
		uint32_t tokencmd_mem_cor_dis        : 1;  /**< R/W - -- */
		uint32_t tokencmd_mem_flip_sb        : 1;  /**< R/W - -- */
		uint32_t tokencmd_mem_flip_db        : 1;  /**< R/W - -- */
		uint32_t qos_mem_cor_dis             : 1;  /**< R/W - -- */
		uint32_t qos_mem_flip_sb             : 1;  /**< R/W - -- */
		uint32_t qos_mem_flip_db             : 1;  /**< R/W - -- */
		uint32_t nexteng_mem_cor_dis         : 1;  /**< R/W - -- */
		uint32_t nexteng_mem_flip_sb         : 1;  /**< R/W - -- */
		uint32_t nexteng_mem_flip_db         : 1;  /**< R/W - -- */
#else
		uint32_t nexteng_mem_flip_db         : 1;
		uint32_t nexteng_mem_flip_sb         : 1;
		uint32_t nexteng_mem_cor_dis         : 1;
		uint32_t qos_mem_flip_db             : 1;
		uint32_t qos_mem_flip_sb             : 1;
		uint32_t qos_mem_cor_dis             : 1;
		uint32_t tokencmd_mem_flip_db        : 1;
		uint32_t tokencmd_mem_flip_sb        : 1;
		uint32_t tokencmd_mem_cor_dis        : 1;
		uint32_t header_mem_flip_db          : 4;
		uint32_t header_mem_flip_sb          : 4;
		uint32_t header_mem_cor_dis          : 1;
		uint32_t info_mem_flip_db            : 4;
		uint32_t info_mem_flip_sb            : 4;
		uint32_t info_mem_cor_dis            : 1;
		uint32_t reserved_27_31              : 5;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_mem_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_mem_ecc_ctl_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_mem_ecc_ctl_t;

#define BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL_FUNC(void)
{
	return 0x000084206070ADCCull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL bdk_tns_sde_pe_lcmd_mem_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL 0
#define arguments_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_MEM_ECC_CTL "TNS_SDE_PE_LCMD_MEM_ECC_CTL"


/**
 * NCB32b - tns_sde_pe_lcmd_neng#_w0
 *
 * --
 * Bits[31:2] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_nengx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_nengx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t egressvif                   : 3;  /**< R/W - -- */
		uint32_t reasoncode                  : 10; /**< R/W - -- */
		uint32_t pktcmd                      : 2;  /**< R/W - -- */
		uint32_t slavelaneselect             : 3;  /**< R/W - -- */
		uint32_t nextengine                  : 8;  /**< R/W - -- */
		uint32_t ttl                         : 6;  /**< R/W - -- */
#else
		uint32_t ttl                         : 6;
		uint32_t nextengine                  : 8;
		uint32_t slavelaneselect             : 3;
		uint32_t pktcmd                      : 2;
		uint32_t reasoncode                  : 10;
		uint32_t egressvif                   : 3;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_nengx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_nengx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_nengx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060709000ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_NENGX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W0(...) bdk_tns_sde_pe_lcmd_nengx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W0(...) "TNS_SDE_PE_LCMD_NENGX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_neng#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_NENG(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_nengx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_nengx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lm_cmd                      : 1;  /**< R/W - -- */
		uint32_t ismekeysel                  : 2;  /**< R/W - -- */
		uint32_t ecmpsize                    : 12; /**< R/W - -- */
		uint32_t egressvif                   : 17; /**< R/W - Continuation of MSBs of field EGRESSVIF from previous word. */
#else
		uint32_t egressvif                   : 17;
		uint32_t ecmpsize                    : 12;
		uint32_t ismekeysel                  : 2;
		uint32_t lm_cmd                      : 1;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_nengx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_nengx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_nengx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060709004ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_NENGX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W1(...) bdk_tns_sde_pe_lcmd_nengx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W1(...) "TNS_SDE_PE_LCMD_NENGX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_neng#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_NENG(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_nengx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_nengx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t rsrvd                       : 2;  /**< R/W - -- */
#else
		uint32_t rsrvd                       : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_nengx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_nengx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_nengx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_NENGX_W2(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060709008ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_NENGX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_NENGX_W2(...) bdk_tns_sde_pe_lcmd_nengx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_NENGX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_NENGX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_NENGX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_NENGX_W2(...) "TNS_SDE_PE_LCMD_NENGX_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_pindex2port#
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_pindex2portx {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_pindex2portx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t pindex                      : 4;  /**< R/W - -- */
#else
		uint32_t pindex                      : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_pindex2portx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_pindex2portx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_pindex2portx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x000084206070A800ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(...) bdk_tns_sde_pe_lcmd_pindex2portx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_PINDEX2PORTX(...) "TNS_SDE_PE_LCMD_PINDEX2PORTX"


/**
 * NCB32b - tns_sde_pe_lcmd_prsr_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_prsr_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_prsr_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_prsr_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_prsr_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_prsr_dbg_sel_t;

#define BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL_FUNC(void)
{
	return 0x000084206070AD20ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL bdk_tns_sde_pe_lcmd_prsr_dbg_sel_t
#define bustype_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL 0
#define arguments_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_PRSR_DBG_SEL "TNS_SDE_PE_LCMD_PRSR_DBG_SEL"


/**
 * NCB32b - tns_sde_pe_lcmd_qos#
 *
 * QoS memory, contains per port Layer2, IP, MPLS values. There are 16 entry for
 * Layer2, 64 for IP, and 8 for MPLS
 * Layer2 is indexed using PINDEX*16+{PCP, DEI}, IP is indexed using 18*16 +
 * PINDEX*64 + DSCP, MPLS is indexed using 18*64 + 18*16 + PINDEX*8 + EXP
 */
typedef union bdk_tns_sde_pe_lcmd_qosx {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_qosx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t trafficclass                : 4;  /**< R/W - -- */
		uint32_t dropprecedence              : 2;  /**< R/W - -- */
		uint32_t pcp                         : 3;  /**< R/W - -- */
		uint32_t dei                         : 1;  /**< R/W - -- */
		uint32_t dscp                        : 6;  /**< R/W - -- */
		uint32_t exp                         : 3;  /**< R/W - -- */
#else
		uint32_t exp                         : 3;
		uint32_t dscp                        : 6;
		uint32_t dei                         : 1;
		uint32_t pcp                         : 3;
		uint32_t dropprecedence              : 2;
		uint32_t trafficclass                : 4;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_qosx_s  cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_qosx_s  cn88xxp1; */
} bdk_tns_sde_pe_lcmd_qosx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_QOSX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_QOSX(unsigned long param1)
{
	if (((param1 <= 703)))
		return 0x0000842060706000ull + (param1 & 1023) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_QOSX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_QOSX(...) bdk_tns_sde_pe_lcmd_qosx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_QOSX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_QOSX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_QOSX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_QOSX(...) "TNS_SDE_PE_LCMD_QOSX"


/**
 * NCB32b - tns_sde_pe_lcmd_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_pe_lcmd_spad {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_spad_s  cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_spad_s  cn88xxp1; */
} bdk_tns_sde_pe_lcmd_spad_t;

#define BDK_TNS_SDE_PE_LCMD_SPAD BDK_TNS_SDE_PE_LCMD_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_SPAD_FUNC(void)
{
	return 0x000084206070AE1Cull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_SPAD bdk_tns_sde_pe_lcmd_spad_t
#define bustype_BDK_TNS_SDE_PE_LCMD_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_SPAD 0
#define arguments_BDK_TNS_SDE_PE_LCMD_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_SPAD "TNS_SDE_PE_LCMD_SPAD"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t info_mem_spare              : 12; /**< RO/H - -- */
		uint32_t hdr_buff_req_srdy           : 1;  /**< RO/H - -- */
		uint32_t hdr_buff_req_drdy           : 1;  /**< RO/H - -- */
		uint32_t hdr_buff_wr_srdy            : 1;  /**< RO/H - -- */
		uint32_t hdr_buff_wr_drdy            : 1;  /**< RO/H - -- */
		uint32_t token_srdy                  : 1;  /**< RO/H - -- */
		uint32_t token_drdy                  : 1;  /**< RO/H - -- */
		uint32_t token_fifo_usage            : 5;  /**< RO/H - -- */
		uint32_t hdr_buff_fifo_usage         : 4;  /**< RO/H - -- */
		uint32_t hdr_addr_fifo_usage         : 5;  /**< RO/H - -- */
#else
		uint32_t hdr_addr_fifo_usage         : 5;
		uint32_t hdr_buff_fifo_usage         : 4;
		uint32_t token_fifo_usage            : 5;
		uint32_t token_drdy                  : 1;
		uint32_t token_srdy                  : 1;
		uint32_t hdr_buff_wr_drdy            : 1;
		uint32_t hdr_buff_wr_srdy            : 1;
		uint32_t hdr_buff_req_drdy           : 1;
		uint32_t hdr_buff_req_srdy           : 1;
		uint32_t info_mem_spare              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w0_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W0 BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W0_FUNC(void)
{
	return 0x000084206070ADB0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W0 bdk_tns_sde_pe_lcmd_sta_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W0 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W0 "TNS_SDE_PE_LCMD_STA_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t infoll                      : 16; /**< RO/H - -- */
		uint32_t info_mem_spare              : 16; /**< RO/H - Continuation of MSBs of field INFO_MEM_SPARE from previous word. */
#else
		uint32_t info_mem_spare              : 16;
		uint32_t infoll                      : 16;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w1_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W1 BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W1_FUNC(void)
{
	return 0x000084206070ADB4ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W1 bdk_tns_sde_pe_lcmd_sta_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W1 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W1 "TNS_SDE_PE_LCMD_STA_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t rdinfoheadptr               : 5;  /**< RO/H - -- */
		uint32_t linklist                    : 6;  /**< RO/H - -- */
		uint32_t infoll                      : 21; /**< RO/H - Continuation of MSBs of field INFOLL from previous word. */
#else
		uint32_t infoll                      : 21;
		uint32_t linklist                    : 6;
		uint32_t rdinfoheadptr               : 5;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w2_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W2 BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W2_FUNC(void)
{
	return 0x000084206070ADB8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W2 bdk_tns_sde_pe_lcmd_sta_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W2 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W2 "TNS_SDE_PE_LCMD_STA_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t infofreecnt                 : 6;  /**< RO/H - -- */
		uint32_t infotailptr                 : 6;  /**< RO/H - -- */
		uint32_t infoheadptr                 : 6;  /**< RO/H - -- */
		uint32_t rdinfocnt                   : 7;  /**< RO/H - -- */
		uint32_t rdinfotailptr               : 6;  /**< RO/H - -- */
		uint32_t rdinfoheadptr               : 1;  /**< RO/H - Continuation of MSBs of field RDINFOHEADPTR from previous word. */
#else
		uint32_t rdinfoheadptr               : 1;
		uint32_t rdinfotailptr               : 6;
		uint32_t rdinfocnt                   : 7;
		uint32_t infoheadptr                 : 6;
		uint32_t infotailptr                 : 6;
		uint32_t infofreecnt                 : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w3_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W3 BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W3_FUNC(void)
{
	return 0x000084206070ADBCull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W3 bdk_tns_sde_pe_lcmd_sta_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W3 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W3 "TNS_SDE_PE_LCMD_STA_W3"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t rdtailptr                   : 6;  /**< RO/H - -- */
		uint32_t rdheadptr                   : 6;  /**< RO/H - -- */
		uint32_t freetailptr                 : 6;  /**< RO/H - -- */
		uint32_t freeheadptr                 : 6;  /**< RO/H - -- */
		uint32_t freecnt                     : 7;  /**< RO/H - -- */
		uint32_t infofreecnt                 : 1;  /**< RO/H - Continuation of MSBs of field INFOFREECNT from previous word. */
#else
		uint32_t infofreecnt                 : 1;
		uint32_t freecnt                     : 7;
		uint32_t freeheadptr                 : 6;
		uint32_t freetailptr                 : 6;
		uint32_t rdheadptr                   : 6;
		uint32_t rdtailptr                   : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w4_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w4_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W4 BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W4_FUNC(void)
{
	return 0x000084206070ADC0ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W4 bdk_tns_sde_pe_lcmd_sta_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W4 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W4 "TNS_SDE_PE_LCMD_STA_W4"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w5
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w5 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t hdr_buff_fifo_cnt           : 1;  /**< RO/H - -- */
		uint32_t q_empty                     : 17; /**< RO/H - -- */
		uint32_t pindex_cnt                  : 7;  /**< RO/H - -- */
		uint32_t rdcnt                       : 7;  /**< RO/H - -- */
#else
		uint32_t rdcnt                       : 7;
		uint32_t pindex_cnt                  : 7;
		uint32_t q_empty                     : 17;
		uint32_t hdr_buff_fifo_cnt           : 1;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w5_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w5_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w5_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W5 BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W5_FUNC(void)
{
	return 0x000084206070ADC4ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W5 bdk_tns_sde_pe_lcmd_sta_w5_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W5 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W5 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W5 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W5 "TNS_SDE_PE_LCMD_STA_W5"


/**
 * NCB32b - tns_sde_pe_lcmd_sta_w6
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_STA_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_sta_w6 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_sta_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t hdr_buff_fifo_cnt           : 3;  /**< RO/H - Continuation of MSBs of field HDR_BUFF_FIFO_CNT from previous word. */
#else
		uint32_t hdr_buff_fifo_cnt           : 3;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_sta_w6_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_sta_w6_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_sta_w6_t;

#define BDK_TNS_SDE_PE_LCMD_STA_W6 BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_STA_W6_FUNC(void)
{
	return 0x000084206070ADC8ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_STA_W6 bdk_tns_sde_pe_lcmd_sta_w6_t
#define bustype_BDK_TNS_SDE_PE_LCMD_STA_W6 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_STA_W6 0
#define arguments_BDK_TNS_SDE_PE_LCMD_STA_W6 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_STA_W6 "TNS_SDE_PE_LCMD_STA_W6"


/**
 * NCB - tns_sde_pe_lcmd_tid_dat#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_datx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_tid_datx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t layertype7                  : 5;  /**< R/W - -- */
		uint64_t layertype6                  : 5;  /**< R/W - -- */
		uint64_t layertype5                  : 5;  /**< R/W - -- */
		uint64_t layertype4                  : 5;  /**< R/W - -- */
		uint64_t layertype3                  : 5;  /**< R/W - -- */
		uint64_t layertype2                  : 5;  /**< R/W - -- */
		uint64_t layertype1                  : 5;  /**< R/W - -- */
		uint64_t layertype0                  : 5;  /**< R/W - -- */
#else
		uint64_t layertype0                  : 5;
		uint64_t layertype1                  : 5;
		uint64_t layertype2                  : 5;
		uint64_t layertype3                  : 5;
		uint64_t layertype4                  : 5;
		uint64_t layertype5                  : 5;
		uint64_t layertype6                  : 5;
		uint64_t layertype7                  : 5;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_datx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_datx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_datx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DATX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DATX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060707000ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DATX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DATX(...) bdk_tns_sde_pe_lcmd_tid_datx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DATX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DATX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DATX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DATX(...) "TNS_SDE_PE_LCMD_TID_DATX"


/**
 * NCB - tns_sde_pe_lcmd_tid_dbg
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dbg {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_56_63              : 8;
		uint64_t enable                      : 1;  /**< R/W - -- */
		uint64_t valid                       : 1;  /**< R/W - -- */
		uint64_t pindex                      : 5;  /**< R/W - If programmed to a value between 0 - 16 will capture only that ports entry */
		uint64_t key                         : 40; /**< R/W - -- */
		uint64_t hit                         : 1;  /**< R/W - -- */
		uint64_t addr                        : 8;  /**< R/W - -- */
#else
		uint64_t addr                        : 8;
		uint64_t hit                         : 1;
		uint64_t key                         : 40;
		uint64_t pindex                      : 5;
		uint64_t valid                       : 1;
		uint64_t enable                      : 1;
		uint64_t reserved_56_63              : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dbg_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dbg_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dbg_t;

#define BDK_TNS_SDE_PE_LCMD_TID_DBG BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DBG_FUNC(void)
{
	return 0x000084206070AE00ull;
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DBG bdk_tns_sde_pe_lcmd_tid_dbg_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DBG BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DBG 0
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DBG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DBG "TNS_SDE_PE_LCMD_TID_DBG"


/**
 * NCB32b - tns_sde_pe_lcmd_tid_dmsk#_w0
 *
 * Template Id TCAM Data
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dmskx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - -- */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060700000ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(...) bdk_tns_sde_pe_lcmd_tid_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W0(...) "TNS_SDE_PE_LCMD_TID_DMSKX_W0"


/**
 * NCB32b - tns_sde_pe_lcmd_tid_dmsk#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dmskx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060700004ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(...) bdk_tns_sde_pe_lcmd_tid_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W1(...) "TNS_SDE_PE_LCMD_TID_DMSKX_W1"


/**
 * NCB32b - tns_sde_pe_lcmd_tid_dmsk#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dmskx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060700008ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(...) bdk_tns_sde_pe_lcmd_tid_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W2(...) "TNS_SDE_PE_LCMD_TID_DMSKX_W2"


/**
 * NCB32b - tns_sde_pe_lcmd_tid_dmsk#_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dmskx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w3_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084206070000Cull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(...) bdk_tns_sde_pe_lcmd_tid_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W3(...) "TNS_SDE_PE_LCMD_TID_DMSKX_W3"


/**
 * NCB32b - tns_sde_pe_lcmd_tid_dmsk#_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_LCMD_TID_DMSK(0..255)_W0
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_dmskx_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_lcmd_tid_dmskx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t vmvalid                     : 2;  /**< R/W - -- */
#else
		uint32_t vmvalid                     : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_dmskx_w4_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060700010ull + (param1 & 255) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(...) bdk_tns_sde_pe_lcmd_tid_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_DMSKX_W4(...) "TNS_SDE_PE_LCMD_TID_DMSKX_W4"


/**
 * NCB - tns_sde_pe_lcmd_tid_mask#
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT.
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tid_maskx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_tid_maskx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t layertype7                  : 5;  /**< R/W - -- */
		uint64_t layertype6                  : 5;  /**< R/W - -- */
		uint64_t layertype5                  : 5;  /**< R/W - -- */
		uint64_t layertype4                  : 5;  /**< R/W - -- */
		uint64_t layertype3                  : 5;  /**< R/W - -- */
		uint64_t layertype2                  : 5;  /**< R/W - -- */
		uint64_t layertype1                  : 5;  /**< R/W - -- */
		uint64_t layertype0                  : 5;  /**< R/W - -- */
#else
		uint64_t layertype0                  : 5;
		uint64_t layertype1                  : 5;
		uint64_t layertype2                  : 5;
		uint64_t layertype3                  : 5;
		uint64_t layertype4                  : 5;
		uint64_t layertype5                  : 5;
		uint64_t layertype6                  : 5;
		uint64_t layertype7                  : 5;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tid_maskx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tid_maskx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tid_maskx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_MASKX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TID_MASKX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060707800ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TID_MASKX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TID_MASKX(...) bdk_tns_sde_pe_lcmd_tid_maskx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TID_MASKX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_TID_MASKX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TID_MASKX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TID_MASKX(...) "TNS_SDE_PE_LCMD_TID_MASKX"


/**
 * NCB - tns_sde_pe_lcmd_tokencmds#
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_lcmd_tokencmdsx {
	uint64_t u;
	struct bdk_tns_sde_pe_lcmd_tokencmdsx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_34_63              : 30;
		uint64_t inrethm2rloc                : 7;  /**< R/W - -- */
		uint64_t hashaen                     : 8;  /**< R/W - -- */
		uint64_t hashben                     : 8;  /**< R/W - -- */
		uint64_t firstvldlayer               : 3;  /**< R/W - -- */
		uint64_t templateid                  : 8;  /**< R/W - -- */
#else
		uint64_t templateid                  : 8;
		uint64_t firstvldlayer               : 3;
		uint64_t hashben                     : 8;
		uint64_t hashaen                     : 8;
		uint64_t inrethm2rloc                : 7;
		uint64_t reserved_34_63              : 30;
#endif
	} s;
	/* struct bdk_tns_sde_pe_lcmd_tokencmdsx_s cn88xx; */
	/* struct bdk_tns_sde_pe_lcmd_tokencmdsx_s cn88xxp1; */
} bdk_tns_sde_pe_lcmd_tokencmdsx_t;

static inline uint64_t BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842060709800ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_PE_LCMD_TOKENCMDSX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(...) bdk_tns_sde_pe_lcmd_tokencmdsx_t
#define bustype_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_LCMD_TOKENCMDSX(...) "TNS_SDE_PE_LCMD_TOKENCMDSX"


/**
 * NCB32b - tns_sde_pe_skpu_control
 *
 * Misc control bits for the entire parser
 *
 */
typedef union bdk_tns_sde_pe_skpu_control {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_control_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_27_31              : 5;
		uint32_t use_ivif_for_ikt_index      : 1;  /**< R/W - If cleared the address to access the IKT is the src_port provided from the
                                                                 datapath. If set the IKT is looked up using xph.ivif[7:0]
                                                                 if xph is present (else it is looked up using src_port as usual). */
		uint32_t hdr_threshold               : 7;  /**< R/W - Controls number of headers that can exist in the KPU's. To turn off headers
                                                                 from rx, prog it to 0. For normal mode prog 42, for ull change it to 10.
                                                                 (8*kpus + 2). Value has to be less than 64 */
		uint32_t ull_token_mode              : 1;  /**< R/W - Used to control when the token is sent in the ull mode. If set to 0, the token
                                                                 is sent when the full 64B are received. If set to 1, the token is sent when the
                                                                 32B are received. */
		uint32_t cut_through                 : 17; /**< R/W - If set to 1, indicates that port is in cut through mode */
		uint32_t ull_mode                    : 1;  /**< R/W - If set to 1, indicates that parser is operating in ultra low latency mode */
#else
		uint32_t ull_mode                    : 1;
		uint32_t cut_through                 : 17;
		uint32_t ull_token_mode              : 1;
		uint32_t hdr_threshold               : 7;
		uint32_t use_ivif_for_ikt_index      : 1;
		uint32_t reserved_27_31              : 5;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_control_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_control_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_control_t;

#define BDK_TNS_SDE_PE_SKPU_CONTROL BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_CONTROL_FUNC(void)
{
	return 0x0000842060714000ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_CONTROL bdk_tns_sde_pe_skpu_control_t
#define bustype_BDK_TNS_SDE_PE_SKPU_CONTROL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_CONTROL 0
#define arguments_BDK_TNS_SDE_PE_SKPU_CONTROL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_CONTROL "TNS_SDE_PE_SKPU_CONTROL"


/**
 * NCB32b - tns_sde_pe_skpu_ecc_ctl
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_skpu_ecc_ctl {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t cor_dis                     : 1;  /**< R/W - -- */
		uint32_t flip_sb                     : 2;  /**< R/W - -- */
		uint32_t flip_db                     : 2;  /**< R/W - -- */
#else
		uint32_t flip_db                     : 2;
		uint32_t flip_sb                     : 2;
		uint32_t cor_dis                     : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_ecc_ctl_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_ecc_ctl_t;

#define BDK_TNS_SDE_PE_SKPU_ECC_CTL BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_ECC_CTL_FUNC(void)
{
	return 0x0000842060714008ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_ECC_CTL bdk_tns_sde_pe_skpu_ecc_ctl_t
#define bustype_BDK_TNS_SDE_PE_SKPU_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_ECC_CTL 0
#define arguments_BDK_TNS_SDE_PE_SKPU_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_ECC_CTL "TNS_SDE_PE_SKPU_ECC_CTL"


/**
 * NCB - tns_sde_pe_skpu_ikt#_w0
 *
 * Initial KPU Table contains fields to start the parsing
 * Bits[63:36] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_skpu_iktx_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_iktx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t decpointoffset2             : 2;  /**< R/W - -- */
		uint64_t decpointoffset3             : 6;  /**< R/W - -- */
		uint64_t decpointoffset4             : 6;  /**< R/W - -- */
		uint64_t decpointoffset5             : 6;  /**< R/W - -- */
		uint64_t decpointoffset6             : 6;  /**< R/W - -- */
		uint64_t decpointoffset7             : 6;  /**< R/W - -- */
		uint64_t decpointoffset8             : 6;  /**< R/W - -- */
		uint64_t decpointoffset9             : 6;  /**< R/W - -- */
		uint64_t decpointoffset10            : 6;  /**< R/W - -- */
		uint64_t decpointoffset11            : 6;  /**< R/W - -- */
		uint64_t pnum                        : 8;  /**< R/W - -- */
#else
		uint64_t pnum                        : 8;
		uint64_t decpointoffset11            : 6;
		uint64_t decpointoffset10            : 6;
		uint64_t decpointoffset9             : 6;
		uint64_t decpointoffset8             : 6;
		uint64_t decpointoffset7             : 6;
		uint64_t decpointoffset6             : 6;
		uint64_t decpointoffset5             : 6;
		uint64_t decpointoffset4             : 6;
		uint64_t decpointoffset3             : 6;
		uint64_t decpointoffset2             : 2;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_iktx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_iktx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_iktx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W0(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060710000ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_IKTX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_IKTX_W0(...) bdk_tns_sde_pe_skpu_iktx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKTX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_IKTX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_IKTX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_IKTX_W0(...) "TNS_SDE_PE_SKPU_IKTX_W0"


/**
 * NCB - tns_sde_pe_skpu_ikt#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_IKT(0..136)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_iktx_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_iktx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_36_63              : 28;
		uint64_t xphexists                   : 1;  /**< R/W - -- */
		uint64_t hts_exists                  : 1;  /**< R/W - -- */
		uint64_t chnum                       : 2;  /**< R/W - -- */
		uint64_t initialstate                : 8;  /**< R/W - -- */
		uint64_t initialpktptr               : 8;  /**< R/W - -- */
		uint64_t decpointoffset0             : 6;  /**< R/W - -- */
		uint64_t decpointoffset1             : 6;  /**< R/W - -- */
		uint64_t decpointoffset2             : 4;  /**< R/W - Continuation of MSBs of field DECPOINTOFFSET2 from previous word. */
#else
		uint64_t decpointoffset2             : 4;
		uint64_t decpointoffset1             : 6;
		uint64_t decpointoffset0             : 6;
		uint64_t initialpktptr               : 8;
		uint64_t initialstate                : 8;
		uint64_t chnum                       : 2;
		uint64_t hts_exists                  : 1;
		uint64_t xphexists                   : 1;
		uint64_t reserved_36_63              : 28;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_iktx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_iktx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_iktx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKTX_W1(unsigned long param1)
{
	if (((param1 <= 136)))
		return 0x0000842060710008ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_IKTX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_IKTX_W1(...) bdk_tns_sde_pe_skpu_iktx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKTX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_IKTX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_IKTX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_IKTX_W1(...) "TNS_SDE_PE_SKPU_IKTX_W1"


/**
 * NCB32b - tns_sde_pe_skpu_ikt_dbg
 *
 * --
 *
 */
typedef union bdk_tns_sde_pe_skpu_ikt_dbg {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_ikt_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t rx_srdy                     : 1;  /**< RO/H - -- */
		uint32_t rx_drdy                     : 1;  /**< RO/H - -- */
		uint32_t hdr_cnt                     : 7;  /**< RO/H - -- */
#else
		uint32_t hdr_cnt                     : 7;
		uint32_t rx_drdy                     : 1;
		uint32_t rx_srdy                     : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_ikt_dbg_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_ikt_dbg_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_ikt_dbg_t;

#define BDK_TNS_SDE_PE_SKPU_IKT_DBG BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_IKT_DBG_FUNC(void)
{
	return 0x0000842060714004ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_IKT_DBG bdk_tns_sde_pe_skpu_ikt_dbg_t
#define bustype_BDK_TNS_SDE_PE_SKPU_IKT_DBG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_IKT_DBG 0
#define arguments_BDK_TNS_SDE_PE_SKPU_IKT_DBG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_IKT_DBG "TNS_SDE_PE_SKPU_IKT_DBG"


/**
 * NCB32b - tns_sde_pe_skpu_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_pe_skpu_lock {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_lock_s  cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_lock_s  cn88xxp1; */
} bdk_tns_sde_pe_skpu_lock_t;

#define BDK_TNS_SDE_PE_SKPU_LOCK BDK_TNS_SDE_PE_SKPU_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_LOCK_FUNC(void)
{
	return 0x000084206071401Cull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_LOCK bdk_tns_sde_pe_skpu_lock_t
#define bustype_BDK_TNS_SDE_PE_SKPU_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_LOCK 0
#define arguments_BDK_TNS_SDE_PE_SKPU_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_LOCK "TNS_SDE_PE_SKPU_LOCK"


/**
 * NCB32b - tns_sde_pe_skpu_skpu_dbg_w0
 *
 * Provides debug information about last TCAM entry
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_skpu_dbg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 24; /**< R/W/H - -- */
		uint32_t hit                         : 1;  /**< R/W/H - -- */
		uint32_t addr                        : 7;  /**< R/W/H - -- */
#else
		uint32_t addr                        : 7;
		uint32_t hit                         : 1;
		uint32_t key                         : 24;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_dbg_w0_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0_FUNC(void)
{
	return 0x000084206071400Cull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 bdk_tns_sde_pe_skpu_skpu_dbg_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W0 "TNS_SDE_PE_SKPU_SKPU_DBG_W0"


/**
 * NCB32b - tns_sde_pe_skpu_skpu_dbg_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_skpu_dbg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_dbg_w1_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1_FUNC(void)
{
	return 0x0000842060714010ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 bdk_tns_sde_pe_skpu_skpu_dbg_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W1 "TNS_SDE_PE_SKPU_SKPU_DBG_W1"


/**
 * NCB32b - tns_sde_pe_skpu_skpu_dbg_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_skpu_dbg_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w2_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_dbg_w2_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2_FUNC(void)
{
	return 0x0000842060714014ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 bdk_tns_sde_pe_skpu_skpu_dbg_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W2 "TNS_SDE_PE_SKPU_SKPU_DBG_W2"


/**
 * NCB32b - tns_sde_pe_skpu_skpu_dbg_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_DBG_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_dbg_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_skpu_dbg_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_23_31              : 9;
		uint32_t enable                      : 1;  /**< R/W/H - Will only capture an entry when enable=1 AND valid=0 */
		uint32_t valid                       : 1;  /**< R/W/H - A value of 1, indicates that an entry was captured */
		uint32_t pindex                      : 5;  /**< R/W/H - If programmed to a value between 0 - 16 will capture only that ports entry */
		uint32_t key                         : 16; /**< R/W/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 16;
		uint32_t pindex                      : 5;
		uint32_t valid                       : 1;
		uint32_t enable                      : 1;
		uint32_t reserved_23_31              : 9;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_dbg_w3_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_dbg_w3_t;

#define BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3_FUNC(void)
{
	return 0x0000842060714018ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 bdk_tns_sde_pe_skpu_skpu_dbg_w3_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_DBG_W3 "TNS_SDE_PE_SKPU_SKPU_DBG_W3"


/**
 * NCB - tns_sde_pe_skpu_skpu_sram#_w0
 *
 * KPU SRAM
 * Bits[63:35] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_skpu_sramx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata2                   : 6;  /**< R/W - -- */
		uint64_t lyrptradvance0              : 6;  /**< R/W - -- */
		uint64_t lyrptradvance1              : 6;  /**< R/W - -- */
		uint64_t lyrptradvance2              : 6;  /**< R/W - -- */
		uint64_t transitionid                : 4;  /**< R/W - -- */
		uint64_t push2stack                  : 2;  /**< R/W - -- */
		uint64_t parsedone                   : 1;  /**< R/W - -- */
		uint64_t layertype0                  : 5;  /**< R/W - -- */
		uint64_t layertype1                  : 5;  /**< R/W - -- */
		uint64_t layertype2                  : 5;  /**< R/W - -- */
		uint64_t offset0                     : 6;  /**< R/W - -- */
		uint64_t offset1                     : 6;  /**< R/W - -- */
		uint64_t offset2                     : 6;  /**< R/W - -- */
#else
		uint64_t offset2                     : 6;
		uint64_t offset1                     : 6;
		uint64_t offset0                     : 6;
		uint64_t layertype2                  : 5;
		uint64_t layertype1                  : 5;
		uint64_t layertype0                  : 5;
		uint64_t parsedone                   : 1;
		uint64_t push2stack                  : 2;
		uint64_t transitionid                : 4;
		uint64_t lyrptradvance2              : 6;
		uint64_t lyrptradvance1              : 6;
		uint64_t lyrptradvance0              : 6;
		uint64_t metadata2                   : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_sramx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060712000ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(...) bdk_tns_sde_pe_skpu_skpu_sramx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W0(...) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W0"


/**
 * NCB - tns_sde_pe_skpu_skpu_sram#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_SRAM(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_skpu_sramx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t metadata0                   : 6;  /**< R/W - -- */
		uint64_t metadata1                   : 32; /**< R/W - -- */
		uint64_t metadata2                   : 26; /**< R/W - Continuation of MSBs of field METADATA2 from previous word. */
#else
		uint64_t metadata2                   : 26;
		uint64_t metadata1                   : 32;
		uint64_t metadata0                   : 6;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_sramx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060712008ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(...) bdk_tns_sde_pe_skpu_skpu_sramx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W1(...) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W1"


/**
 * NCB - tns_sde_pe_skpu_skpu_sram#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_SKPU_SRAM(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_skpu_sramx_w2 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_skpu_sramx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t innereth                    : 1;  /**< R/W - -- */
		uint64_t state                       : 8;  /**< R/W - -- */
		uint64_t metadata0                   : 26; /**< R/W - Continuation of MSBs of field METADATA0 from previous word. */
#else
		uint64_t metadata0                   : 26;
		uint64_t state                       : 8;
		uint64_t innereth                    : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_skpu_sramx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_skpu_sramx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060712010ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(...) bdk_tns_sde_pe_skpu_skpu_sramx_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SKPU_SRAMX_W2(...) "TNS_SDE_PE_SKPU_SKPU_SRAMX_W2"


/**
 * NCB32b - tns_sde_pe_skpu_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_pe_skpu_spad {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_spad_s  cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_spad_s  cn88xxp1; */
} bdk_tns_sde_pe_skpu_spad_t;

#define BDK_TNS_SDE_PE_SKPU_SPAD BDK_TNS_SDE_PE_SKPU_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_SPAD_FUNC(void)
{
	return 0x0000842060714020ull;
}
#define typedef_BDK_TNS_SDE_PE_SKPU_SPAD bdk_tns_sde_pe_skpu_spad_t
#define bustype_BDK_TNS_SDE_PE_SKPU_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_SPAD 0
#define arguments_BDK_TNS_SDE_PE_SKPU_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_SPAD "TNS_SDE_PE_SKPU_SPAD"


/**
 * NCB - tns_sde_pe_skpu_tcam_dat#_w0
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT
 * Bits[63:41] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_skpu_tcam_datx_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_tcam_datx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t decpoint4                   : 8;  /**< R/W - -- */
		uint64_t decpoint5                   : 8;  /**< R/W - -- */
		uint64_t decpoint6                   : 8;  /**< R/W - -- */
		uint64_t decpoint7                   : 8;  /**< R/W - -- */
		uint64_t decpoint8                   : 8;  /**< R/W - -- */
		uint64_t decpoint9                   : 8;  /**< R/W - -- */
		uint64_t decpoint10                  : 8;  /**< R/W - -- */
		uint64_t decpoint11                  : 8;  /**< R/W - -- */
#else
		uint64_t decpoint11                  : 8;
		uint64_t decpoint10                  : 8;
		uint64_t decpoint9                   : 8;
		uint64_t decpoint8                   : 8;
		uint64_t decpoint7                   : 8;
		uint64_t decpoint6                   : 8;
		uint64_t decpoint5                   : 8;
		uint64_t decpoint4                   : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_datx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_datx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_datx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060713000ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(...) bdk_tns_sde_pe_skpu_tcam_datx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W0(...) "TNS_SDE_PE_SKPU_TCAM_DATX_W0"


/**
 * NCB - tns_sde_pe_skpu_tcam_dat#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DAT(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_datx_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_tcam_datx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t currentstate                : 8;  /**< R/W - -- */
		uint64_t decpoint0                   : 8;  /**< R/W - -- */
		uint64_t decpoint1                   : 8;  /**< R/W - -- */
		uint64_t decpoint2                   : 8;  /**< R/W - -- */
		uint64_t decpoint3                   : 8;  /**< R/W - -- */
#else
		uint64_t decpoint3                   : 8;
		uint64_t decpoint2                   : 8;
		uint64_t decpoint1                   : 8;
		uint64_t decpoint0                   : 8;
		uint64_t currentstate                : 8;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_datx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_datx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_datx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060713008ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(...) bdk_tns_sde_pe_skpu_tcam_datx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DATX_W1(...) "TNS_SDE_PE_SKPU_TCAM_DATX_W1"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w0
 *
 * This regiter provides access to the SKPU TCAM
 * Bits[31:18] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w0 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - -- */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711000ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W0(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W0"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w1 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711004ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W1(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W1"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w2
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w2 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w2_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w2_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w2_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711008ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w2_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W2(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W2"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w3
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w3 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w3_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w3_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w3_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x000084206071100Cull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w3_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W3(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W3"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w4
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w4 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w4_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w4_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w4_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711010ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w4_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W4(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W4"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w5
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w5 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t vmdata                      : 32; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 32;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w5_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w5_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w5_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711014ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w5_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W5(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W5"


/**
 * NCB32b - tns_sde_pe_skpu_tcam_dmsk#_w6
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_DMSK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_dmskx_w6 {
	uint32_t u;
	struct bdk_tns_sde_pe_skpu_tcam_dmskx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t vmvalid                     : 2;  /**< R/W - -- */
		uint32_t vmdata                      : 16; /**< R/W - Continuation of MSBs of field VMDATA from previous word. */
#else
		uint32_t vmdata                      : 16;
		uint32_t vmvalid                     : 2;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w6_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_dmskx_w6_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_dmskx_w6_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060711018ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(...) bdk_tns_sde_pe_skpu_tcam_dmskx_w6_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_DMSKX_W6(...) "TNS_SDE_PE_SKPU_TCAM_DMSKX_W6"


/**
 * NCB - tns_sde_pe_skpu_tcam_mask#_w0
 *
 * DUMMY REGISTER -- ACCESS TO THIS REGISTER HAS NO EFFECT
 * Bits[63:41] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_pe_skpu_tcam_maskx_w0 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_tcam_maskx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t decpoint4                   : 8;  /**< R/W - -- */
		uint64_t decpoint5                   : 8;  /**< R/W - -- */
		uint64_t decpoint6                   : 8;  /**< R/W - -- */
		uint64_t decpoint7                   : 8;  /**< R/W - -- */
		uint64_t decpoint8                   : 8;  /**< R/W - -- */
		uint64_t decpoint9                   : 8;  /**< R/W - -- */
		uint64_t decpoint10                  : 8;  /**< R/W - -- */
		uint64_t decpoint11                  : 8;  /**< R/W - -- */
#else
		uint64_t decpoint11                  : 8;
		uint64_t decpoint10                  : 8;
		uint64_t decpoint9                   : 8;
		uint64_t decpoint8                   : 8;
		uint64_t decpoint7                   : 8;
		uint64_t decpoint6                   : 8;
		uint64_t decpoint5                   : 8;
		uint64_t decpoint4                   : 8;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_maskx_w0_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_maskx_w0_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_maskx_w0_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060713800ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(...) bdk_tns_sde_pe_skpu_tcam_maskx_w0_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W0(...) "TNS_SDE_PE_SKPU_TCAM_MASKX_W0"


/**
 * NCB - tns_sde_pe_skpu_tcam_mask#_w1
 *
 * Continuation of structure defined in TNS_SDE_PE_SKPU_TCAM_MASK(0..127)_W0
 *
 */
typedef union bdk_tns_sde_pe_skpu_tcam_maskx_w1 {
	uint64_t u;
	struct bdk_tns_sde_pe_skpu_tcam_maskx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t rowvalid                    : 1;  /**< R/W - -- */
		uint64_t currentstate                : 8;  /**< R/W - -- */
		uint64_t decpoint0                   : 8;  /**< R/W - -- */
		uint64_t decpoint1                   : 8;  /**< R/W - -- */
		uint64_t decpoint2                   : 8;  /**< R/W - -- */
		uint64_t decpoint3                   : 8;  /**< R/W - -- */
#else
		uint64_t decpoint3                   : 8;
		uint64_t decpoint2                   : 8;
		uint64_t decpoint1                   : 8;
		uint64_t decpoint0                   : 8;
		uint64_t currentstate                : 8;
		uint64_t rowvalid                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_sde_pe_skpu_tcam_maskx_w1_s cn88xx; */
	/* struct bdk_tns_sde_pe_skpu_tcam_maskx_w1_s cn88xxp1; */
} bdk_tns_sde_pe_skpu_tcam_maskx_w1_t;

static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842060713808ull + (param1 & 127) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(...) bdk_tns_sde_pe_skpu_tcam_maskx_w1_t
#define bustype_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_PE_SKPU_TCAM_MASKX_W1(...) "TNS_SDE_PE_SKPU_TCAM_MASKX_W1"


/**
 * NCB32b - tns_sde_urw1_afull_thresh
 *
 * Controls the max inflight requests.
 *
 */
typedef union bdk_tns_sde_urw1_afull_thresh {
	uint32_t u;
	struct bdk_tns_sde_urw1_afull_thresh_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t vif_lat_fifo                : 6;  /**< R/W - -- */
#else
		uint32_t vif_lat_fifo                : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_afull_thresh_s cn88xx; */
	/* struct bdk_tns_sde_urw1_afull_thresh_s cn88xxp1; */
} bdk_tns_sde_urw1_afull_thresh_t;

#define BDK_TNS_SDE_URW1_AFULL_THRESH BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_AFULL_THRESH_FUNC(void)
{
	return 0x000084206040B0B8ull;
}
#define typedef_BDK_TNS_SDE_URW1_AFULL_THRESH bdk_tns_sde_urw1_afull_thresh_t
#define bustype_BDK_TNS_SDE_URW1_AFULL_THRESH BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_AFULL_THRESH 0
#define arguments_BDK_TNS_SDE_URW1_AFULL_THRESH -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_AFULL_THRESH "TNS_SDE_URW1_AFULL_THRESH"


/**
 * NCB32b - tns_sde_urw1_control
 *
 * Contains disable bits for various features
 *
 */
typedef union bdk_tns_sde_urw1_control {
	uint32_t u;
	struct bdk_tns_sde_urw1_control_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t disable_se_vif_lkup         : 1;  /**< R/W - -- */
		uint32_t logic_rst                   : 1;  /**< R/W - -- */
#else
		uint32_t logic_rst                   : 1;
		uint32_t disable_se_vif_lkup         : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_control_s  cn88xx; */
	/* struct bdk_tns_sde_urw1_control_s  cn88xxp1; */
} bdk_tns_sde_urw1_control_t;

#define BDK_TNS_SDE_URW1_CONTROL BDK_TNS_SDE_URW1_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_CONTROL_FUNC(void)
{
	return 0x000084206040B0B0ull;
}
#define typedef_BDK_TNS_SDE_URW1_CONTROL bdk_tns_sde_urw1_control_t
#define bustype_BDK_TNS_SDE_URW1_CONTROL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_CONTROL 0
#define arguments_BDK_TNS_SDE_URW1_CONTROL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_CONTROL "TNS_SDE_URW1_CONTROL"


/**
 * NCB32b - tns_sde_urw1_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw1_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_urw1_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_sde_urw1_dbg_sel_s  cn88xxp1; */
} bdk_tns_sde_urw1_dbg_sel_t;

#define BDK_TNS_SDE_URW1_DBG_SEL BDK_TNS_SDE_URW1_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_SEL_FUNC(void)
{
	return 0x000084206040B080ull;
}
#define typedef_BDK_TNS_SDE_URW1_DBG_SEL bdk_tns_sde_urw1_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW1_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW1_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_DBG_SEL "TNS_SDE_URW1_DBG_SEL"


/**
 * NCB32b - tns_sde_urw1_dbg_sta_live
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw1_dbg_sta_live {
	uint32_t u;
	struct bdk_tns_sde_urw1_dbg_sta_live_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t data                        : 9;  /**< RO/H - -- */
#else
		uint32_t data                        : 9;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_dbg_sta_live_s cn88xx; */
	/* struct bdk_tns_sde_urw1_dbg_sta_live_s cn88xxp1; */
} bdk_tns_sde_urw1_dbg_sta_live_t;

#define BDK_TNS_SDE_URW1_DBG_STA_LIVE BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_STA_LIVE_FUNC(void)
{
	return 0x000084206040B0D4ull;
}
#define typedef_BDK_TNS_SDE_URW1_DBG_STA_LIVE bdk_tns_sde_urw1_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW1_DBG_STA_LIVE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW1_DBG_STA_LIVE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_DBG_STA_LIVE "TNS_SDE_URW1_DBG_STA_LIVE"


/**
 * NCB32b - tns_sde_urw1_dbg_vlf
 *
 * For debug hooks to VLF fifo
 *
 */
typedef union bdk_tns_sde_urw1_dbg_vlf {
	uint32_t u;
	struct bdk_tns_sde_urw1_dbg_vlf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t enqen                       : 1;  /**< R/W - -- */
		uint32_t deqen                       : 1;  /**< R/W - -- */
		uint32_t contenq                     : 1;  /**< R/W - -- */
		uint32_t contdeq                     : 1;  /**< R/W - -- */
#else
		uint32_t contdeq                     : 1;
		uint32_t contenq                     : 1;
		uint32_t deqen                       : 1;
		uint32_t enqen                       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_dbg_vlf_s  cn88xx; */
	/* struct bdk_tns_sde_urw1_dbg_vlf_s  cn88xxp1; */
} bdk_tns_sde_urw1_dbg_vlf_t;

#define BDK_TNS_SDE_URW1_DBG_VLF BDK_TNS_SDE_URW1_DBG_VLF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DBG_VLF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DBG_VLF_FUNC(void)
{
	return 0x000084206040B0CCull;
}
#define typedef_BDK_TNS_SDE_URW1_DBG_VLF bdk_tns_sde_urw1_dbg_vlf_t
#define bustype_BDK_TNS_SDE_URW1_DBG_VLF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_DBG_VLF 0
#define arguments_BDK_TNS_SDE_URW1_DBG_VLF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_DBG_VLF "TNS_SDE_URW1_DBG_VLF"


/**
 * NCB32b - tns_sde_urw1_dyn_dbg_vlf
 *
 * For debug hooks to VLF fifo
 *
 */
typedef union bdk_tns_sde_urw1_dyn_dbg_vlf {
	uint32_t u;
	struct bdk_tns_sde_urw1_dyn_dbg_vlf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t data                        : 12; /**< R/W/H - -- */
#else
		uint32_t data                        : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_dyn_dbg_vlf_s cn88xx; */
	/* struct bdk_tns_sde_urw1_dyn_dbg_vlf_s cn88xxp1; */
} bdk_tns_sde_urw1_dyn_dbg_vlf_t;

#define BDK_TNS_SDE_URW1_DYN_DBG_VLF BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_DYN_DBG_VLF_FUNC(void)
{
	return 0x000084206040B0D0ull;
}
#define typedef_BDK_TNS_SDE_URW1_DYN_DBG_VLF bdk_tns_sde_urw1_dyn_dbg_vlf_t
#define bustype_BDK_TNS_SDE_URW1_DYN_DBG_VLF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_DYN_DBG_VLF 0
#define arguments_BDK_TNS_SDE_URW1_DYN_DBG_VLF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_DYN_DBG_VLF "TNS_SDE_URW1_DYN_DBG_VLF"


/**
 * NCB32b - tns_sde_urw1_ecc_ctl_cd
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw1_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_urw1_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t cpu_rsn_tbl                 : 1;  /**< R/W - -- */
		uint32_t eflt_tbl                    : 1;  /**< R/W - -- */
		uint32_t evif_tbl                    : 1;  /**< R/W - -- */
		uint32_t ivif_tbl                    : 1;  /**< R/W - -- */
		uint32_t templateid_tbl              : 1;  /**< R/W - -- */
		uint32_t trt_tbl                     : 1;  /**< R/W - -- */
		uint32_t vlf_fifo                    : 1;  /**< R/W - -- */
#else
		uint32_t vlf_fifo                    : 1;
		uint32_t trt_tbl                     : 1;
		uint32_t templateid_tbl              : 1;
		uint32_t ivif_tbl                    : 1;
		uint32_t evif_tbl                    : 1;
		uint32_t eflt_tbl                    : 1;
		uint32_t cpu_rsn_tbl                 : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_urw1_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_urw1_ecc_ctl_cd_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_CD BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_CD_FUNC(void)
{
	return 0x000084206040B0ACull;
}
#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_CD bdk_tns_sde_urw1_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_CD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_CD "TNS_SDE_URW1_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_urw1_ecc_ctl_flp_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw1_ecc_ctl_flp_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw1_ecc_ctl_flp_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sb_vlf_fifo                 : 8;  /**< R/W - -- */
		uint32_t db_cpu_rsn_tbl              : 1;  /**< R/W - -- */
		uint32_t db_eflt_tbl                 : 2;  /**< R/W - -- */
		uint32_t db_evif_tbl                 : 2;  /**< R/W - -- */
		uint32_t db_ivif_tbl                 : 2;  /**< R/W - -- */
		uint32_t db_templateid_tbl           : 2;  /**< R/W - -- */
		uint32_t db_trt_tbl                  : 2;  /**< R/W - -- */
		uint32_t db_vlf_fifo                 : 13; /**< R/W - -- */
#else
		uint32_t db_vlf_fifo                 : 13;
		uint32_t db_trt_tbl                  : 2;
		uint32_t db_templateid_tbl           : 2;
		uint32_t db_ivif_tbl                 : 2;
		uint32_t db_evif_tbl                 : 2;
		uint32_t db_eflt_tbl                 : 2;
		uint32_t db_cpu_rsn_tbl              : 1;
		uint32_t sb_vlf_fifo                 : 8;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_ecc_ctl_flp_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw1_ecc_ctl_flp_w0_s cn88xxp1; */
} bdk_tns_sde_urw1_ecc_ctl_flp_w0_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0_FUNC(void)
{
	return 0x000084206040B0A4ull;
}
#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 bdk_tns_sde_urw1_ecc_ctl_flp_w0_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W0 "TNS_SDE_URW1_ECC_CTL_FLP_W0"


/**
 * NCB32b - tns_sde_urw1_ecc_ctl_flp_w1
 *
 * Continuation of structure defined in TNS_SDE_URW1_ECC_CTL_FLP_W0
 *
 */
typedef union bdk_tns_sde_urw1_ecc_ctl_flp_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw1_ecc_ctl_flp_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t sb_cpu_rsn_tbl              : 1;  /**< R/W - -- */
		uint32_t sb_eflt_tbl                 : 2;  /**< R/W - -- */
		uint32_t sb_evif_tbl                 : 2;  /**< R/W - -- */
		uint32_t sb_ivif_tbl                 : 2;  /**< R/W - -- */
		uint32_t sb_templateid_tbl           : 2;  /**< R/W - -- */
		uint32_t sb_trt_tbl                  : 2;  /**< R/W - -- */
		uint32_t sb_vlf_fifo                 : 5;  /**< R/W - Continuation of MSBs of field SB_VLF_FIFO from previous word. */
#else
		uint32_t sb_vlf_fifo                 : 5;
		uint32_t sb_trt_tbl                  : 2;
		uint32_t sb_templateid_tbl           : 2;
		uint32_t sb_ivif_tbl                 : 2;
		uint32_t sb_evif_tbl                 : 2;
		uint32_t sb_eflt_tbl                 : 2;
		uint32_t sb_cpu_rsn_tbl              : 1;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_ecc_ctl_flp_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw1_ecc_ctl_flp_w1_s cn88xxp1; */
} bdk_tns_sde_urw1_ecc_ctl_flp_w1_t;

#define BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1_FUNC(void)
{
	return 0x000084206040B0A8ull;
}
#define typedef_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 bdk_tns_sde_urw1_ecc_ctl_flp_w1_t
#define bustype_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 0
#define arguments_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_ECC_CTL_FLP_W1 "TNS_SDE_URW1_ECC_CTL_FLP_W1"


/**
 * NCB32b - tns_sde_urw1_egr_flt_tbl#_w#
 *
 * Contains CBL bitmap. Indexed by token.filter_grp_num
 * Bits[31:9] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw1_egr_flt_tblx_wx {
	uint32_t u;
	struct bdk_tns_sde_urw1_egr_flt_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t eflt_data                   : 32; /**< R/W - -- */
#else
		uint32_t eflt_data                   : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_egr_flt_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_egr_flt_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw1_egr_flt_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 255)) && ((param2 <= 4)))
		return 0x0000842060408000ull + (param1 & 255) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(...) bdk_tns_sde_urw1_egr_flt_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW1_EGR_FLT_TBLX_WX(...) "TNS_SDE_URW1_EGR_FLT_TBLX_WX"


/**
 * NCB - tns_sde_urw1_evif_tbl#_w#
 *
 * Local Vif table.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw1_evif_tblx_wx {
	uint64_t u;
	struct bdk_tns_sde_urw1_evif_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t evif_response               : 64; /**< R/W - -- */
#else
		uint64_t evif_response               : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_evif_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_evif_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw1_evif_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EVIF_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EVIF_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 255)) && ((param2 <= 2)))
		return 0x0000842060406000ull + (param1 & 255) * 0x20ull + (param2 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW1_EVIF_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(...) bdk_tns_sde_urw1_evif_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW1_EVIF_TBLX_WX(...) "TNS_SDE_URW1_EVIF_TBLX_WX"


/**
 * NCB32b - tns_sde_urw1_evif_w#
 *
 * eVif Range0_3
 * Bits 31..8 of registers ending in _W1 are unused.
 */
typedef union bdk_tns_sde_urw1_evif_wx {
	uint32_t u;
	struct bdk_tns_sde_urw1_evif_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t range0_3                    : 32; /**< R/W - -- */
#else
		uint32_t range0_3                    : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_evif_wx_s  cn88xx; */
	/* struct bdk_tns_sde_urw1_evif_wx_s  cn88xxp1; */
} bdk_tns_sde_urw1_evif_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_EVIF_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_EVIF_WX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206040B0BCull + (param1 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_EVIF_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_EVIF_WX(...) bdk_tns_sde_urw1_evif_wx_t
#define bustype_BDK_TNS_SDE_URW1_EVIF_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_EVIF_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW1_EVIF_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_EVIF_WX(...) "TNS_SDE_URW1_EVIF_WX"


/**
 * NCB32b - tns_sde_urw1_int_en_hi_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw1_int_en_hi_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_en_hi_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lkup_db_err                 : 7;  /**< R/W - -- */
		uint32_t lkup_sb_err                 : 25; /**< R/W - -- */
#else
		uint32_t lkup_sb_err                 : 25;
		uint32_t lkup_db_err                 : 7;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_en_hi_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_en_hi_w0_s cn88xxp1; */
} bdk_tns_sde_urw1_int_en_hi_w0_t;

#define BDK_TNS_SDE_URW1_INT_EN_HI_W0 BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W0_FUNC(void)
{
	return 0x000084206040B08Cull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_EN_HI_W0 bdk_tns_sde_urw1_int_en_hi_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_HI_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_EN_HI_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_HI_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_EN_HI_W0 "TNS_SDE_URW1_INT_EN_HI_W0"


/**
 * NCB32b - tns_sde_urw1_int_en_hi_w1
 *
 * Continuation of structure defined in TNS_SDE_URW1_INT_EN_HI_W0
 *
 */
typedef union bdk_tns_sde_urw1_int_en_hi_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_en_hi_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t rewrite_ptr_exceed8         : 1;  /**< R/W - -- */
		uint32_t lkup_db_err                 : 18; /**< R/W - Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else
		uint32_t lkup_db_err                 : 18;
		uint32_t rewrite_ptr_exceed8         : 1;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_en_hi_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_en_hi_w1_s cn88xxp1; */
} bdk_tns_sde_urw1_int_en_hi_w1_t;

#define BDK_TNS_SDE_URW1_INT_EN_HI_W1 BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_HI_W1_FUNC(void)
{
	return 0x000084206040B090ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_EN_HI_W1 bdk_tns_sde_urw1_int_en_hi_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_HI_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_EN_HI_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_HI_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_EN_HI_W1 "TNS_SDE_URW1_INT_EN_HI_W1"


/**
 * NCB32b - tns_sde_urw1_int_en_lo_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw1_int_en_lo_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_en_lo_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lkup_db_err                 : 7;  /**< R/W - -- */
		uint32_t lkup_sb_err                 : 25; /**< R/W - -- */
#else
		uint32_t lkup_sb_err                 : 25;
		uint32_t lkup_db_err                 : 7;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_en_lo_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_en_lo_w0_s cn88xxp1; */
} bdk_tns_sde_urw1_int_en_lo_w0_t;

#define BDK_TNS_SDE_URW1_INT_EN_LO_W0 BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W0_FUNC(void)
{
	return 0x000084206040B094ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_EN_LO_W0 bdk_tns_sde_urw1_int_en_lo_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_LO_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_EN_LO_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_LO_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_EN_LO_W0 "TNS_SDE_URW1_INT_EN_LO_W0"


/**
 * NCB32b - tns_sde_urw1_int_en_lo_w1
 *
 * Continuation of structure defined in TNS_SDE_URW1_INT_EN_LO_W0
 *
 */
typedef union bdk_tns_sde_urw1_int_en_lo_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_en_lo_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t rewrite_ptr_exceed8         : 1;  /**< R/W - -- */
		uint32_t lkup_db_err                 : 18; /**< R/W - Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else
		uint32_t lkup_db_err                 : 18;
		uint32_t rewrite_ptr_exceed8         : 1;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_en_lo_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_en_lo_w1_s cn88xxp1; */
} bdk_tns_sde_urw1_int_en_lo_w1_t;

#define BDK_TNS_SDE_URW1_INT_EN_LO_W1 BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_EN_LO_W1_FUNC(void)
{
	return 0x000084206040B098ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_EN_LO_W1 bdk_tns_sde_urw1_int_en_lo_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_EN_LO_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_EN_LO_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_EN_LO_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_EN_LO_W1 "TNS_SDE_URW1_INT_EN_LO_W1"


/**
 * NCB32b - tns_sde_urw1_int_frc_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw1_int_frc_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_frc_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lkup_db_err                 : 7;  /**< WO - -- */
		uint32_t lkup_sb_err                 : 25; /**< WO - -- */
#else
		uint32_t lkup_sb_err                 : 25;
		uint32_t lkup_db_err                 : 7;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_frc_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_frc_w0_s cn88xxp1; */
} bdk_tns_sde_urw1_int_frc_w0_t;

#define BDK_TNS_SDE_URW1_INT_FRC_W0 BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W0_FUNC(void)
{
	return 0x000084206040B09Cull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_FRC_W0 bdk_tns_sde_urw1_int_frc_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_FRC_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_FRC_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_FRC_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_FRC_W0 "TNS_SDE_URW1_INT_FRC_W0"


/**
 * NCB32b - tns_sde_urw1_int_frc_w1
 *
 * Continuation of structure defined in TNS_SDE_URW1_INT_FRC_W0
 *
 */
typedef union bdk_tns_sde_urw1_int_frc_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_frc_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t rewrite_ptr_exceed8         : 1;  /**< WO - -- */
		uint32_t lkup_db_err                 : 18; /**< WO - Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else
		uint32_t lkup_db_err                 : 18;
		uint32_t rewrite_ptr_exceed8         : 1;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_frc_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_frc_w1_s cn88xxp1; */
} bdk_tns_sde_urw1_int_frc_w1_t;

#define BDK_TNS_SDE_URW1_INT_FRC_W1 BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_FRC_W1_FUNC(void)
{
	return 0x000084206040B0A0ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_FRC_W1 bdk_tns_sde_urw1_int_frc_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_FRC_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_FRC_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_FRC_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_FRC_W1 "TNS_SDE_URW1_INT_FRC_W1"


/**
 * NCB32b - tns_sde_urw1_int_w1c_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw1_int_w1c_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_w1c_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lkup_db_err                 : 7;  /**< R/W1C/H - -- */
		uint32_t lkup_sb_err                 : 25; /**< R/W1C/H - -- */
#else
		uint32_t lkup_sb_err                 : 25;
		uint32_t lkup_db_err                 : 7;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_w1c_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_w1c_w0_s cn88xxp1; */
} bdk_tns_sde_urw1_int_w1c_w0_t;

#define BDK_TNS_SDE_URW1_INT_W1C_W0 BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W0_FUNC(void)
{
	return 0x000084206040B084ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_W1C_W0 bdk_tns_sde_urw1_int_w1c_w0_t
#define bustype_BDK_TNS_SDE_URW1_INT_W1C_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_W1C_W0 0
#define arguments_BDK_TNS_SDE_URW1_INT_W1C_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_W1C_W0 "TNS_SDE_URW1_INT_W1C_W0"


/**
 * NCB32b - tns_sde_urw1_int_w1c_w1
 *
 * Continuation of structure defined in TNS_SDE_URW1_INT_W1C_W0
 *
 */
typedef union bdk_tns_sde_urw1_int_w1c_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw1_int_w1c_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t rewrite_ptr_exceed8         : 1;  /**< R/W1C/H - -- */
		uint32_t lkup_db_err                 : 18; /**< R/W1C/H - Continuation of MSBs of field LKUP_DB_ERR from previous word. */
#else
		uint32_t lkup_db_err                 : 18;
		uint32_t rewrite_ptr_exceed8         : 1;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_int_w1c_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw1_int_w1c_w1_s cn88xxp1; */
} bdk_tns_sde_urw1_int_w1c_w1_t;

#define BDK_TNS_SDE_URW1_INT_W1C_W1 BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_INT_W1C_W1_FUNC(void)
{
	return 0x000084206040B088ull;
}
#define typedef_BDK_TNS_SDE_URW1_INT_W1C_W1 bdk_tns_sde_urw1_int_w1c_w1_t
#define bustype_BDK_TNS_SDE_URW1_INT_W1C_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_INT_W1C_W1 0
#define arguments_BDK_TNS_SDE_URW1_INT_W1C_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_INT_W1C_W1 "TNS_SDE_URW1_INT_W1C_W1"


/**
 * NCB - tns_sde_urw1_ivif_tbl#_w#
 *
 * Local Vif table.
 * Refer to urw/xp_urw_tbl.vh for the details of this table.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw1_ivif_tblx_wx {
	uint64_t u;
	struct bdk_tns_sde_urw1_ivif_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t ivif_response               : 64; /**< R/W - -- */
#else
		uint64_t ivif_response               : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_ivif_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_ivif_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw1_ivif_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_IVIF_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_IVIF_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 255)) && ((param2 <= 2)))
		return 0x0000842060404000ull + (param1 & 255) * 0x20ull + (param2 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW1_IVIF_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(...) bdk_tns_sde_urw1_ivif_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW1_IVIF_TBLX_WX(...) "TNS_SDE_URW1_IVIF_TBLX_WX"


/**
 * NCB32b - tns_sde_urw1_ivif_w#
 *
 * iVif Range0_3
 * Bits 31..8 of registers ending in _W1 are unused.
 */
typedef union bdk_tns_sde_urw1_ivif_wx {
	uint32_t u;
	struct bdk_tns_sde_urw1_ivif_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t range0_3                    : 32; /**< R/W - -- */
#else
		uint32_t range0_3                    : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_ivif_wx_s  cn88xx; */
	/* struct bdk_tns_sde_urw1_ivif_wx_s  cn88xxp1; */
} bdk_tns_sde_urw1_ivif_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_IVIF_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_IVIF_WX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084206040B0C4ull + (param1 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_IVIF_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_IVIF_WX(...) bdk_tns_sde_urw1_ivif_wx_t
#define bustype_BDK_TNS_SDE_URW1_IVIF_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_IVIF_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW1_IVIF_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_IVIF_WX(...) "TNS_SDE_URW1_IVIF_WX"


/**
 * NCB32b - tns_sde_urw1_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_urw1_lock {
	uint32_t u;
	struct bdk_tns_sde_urw1_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_lock_s     cn88xx; */
	/* struct bdk_tns_sde_urw1_lock_s     cn88xxp1; */
} bdk_tns_sde_urw1_lock_t;

#define BDK_TNS_SDE_URW1_LOCK BDK_TNS_SDE_URW1_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_LOCK_FUNC(void)
{
	return 0x000084206040B0D8ull;
}
#define typedef_BDK_TNS_SDE_URW1_LOCK bdk_tns_sde_urw1_lock_t
#define bustype_BDK_TNS_SDE_URW1_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_LOCK 0
#define arguments_BDK_TNS_SDE_URW1_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_LOCK "TNS_SDE_URW1_LOCK"


/**
 * NCB32b - tns_sde_urw1_mir_mask
 *
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 *
 */
typedef union bdk_tns_sde_urw1_mir_mask {
	uint32_t u;
	struct bdk_tns_sde_urw1_mir_mask_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ivif                        : 16; /**< R/W - -- */
		uint32_t evif                        : 16; /**< R/W - -- */
#else
		uint32_t evif                        : 16;
		uint32_t ivif                        : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_mir_mask_s cn88xx; */
	/* struct bdk_tns_sde_urw1_mir_mask_s cn88xxp1; */
} bdk_tns_sde_urw1_mir_mask_t;

#define BDK_TNS_SDE_URW1_MIR_MASK BDK_TNS_SDE_URW1_MIR_MASK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_MIR_MASK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_MIR_MASK_FUNC(void)
{
	return 0x000084206040B0B4ull;
}
#define typedef_BDK_TNS_SDE_URW1_MIR_MASK bdk_tns_sde_urw1_mir_mask_t
#define bustype_BDK_TNS_SDE_URW1_MIR_MASK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_MIR_MASK 0
#define arguments_BDK_TNS_SDE_URW1_MIR_MASK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_MIR_MASK "TNS_SDE_URW1_MIR_MASK"


/**
 * NCB32b - tns_sde_urw1_rsn_tbl#
 *
 * Reason Code table used for CPU packets and cpu copies. Indexed by lower 10 bits
 * of reasonCode.
 */
typedef union bdk_tns_sde_urw1_rsn_tblx {
	uint32_t u;
	struct bdk_tns_sde_urw1_rsn_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t port                        : 8;  /**< R/W - -- */
		uint32_t traffic_class               : 4;  /**< R/W - -- */
		uint32_t truncation                  : 1;  /**< R/W - -- */
		uint32_t format                      : 1;  /**< R/W - -- */
#else
		uint32_t format                      : 1;
		uint32_t truncation                  : 1;
		uint32_t traffic_class               : 4;
		uint32_t port                        : 8;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_rsn_tblx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_rsn_tblx_s cn88xxp1; */
} bdk_tns_sde_urw1_rsn_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW1_RSN_TBLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_RSN_TBLX(unsigned long param1)
{
	if (((param1 <= 1023)))
		return 0x000084206040A000ull + (param1 & 1023) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_RSN_TBLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_RSN_TBLX(...) bdk_tns_sde_urw1_rsn_tblx_t
#define bustype_BDK_TNS_SDE_URW1_RSN_TBLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_RSN_TBLX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW1_RSN_TBLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_RSN_TBLX(...) "TNS_SDE_URW1_RSN_TBLX"


/**
 * NCB - tns_sde_urw1_se_resp_tbl#
 *
 * Search profile table to gather vif responses.
 * This field tells if the evif response is 32 bit valid. Lower 32-bits of
 * 64-bit se lane should be valid.
 * If this bit is set, then token_id_0_32bit_format should be : 1000_0000
 */
typedef union bdk_tns_sde_urw1_se_resp_tblx {
	uint64_t u;
	struct bdk_tns_sde_urw1_se_resp_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_61_63              : 3;
		uint64_t token_id_0_32bit_format     : 1;  /**< R/W - -- */
		uint64_t token_id_0_bit_map          : 4;  /**< R/W - -- */
		uint64_t token_id_1_32bit_format     : 1;  /**< R/W - -- */
		uint64_t token_id_1_bit_map          : 4;  /**< R/W - -- */
		uint64_t prfid                       : 7;  /**< R/W - -- */
		uint64_t cmd_en                      : 4;  /**< R/W - -- */
		uint64_t ivif_offset                 : 20; /**< R/W - -- */
		uint64_t evif_offset                 : 20; /**< R/W - -- */
#else
		uint64_t evif_offset                 : 20;
		uint64_t ivif_offset                 : 20;
		uint64_t cmd_en                      : 4;
		uint64_t prfid                       : 7;
		uint64_t token_id_1_bit_map          : 4;
		uint64_t token_id_1_32bit_format     : 1;
		uint64_t token_id_0_bit_map          : 4;
		uint64_t token_id_0_32bit_format     : 1;
		uint64_t reserved_61_63              : 3;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_se_resp_tblx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_se_resp_tblx_s cn88xxp1; */
} bdk_tns_sde_urw1_se_resp_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW1_SE_RESP_TBLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_SE_RESP_TBLX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x000084206040B000ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW1_SE_RESP_TBLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_SE_RESP_TBLX(...) bdk_tns_sde_urw1_se_resp_tblx_t
#define bustype_BDK_TNS_SDE_URW1_SE_RESP_TBLX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW1_SE_RESP_TBLX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW1_SE_RESP_TBLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_SE_RESP_TBLX(...) "TNS_SDE_URW1_SE_RESP_TBLX"


/**
 * NCB32b - tns_sde_urw1_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_urw1_spad {
	uint32_t u;
	struct bdk_tns_sde_urw1_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_spad_s     cn88xx; */
	/* struct bdk_tns_sde_urw1_spad_s     cn88xxp1; */
} bdk_tns_sde_urw1_spad_t;

#define BDK_TNS_SDE_URW1_SPAD BDK_TNS_SDE_URW1_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW1_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_SPAD_FUNC(void)
{
	return 0x000084206040B0DCull;
}
#define typedef_BDK_TNS_SDE_URW1_SPAD bdk_tns_sde_urw1_spad_t
#define bustype_BDK_TNS_SDE_URW1_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_SPAD 0
#define arguments_BDK_TNS_SDE_URW1_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW1_SPAD "TNS_SDE_URW1_SPAD"


/**
 * NCB32b - tns_sde_urw1_tpid_tbl#_w#
 *
 * Template ID Table contains layer offset, layerType and other tbd fields
 * Bits[31:8] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw1_tpid_tblx_wx {
	uint32_t u;
	struct bdk_tns_sde_urw1_tpid_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_tpid_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_tpid_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw1_tpid_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_TPID_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_TPID_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 255)) && ((param2 <= 4)))
		return 0x0000842060400000ull + (param1 & 255) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_TPID_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_TPID_TBLX_WX(...) bdk_tns_sde_urw1_tpid_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_TPID_TBLX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_TPID_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW1_TPID_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW1_TPID_TBLX_WX(...) "TNS_SDE_URW1_TPID_TBLX_WX"


/**
 * NCB32b - tns_sde_urw1_trt_tbl#_w#
 *
 * Table contains 137 bits for resolving trunks. Each bit is for a logical port.
 * Indexed by HASH1%256.
 * This hash must be same across multiple asics.
 * Bits[31:9] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw1_trt_tblx_wx {
	uint32_t u;
	struct bdk_tns_sde_urw1_trt_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw1_trt_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw1_trt_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw1_trt_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW1_TRT_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW1_TRT_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 255)) && ((param2 <= 4)))
		return 0x0000842060402000ull + (param1 & 255) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW1_TRT_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW1_TRT_TBLX_WX(...) bdk_tns_sde_urw1_trt_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW1_TRT_TBLX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW1_TRT_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW1_TRT_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW1_TRT_TBLX_WX(...) "TNS_SDE_URW1_TRT_TBLX_WX"


/**
 * NCB32b - tns_sde_urw2a_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw2a_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_urw2a_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_urw2a_dbg_sel_t;

#define BDK_TNS_SDE_URW2A_DBG_SEL BDK_TNS_SDE_URW2A_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_SEL_FUNC(void)
{
	return 0x0000842060481C58ull;
}
#define typedef_BDK_TNS_SDE_URW2A_DBG_SEL bdk_tns_sde_urw2a_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW2A_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW2A_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_DBG_SEL "TNS_SDE_URW2A_DBG_SEL"


/**
 * NCB32b - tns_sde_urw2a_dbg_sta_live_w#
 *
 * Bits 31..27 of registers ending in _W6 are unused.
 *
 */
typedef union bdk_tns_sde_urw2a_dbg_sta_live_wx {
	uint32_t u;
	struct bdk_tns_sde_urw2a_dbg_sta_live_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO/H - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_dbg_sta_live_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_dbg_sta_live_wx_s cn88xxp1; */
} bdk_tns_sde_urw2a_dbg_sta_live_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(unsigned long param1)
{
	if (((param1 <= 6)))
		return 0x0000842060481C3Cull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(...) bdk_tns_sde_urw2a_dbg_sta_live_wx_t
#define bustype_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_DBG_STA_LIVE_WX(...) "TNS_SDE_URW2A_DBG_STA_LIVE_WX"


/**
 * NCB32b - tns_sde_urw2a_etag_w0
 *
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
typedef union bdk_tns_sde_urw2a_etag_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_etag_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - -- */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_etag_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_etag_w0_s cn88xxp1; */
} bdk_tns_sde_urw2a_etag_w0_t;

#define BDK_TNS_SDE_URW2A_ETAG_W0 BDK_TNS_SDE_URW2A_ETAG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W0_FUNC(void)
{
	return 0x0000842060481C28ull;
}
#define typedef_BDK_TNS_SDE_URW2A_ETAG_W0 bdk_tns_sde_urw2a_etag_w0_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W0 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_ETAG_W0 "TNS_SDE_URW2A_ETAG_W0"


/**
 * NCB32b - tns_sde_urw2a_etag_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2a_etag_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_etag_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_etag_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_etag_w1_s cn88xxp1; */
} bdk_tns_sde_urw2a_etag_w1_t;

#define BDK_TNS_SDE_URW2A_ETAG_W1 BDK_TNS_SDE_URW2A_ETAG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W1_FUNC(void)
{
	return 0x0000842060481C2Cull;
}
#define typedef_BDK_TNS_SDE_URW2A_ETAG_W1 bdk_tns_sde_urw2a_etag_w1_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W1 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_ETAG_W1 "TNS_SDE_URW2A_ETAG_W1"


/**
 * NCB32b - tns_sde_urw2a_etag_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2a_etag_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_etag_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_etag_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_etag_w2_s cn88xxp1; */
} bdk_tns_sde_urw2a_etag_w2_t;

#define BDK_TNS_SDE_URW2A_ETAG_W2 BDK_TNS_SDE_URW2A_ETAG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W2_FUNC(void)
{
	return 0x0000842060481C30ull;
}
#define typedef_BDK_TNS_SDE_URW2A_ETAG_W2 bdk_tns_sde_urw2a_etag_w2_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W2 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_ETAG_W2 "TNS_SDE_URW2A_ETAG_W2"


/**
 * NCB32b - tns_sde_urw2a_etag_w3
 *
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2a_etag_w3 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_etag_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_etag_w3_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_etag_w3_s cn88xxp1; */
} bdk_tns_sde_urw2a_etag_w3_t;

#define BDK_TNS_SDE_URW2A_ETAG_W3 BDK_TNS_SDE_URW2A_ETAG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W3_FUNC(void)
{
	return 0x0000842060481C34ull;
}
#define typedef_BDK_TNS_SDE_URW2A_ETAG_W3 bdk_tns_sde_urw2a_etag_w3_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W3 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_ETAG_W3 "TNS_SDE_URW2A_ETAG_W3"


/**
 * NCB32b - tns_sde_urw2a_etag_w4
 *
 * Continuation of structure defined in TNS_SDE_URW2A_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2a_etag_w4 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_etag_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t modify_etag_en              : 1;  /**< R/W - -- */
		uint32_t pt_en                       : 9;  /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 9;
		uint32_t modify_etag_en              : 1;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_etag_w4_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_etag_w4_s cn88xxp1; */
} bdk_tns_sde_urw2a_etag_w4_t;

#define BDK_TNS_SDE_URW2A_ETAG_W4 BDK_TNS_SDE_URW2A_ETAG_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_ETAG_W4_FUNC(void)
{
	return 0x0000842060481C38ull;
}
#define typedef_BDK_TNS_SDE_URW2A_ETAG_W4 bdk_tns_sde_urw2a_etag_w4_t
#define bustype_BDK_TNS_SDE_URW2A_ETAG_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_ETAG_W4 0
#define arguments_BDK_TNS_SDE_URW2A_ETAG_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_ETAG_W4 "TNS_SDE_URW2A_ETAG_W4"


/**
 * NCB - tns_sde_urw2a_hdr_w0
 *
 * Contains disable bits for various features
 *
 */
typedef union bdk_tns_sde_urw2a_hdr_w0 {
	uint64_t u;
	struct bdk_tns_sde_urw2a_hdr_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lpb_pt_en                   : 48; /**< R/W - -- */
		uint64_t etag_etype                  : 16; /**< R/W - -- */
#else
		uint64_t etag_etype                  : 16;
		uint64_t lpb_pt_en                   : 48;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_hdr_w0_s  cn88xx; */
	/* struct bdk_tns_sde_urw2a_hdr_w0_s  cn88xxp1; */
} bdk_tns_sde_urw2a_hdr_w0_t;

#define BDK_TNS_SDE_URW2A_HDR_W0 BDK_TNS_SDE_URW2A_HDR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W0_FUNC(void)
{
	return 0x0000842060481C00ull;
}
#define typedef_BDK_TNS_SDE_URW2A_HDR_W0 bdk_tns_sde_urw2a_hdr_w0_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_HDR_W0 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_HDR_W0 "TNS_SDE_URW2A_HDR_W0"


/**
 * NCB - tns_sde_urw2a_hdr_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2a_hdr_w1 {
	uint64_t u;
	struct bdk_tns_sde_urw2a_hdr_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lpb_pt_en                   : 64; /**< R/W - Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else
		uint64_t lpb_pt_en                   : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_hdr_w1_s  cn88xx; */
	/* struct bdk_tns_sde_urw2a_hdr_w1_s  cn88xxp1; */
} bdk_tns_sde_urw2a_hdr_w1_t;

#define BDK_TNS_SDE_URW2A_HDR_W1 BDK_TNS_SDE_URW2A_HDR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W1_FUNC(void)
{
	return 0x0000842060481C08ull;
}
#define typedef_BDK_TNS_SDE_URW2A_HDR_W1 bdk_tns_sde_urw2a_hdr_w1_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_HDR_W1 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_HDR_W1 "TNS_SDE_URW2A_HDR_W1"


/**
 * NCB - tns_sde_urw2a_hdr_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2a_hdr_w2 {
	uint64_t u;
	struct bdk_tns_sde_urw2a_hdr_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cpu_xph_en                  : 39; /**< R/W - -- */
		uint64_t lpb_pt_en                   : 25; /**< R/W - Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else
		uint64_t lpb_pt_en                   : 25;
		uint64_t cpu_xph_en                  : 39;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_hdr_w2_s  cn88xx; */
	/* struct bdk_tns_sde_urw2a_hdr_w2_s  cn88xxp1; */
} bdk_tns_sde_urw2a_hdr_w2_t;

#define BDK_TNS_SDE_URW2A_HDR_W2 BDK_TNS_SDE_URW2A_HDR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W2_FUNC(void)
{
	return 0x0000842060481C10ull;
}
#define typedef_BDK_TNS_SDE_URW2A_HDR_W2 bdk_tns_sde_urw2a_hdr_w2_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_HDR_W2 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_HDR_W2 "TNS_SDE_URW2A_HDR_W2"


/**
 * NCB - tns_sde_urw2a_hdr_w3
 *
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2a_hdr_w3 {
	uint64_t u;
	struct bdk_tns_sde_urw2a_hdr_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cpu_xph_en                  : 64; /**< R/W - Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else
		uint64_t cpu_xph_en                  : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_hdr_w3_s  cn88xx; */
	/* struct bdk_tns_sde_urw2a_hdr_w3_s  cn88xxp1; */
} bdk_tns_sde_urw2a_hdr_w3_t;

#define BDK_TNS_SDE_URW2A_HDR_W3 BDK_TNS_SDE_URW2A_HDR_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W3_FUNC(void)
{
	return 0x0000842060481C18ull;
}
#define typedef_BDK_TNS_SDE_URW2A_HDR_W3 bdk_tns_sde_urw2a_hdr_w3_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W3 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_HDR_W3 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_HDR_W3 "TNS_SDE_URW2A_HDR_W3"


/**
 * NCB - tns_sde_urw2a_hdr_w4
 *
 * Continuation of structure defined in TNS_SDE_URW2A_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2a_hdr_w4 {
	uint64_t u;
	struct bdk_tns_sde_urw2a_hdr_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t use_xph_ts                  : 1;  /**< R/W - -- */
		uint64_t cpu_xph_en                  : 34; /**< R/W - Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else
		uint64_t cpu_xph_en                  : 34;
		uint64_t use_xph_ts                  : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_hdr_w4_s  cn88xx; */
	/* struct bdk_tns_sde_urw2a_hdr_w4_s  cn88xxp1; */
} bdk_tns_sde_urw2a_hdr_w4_t;

#define BDK_TNS_SDE_URW2A_HDR_W4 BDK_TNS_SDE_URW2A_HDR_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_HDR_W4_FUNC(void)
{
	return 0x0000842060481C20ull;
}
#define typedef_BDK_TNS_SDE_URW2A_HDR_W4 bdk_tns_sde_urw2a_hdr_w4_t
#define bustype_BDK_TNS_SDE_URW2A_HDR_W4 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_HDR_W4 0
#define arguments_BDK_TNS_SDE_URW2A_HDR_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_HDR_W4 "TNS_SDE_URW2A_HDR_W4"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w0
 *
 * Contains constant 32 byte data for the 8 commands. This data defaults the
 * 32-byte layer
 * When writing, the MSBs (word 8) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bmap                        : 32; /**< R/W - -- */
#else
		uint32_t bmap                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w0_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481000ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w0_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W0(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W0"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w1_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481004ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w1_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W1(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W1"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w2_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481008ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w2_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W2(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W2"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w3
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w3 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w3_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w3_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w3_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206048100Cull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w3_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W3(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W3"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w4
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w4 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w4_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w4_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w4_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481010ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w4_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W4(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W4"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w5
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w5 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w5_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w5_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w5_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481014ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w5_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W5(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W5"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w6
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w6 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w6_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w6_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w6_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481018ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w6_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W6(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W6"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w7
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w7 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w7_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w7_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w7_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x000084206048101Cull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w7_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W7(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W7"


/**
 * NCB32b - tns_sde_urw2a_ins_ctd_tbl#_w8
 *
 * Continuation of structure defined in TNS_SDE_URW2A_INS_CTD_TBL(0..31)_W0
 *
 */
typedef union bdk_tns_sde_urw2a_ins_ctd_tblx_w8 {
	uint32_t u;
	struct bdk_tns_sde_urw2a_ins_ctd_tblx_w8_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w8_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_ctd_tblx_w8_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_ctd_tblx_w8_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060481020ull + (param1 & 31) * 0x40ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(...) bdk_tns_sde_urw2a_ins_ctd_tblx_w8_t
#define bustype_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_CTD_TBLX_W8(...) "TNS_SDE_URW2A_INS_CTD_TBLX_W8"


/**
 * NCB - tns_sde_urw2a_ins_mem_tbl#_w#
 *
 * Contains instructions for building the insert data.
 * Bits[63:49] in _W[3] are unused.
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw2a_ins_mem_tblx_wx {
	uint64_t u;
	struct bdk_tns_sde_urw2a_ins_mem_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_ins_mem_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_ins_mem_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw2a_ins_mem_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 127)) && ((param2 <= 3)))
		return 0x0000842060480000ull + (param1 & 127) * 0x20ull + (param2 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(...) bdk_tns_sde_urw2a_ins_mem_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW2A_INS_MEM_TBLX_WX(...) "TNS_SDE_URW2A_INS_MEM_TBLX_WX"


/**
 * NCB32b - tns_sde_urw2a_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_urw2a_lock {
	uint32_t u;
	struct bdk_tns_sde_urw2a_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_lock_s    cn88xx; */
	/* struct bdk_tns_sde_urw2a_lock_s    cn88xxp1; */
} bdk_tns_sde_urw2a_lock_t;

#define BDK_TNS_SDE_URW2A_LOCK BDK_TNS_SDE_URW2A_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_LOCK_FUNC(void)
{
	return 0x0000842060481C5Cull;
}
#define typedef_BDK_TNS_SDE_URW2A_LOCK bdk_tns_sde_urw2a_lock_t
#define bustype_BDK_TNS_SDE_URW2A_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_LOCK 0
#define arguments_BDK_TNS_SDE_URW2A_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_LOCK "TNS_SDE_URW2A_LOCK"


/**
 * NCB - tns_sde_urw2a_rwmem_tbl#_w#
 *
 * Each line contains 2 commands. Indexed by rewritePtr0-7[7:0]
 * Bits[63:44] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw2a_rwmem_tblx_wx {
	uint64_t u;
	struct bdk_tns_sde_urw2a_rwmem_tblx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cmd_data                    : 64; /**< R/W - -- */
#else
		uint64_t cmd_data                    : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_rwmem_tblx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw2a_rwmem_tblx_wx_s cn88xxp1; */
} bdk_tns_sde_urw2a_rwmem_tblx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 63)) && ((param2 <= 1)))
		return 0x0000842060481800ull + (param1 & 63) * 0x10ull + (param2 & 1) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(...) bdk_tns_sde_urw2a_rwmem_tblx_wx_t
#define bustype_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW2A_RWMEM_TBLX_WX(...) "TNS_SDE_URW2A_RWMEM_TBLX_WX"


/**
 * NCB32b - tns_sde_urw2a_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_urw2a_spad {
	uint32_t u;
	struct bdk_tns_sde_urw2a_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2a_spad_s    cn88xx; */
	/* struct bdk_tns_sde_urw2a_spad_s    cn88xxp1; */
} bdk_tns_sde_urw2a_spad_t;

#define BDK_TNS_SDE_URW2A_SPAD BDK_TNS_SDE_URW2A_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2A_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2A_SPAD_FUNC(void)
{
	return 0x0000842060481C60ull;
}
#define typedef_BDK_TNS_SDE_URW2A_SPAD bdk_tns_sde_urw2a_spad_t
#define bustype_BDK_TNS_SDE_URW2A_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2A_SPAD 0
#define arguments_BDK_TNS_SDE_URW2A_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2A_SPAD "TNS_SDE_URW2A_SPAD"


/**
 * NCB32b - tns_sde_urw2b_control
 *
 * Contains disable bits for various features
 *
 */
typedef union bdk_tns_sde_urw2b_control {
	uint32_t u;
	struct bdk_tns_sde_urw2b_control_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t cut_through_mode            : 1;  /**< R/W - -- */
		uint32_t logic_rst                   : 1;  /**< R/W - -- */
		uint32_t set_refcntvld_tosdma        : 1;  /**< R/W - -- */
		uint32_t enable_selective_mtu_checking : 1;/**< R/W - -- */
#else
		uint32_t enable_selective_mtu_checking : 1;
		uint32_t set_refcntvld_tosdma        : 1;
		uint32_t logic_rst                   : 1;
		uint32_t cut_through_mode            : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_control_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_control_s cn88xxp1; */
} bdk_tns_sde_urw2b_control_t;

#define BDK_TNS_SDE_URW2B_CONTROL BDK_TNS_SDE_URW2B_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_CONTROL_FUNC(void)
{
	return 0x000084206050005Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_CONTROL bdk_tns_sde_urw2b_control_t
#define bustype_BDK_TNS_SDE_URW2B_CONTROL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_CONTROL 0
#define arguments_BDK_TNS_SDE_URW2B_CONTROL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_CONTROL "TNS_SDE_URW2B_CONTROL"


/**
 * NCB32b - tns_sde_urw2b_cpu_rcod_base
 *
 * The reason codes for packets going to CPU use this value as a base
 * RCODE_NEW_ADDR  = CFG_CPU_RCODES_BASE + 3'd2;
 * RCODE_MTU_ERR   = CFG_CPU_RCODES_BASE + 3'd3;
 */
typedef union bdk_tns_sde_urw2b_cpu_rcod_base {
	uint32_t u;
	struct bdk_tns_sde_urw2b_cpu_rcod_base_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t field                       : 10; /**< R/W - -- */
#else
		uint32_t field                       : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_cpu_rcod_base_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_cpu_rcod_base_s cn88xxp1; */
} bdk_tns_sde_urw2b_cpu_rcod_base_t;

#define BDK_TNS_SDE_URW2B_CPU_RCOD_BASE BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_CPU_RCOD_BASE_FUNC(void)
{
	return 0x000084206050007Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE bdk_tns_sde_urw2b_cpu_rcod_base_t
#define bustype_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE 0
#define arguments_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_CPU_RCOD_BASE "TNS_SDE_URW2B_CPU_RCOD_BASE"


/**
 * NCB32b - tns_sde_urw2b_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw2b_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_urw2b_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_dbg_sel_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_dbg_sel_s cn88xxp1; */
} bdk_tns_sde_urw2b_dbg_sel_t;

#define BDK_TNS_SDE_URW2B_DBG_SEL BDK_TNS_SDE_URW2B_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_SEL_FUNC(void)
{
	return 0x0000842060500094ull;
}
#define typedef_BDK_TNS_SDE_URW2B_DBG_SEL bdk_tns_sde_urw2b_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW2B_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW2B_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_DBG_SEL "TNS_SDE_URW2B_DBG_SEL"


/**
 * NCB32b - tns_sde_urw2b_dbg_sta_live
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw2b_dbg_sta_live {
	uint32_t u;
	struct bdk_tns_sde_urw2b_dbg_sta_live_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t data                        : 6;  /**< RO/H - -- */
#else
		uint32_t data                        : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_dbg_sta_live_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_dbg_sta_live_s cn88xxp1; */
} bdk_tns_sde_urw2b_dbg_sta_live_t;

#define BDK_TNS_SDE_URW2B_DBG_STA_LIVE BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_DBG_STA_LIVE_FUNC(void)
{
	return 0x0000842060500090ull;
}
#define typedef_BDK_TNS_SDE_URW2B_DBG_STA_LIVE bdk_tns_sde_urw2b_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW2B_DBG_STA_LIVE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW2B_DBG_STA_LIVE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_DBG_STA_LIVE "TNS_SDE_URW2B_DBG_STA_LIVE"


/**
 * NCB32b - tns_sde_urw2b_etag_w0
 *
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
typedef union bdk_tns_sde_urw2b_etag_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_etag_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - -- */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_etag_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_etag_w0_s cn88xxp1; */
} bdk_tns_sde_urw2b_etag_w0_t;

#define BDK_TNS_SDE_URW2B_ETAG_W0 BDK_TNS_SDE_URW2B_ETAG_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W0_FUNC(void)
{
	return 0x0000842060500038ull;
}
#define typedef_BDK_TNS_SDE_URW2B_ETAG_W0 bdk_tns_sde_urw2b_etag_w0_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W0 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_ETAG_W0 "TNS_SDE_URW2B_ETAG_W0"


/**
 * NCB32b - tns_sde_urw2b_etag_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2b_etag_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_etag_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_etag_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_etag_w1_s cn88xxp1; */
} bdk_tns_sde_urw2b_etag_w1_t;

#define BDK_TNS_SDE_URW2B_ETAG_W1 BDK_TNS_SDE_URW2B_ETAG_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W1_FUNC(void)
{
	return 0x000084206050003Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_ETAG_W1 bdk_tns_sde_urw2b_etag_w1_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W1 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_ETAG_W1 "TNS_SDE_URW2B_ETAG_W1"


/**
 * NCB32b - tns_sde_urw2b_etag_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2b_etag_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_etag_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_etag_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_etag_w2_s cn88xxp1; */
} bdk_tns_sde_urw2b_etag_w2_t;

#define BDK_TNS_SDE_URW2B_ETAG_W2 BDK_TNS_SDE_URW2B_ETAG_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W2_FUNC(void)
{
	return 0x0000842060500040ull;
}
#define typedef_BDK_TNS_SDE_URW2B_ETAG_W2 bdk_tns_sde_urw2b_etag_w2_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W2 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_ETAG_W2 "TNS_SDE_URW2B_ETAG_W2"


/**
 * NCB32b - tns_sde_urw2b_etag_w3
 *
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2b_etag_w3 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_etag_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t pt_en                       : 32; /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_etag_w3_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_etag_w3_s cn88xxp1; */
} bdk_tns_sde_urw2b_etag_w3_t;

#define BDK_TNS_SDE_URW2B_ETAG_W3 BDK_TNS_SDE_URW2B_ETAG_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W3_FUNC(void)
{
	return 0x0000842060500044ull;
}
#define typedef_BDK_TNS_SDE_URW2B_ETAG_W3 bdk_tns_sde_urw2b_etag_w3_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W3 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_ETAG_W3 "TNS_SDE_URW2B_ETAG_W3"


/**
 * NCB32b - tns_sde_urw2b_etag_w4
 *
 * Continuation of structure defined in TNS_SDE_URW2B_ETAG_W0
 *
 */
typedef union bdk_tns_sde_urw2b_etag_w4 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_etag_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t modify_etag_en              : 1;  /**< R/W - -- */
		uint32_t pt_en                       : 9;  /**< R/W - Continuation of MSBs of field PORT_EN from previous word. */
#else
		uint32_t pt_en                       : 9;
		uint32_t modify_etag_en              : 1;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_etag_w4_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_etag_w4_s cn88xxp1; */
} bdk_tns_sde_urw2b_etag_w4_t;

#define BDK_TNS_SDE_URW2B_ETAG_W4 BDK_TNS_SDE_URW2B_ETAG_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_ETAG_W4_FUNC(void)
{
	return 0x0000842060500048ull;
}
#define typedef_BDK_TNS_SDE_URW2B_ETAG_W4 bdk_tns_sde_urw2b_etag_w4_t
#define bustype_BDK_TNS_SDE_URW2B_ETAG_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_ETAG_W4 0
#define arguments_BDK_TNS_SDE_URW2B_ETAG_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_ETAG_W4 "TNS_SDE_URW2B_ETAG_W4"


/**
 * NCB - tns_sde_urw2b_hdr_w0
 *
 * Contains disable bits for various features
 *
 */
typedef union bdk_tns_sde_urw2b_hdr_w0 {
	uint64_t u;
	struct bdk_tns_sde_urw2b_hdr_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lpb_pt_en                   : 48; /**< R/W - -- */
		uint64_t etag_etype                  : 16; /**< R/W - -- */
#else
		uint64_t etag_etype                  : 16;
		uint64_t lpb_pt_en                   : 48;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_hdr_w0_s  cn88xx; */
	/* struct bdk_tns_sde_urw2b_hdr_w0_s  cn88xxp1; */
} bdk_tns_sde_urw2b_hdr_w0_t;

#define BDK_TNS_SDE_URW2B_HDR_W0 BDK_TNS_SDE_URW2B_HDR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W0_FUNC(void)
{
	return 0x0000842060500010ull;
}
#define typedef_BDK_TNS_SDE_URW2B_HDR_W0 bdk_tns_sde_urw2b_hdr_w0_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2B_HDR_W0 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_HDR_W0 "TNS_SDE_URW2B_HDR_W0"


/**
 * NCB - tns_sde_urw2b_hdr_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_hdr_w1 {
	uint64_t u;
	struct bdk_tns_sde_urw2b_hdr_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t lpb_pt_en                   : 64; /**< R/W - Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else
		uint64_t lpb_pt_en                   : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_hdr_w1_s  cn88xx; */
	/* struct bdk_tns_sde_urw2b_hdr_w1_s  cn88xxp1; */
} bdk_tns_sde_urw2b_hdr_w1_t;

#define BDK_TNS_SDE_URW2B_HDR_W1 BDK_TNS_SDE_URW2B_HDR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W1_FUNC(void)
{
	return 0x0000842060500018ull;
}
#define typedef_BDK_TNS_SDE_URW2B_HDR_W1 bdk_tns_sde_urw2b_hdr_w1_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2B_HDR_W1 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_HDR_W1 "TNS_SDE_URW2B_HDR_W1"


/**
 * NCB - tns_sde_urw2b_hdr_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_hdr_w2 {
	uint64_t u;
	struct bdk_tns_sde_urw2b_hdr_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cpu_xph_en                  : 39; /**< R/W - -- */
		uint64_t lpb_pt_en                   : 25; /**< R/W - Continuation of MSBs of field LPB_PORT_EN from previous word. */
#else
		uint64_t lpb_pt_en                   : 25;
		uint64_t cpu_xph_en                  : 39;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_hdr_w2_s  cn88xx; */
	/* struct bdk_tns_sde_urw2b_hdr_w2_s  cn88xxp1; */
} bdk_tns_sde_urw2b_hdr_w2_t;

#define BDK_TNS_SDE_URW2B_HDR_W2 BDK_TNS_SDE_URW2B_HDR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W2_FUNC(void)
{
	return 0x0000842060500020ull;
}
#define typedef_BDK_TNS_SDE_URW2B_HDR_W2 bdk_tns_sde_urw2b_hdr_w2_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2B_HDR_W2 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_HDR_W2 "TNS_SDE_URW2B_HDR_W2"


/**
 * NCB - tns_sde_urw2b_hdr_w3
 *
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_hdr_w3 {
	uint64_t u;
	struct bdk_tns_sde_urw2b_hdr_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t cpu_xph_en                  : 64; /**< R/W - Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else
		uint64_t cpu_xph_en                  : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_hdr_w3_s  cn88xx; */
	/* struct bdk_tns_sde_urw2b_hdr_w3_s  cn88xxp1; */
} bdk_tns_sde_urw2b_hdr_w3_t;

#define BDK_TNS_SDE_URW2B_HDR_W3 BDK_TNS_SDE_URW2B_HDR_W3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W3_FUNC(void)
{
	return 0x0000842060500028ull;
}
#define typedef_BDK_TNS_SDE_URW2B_HDR_W3 bdk_tns_sde_urw2b_hdr_w3_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W3 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2B_HDR_W3 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_HDR_W3 "TNS_SDE_URW2B_HDR_W3"


/**
 * NCB - tns_sde_urw2b_hdr_w4
 *
 * Continuation of structure defined in TNS_SDE_URW2B_HDR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_hdr_w4 {
	uint64_t u;
	struct bdk_tns_sde_urw2b_hdr_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t use_xph_ts                  : 1;  /**< R/W - -- */
		uint64_t cpu_xph_en                  : 34; /**< R/W - Continuation of MSBs of field CPU_XPH_EN from previous word. */
#else
		uint64_t cpu_xph_en                  : 34;
		uint64_t use_xph_ts                  : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_hdr_w4_s  cn88xx; */
	/* struct bdk_tns_sde_urw2b_hdr_w4_s  cn88xxp1; */
} bdk_tns_sde_urw2b_hdr_w4_t;

#define BDK_TNS_SDE_URW2B_HDR_W4 BDK_TNS_SDE_URW2B_HDR_W4_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_HDR_W4_FUNC(void)
{
	return 0x0000842060500030ull;
}
#define typedef_BDK_TNS_SDE_URW2B_HDR_W4 bdk_tns_sde_urw2b_hdr_w4_t
#define bustype_BDK_TNS_SDE_URW2B_HDR_W4 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW2B_HDR_W4 0
#define arguments_BDK_TNS_SDE_URW2B_HDR_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_HDR_W4 "TNS_SDE_URW2B_HDR_W4"


/**
 * NCB32b - tns_sde_urw2b_int_en_hi
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw2b_int_en_hi {
	uint32_t u;
	struct bdk_tns_sde_urw2b_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t hdrsize_ovfl                : 1;  /**< R/W - -- */
#else
		uint32_t hdrsize_ovfl                : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_int_en_hi_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_int_en_hi_s cn88xxp1; */
} bdk_tns_sde_urw2b_int_en_hi_t;

#define BDK_TNS_SDE_URW2B_INT_EN_HI BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_HI_FUNC(void)
{
	return 0x0000842060500004ull;
}
#define typedef_BDK_TNS_SDE_URW2B_INT_EN_HI bdk_tns_sde_urw2b_int_en_hi_t
#define bustype_BDK_TNS_SDE_URW2B_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_INT_EN_HI 0
#define arguments_BDK_TNS_SDE_URW2B_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_INT_EN_HI "TNS_SDE_URW2B_INT_EN_HI"


/**
 * NCB32b - tns_sde_urw2b_int_en_lo
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw2b_int_en_lo {
	uint32_t u;
	struct bdk_tns_sde_urw2b_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t hdrsize_ovfl                : 1;  /**< R/W - -- */
#else
		uint32_t hdrsize_ovfl                : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_int_en_lo_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_int_en_lo_s cn88xxp1; */
} bdk_tns_sde_urw2b_int_en_lo_t;

#define BDK_TNS_SDE_URW2B_INT_EN_LO BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_EN_LO_FUNC(void)
{
	return 0x0000842060500008ull;
}
#define typedef_BDK_TNS_SDE_URW2B_INT_EN_LO bdk_tns_sde_urw2b_int_en_lo_t
#define bustype_BDK_TNS_SDE_URW2B_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_INT_EN_LO 0
#define arguments_BDK_TNS_SDE_URW2B_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_INT_EN_LO "TNS_SDE_URW2B_INT_EN_LO"


/**
 * NCB32b - tns_sde_urw2b_int_frc
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw2b_int_frc {
	uint32_t u;
	struct bdk_tns_sde_urw2b_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t hdrsize_ovfl                : 1;  /**< WO - -- */
#else
		uint32_t hdrsize_ovfl                : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_int_frc_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_int_frc_s cn88xxp1; */
} bdk_tns_sde_urw2b_int_frc_t;

#define BDK_TNS_SDE_URW2B_INT_FRC BDK_TNS_SDE_URW2B_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_FRC_FUNC(void)
{
	return 0x000084206050000Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_INT_FRC bdk_tns_sde_urw2b_int_frc_t
#define bustype_BDK_TNS_SDE_URW2B_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_INT_FRC 0
#define arguments_BDK_TNS_SDE_URW2B_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_INT_FRC "TNS_SDE_URW2B_INT_FRC"


/**
 * NCB32b - tns_sde_urw2b_int_w1c
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw2b_int_w1c {
	uint32_t u;
	struct bdk_tns_sde_urw2b_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t hdrsize_ovfl                : 1;  /**< R/W1C/H - -- */
#else
		uint32_t hdrsize_ovfl                : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_int_w1c_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_int_w1c_s cn88xxp1; */
} bdk_tns_sde_urw2b_int_w1c_t;

#define BDK_TNS_SDE_URW2B_INT_W1C BDK_TNS_SDE_URW2B_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_INT_W1C_FUNC(void)
{
	return 0x0000842060500000ull;
}
#define typedef_BDK_TNS_SDE_URW2B_INT_W1C bdk_tns_sde_urw2b_int_w1c_t
#define bustype_BDK_TNS_SDE_URW2B_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_INT_W1C 0
#define arguments_BDK_TNS_SDE_URW2B_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_INT_W1C "TNS_SDE_URW2B_INT_W1C"


/**
 * NCB32b - tns_sde_urw2b_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_urw2b_lock {
	uint32_t u;
	struct bdk_tns_sde_urw2b_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_lock_s    cn88xx; */
	/* struct bdk_tns_sde_urw2b_lock_s    cn88xxp1; */
} bdk_tns_sde_urw2b_lock_t;

#define BDK_TNS_SDE_URW2B_LOCK BDK_TNS_SDE_URW2B_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_LOCK_FUNC(void)
{
	return 0x0000842060500098ull;
}
#define typedef_BDK_TNS_SDE_URW2B_LOCK bdk_tns_sde_urw2b_lock_t
#define bustype_BDK_TNS_SDE_URW2B_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_LOCK 0
#define arguments_BDK_TNS_SDE_URW2B_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_LOCK "TNS_SDE_URW2B_LOCK"


/**
 * NCB32b - tns_sde_urw2b_mir_mask_w0
 *
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 *
 */
typedef union bdk_tns_sde_urw2b_mir_mask_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mir_mask_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ivif                        : 16; /**< R/W - -- */
		uint32_t evif                        : 16; /**< R/W - -- */
#else
		uint32_t evif                        : 16;
		uint32_t ivif                        : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mir_mask_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mir_mask_w0_s cn88xxp1; */
} bdk_tns_sde_urw2b_mir_mask_w0_t;

#define BDK_TNS_SDE_URW2B_MIR_MASK_W0 BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W0_FUNC(void)
{
	return 0x0000842060500064ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MIR_MASK_W0 bdk_tns_sde_urw2b_mir_mask_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MIR_MASK_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MIR_MASK_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MIR_MASK_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MIR_MASK_W0 "TNS_SDE_URW2B_MIR_MASK_W0"


/**
 * NCB32b - tns_sde_urw2b_mir_mask_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2B_MIR_MASK_W0
 *
 */
typedef union bdk_tns_sde_urw2b_mir_mask_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mir_mask_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ing                         : 16; /**< R/W - -- */
		uint32_t egr                         : 16; /**< R/W - -- */
#else
		uint32_t egr                         : 16;
		uint32_t ing                         : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mir_mask_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mir_mask_w1_s cn88xxp1; */
} bdk_tns_sde_urw2b_mir_mask_w1_t;

#define BDK_TNS_SDE_URW2B_MIR_MASK_W1 BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MIR_MASK_W1_FUNC(void)
{
	return 0x0000842060500068ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MIR_MASK_W1 bdk_tns_sde_urw2b_mir_mask_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MIR_MASK_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MIR_MASK_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MIR_MASK_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MIR_MASK_W1 "TNS_SDE_URW2B_MIR_MASK_W1"


/**
 * NCB32b - tns_sde_urw2b_mre_dcnt_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw2b_mre_dcnt_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mre_dcnt_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mtu_err                     : 6;  /**< RO/H - -- */
		uint32_t mre_ptr                     : 13; /**< RO/H - -- */
		uint32_t qcn_sample                  : 13; /**< RO/H - -- */
#else
		uint32_t qcn_sample                  : 13;
		uint32_t mre_ptr                     : 13;
		uint32_t mtu_err                     : 6;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w0_s cn88xxp1; */
} bdk_tns_sde_urw2b_mre_dcnt_w0_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W0 BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W0_FUNC(void)
{
	return 0x0000842060500084ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 bdk_tns_sde_urw2b_mre_dcnt_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W0 "TNS_SDE_URW2B_MRE_DCNT_W0"


/**
 * NCB32b - tns_sde_urw2b_mre_dcnt_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2B_MRE_DCNT_W0
 *
 */
typedef union bdk_tns_sde_urw2b_mre_dcnt_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mre_dcnt_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ing_mir                     : 12; /**< RO/H - -- */
		uint32_t egr_mir                     : 13; /**< RO/H - -- */
		uint32_t mtu_err                     : 7;  /**< RO/H - Continuation of MSBs of field MTU_ERR from previous word. */
#else
		uint32_t mtu_err                     : 7;
		uint32_t egr_mir                     : 13;
		uint32_t ing_mir                     : 12;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w1_s cn88xxp1; */
} bdk_tns_sde_urw2b_mre_dcnt_w1_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W1 BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W1_FUNC(void)
{
	return 0x0000842060500088ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 bdk_tns_sde_urw2b_mre_dcnt_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W1 "TNS_SDE_URW2B_MRE_DCNT_W1"


/**
 * NCB32b - tns_sde_urw2b_mre_dcnt_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2B_MRE_DCNT_W0
 *
 */
typedef union bdk_tns_sde_urw2b_mre_dcnt_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mre_dcnt_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t ing_mir                     : 1;  /**< RO/H - Continuation of MSBs of field ING_MIR from previous word. */
#else
		uint32_t ing_mir                     : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mre_dcnt_w2_s cn88xxp1; */
} bdk_tns_sde_urw2b_mre_dcnt_w2_t;

#define BDK_TNS_SDE_URW2B_MRE_DCNT_W2 BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_DCNT_W2_FUNC(void)
{
	return 0x000084206050008Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 bdk_tns_sde_urw2b_mre_dcnt_w2_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MRE_DCNT_W2 "TNS_SDE_URW2B_MRE_DCNT_W2"


/**
 * NCB32b - tns_sde_urw2b_mre_pri_tbl
 *
 * This is a 2-wide and 4 deep table and holds pri for various cases.
 *
 */
typedef union bdk_tns_sde_urw2b_mre_pri_tbl {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mre_pri_tbl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t data                        : 8;  /**< R/W - -- */
#else
		uint32_t data                        : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mre_pri_tbl_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mre_pri_tbl_s cn88xxp1; */
} bdk_tns_sde_urw2b_mre_pri_tbl_t;

#define BDK_TNS_SDE_URW2B_MRE_PRI_TBL BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MRE_PRI_TBL_FUNC(void)
{
	return 0x0000842060500078ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MRE_PRI_TBL bdk_tns_sde_urw2b_mre_pri_tbl_t
#define bustype_BDK_TNS_SDE_URW2B_MRE_PRI_TBL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MRE_PRI_TBL 0
#define arguments_BDK_TNS_SDE_URW2B_MRE_PRI_TBL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MRE_PRI_TBL "TNS_SDE_URW2B_MRE_PRI_TBL"


/**
 * NCB32b - tns_sde_urw2b_mreif
 *
 * This is a 2-wide and 4 deep table and holds pri for various cases.
 *
 */
typedef union bdk_tns_sde_urw2b_mreif {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mreif_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t invalid_template_id         : 8;  /**< R/W - -- */
		uint32_t enable_overwrites_ing_mir   : 1;  /**< R/W - -- */
		uint32_t enable_overwrites_egr_mir   : 1;  /**< R/W - -- */
		uint32_t enable_overwrites_mtu_err   : 1;  /**< R/W - -- */
		uint32_t enable_overwrites_mre_ptr   : 1;  /**< R/W - -- */
		uint32_t zeroout_mrelast             : 1;  /**< R/W - -- */
#else
		uint32_t zeroout_mrelast             : 1;
		uint32_t enable_overwrites_mre_ptr   : 1;
		uint32_t enable_overwrites_mtu_err   : 1;
		uint32_t enable_overwrites_egr_mir   : 1;
		uint32_t enable_overwrites_ing_mir   : 1;
		uint32_t invalid_template_id         : 8;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mreif_s   cn88xx; */
	/* struct bdk_tns_sde_urw2b_mreif_s   cn88xxp1; */
} bdk_tns_sde_urw2b_mreif_t;

#define BDK_TNS_SDE_URW2B_MREIF BDK_TNS_SDE_URW2B_MREIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREIF_FUNC(void)
{
	return 0x0000842060500080ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MREIF bdk_tns_sde_urw2b_mreif_t
#define bustype_BDK_TNS_SDE_URW2B_MREIF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MREIF 0
#define arguments_BDK_TNS_SDE_URW2B_MREIF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MREIF "TNS_SDE_URW2B_MREIF"


/**
 * NCB32b - tns_sde_urw2b_mreptr_w0
 *
 * This holds MRE Pointers for Ingress, Egress and CPU cases.
 *
 */
typedef union bdk_tns_sde_urw2b_mreptr_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mreptr_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t cpu                         : 14; /**< R/W - -- */
		uint32_t qcn_sample                  : 18; /**< R/W - -- */
#else
		uint32_t qcn_sample                  : 18;
		uint32_t cpu                         : 14;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mreptr_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mreptr_w0_s cn88xxp1; */
} bdk_tns_sde_urw2b_mreptr_w0_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W0 BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W0_FUNC(void)
{
	return 0x000084206050006Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W0 bdk_tns_sde_urw2b_mreptr_w0_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W0 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W0 "TNS_SDE_URW2B_MREPTR_W0"


/**
 * NCB32b - tns_sde_urw2b_mreptr_w1
 *
 * Continuation of structure defined in TNS_SDE_URW2B_MREPTR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_mreptr_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mreptr_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ing                         : 10; /**< R/W - -- */
		uint32_t egr                         : 18; /**< R/W - -- */
		uint32_t cpu                         : 4;  /**< R/W - Continuation of MSBs of field CPU from previous word. */
#else
		uint32_t cpu                         : 4;
		uint32_t egr                         : 18;
		uint32_t ing                         : 10;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mreptr_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mreptr_w1_s cn88xxp1; */
} bdk_tns_sde_urw2b_mreptr_w1_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W1 BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W1_FUNC(void)
{
	return 0x0000842060500070ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W1 bdk_tns_sde_urw2b_mreptr_w1_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W1 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W1 "TNS_SDE_URW2B_MREPTR_W1"


/**
 * NCB32b - tns_sde_urw2b_mreptr_w2
 *
 * Continuation of structure defined in TNS_SDE_URW2B_MREPTR_W0
 *
 */
typedef union bdk_tns_sde_urw2b_mreptr_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mreptr_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ing                         : 8;  /**< R/W - Continuation of MSBs of field ING from previous word. */
#else
		uint32_t ing                         : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mreptr_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mreptr_w2_s cn88xxp1; */
} bdk_tns_sde_urw2b_mreptr_w2_t;

#define BDK_TNS_SDE_URW2B_MREPTR_W2 BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MREPTR_W2_FUNC(void)
{
	return 0x0000842060500074ull;
}
#define typedef_BDK_TNS_SDE_URW2B_MREPTR_W2 bdk_tns_sde_urw2b_mreptr_w2_t
#define bustype_BDK_TNS_SDE_URW2B_MREPTR_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MREPTR_W2 0
#define arguments_BDK_TNS_SDE_URW2B_MREPTR_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MREPTR_W2 "TNS_SDE_URW2B_MREPTR_W2"


/**
 * NCB32b - tns_sde_urw2b_mtu_prf_tbl_w#
 *
 * Indexed by 3 bits of mtu_profile in the token. Outputs a 14 bit max_mtu size.
 * Bits 31..16 of registers ending in _W3 are unused.
 */
typedef union bdk_tns_sde_urw2b_mtu_prf_tbl_wx {
	uint32_t u;
	struct bdk_tns_sde_urw2b_mtu_prf_tbl_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_mtu_prf_tbl_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_mtu_prf_tbl_wx_s cn88xxp1; */
} bdk_tns_sde_urw2b_mtu_prf_tbl_wx_t;

static inline uint64_t BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084206050004Cull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(...) bdk_tns_sde_urw2b_mtu_prf_tbl_wx_t
#define bustype_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_MTU_PRF_TBL_WX(...) "TNS_SDE_URW2B_MTU_PRF_TBL_WX"


/**
 * NCB32b - tns_sde_urw2b_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_urw2b_spad {
	uint32_t u;
	struct bdk_tns_sde_urw2b_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_spad_s    cn88xx; */
	/* struct bdk_tns_sde_urw2b_spad_s    cn88xxp1; */
} bdk_tns_sde_urw2b_spad_t;

#define BDK_TNS_SDE_URW2B_SPAD BDK_TNS_SDE_URW2B_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_SPAD_FUNC(void)
{
	return 0x000084206050009Cull;
}
#define typedef_BDK_TNS_SDE_URW2B_SPAD bdk_tns_sde_urw2b_spad_t
#define bustype_BDK_TNS_SDE_URW2B_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_SPAD 0
#define arguments_BDK_TNS_SDE_URW2B_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_SPAD "TNS_SDE_URW2B_SPAD"


/**
 * NCB32b - tns_sde_urw2b_tcls_pmap_tbl
 *
 * Mapping table to map {4-bit token.traffic_class} class to 2 bit priority.
 *
 */
typedef union bdk_tns_sde_urw2b_tcls_pmap_tbl {
	uint32_t u;
	struct bdk_tns_sde_urw2b_tcls_pmap_tbl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw2b_tcls_pmap_tbl_s cn88xx; */
	/* struct bdk_tns_sde_urw2b_tcls_pmap_tbl_s cn88xxp1; */
} bdk_tns_sde_urw2b_tcls_pmap_tbl_t;

#define BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL_FUNC(void)
{
	return 0x0000842060500060ull;
}
#define typedef_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL bdk_tns_sde_urw2b_tcls_pmap_tbl_t
#define bustype_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL 0
#define arguments_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW2B_TCLS_PMAP_TBL "TNS_SDE_URW2B_TCLS_PMAP_TBL"


/**
 * NCB - tns_sde_urw3_cnncmd_tbl#
 *
 * Contains canon commands for layers which match the stored layerType and
 * layerHash values
 */
typedef union bdk_tns_sde_urw3_cnncmd_tblx {
	uint64_t u;
	struct bdk_tns_sde_urw3_cnncmd_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_42_63              : 22;
		uint64_t layertype                   : 6;  /**< R/W - -- */
		uint64_t layerhash                   : 4;  /**< R/W - -- */
		uint64_t contbytes                   : 8;  /**< R/W - -- */
		uint64_t bitvector                   : 24; /**< R/W - -- */
#else
		uint64_t bitvector                   : 24;
		uint64_t contbytes                   : 8;
		uint64_t layerhash                   : 4;
		uint64_t layertype                   : 6;
		uint64_t reserved_42_63              : 22;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_cnncmd_tblx_s cn88xx; */
	/* struct bdk_tns_sde_urw3_cnncmd_tblx_s cn88xxp1; */
} bdk_tns_sde_urw3_cnncmd_tblx_t;

static inline uint64_t BDK_TNS_SDE_URW3_CNNCMD_TBLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_CNNCMD_TBLX(unsigned long param1)
{
	if (((param1 <= 35)))
		return 0x0000842060580400ull + (param1 & 63) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW3_CNNCMD_TBLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_CNNCMD_TBLX(...) bdk_tns_sde_urw3_cnncmd_tblx_t
#define bustype_BDK_TNS_SDE_URW3_CNNCMD_TBLX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_CNNCMD_TBLX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_CNNCMD_TBLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_CNNCMD_TBLX(...) "TNS_SDE_URW3_CNNCMD_TBLX"


/**
 * NCB32b - tns_sde_urw3_control
 *
 * Contains disable bits for various features
 *
 */
typedef union bdk_tns_sde_urw3_control {
	uint32_t u;
	struct bdk_tns_sde_urw3_control_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t dbg_mode_donot_free_hdrbuf  : 1;  /**< R/W - -- */
		uint32_t disable_se_ins_lkup         : 1;  /**< R/W - -- */
		uint32_t disable_txq_lkup            : 1;  /**< R/W - -- */
		uint32_t logic_rst                   : 1;  /**< R/W - -- */
#else
		uint32_t logic_rst                   : 1;
		uint32_t disable_txq_lkup            : 1;
		uint32_t disable_se_ins_lkup         : 1;
		uint32_t dbg_mode_donot_free_hdrbuf  : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_control_s  cn88xx; */
	/* struct bdk_tns_sde_urw3_control_s  cn88xxp1; */
} bdk_tns_sde_urw3_control_t;

#define BDK_TNS_SDE_URW3_CONTROL BDK_TNS_SDE_URW3_CONTROL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_CONTROL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_CONTROL_FUNC(void)
{
	return 0x0000842060580840ull;
}
#define typedef_BDK_TNS_SDE_URW3_CONTROL bdk_tns_sde_urw3_control_t
#define bustype_BDK_TNS_SDE_URW3_CONTROL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_CONTROL 0
#define arguments_BDK_TNS_SDE_URW3_CONTROL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_CONTROL "TNS_SDE_URW3_CONTROL"


/**
 * NCB32b - tns_sde_urw3_dbg_lpathf
 *
 * For debug hooks to VLF fifo
 *
 */
typedef union bdk_tns_sde_urw3_dbg_lpathf {
	uint32_t u;
	struct bdk_tns_sde_urw3_dbg_lpathf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t enqen                       : 1;  /**< R/W - -- */
		uint32_t deqen                       : 1;  /**< R/W - -- */
		uint32_t contenq                     : 1;  /**< R/W - -- */
		uint32_t contdeq                     : 1;  /**< R/W - -- */
#else
		uint32_t contdeq                     : 1;
		uint32_t contenq                     : 1;
		uint32_t deqen                       : 1;
		uint32_t enqen                       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dbg_lpathf_s cn88xx; */
	/* struct bdk_tns_sde_urw3_dbg_lpathf_s cn88xxp1; */
} bdk_tns_sde_urw3_dbg_lpathf_t;

#define BDK_TNS_SDE_URW3_DBG_LPATHF BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_LPATHF_FUNC(void)
{
	return 0x0000842060580894ull;
}
#define typedef_BDK_TNS_SDE_URW3_DBG_LPATHF bdk_tns_sde_urw3_dbg_lpathf_t
#define bustype_BDK_TNS_SDE_URW3_DBG_LPATHF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_DBG_LPATHF 0
#define arguments_BDK_TNS_SDE_URW3_DBG_LPATHF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DBG_LPATHF "TNS_SDE_URW3_DBG_LPATHF"


/**
 * NCB32b - tns_sde_urw3_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_dbg_sel {
	uint32_t u;
	struct bdk_tns_sde_urw3_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t field_a                     : 8;  /**< R/W - Mux selector for bits 35:0 of the debug bus. Value 0 will drive all 0s. */
		uint32_t field_b                     : 8;  /**< R/W - Mux selector for bits 71:36 of the debug bus. Value 0 will drive all 0s. */
#else
		uint32_t field_b                     : 8;
		uint32_t field_a                     : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_sde_urw3_dbg_sel_s  cn88xxp1; */
} bdk_tns_sde_urw3_dbg_sel_t;

#define BDK_TNS_SDE_URW3_DBG_SEL BDK_TNS_SDE_URW3_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_SEL_FUNC(void)
{
	return 0x00008420605808ACull;
}
#define typedef_BDK_TNS_SDE_URW3_DBG_SEL bdk_tns_sde_urw3_dbg_sel_t
#define bustype_BDK_TNS_SDE_URW3_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_DBG_SEL 0
#define arguments_BDK_TNS_SDE_URW3_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DBG_SEL "TNS_SDE_URW3_DBG_SEL"


/**
 * NCB - tns_sde_urw3_dbg_sta_live
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_dbg_sta_live {
	uint64_t u;
	struct bdk_tns_sde_urw3_dbg_sta_live_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t txqif_data                  : 17; /**< RO/H - -- */
		uint64_t se_vif_if_data              : 20; /**< RO/H - -- */
		uint64_t se_ins_if_data              : 12; /**< RO/H - -- */
		uint64_t hif_data                    : 15; /**< RO/H - -- */
#else
		uint64_t hif_data                    : 15;
		uint64_t se_ins_if_data              : 12;
		uint64_t se_vif_if_data              : 20;
		uint64_t txqif_data                  : 17;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dbg_sta_live_s cn88xx; */
	/* struct bdk_tns_sde_urw3_dbg_sta_live_s cn88xxp1; */
} bdk_tns_sde_urw3_dbg_sta_live_t;

#define BDK_TNS_SDE_URW3_DBG_STA_LIVE BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_STA_LIVE_FUNC(void)
{
	return 0x00008420605808B0ull;
}
#define typedef_BDK_TNS_SDE_URW3_DBG_STA_LIVE bdk_tns_sde_urw3_dbg_sta_live_t
#define bustype_BDK_TNS_SDE_URW3_DBG_STA_LIVE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_DBG_STA_LIVE 0
#define arguments_BDK_TNS_SDE_URW3_DBG_STA_LIVE -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DBG_STA_LIVE "TNS_SDE_URW3_DBG_STA_LIVE"


/**
 * NCB32b - tns_sde_urw3_dbg_txq_rpf
 *
 * For debug hooks to VLF fifo
 *
 */
typedef union bdk_tns_sde_urw3_dbg_txq_rpf {
	uint32_t u;
	struct bdk_tns_sde_urw3_dbg_txq_rpf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t enqen                       : 1;  /**< R/W - -- */
		uint32_t deqen                       : 1;  /**< R/W - -- */
		uint32_t contenq                     : 1;  /**< R/W - -- */
		uint32_t contdeq                     : 1;  /**< R/W - -- */
#else
		uint32_t contdeq                     : 1;
		uint32_t contenq                     : 1;
		uint32_t deqen                       : 1;
		uint32_t enqen                       : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dbg_txq_rpf_s cn88xx; */
	/* struct bdk_tns_sde_urw3_dbg_txq_rpf_s cn88xxp1; */
} bdk_tns_sde_urw3_dbg_txq_rpf_t;

#define BDK_TNS_SDE_URW3_DBG_TXQ_RPF BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DBG_TXQ_RPF_FUNC(void)
{
	return 0x0000842060580898ull;
}
#define typedef_BDK_TNS_SDE_URW3_DBG_TXQ_RPF bdk_tns_sde_urw3_dbg_txq_rpf_t
#define bustype_BDK_TNS_SDE_URW3_DBG_TXQ_RPF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_DBG_TXQ_RPF 0
#define arguments_BDK_TNS_SDE_URW3_DBG_TXQ_RPF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DBG_TXQ_RPF "TNS_SDE_URW3_DBG_TXQ_RPF"


/**
 * NCB32b - tns_sde_urw3_dyn_dbg_lpathf
 *
 * For debug hooks to Lpath fifo
 *
 */
typedef union bdk_tns_sde_urw3_dyn_dbg_lpathf {
	uint32_t u;
	struct bdk_tns_sde_urw3_dyn_dbg_lpathf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t data                        : 12; /**< R/W/H - -- */
#else
		uint32_t data                        : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dyn_dbg_lpathf_s cn88xx; */
	/* struct bdk_tns_sde_urw3_dyn_dbg_lpathf_s cn88xxp1; */
} bdk_tns_sde_urw3_dyn_dbg_lpathf_t;

#define BDK_TNS_SDE_URW3_DYN_DBG_LPATHF BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_LPATHF_FUNC(void)
{
	return 0x00008420605808A4ull;
}
#define typedef_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF bdk_tns_sde_urw3_dyn_dbg_lpathf_t
#define bustype_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF 0
#define arguments_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DYN_DBG_LPATHF "TNS_SDE_URW3_DYN_DBG_LPATHF"


/**
 * NCB32b - tns_sde_urw3_dyn_dbg_txq_rpf
 *
 * For debug hooks to Lpath fifo
 *
 */
typedef union bdk_tns_sde_urw3_dyn_dbg_txq_rpf {
	uint32_t u;
	struct bdk_tns_sde_urw3_dyn_dbg_txq_rpf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t data                        : 12; /**< R/W/H - -- */
#else
		uint32_t data                        : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_dyn_dbg_txq_rpf_s cn88xx; */
	/* struct bdk_tns_sde_urw3_dyn_dbg_txq_rpf_s cn88xxp1; */
} bdk_tns_sde_urw3_dyn_dbg_txq_rpf_t;

#define BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF_FUNC(void)
{
	return 0x00008420605808A8ull;
}
#define typedef_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF bdk_tns_sde_urw3_dyn_dbg_txq_rpf_t
#define bustype_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF 0
#define arguments_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_DYN_DBG_TXQ_RPF "TNS_SDE_URW3_DYN_DBG_TXQ_RPF"


/**
 * NCB32b - tns_sde_urw3_ecc_ctl_cd
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_ecc_ctl_cd {
	uint32_t u;
	struct bdk_tns_sde_urw3_ecc_ctl_cd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t lpath_fifo                  : 1;  /**< R/W - -- */
		uint32_t resp_fifo                   : 1;  /**< R/W - -- */
		uint32_t se_fifo                     : 16; /**< R/W - -- */
		uint32_t se_lane_mem                 : 8;  /**< R/W - -- */
#else
		uint32_t se_lane_mem                 : 8;
		uint32_t se_fifo                     : 16;
		uint32_t resp_fifo                   : 1;
		uint32_t lpath_fifo                  : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ecc_ctl_cd_s cn88xx; */
	/* struct bdk_tns_sde_urw3_ecc_ctl_cd_s cn88xxp1; */
} bdk_tns_sde_urw3_ecc_ctl_cd_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_CD BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_CD_FUNC(void)
{
	return 0x000084206058083Cull;
}
#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_CD bdk_tns_sde_urw3_ecc_ctl_cd_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_CD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_CD 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_CD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_CD "TNS_SDE_URW3_ECC_CTL_CD"


/**
 * NCB32b - tns_sde_urw3_ecc_ctl_flp_w0
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_ecc_ctl_flp_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t db_se_fifo                  : 16; /**< R/W - -- */
		uint32_t sb_se_lane_mem              : 8;  /**< R/W - -- */
		uint32_t db_se_lane_mem              : 8;  /**< R/W - -- */
#else
		uint32_t db_se_lane_mem              : 8;
		uint32_t sb_se_lane_mem              : 8;
		uint32_t db_se_fifo                  : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_ecc_ctl_flp_w0_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0_FUNC(void)
{
	return 0x0000842060580830ull;
}
#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 bdk_tns_sde_urw3_ecc_ctl_flp_w0_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W0 "TNS_SDE_URW3_ECC_CTL_FLP_W0"


/**
 * NCB32b - tns_sde_urw3_ecc_ctl_flp_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_ECC_CTL_FLP_W0
 *
 */
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_ecc_ctl_flp_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t db_lpath_fifo               : 14; /**< R/W - -- */
		uint32_t sb_resp_fifo                : 1;  /**< R/W - -- */
		uint32_t db_resp_fifo                : 1;  /**< R/W - -- */
		uint32_t sb_se_fifo                  : 16; /**< R/W - -- */
#else
		uint32_t sb_se_fifo                  : 16;
		uint32_t db_resp_fifo                : 1;
		uint32_t sb_resp_fifo                : 1;
		uint32_t db_lpath_fifo               : 14;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_ecc_ctl_flp_w1_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1_FUNC(void)
{
	return 0x0000842060580834ull;
}
#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 bdk_tns_sde_urw3_ecc_ctl_flp_w1_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W1 "TNS_SDE_URW3_ECC_CTL_FLP_W1"


/**
 * NCB32b - tns_sde_urw3_ecc_ctl_flp_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_ECC_CTL_FLP_W0
 *
 */
typedef union bdk_tns_sde_urw3_ecc_ctl_flp_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_ecc_ctl_flp_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t sb_lpath_fifo               : 15; /**< R/W - -- */
		uint32_t db_lpath_fifo               : 1;  /**< R/W - Continuation of MSBs of field DB_LPATH_FIFO from previous word. */
#else
		uint32_t db_lpath_fifo               : 1;
		uint32_t sb_lpath_fifo               : 15;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_ecc_ctl_flp_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_ecc_ctl_flp_w2_t;

#define BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2_FUNC(void)
{
	return 0x0000842060580838ull;
}
#define typedef_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 bdk_tns_sde_urw3_ecc_ctl_flp_w2_t
#define bustype_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 0
#define arguments_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_ECC_CTL_FLP_W2 "TNS_SDE_URW3_ECC_CTL_FLP_W2"


/**
 * NCB32b - tns_sde_urw3_etag
 *
 * Contains enable bits per port and modify etag enable for packet modifications
 * going to etag ports.
 */
typedef union bdk_tns_sde_urw3_etag {
	uint32_t u;
	struct bdk_tns_sde_urw3_etag_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t modify_etag_en              : 1;  /**< R/W - -- */
#else
		uint32_t modify_etag_en              : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_etag_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_etag_s     cn88xxp1; */
} bdk_tns_sde_urw3_etag_t;

#define BDK_TNS_SDE_URW3_ETAG BDK_TNS_SDE_URW3_ETAG_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_ETAG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_ETAG_FUNC(void)
{
	return 0x0000842060580844ull;
}
#define typedef_BDK_TNS_SDE_URW3_ETAG bdk_tns_sde_urw3_etag_t
#define bustype_BDK_TNS_SDE_URW3_ETAG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_ETAG 0
#define arguments_BDK_TNS_SDE_URW3_ETAG -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_ETAG "TNS_SDE_URW3_ETAG"


/**
 * NCB32b - tns_sde_urw3_evif_mreptr_w0
 *
 * Upper 8 bits of Evif are compared with range_lo and range_hi and if they fall
 * within, evif[17:0] AND  mask is treated as MREPTR and original header goes
 * directly to MRE.
 */
typedef union bdk_tns_sde_urw3_evif_mreptr_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_evif_mreptr_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t range_lo                    : 6;  /**< R/W - -- */
		uint32_t range_hi                    : 8;  /**< R/W - -- */
		uint32_t mre_mask                    : 18; /**< R/W - -- */
#else
		uint32_t mre_mask                    : 18;
		uint32_t range_hi                    : 8;
		uint32_t range_lo                    : 6;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_evif_mreptr_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_evif_mreptr_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_evif_mreptr_w0_t;

#define BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W0_FUNC(void)
{
	return 0x000084206058089Cull;
}
#define typedef_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 bdk_tns_sde_urw3_evif_mreptr_w0_t
#define bustype_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 0
#define arguments_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_EVIF_MREPTR_W0 "TNS_SDE_URW3_EVIF_MREPTR_W0"


/**
 * NCB32b - tns_sde_urw3_evif_mreptr_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_EVIF_MREPTR_W0
 *
 */
typedef union bdk_tns_sde_urw3_evif_mreptr_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_evif_mreptr_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t range_lo                    : 2;  /**< R/W - Continuation of MSBs of field RANGE_LO from previous word. */
#else
		uint32_t range_lo                    : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_evif_mreptr_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_evif_mreptr_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_evif_mreptr_w1_t;

#define BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_EVIF_MREPTR_W1_FUNC(void)
{
	return 0x00008420605808A0ull;
}
#define typedef_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 bdk_tns_sde_urw3_evif_mreptr_w1_t
#define bustype_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 0
#define arguments_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_EVIF_MREPTR_W1 "TNS_SDE_URW3_EVIF_MREPTR_W1"


/**
 * NCB - tns_sde_urw3_ins0
 *
 * INS0 Range0_3
 *
 */
typedef union bdk_tns_sde_urw3_ins0 {
	uint64_t u;
	struct bdk_tns_sde_urw3_ins0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t range0_3                    : 40; /**< R/W - -- */
#else
		uint64_t range0_3                    : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ins0_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_ins0_s     cn88xxp1; */
} bdk_tns_sde_urw3_ins0_t;

#define BDK_TNS_SDE_URW3_INS0 BDK_TNS_SDE_URW3_INS0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS0_FUNC(void)
{
	return 0x0000842060580868ull;
}
#define typedef_BDK_TNS_SDE_URW3_INS0 bdk_tns_sde_urw3_ins0_t
#define bustype_BDK_TNS_SDE_URW3_INS0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_INS0 0
#define arguments_BDK_TNS_SDE_URW3_INS0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INS0 "TNS_SDE_URW3_INS0"


/**
 * NCB - tns_sde_urw3_ins1
 *
 * INS0 Range0_3
 *
 */
typedef union bdk_tns_sde_urw3_ins1 {
	uint64_t u;
	struct bdk_tns_sde_urw3_ins1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t range0_3                    : 40; /**< R/W - -- */
#else
		uint64_t range0_3                    : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ins1_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_ins1_s     cn88xxp1; */
} bdk_tns_sde_urw3_ins1_t;

#define BDK_TNS_SDE_URW3_INS1 BDK_TNS_SDE_URW3_INS1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS1_FUNC(void)
{
	return 0x0000842060580870ull;
}
#define typedef_BDK_TNS_SDE_URW3_INS1 bdk_tns_sde_urw3_ins1_t
#define bustype_BDK_TNS_SDE_URW3_INS1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_INS1 0
#define arguments_BDK_TNS_SDE_URW3_INS1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INS1 "TNS_SDE_URW3_INS1"


/**
 * NCB - tns_sde_urw3_ins2
 *
 * INS0 Range0_3
 *
 */
typedef union bdk_tns_sde_urw3_ins2 {
	uint64_t u;
	struct bdk_tns_sde_urw3_ins2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t range0_3                    : 40; /**< R/W - -- */
#else
		uint64_t range0_3                    : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ins2_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_ins2_s     cn88xxp1; */
} bdk_tns_sde_urw3_ins2_t;

#define BDK_TNS_SDE_URW3_INS2 BDK_TNS_SDE_URW3_INS2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS2_FUNC(void)
{
	return 0x0000842060580878ull;
}
#define typedef_BDK_TNS_SDE_URW3_INS2 bdk_tns_sde_urw3_ins2_t
#define bustype_BDK_TNS_SDE_URW3_INS2 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_INS2 0
#define arguments_BDK_TNS_SDE_URW3_INS2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INS2 "TNS_SDE_URW3_INS2"


/**
 * NCB - tns_sde_urw3_ins3
 *
 * INS0 Range0_3
 *
 */
typedef union bdk_tns_sde_urw3_ins3 {
	uint64_t u;
	struct bdk_tns_sde_urw3_ins3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t range0_3                    : 40; /**< R/W - -- */
#else
		uint64_t range0_3                    : 40;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ins3_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_ins3_s     cn88xxp1; */
} bdk_tns_sde_urw3_ins3_t;

#define BDK_TNS_SDE_URW3_INS3 BDK_TNS_SDE_URW3_INS3_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INS3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS3_FUNC(void)
{
	return 0x0000842060580880ull;
}
#define typedef_BDK_TNS_SDE_URW3_INS3 bdk_tns_sde_urw3_ins3_t
#define bustype_BDK_TNS_SDE_URW3_INS3 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_INS3 0
#define arguments_BDK_TNS_SDE_URW3_INS3 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INS3 "TNS_SDE_URW3_INS3"


/**
 * NCB - tns_sde_urw3_ins_fif#
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_ins_fifx {
	uint64_t u;
	struct bdk_tns_sde_urw3_ins_fifx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_ins_fifx_s cn88xx; */
	/* struct bdk_tns_sde_urw3_ins_fifx_s cn88xxp1; */
} bdk_tns_sde_urw3_ins_fifx_t;

static inline uint64_t BDK_TNS_SDE_URW3_INS_FIFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INS_FIFX(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060580700ull + (param1 & 31) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW3_INS_FIFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_INS_FIFX(...) bdk_tns_sde_urw3_ins_fifx_t
#define bustype_BDK_TNS_SDE_URW3_INS_FIFX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_INS_FIFX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_INS_FIFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INS_FIFX(...) "TNS_SDE_URW3_INS_FIFX"


/**
 * NCB32b - tns_sde_urw3_int_en_hi_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw3_int_en_hi_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_hi_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sevif_if_db_err             : 8;  /**< R/W - -- */
		uint32_t sevif_if_sb_err             : 8;  /**< R/W - -- */
		uint32_t se_bad_tid_irq              : 8;  /**< R/W - -- */
		uint32_t seins_bad_tid_irq           : 4;  /**< R/W - -- */
		uint32_t se_vif_timeout              : 1;  /**< R/W - -- */
		uint32_t se_ins_timeout              : 1;  /**< R/W - -- */
		uint32_t txq_timeout                 : 1;  /**< R/W - -- */
		uint32_t seins_resp_mem_miss         : 1;  /**< R/W - -- */
#else
		uint32_t seins_resp_mem_miss         : 1;
		uint32_t txq_timeout                 : 1;
		uint32_t se_ins_timeout              : 1;
		uint32_t se_vif_timeout              : 1;
		uint32_t seins_bad_tid_irq           : 4;
		uint32_t se_bad_tid_irq              : 8;
		uint32_t sevif_if_sb_err             : 8;
		uint32_t sevif_if_db_err             : 8;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_hi_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_hi_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_hi_w0_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W0 BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W0_FUNC(void)
{
	return 0x000084206058080Cull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W0 bdk_tns_sde_urw3_int_en_hi_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W0 "TNS_SDE_URW3_INT_EN_HI_W0"


/**
 * NCB32b - tns_sde_urw3_int_en_hi_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_HI_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_en_hi_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_hi_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t seins_if_db_err             : 16; /**< R/W - -- */
		uint32_t seins_if_sb_err             : 16; /**< R/W - -- */
#else
		uint32_t seins_if_sb_err             : 16;
		uint32_t seins_if_db_err             : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_hi_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_hi_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_hi_w1_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W1 BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W1_FUNC(void)
{
	return 0x0000842060580810ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W1 bdk_tns_sde_urw3_int_en_hi_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W1 "TNS_SDE_URW3_INT_EN_HI_W1"


/**
 * NCB32b - tns_sde_urw3_int_en_hi_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_HI_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_en_hi_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_hi_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tkn_modify_db_err           : 15; /**< R/W - -- */
		uint32_t tkn_modify_sb_err           : 15; /**< R/W - -- */
		uint32_t txq_if_db_err               : 1;  /**< R/W - -- */
		uint32_t txq_if_sb_err               : 1;  /**< R/W - -- */
#else
		uint32_t txq_if_sb_err               : 1;
		uint32_t txq_if_db_err               : 1;
		uint32_t tkn_modify_sb_err           : 15;
		uint32_t tkn_modify_db_err           : 15;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_hi_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_hi_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_hi_w2_t;

#define BDK_TNS_SDE_URW3_INT_EN_HI_W2 BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_HI_W2_FUNC(void)
{
	return 0x0000842060580814ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_HI_W2 bdk_tns_sde_urw3_int_en_hi_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_HI_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_HI_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_HI_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_HI_W2 "TNS_SDE_URW3_INT_EN_HI_W2"


/**
 * NCB32b - tns_sde_urw3_int_en_lo_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw3_int_en_lo_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_lo_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sevif_if_db_err             : 8;  /**< R/W - -- */
		uint32_t sevif_if_sb_err             : 8;  /**< R/W - -- */
		uint32_t se_bad_tid_irq              : 8;  /**< R/W - -- */
		uint32_t seins_bad_tid_irq           : 4;  /**< R/W - -- */
		uint32_t se_vif_timeout              : 1;  /**< R/W - -- */
		uint32_t se_ins_timeout              : 1;  /**< R/W - -- */
		uint32_t txq_timeout                 : 1;  /**< R/W - -- */
		uint32_t seins_resp_mem_miss         : 1;  /**< R/W - -- */
#else
		uint32_t seins_resp_mem_miss         : 1;
		uint32_t txq_timeout                 : 1;
		uint32_t se_ins_timeout              : 1;
		uint32_t se_vif_timeout              : 1;
		uint32_t seins_bad_tid_irq           : 4;
		uint32_t se_bad_tid_irq              : 8;
		uint32_t sevif_if_sb_err             : 8;
		uint32_t sevif_if_db_err             : 8;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_lo_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_lo_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_lo_w0_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W0 BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W0_FUNC(void)
{
	return 0x0000842060580818ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W0 bdk_tns_sde_urw3_int_en_lo_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W0 "TNS_SDE_URW3_INT_EN_LO_W0"


/**
 * NCB32b - tns_sde_urw3_int_en_lo_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_LO_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_en_lo_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_lo_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t seins_if_db_err             : 16; /**< R/W - -- */
		uint32_t seins_if_sb_err             : 16; /**< R/W - -- */
#else
		uint32_t seins_if_sb_err             : 16;
		uint32_t seins_if_db_err             : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_lo_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_lo_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_lo_w1_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W1 BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W1_FUNC(void)
{
	return 0x000084206058081Cull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W1 bdk_tns_sde_urw3_int_en_lo_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W1 "TNS_SDE_URW3_INT_EN_LO_W1"


/**
 * NCB32b - tns_sde_urw3_int_en_lo_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_EN_LO_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_en_lo_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_en_lo_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tkn_modify_db_err           : 15; /**< R/W - -- */
		uint32_t tkn_modify_sb_err           : 15; /**< R/W - -- */
		uint32_t txq_if_db_err               : 1;  /**< R/W - -- */
		uint32_t txq_if_sb_err               : 1;  /**< R/W - -- */
#else
		uint32_t txq_if_sb_err               : 1;
		uint32_t txq_if_db_err               : 1;
		uint32_t tkn_modify_sb_err           : 15;
		uint32_t tkn_modify_db_err           : 15;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_en_lo_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_en_lo_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_int_en_lo_w2_t;

#define BDK_TNS_SDE_URW3_INT_EN_LO_W2 BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_EN_LO_W2_FUNC(void)
{
	return 0x0000842060580820ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_EN_LO_W2 bdk_tns_sde_urw3_int_en_lo_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_EN_LO_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_EN_LO_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_EN_LO_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_EN_LO_W2 "TNS_SDE_URW3_INT_EN_LO_W2"


/**
 * NCB32b - tns_sde_urw3_int_frc_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw3_int_frc_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_frc_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sevif_if_db_err             : 8;  /**< WO - -- */
		uint32_t sevif_if_sb_err             : 8;  /**< WO - -- */
		uint32_t se_bad_tid_irq              : 8;  /**< WO - -- */
		uint32_t seins_bad_tid_irq           : 4;  /**< WO - -- */
		uint32_t se_vif_timeout              : 1;  /**< WO - -- */
		uint32_t se_ins_timeout              : 1;  /**< WO - -- */
		uint32_t txq_timeout                 : 1;  /**< WO - -- */
		uint32_t seins_resp_mem_miss         : 1;  /**< WO - -- */
#else
		uint32_t seins_resp_mem_miss         : 1;
		uint32_t txq_timeout                 : 1;
		uint32_t se_ins_timeout              : 1;
		uint32_t se_vif_timeout              : 1;
		uint32_t seins_bad_tid_irq           : 4;
		uint32_t se_bad_tid_irq              : 8;
		uint32_t sevif_if_sb_err             : 8;
		uint32_t sevif_if_db_err             : 8;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_frc_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_frc_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_int_frc_w0_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W0 BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W0_FUNC(void)
{
	return 0x0000842060580824ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W0 bdk_tns_sde_urw3_int_frc_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W0 "TNS_SDE_URW3_INT_FRC_W0"


/**
 * NCB32b - tns_sde_urw3_int_frc_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_FRC_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_frc_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_frc_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t seins_if_db_err             : 16; /**< WO - -- */
		uint32_t seins_if_sb_err             : 16; /**< WO - -- */
#else
		uint32_t seins_if_sb_err             : 16;
		uint32_t seins_if_db_err             : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_frc_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_frc_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_int_frc_w1_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W1 BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W1_FUNC(void)
{
	return 0x0000842060580828ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W1 bdk_tns_sde_urw3_int_frc_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W1 "TNS_SDE_URW3_INT_FRC_W1"


/**
 * NCB32b - tns_sde_urw3_int_frc_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_FRC_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_frc_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_frc_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tkn_modify_db_err           : 15; /**< WO - -- */
		uint32_t tkn_modify_sb_err           : 15; /**< WO - -- */
		uint32_t txq_if_db_err               : 1;  /**< WO - -- */
		uint32_t txq_if_sb_err               : 1;  /**< WO - -- */
#else
		uint32_t txq_if_sb_err               : 1;
		uint32_t txq_if_db_err               : 1;
		uint32_t tkn_modify_sb_err           : 15;
		uint32_t tkn_modify_db_err           : 15;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_frc_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_frc_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_int_frc_w2_t;

#define BDK_TNS_SDE_URW3_INT_FRC_W2 BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_FRC_W2_FUNC(void)
{
	return 0x000084206058082Cull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_FRC_W2 bdk_tns_sde_urw3_int_frc_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_FRC_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_FRC_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_FRC_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_FRC_W2 "TNS_SDE_URW3_INT_FRC_W2"


/**
 * NCB32b - tns_sde_urw3_int_w1c_w0
 *
 * Channel Interrupt register low priority
 *
 */
typedef union bdk_tns_sde_urw3_int_w1c_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_w1c_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sevif_if_db_err             : 8;  /**< R/W1C/H - -- */
		uint32_t sevif_if_sb_err             : 8;  /**< R/W1C/H - -- */
		uint32_t se_bad_tid_irq              : 8;  /**< R/W1C/H - -- */
		uint32_t seins_bad_tid_irq           : 4;  /**< R/W1C/H - -- */
		uint32_t se_vif_timeout              : 1;  /**< R/W1C/H - -- */
		uint32_t se_ins_timeout              : 1;  /**< R/W1C/H - -- */
		uint32_t txq_timeout                 : 1;  /**< R/W1C/H - -- */
		uint32_t seins_resp_mem_miss         : 1;  /**< R/W1C/H - -- */
#else
		uint32_t seins_resp_mem_miss         : 1;
		uint32_t txq_timeout                 : 1;
		uint32_t se_ins_timeout              : 1;
		uint32_t se_vif_timeout              : 1;
		uint32_t seins_bad_tid_irq           : 4;
		uint32_t se_bad_tid_irq              : 8;
		uint32_t sevif_if_sb_err             : 8;
		uint32_t sevif_if_db_err             : 8;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_w1c_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_w1c_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_int_w1c_w0_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W0 BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W0_FUNC(void)
{
	return 0x0000842060580800ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W0 bdk_tns_sde_urw3_int_w1c_w0_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W0 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W0 "TNS_SDE_URW3_INT_W1C_W0"


/**
 * NCB32b - tns_sde_urw3_int_w1c_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_W1C_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_w1c_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_w1c_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t seins_if_db_err             : 16; /**< R/W1C/H - -- */
		uint32_t seins_if_sb_err             : 16; /**< R/W1C/H - -- */
#else
		uint32_t seins_if_sb_err             : 16;
		uint32_t seins_if_db_err             : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_w1c_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_w1c_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_int_w1c_w1_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W1 BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W1_FUNC(void)
{
	return 0x0000842060580804ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W1 bdk_tns_sde_urw3_int_w1c_w1_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W1 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W1 "TNS_SDE_URW3_INT_W1C_W1"


/**
 * NCB32b - tns_sde_urw3_int_w1c_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_INT_W1C_W0
 *
 */
typedef union bdk_tns_sde_urw3_int_w1c_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_int_w1c_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tkn_modify_db_err           : 15; /**< R/W1C/H - -- */
		uint32_t tkn_modify_sb_err           : 15; /**< R/W1C/H - -- */
		uint32_t txq_if_db_err               : 1;  /**< R/W1C/H - -- */
		uint32_t txq_if_sb_err               : 1;  /**< R/W1C/H - -- */
#else
		uint32_t txq_if_sb_err               : 1;
		uint32_t txq_if_db_err               : 1;
		uint32_t tkn_modify_sb_err           : 15;
		uint32_t tkn_modify_db_err           : 15;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_int_w1c_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_int_w1c_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_int_w1c_w2_t;

#define BDK_TNS_SDE_URW3_INT_W1C_W2 BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_INT_W1C_W2_FUNC(void)
{
	return 0x0000842060580808ull;
}
#define typedef_BDK_TNS_SDE_URW3_INT_W1C_W2 bdk_tns_sde_urw3_int_w1c_w2_t
#define bustype_BDK_TNS_SDE_URW3_INT_W1C_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_INT_W1C_W2 0
#define arguments_BDK_TNS_SDE_URW3_INT_W1C_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_INT_W1C_W2 "TNS_SDE_URW3_INT_W1C_W2"


/**
 * NCB32b - tns_sde_urw3_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_sde_urw3_lock {
	uint32_t u;
	struct bdk_tns_sde_urw3_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_lock_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_lock_s     cn88xxp1; */
} bdk_tns_sde_urw3_lock_t;

#define BDK_TNS_SDE_URW3_LOCK BDK_TNS_SDE_URW3_LOCK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_LOCK_FUNC(void)
{
	return 0x00008420605808B8ull;
}
#define typedef_BDK_TNS_SDE_URW3_LOCK bdk_tns_sde_urw3_lock_t
#define bustype_BDK_TNS_SDE_URW3_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_LOCK 0
#define arguments_BDK_TNS_SDE_URW3_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_LOCK "TNS_SDE_URW3_LOCK"


/**
 * NCB32b - tns_sde_urw3_max_in_flight
 *
 * Controls the max inflight requests.
 *
 */
typedef union bdk_tns_sde_urw3_max_in_flight {
	uint32_t u;
	struct bdk_tns_sde_urw3_max_in_flight_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t vif_req                     : 6;  /**< R/W - -- */
		uint32_t txq_req                     : 6;  /**< R/W - -- */
		uint32_t ins_req                     : 6;  /**< R/W - -- */
		uint32_t vif_flush_en                : 1;  /**< R/W - -- */
		uint32_t ins_flush_en                : 1;  /**< R/W - -- */
#else
		uint32_t ins_flush_en                : 1;
		uint32_t vif_flush_en                : 1;
		uint32_t ins_req                     : 6;
		uint32_t txq_req                     : 6;
		uint32_t vif_req                     : 6;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_max_in_flight_s cn88xx; */
	/* struct bdk_tns_sde_urw3_max_in_flight_s cn88xxp1; */
} bdk_tns_sde_urw3_max_in_flight_t;

#define BDK_TNS_SDE_URW3_MAX_IN_FLIGHT BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_MAX_IN_FLIGHT_FUNC(void)
{
	return 0x000084206058084Cull;
}
#define typedef_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT bdk_tns_sde_urw3_max_in_flight_t
#define bustype_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT 0
#define arguments_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_MAX_IN_FLIGHT "TNS_SDE_URW3_MAX_IN_FLIGHT"


/**
 * NCB32b - tns_sde_urw3_mir_mask
 *
 * This holds masks for Ingress, Egress, evif and ivif Mirror.
 *
 */
typedef union bdk_tns_sde_urw3_mir_mask {
	uint32_t u;
	struct bdk_tns_sde_urw3_mir_mask_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ivif                        : 16; /**< R/W - -- */
		uint32_t evif                        : 16; /**< R/W - -- */
#else
		uint32_t evif                        : 16;
		uint32_t ivif                        : 16;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_mir_mask_s cn88xx; */
	/* struct bdk_tns_sde_urw3_mir_mask_s cn88xxp1; */
} bdk_tns_sde_urw3_mir_mask_t;

#define BDK_TNS_SDE_URW3_MIR_MASK BDK_TNS_SDE_URW3_MIR_MASK_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_MIR_MASK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_MIR_MASK_FUNC(void)
{
	return 0x0000842060580848ull;
}
#define typedef_BDK_TNS_SDE_URW3_MIR_MASK bdk_tns_sde_urw3_mir_mask_t
#define bustype_BDK_TNS_SDE_URW3_MIR_MASK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_MIR_MASK 0
#define arguments_BDK_TNS_SDE_URW3_MIR_MASK -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_MIR_MASK "TNS_SDE_URW3_MIR_MASK"


/**
 * NCB32b - tns_sde_urw3_prt_em_w#
 *
 * This holds port enable for egress mirroring.
 * Bits 31..9 of registers ending in _W4 are unused.
 */
typedef union bdk_tns_sde_urw3_prt_em_wx {
	uint32_t u;
	struct bdk_tns_sde_urw3_prt_em_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t en                          : 32; /**< R/W - -- */
#else
		uint32_t en                          : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_prt_em_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw3_prt_em_wx_s cn88xxp1; */
} bdk_tns_sde_urw3_prt_em_wx_t;

static inline uint64_t BDK_TNS_SDE_URW3_PRT_EM_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_PRT_EM_WX(unsigned long param1)
{
	if (((param1 <= 4)))
		return 0x0000842060580854ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW3_PRT_EM_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_PRT_EM_WX(...) bdk_tns_sde_urw3_prt_em_wx_t
#define bustype_BDK_TNS_SDE_URW3_PRT_EM_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_PRT_EM_WX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_PRT_EM_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_PRT_EM_WX(...) "TNS_SDE_URW3_PRT_EM_WX"


/**
 * NCB32b - tns_sde_urw3_rr
 *
 * Arbitration cfgs to configure the arbiter
 *
 */
typedef union bdk_tns_sde_urw3_rr {
	uint32_t u;
	struct bdk_tns_sde_urw3_rr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t strict_prio                 : 2;  /**< R/W - -- */
		uint32_t wrr_weight0                 : 12; /**< R/W - -- */
		uint32_t wrr_weight1                 : 12; /**< R/W - -- */
#else
		uint32_t wrr_weight1                 : 12;
		uint32_t wrr_weight0                 : 12;
		uint32_t strict_prio                 : 2;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_rr_s       cn88xx; */
	/* struct bdk_tns_sde_urw3_rr_s       cn88xxp1; */
} bdk_tns_sde_urw3_rr_t;

#define BDK_TNS_SDE_URW3_RR BDK_TNS_SDE_URW3_RR_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_RR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_RR_FUNC(void)
{
	return 0x0000842060580890ull;
}
#define typedef_BDK_TNS_SDE_URW3_RR bdk_tns_sde_urw3_rr_t
#define bustype_BDK_TNS_SDE_URW3_RR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_RR 0
#define arguments_BDK_TNS_SDE_URW3_RR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_RR "TNS_SDE_URW3_RR"


/**
 * NCB32b - tns_sde_urw3_se_ins_fif
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_se_ins_fif {
	uint32_t u;
	struct bdk_tns_sde_urw3_se_ins_fif_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t sel                         : 4;  /**< R/W - -- */
#else
		uint32_t sel                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_se_ins_fif_s cn88xx; */
	/* struct bdk_tns_sde_urw3_se_ins_fif_s cn88xxp1; */
} bdk_tns_sde_urw3_se_ins_fif_t;

#define BDK_TNS_SDE_URW3_SE_INS_FIF BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SE_INS_FIF_FUNC(void)
{
	return 0x000084206058088Cull;
}
#define typedef_BDK_TNS_SDE_URW3_SE_INS_FIF bdk_tns_sde_urw3_se_ins_fif_t
#define bustype_BDK_TNS_SDE_URW3_SE_INS_FIF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SE_INS_FIF 0
#define arguments_BDK_TNS_SDE_URW3_SE_INS_FIF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SE_INS_FIF "TNS_SDE_URW3_SE_INS_FIF"


/**
 * NCB32b - tns_sde_urw3_se_vif_fif
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_se_vif_fif {
	uint32_t u;
	struct bdk_tns_sde_urw3_se_vif_fif_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t sel                         : 4;  /**< R/W - -- */
#else
		uint32_t sel                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_se_vif_fif_s cn88xx; */
	/* struct bdk_tns_sde_urw3_se_vif_fif_s cn88xxp1; */
} bdk_tns_sde_urw3_se_vif_fif_t;

#define BDK_TNS_SDE_URW3_SE_VIF_FIF BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SE_VIF_FIF_FUNC(void)
{
	return 0x0000842060580888ull;
}
#define typedef_BDK_TNS_SDE_URW3_SE_VIF_FIF bdk_tns_sde_urw3_se_vif_fif_t
#define bustype_BDK_TNS_SDE_URW3_SE_VIF_FIF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SE_VIF_FIF 0
#define arguments_BDK_TNS_SDE_URW3_SE_VIF_FIF -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SE_VIF_FIF "TNS_SDE_URW3_SE_VIF_FIF"


/**
 * NCB32b - tns_sde_urw3_sein_rp_tbl#_w0
 *
 * Search profile table to gather vif responses.
 * This field tells if the evif response is 32 bit valid. Lower 32-bits of
 * 64-bit se lane should be valid.
 * If this bit is set, then token_id_0_32bit_format should be : 1000_0000
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w0 {
	uint32_t u;
	struct bdk_tns_sde_urw3_sein_rp_tblx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t token_id_0_bit_map          : 2;  /**< R/W - -- */
		uint32_t token_id_1_32bit_format     : 1;  /**< R/W - -- */
		uint32_t token_id_1_bit_map          : 4;  /**< R/W - -- */
		uint32_t token_id_2_32bit_format     : 1;  /**< R/W - -- */
		uint32_t token_id_2_bit_map          : 4;  /**< R/W - -- */
		uint32_t token_id_3_32bit_format     : 1;  /**< R/W - -- */
		uint32_t token_id_3_bit_map          : 4;  /**< R/W - -- */
		uint32_t prf_id                      : 7;  /**< R/W - -- */
		uint32_t prf_id_key                  : 8;  /**< R/W - -- */
#else
		uint32_t prf_id_key                  : 8;
		uint32_t prf_id                      : 7;
		uint32_t token_id_3_bit_map          : 4;
		uint32_t token_id_3_32bit_format     : 1;
		uint32_t token_id_2_bit_map          : 4;
		uint32_t token_id_2_32bit_format     : 1;
		uint32_t token_id_1_bit_map          : 4;
		uint32_t token_id_1_32bit_format     : 1;
		uint32_t token_id_0_bit_map          : 2;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w0_s cn88xx; */
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w0_s cn88xxp1; */
} bdk_tns_sde_urw3_sein_rp_tblx_w0_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(unsigned long param1)
{
	if (((param1 <= 23)))
		return 0x0000842060580200ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(...) bdk_tns_sde_urw3_sein_rp_tblx_w0_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W0(...) "TNS_SDE_URW3_SEIN_RP_TBLX_W0"


/**
 * NCB32b - tns_sde_urw3_sein_rp_tbl#_w1
 *
 * Continuation of structure defined in TNS_SDE_URW3_SEIN_RP_TBL(0..23)_W0
 *
 */
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w1 {
	uint32_t u;
	struct bdk_tns_sde_urw3_sein_rp_tblx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t offset1                     : 5;  /**< R/W - -- */
		uint32_t offset2                     : 12; /**< R/W - -- */
		uint32_t offset3                     : 12; /**< R/W - -- */
		uint32_t token_id_0_32bit_format     : 1;  /**< R/W - -- */
		uint32_t token_id_0_bit_map          : 2;  /**< R/W - Continuation of MSBs of field TOKEN_ID_0_BIT_MAP from previous word. */
#else
		uint32_t token_id_0_bit_map          : 2;
		uint32_t token_id_0_32bit_format     : 1;
		uint32_t offset3                     : 12;
		uint32_t offset2                     : 12;
		uint32_t offset1                     : 5;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w1_s cn88xx; */
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w1_s cn88xxp1; */
} bdk_tns_sde_urw3_sein_rp_tblx_w1_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(unsigned long param1)
{
	if (((param1 <= 23)))
		return 0x0000842060580204ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(...) bdk_tns_sde_urw3_sein_rp_tblx_w1_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W1(...) "TNS_SDE_URW3_SEIN_RP_TBLX_W1"


/**
 * NCB32b - tns_sde_urw3_sein_rp_tbl#_w2
 *
 * Continuation of structure defined in TNS_SDE_URW3_SEIN_RP_TBL(0..23)_W0
 *
 */
typedef union bdk_tns_sde_urw3_sein_rp_tblx_w2 {
	uint32_t u;
	struct bdk_tns_sde_urw3_sein_rp_tblx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t offset0                     : 12; /**< R/W - -- */
		uint32_t offset1                     : 7;  /**< R/W - Continuation of MSBs of field OFFSET1 from previous word. */
#else
		uint32_t offset1                     : 7;
		uint32_t offset0                     : 12;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w2_s cn88xx; */
	/* struct bdk_tns_sde_urw3_sein_rp_tblx_w2_s cn88xxp1; */
} bdk_tns_sde_urw3_sein_rp_tblx_w2_t;

static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(unsigned long param1)
{
	if (((param1 <= 23)))
		return 0x0000842060580208ull + (param1 & 31) * 0x10ull;
	csr_fatal("BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(...) bdk_tns_sde_urw3_sein_rp_tblx_w2_t
#define bustype_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SEIN_RP_TBLX_W2(...) "TNS_SDE_URW3_SEIN_RP_TBLX_W2"


/**
 * NCB32b - tns_sde_urw3_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_sde_urw3_spad {
	uint32_t u;
	struct bdk_tns_sde_urw3_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_spad_s     cn88xx; */
	/* struct bdk_tns_sde_urw3_spad_s     cn88xxp1; */
} bdk_tns_sde_urw3_spad_t;

#define BDK_TNS_SDE_URW3_SPAD BDK_TNS_SDE_URW3_SPAD_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_SPAD_FUNC(void)
{
	return 0x00008420605808BCull;
}
#define typedef_BDK_TNS_SDE_URW3_SPAD bdk_tns_sde_urw3_spad_t
#define bustype_BDK_TNS_SDE_URW3_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_SPAD 0
#define arguments_BDK_TNS_SDE_URW3_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_SPAD "TNS_SDE_URW3_SPAD"


/**
 * NCB32b - tns_sde_urw3_tqif#_w#
 *
 * --
 * Bits[31:14] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_sde_urw3_tqifx_wx {
	uint32_t u;
	struct bdk_tns_sde_urw3_tqifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_tqifx_wx_s cn88xx; */
	/* struct bdk_tns_sde_urw3_tqifx_wx_s cn88xxp1; */
} bdk_tns_sde_urw3_tqifx_wx_t;

static inline uint64_t BDK_TNS_SDE_URW3_TQIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_TQIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 31)) && ((param2 <= 2)))
		return 0x0000842060580000ull + (param1 & 31) * 0x10ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SDE_URW3_TQIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_TQIFX_WX(...) bdk_tns_sde_urw3_tqifx_wx_t
#define bustype_BDK_TNS_SDE_URW3_TQIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_TQIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SDE_URW3_TQIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SDE_URW3_TQIFX_WX(...) "TNS_SDE_URW3_TQIFX_WX"


/**
 * NCB - tns_sde_urw3_vif_fif#
 *
 * --
 *
 */
typedef union bdk_tns_sde_urw3_vif_fifx {
	uint64_t u;
	struct bdk_tns_sde_urw3_vif_fifx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_vif_fifx_s cn88xx; */
	/* struct bdk_tns_sde_urw3_vif_fifx_s cn88xxp1; */
} bdk_tns_sde_urw3_vif_fifx_t;

static inline uint64_t BDK_TNS_SDE_URW3_VIF_FIFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_VIF_FIFX(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842060580600ull + (param1 & 31) * 0x8ull;
	csr_fatal("BDK_TNS_SDE_URW3_VIF_FIFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SDE_URW3_VIF_FIFX(...) bdk_tns_sde_urw3_vif_fifx_t
#define bustype_BDK_TNS_SDE_URW3_VIF_FIFX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SDE_URW3_VIF_FIFX(p1) (p1)
#define arguments_BDK_TNS_SDE_URW3_VIF_FIFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_VIF_FIFX(...) "TNS_SDE_URW3_VIF_FIFX"


/**
 * NCB32b - tns_sde_urw3_wrr
 *
 * Controls the priority of slow path and fast path
 *
 */
typedef union bdk_tns_sde_urw3_wrr {
	uint32_t u;
	struct bdk_tns_sde_urw3_wrr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t weight1                     : 12; /**< R/W - -- */
		uint32_t weight0                     : 12; /**< R/W - -- */
		uint32_t strict_prio                 : 2;  /**< R/W - -- */
#else
		uint32_t strict_prio                 : 2;
		uint32_t weight0                     : 12;
		uint32_t weight1                     : 12;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_sde_urw3_wrr_s      cn88xx; */
	/* struct bdk_tns_sde_urw3_wrr_s      cn88xxp1; */
} bdk_tns_sde_urw3_wrr_t;

#define BDK_TNS_SDE_URW3_WRR BDK_TNS_SDE_URW3_WRR_FUNC()
static inline uint64_t BDK_TNS_SDE_URW3_WRR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SDE_URW3_WRR_FUNC(void)
{
	return 0x0000842060580850ull;
}
#define typedef_BDK_TNS_SDE_URW3_WRR bdk_tns_sde_urw3_wrr_t
#define bustype_BDK_TNS_SDE_URW3_WRR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SDE_URW3_WRR 0
#define arguments_BDK_TNS_SDE_URW3_WRR -1,-1,-1,-1
#define basename_BDK_TNS_SDE_URW3_WRR "TNS_SDE_URW3_WRR"


/**
 * NCB32b - tns_se_age_mem_age_int_en_hi
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_age_int_en_hi {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t mask_sb_err                 : 2;  /**< R/W - -- */
		uint32_t mask_db_err                 : 2;  /**< R/W - -- */
		uint32_t mark_sb_err                 : 2;  /**< R/W - -- */
		uint32_t mark_db_err                 : 2;  /**< R/W - -- */
		uint32_t age_fifo_non_empty          : 1;  /**< R/W - There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
		uint32_t age_fifo_ovfl               : 1;  /**< R/W - Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else
		uint32_t age_fifo_ovfl               : 1;
		uint32_t age_fifo_non_empty          : 1;
		uint32_t mark_db_err                 : 2;
		uint32_t mark_sb_err                 : 2;
		uint32_t mask_db_err                 : 2;
		uint32_t mask_sb_err                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_int_en_hi_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_int_en_hi_s cn88xxp1; */
} bdk_tns_se_age_mem_age_int_en_hi_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI_FUNC(void)
{
	return 0x0000842056010014ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI bdk_tns_se_age_mem_age_int_en_hi_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_HI "TNS_SE_AGE_MEM_AGE_INT_EN_HI"


/**
 * NCB32b - tns_se_age_mem_age_int_en_lo
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_age_int_en_lo {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t mask_sb_err                 : 2;  /**< R/W - -- */
		uint32_t mask_db_err                 : 2;  /**< R/W - -- */
		uint32_t mark_sb_err                 : 2;  /**< R/W - -- */
		uint32_t mark_db_err                 : 2;  /**< R/W - -- */
		uint32_t age_fifo_non_empty          : 1;  /**< R/W - There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
		uint32_t age_fifo_ovfl               : 1;  /**< R/W - Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else
		uint32_t age_fifo_ovfl               : 1;
		uint32_t age_fifo_non_empty          : 1;
		uint32_t mark_db_err                 : 2;
		uint32_t mark_sb_err                 : 2;
		uint32_t mask_db_err                 : 2;
		uint32_t mask_sb_err                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_int_en_lo_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_int_en_lo_s cn88xxp1; */
} bdk_tns_se_age_mem_age_int_en_lo_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO_FUNC(void)
{
	return 0x0000842056010018ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO bdk_tns_se_age_mem_age_int_en_lo_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_EN_LO "TNS_SE_AGE_MEM_AGE_INT_EN_LO"


/**
 * NCB32b - tns_se_age_mem_age_int_frc
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_age_int_frc {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t mask_sb_err                 : 2;  /**< WO - -- */
		uint32_t mask_db_err                 : 2;  /**< WO - -- */
		uint32_t mark_sb_err                 : 2;  /**< WO - -- */
		uint32_t mark_db_err                 : 2;  /**< WO - -- */
		uint32_t age_fifo_non_empty          : 1;  /**< WO - There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
		uint32_t age_fifo_ovfl               : 1;  /**< WO - Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else
		uint32_t age_fifo_ovfl               : 1;
		uint32_t age_fifo_non_empty          : 1;
		uint32_t mark_db_err                 : 2;
		uint32_t mark_sb_err                 : 2;
		uint32_t mask_db_err                 : 2;
		uint32_t mask_sb_err                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_int_frc_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_int_frc_s cn88xxp1; */
} bdk_tns_se_age_mem_age_int_frc_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_FRC BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_FRC_FUNC(void)
{
	return 0x000084205601001Cull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC bdk_tns_se_age_mem_age_int_frc_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_FRC "TNS_SE_AGE_MEM_AGE_INT_FRC"


/**
 * NCB32b - tns_se_age_mem_age_int_w1c
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_age_int_w1c {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t mask_sb_err                 : 2;  /**< R/W1C/H - -- */
		uint32_t mask_db_err                 : 2;  /**< R/W1C/H - -- */
		uint32_t mark_sb_err                 : 2;  /**< R/W1C/H - -- */
		uint32_t mark_db_err                 : 2;  /**< R/W1C/H - -- */
		uint32_t age_fifo_non_empty          : 1;  /**< R/W1C/H - There is a 64-deep FIFO, each entry holding a row of age mark memory.
                                                                 An interrupt generated when the FIFO is non-empty. */
		uint32_t age_fifo_ovfl               : 1;  /**< R/W1C/H - Another interrupt generated when the FIFO occupancy is exceeding configured
                                                                 threshold. */
#else
		uint32_t age_fifo_ovfl               : 1;
		uint32_t age_fifo_non_empty          : 1;
		uint32_t mark_db_err                 : 2;
		uint32_t mark_sb_err                 : 2;
		uint32_t mask_db_err                 : 2;
		uint32_t mask_sb_err                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_int_w1c_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_int_w1c_s cn88xxp1; */
} bdk_tns_se_age_mem_age_int_w1c_t;

#define BDK_TNS_SE_AGE_MEM_AGE_INT_W1C BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_INT_W1C_FUNC(void)
{
	return 0x0000842056010010ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C bdk_tns_se_age_mem_age_int_w1c_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_INT_W1C "TNS_SE_AGE_MEM_AGE_INT_W1C"


/**
 * NCB32b - tns_se_age_mem_age_sta_w0
 *
 * This is a read only status register.
 *
 */
typedef union bdk_tns_se_age_mem_age_sta_w0 {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_sta_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_data                    : 32; /**< R/W/H - A bit of 0 means the corresponding entry has not been hit during past refr
                                                                 cycle. */
#else
		uint32_t row_data                    : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_sta_w0_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_sta_w0_s cn88xxp1; */
} bdk_tns_se_age_mem_age_sta_w0_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W0 BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W0_FUNC(void)
{
	return 0x0000842056010020ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 bdk_tns_se_age_mem_age_sta_w0_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W0 "TNS_SE_AGE_MEM_AGE_STA_W0"


/**
 * NCB32b - tns_se_age_mem_age_sta_w1
 *
 * Continuation of structure defined in TNS_SE_AGE_MEM_AGE_STA_W0
 *
 */
typedef union bdk_tns_se_age_mem_age_sta_w1 {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_sta_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_data                    : 32; /**< R/W/H - Continuation of MSBs of field ROW_DATA from previous word. */
#else
		uint32_t row_data                    : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_sta_w1_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_sta_w1_s cn88xxp1; */
} bdk_tns_se_age_mem_age_sta_w1_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W1 BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W1_FUNC(void)
{
	return 0x0000842056010024ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 bdk_tns_se_age_mem_age_sta_w1_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W1 "TNS_SE_AGE_MEM_AGE_STA_W1"


/**
 * NCB32b - tns_se_age_mem_age_sta_w2
 *
 * Continuation of structure defined in TNS_SE_AGE_MEM_AGE_STA_W0
 *
 */
typedef union bdk_tns_se_age_mem_age_sta_w2 {
	uint32_t u;
	struct bdk_tns_se_age_mem_age_sta_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_23_31              : 9;
		uint32_t refr_done                   : 1;  /**< R/W/H - In triggered mode, done last triggered age referesh if set.
                                                                 In auto mode, currently not in refresh state if set. */
		uint32_t fifo_usage                  : 7;  /**< R/W/H - -- */
		uint32_t mem_offset                  : 15; /**< R/W/H - -- */
#else
		uint32_t mem_offset                  : 15;
		uint32_t fifo_usage                  : 7;
		uint32_t refr_done                   : 1;
		uint32_t reserved_23_31              : 9;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_age_sta_w2_s cn88xx; */
	/* struct bdk_tns_se_age_mem_age_sta_w2_s cn88xxp1; */
} bdk_tns_se_age_mem_age_sta_w2_t;

#define BDK_TNS_SE_AGE_MEM_AGE_STA_W2 BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_AGE_STA_W2_FUNC(void)
{
	return 0x0000842056010028ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 bdk_tns_se_age_mem_age_sta_w2_t
#define bustype_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 0
#define arguments_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_AGE_STA_W2 "TNS_SE_AGE_MEM_AGE_STA_W2"


/**
 * NCB32b - tns_se_age_mem_bist_stdn
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_bist_stdn {
	uint32_t u;
	struct bdk_tns_se_age_mem_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t bist_status                 : 4;  /**< RO/H - -- */
		uint32_t bist_done                   : 4;  /**< RO/H - -- */
#else
		uint32_t bist_done                   : 4;
		uint32_t bist_status                 : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_bist_stdn_s cn88xx; */
	/* struct bdk_tns_se_age_mem_bist_stdn_s cn88xxp1; */
} bdk_tns_se_age_mem_bist_stdn_t;

#define BDK_TNS_SE_AGE_MEM_BIST_STDN BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_BIST_STDN_FUNC(void)
{
	return 0x0000842056010044ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_BIST_STDN bdk_tns_se_age_mem_bist_stdn_t
#define bustype_BDK_TNS_SE_AGE_MEM_BIST_STDN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_BIST_STDN 0
#define arguments_BDK_TNS_SE_AGE_MEM_BIST_STDN -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_BIST_STDN "TNS_SE_AGE_MEM_BIST_STDN"


/**
 * NCB32b - tns_se_age_mem_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_age_mem_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t age_dbg_sel                 : 8;  /**< R/W - -- */
#else
		uint32_t age_dbg_sel                 : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_age_mem_dbg_sel_s cn88xxp1; */
} bdk_tns_se_age_mem_dbg_sel_t;

#define BDK_TNS_SE_AGE_MEM_DBG_SEL BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_DBG_SEL_FUNC(void)
{
	return 0x0000842056010040ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_DBG_SEL bdk_tns_se_age_mem_dbg_sel_t
#define bustype_BDK_TNS_SE_AGE_MEM_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_DBG_SEL 0
#define arguments_BDK_TNS_SE_AGE_MEM_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_DBG_SEL "TNS_SE_AGE_MEM_DBG_SEL"


/**
 * NCB32b - tns_se_age_mem_ecc_ctl
 *
 * ECC configuration for AGE memories
 *
 */
typedef union bdk_tns_se_age_mem_ecc_ctl {
	uint32_t u;
	struct bdk_tns_se_age_mem_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t mask_flip_sb_ecc            : 2;  /**< R/W - -- */
		uint32_t mask_flip_db_ecc            : 2;  /**< R/W - -- */
		uint32_t mask_cor_dis                : 2;  /**< R/W - -- */
		uint32_t mark_flip_sb_ecc            : 2;  /**< R/W - -- */
		uint32_t mark_flip_db_ecc            : 2;  /**< R/W - -- */
		uint32_t mark_cor_dis                : 2;  /**< R/W - -- */
#else
		uint32_t mark_cor_dis                : 2;
		uint32_t mark_flip_db_ecc            : 2;
		uint32_t mark_flip_sb_ecc            : 2;
		uint32_t mask_cor_dis                : 2;
		uint32_t mask_flip_db_ecc            : 2;
		uint32_t mask_flip_sb_ecc            : 2;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_se_age_mem_ecc_ctl_s cn88xxp1; */
} bdk_tns_se_age_mem_ecc_ctl_t;

#define BDK_TNS_SE_AGE_MEM_ECC_CTL BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_ECC_CTL_FUNC(void)
{
	return 0x000084205601002Cull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_ECC_CTL bdk_tns_se_age_mem_ecc_ctl_t
#define bustype_BDK_TNS_SE_AGE_MEM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_ECC_CTL 0
#define arguments_BDK_TNS_SE_AGE_MEM_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_ECC_CTL "TNS_SE_AGE_MEM_ECC_CTL"


/**
 * NCB32b - tns_se_age_mem_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_age_mem_lock {
	uint32_t u;
	struct bdk_tns_se_age_mem_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_lock_s   cn88xx; */
	/* struct bdk_tns_se_age_mem_lock_s   cn88xxp1; */
} bdk_tns_se_age_mem_lock_t;

#define BDK_TNS_SE_AGE_MEM_LOCK BDK_TNS_SE_AGE_MEM_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_LOCK_FUNC(void)
{
	return 0x0000842056010048ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_LOCK bdk_tns_se_age_mem_lock_t
#define bustype_BDK_TNS_SE_AGE_MEM_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_LOCK 0
#define arguments_BDK_TNS_SE_AGE_MEM_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_LOCK "TNS_SE_AGE_MEM_LOCK"


/**
 * NCB - tns_se_age_mem_mark#d#
 *
 * 0.25Mb of memory bits enables age marking for maximum 0.25M table entries. All
 * age marking memory
 * organized into 2 tiles of 64-bit by 2K-row tiles, forming a contiguous
 * address space from 0 to 4K rows.
 */
typedef union bdk_tns_se_age_mem_markxdx {
	uint64_t u;
	struct bdk_tns_se_age_mem_markxdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t age_mark                    : 64; /**< R/W - -- */
#else
		uint64_t age_mark                    : 64;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_markxdx_s cn88xx; */
	/* struct bdk_tns_se_age_mem_markxdx_s cn88xxp1; */
} bdk_tns_se_age_mem_markxdx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MARKXDX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MARKXDX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 2047)))
		return 0x0000842056000000ull + (param1 & 1) * 0x4000ull + (param2 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_SE_AGE_MEM_MARKXDX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_MEM_MARKXDX(...) bdk_tns_se_age_mem_markxdx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MARKXDX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_AGE_MEM_MARKXDX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_AGE_MEM_MARKXDX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_MARKXDX(...) "TNS_SE_AGE_MEM_MARKXDX"


/**
 * NCB - tns_se_age_mem_mask#d#
 *
 * Each age mark bit is associated with an age mask bit to disable aging of the
 * particular entry.
 */
typedef union bdk_tns_se_age_mem_maskxdx {
	uint64_t u;
	struct bdk_tns_se_age_mem_maskxdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t age_mask                    : 64; /**< R/W - -- */
#else
		uint64_t age_mask                    : 64;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_maskxdx_s cn88xx; */
	/* struct bdk_tns_se_age_mem_maskxdx_s cn88xxp1; */
} bdk_tns_se_age_mem_maskxdx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MASKXDX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MASKXDX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 2047)))
		return 0x0000842056008000ull + (param1 & 1) * 0x4000ull + (param2 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_SE_AGE_MEM_MASKXDX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_MEM_MASKXDX(...) bdk_tns_se_age_mem_maskxdx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MASKXDX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_AGE_MEM_MASKXDX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_AGE_MEM_MASKXDX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_MASKXDX(...) "TNS_SE_AGE_MEM_MASKXDX"


/**
 * NCB32b - tns_se_age_mem_mrk_ecc_log#
 *
 * These are read only
 *
 */
typedef union bdk_tns_se_age_mem_mrk_ecc_logx {
	uint32_t u;
	struct bdk_tns_se_age_mem_mrk_ecc_logx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_mrk_ecc_logx_s cn88xx; */
	/* struct bdk_tns_se_age_mem_mrk_ecc_logx_s cn88xxp1; */
} bdk_tns_se_age_mem_mrk_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056010038ull + (param1 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(...) bdk_tns_se_age_mem_mrk_ecc_logx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(p1) (p1)
#define arguments_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_MRK_ECC_LOGX(...) "TNS_SE_AGE_MEM_MRK_ECC_LOGX"


/**
 * NCB32b - tns_se_age_mem_msk_ecc_log#
 *
 * These are read only
 *
 */
typedef union bdk_tns_se_age_mem_msk_ecc_logx {
	uint32_t u;
	struct bdk_tns_se_age_mem_msk_ecc_logx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_msk_ecc_logx_s cn88xx; */
	/* struct bdk_tns_se_age_mem_msk_ecc_logx_s cn88xxp1; */
} bdk_tns_se_age_mem_msk_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056010030ull + (param1 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(...) bdk_tns_se_age_mem_msk_ecc_logx_t
#define bustype_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(p1) (p1)
#define arguments_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_MSK_ECC_LOGX(...) "TNS_SE_AGE_MEM_MSK_ECC_LOGX"


/**
 * NCB - tns_se_age_mem_rfrsh_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_age_mem_rfrsh_w0 {
	uint64_t u;
	struct bdk_tns_se_age_mem_rfrsh_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t trig_cfg_bmp                : 25; /**< R/W - bitmap of age configuration to trigger age refresh, rising edge triggered */
		uint64_t en_pause                    : 1;  /**< R/W - if set, hardware pauses refresh when age fifo occurpancy exceeds configured
                                                                 threshold */
		uint64_t fifo_thd                    : 6;  /**< R/W - fifo usage may overshoot, maximum value ceiled at 6'd56. */
		uint64_t unit_time                   : 32; /**< R/W - Unit of time for agine is number of switch-clock cycle. */
#else
		uint64_t unit_time                   : 32;
		uint64_t fifo_thd                    : 6;
		uint64_t en_pause                    : 1;
		uint64_t trig_cfg_bmp                : 25;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_rfrsh_w0_s cn88xx; */
	/* struct bdk_tns_se_age_mem_rfrsh_w0_s cn88xxp1; */
} bdk_tns_se_age_mem_rfrsh_w0_t;

#define BDK_TNS_SE_AGE_MEM_RFRSH_W0 BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W0_FUNC(void)
{
	return 0x0000842056010000ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_RFRSH_W0 bdk_tns_se_age_mem_rfrsh_w0_t
#define bustype_BDK_TNS_SE_AGE_MEM_RFRSH_W0 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_AGE_MEM_RFRSH_W0 0
#define arguments_BDK_TNS_SE_AGE_MEM_RFRSH_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_RFRSH_W0 "TNS_SE_AGE_MEM_RFRSH_W0"


/**
 * NCB - tns_se_age_mem_rfrsh_w1
 *
 * Continuation of structure defined in TNS_SE_AGE_MEM_RFRSH_W0
 *
 */
typedef union bdk_tns_se_age_mem_rfrsh_w1 {
	uint64_t u;
	struct bdk_tns_se_age_mem_rfrsh_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_40_63              : 24;
		uint64_t mode                        : 1;  /**< R/W - 1: auto refresh
                                                                 0: triggered refresh */
		uint64_t trig_cfg_bmp                : 39; /**< R/W - Continuation of MSBs of field TRIG_CFG_BMP from previous word. */
#else
		uint64_t trig_cfg_bmp                : 39;
		uint64_t mode                        : 1;
		uint64_t reserved_40_63              : 24;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_rfrsh_w1_s cn88xx; */
	/* struct bdk_tns_se_age_mem_rfrsh_w1_s cn88xxp1; */
} bdk_tns_se_age_mem_rfrsh_w1_t;

#define BDK_TNS_SE_AGE_MEM_RFRSH_W1 BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_RFRSH_W1_FUNC(void)
{
	return 0x0000842056010008ull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_RFRSH_W1 bdk_tns_se_age_mem_rfrsh_w1_t
#define bustype_BDK_TNS_SE_AGE_MEM_RFRSH_W1 BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_AGE_MEM_RFRSH_W1 0
#define arguments_BDK_TNS_SE_AGE_MEM_RFRSH_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_RFRSH_W1 "TNS_SE_AGE_MEM_RFRSH_W1"


/**
 * NCB32b - tns_se_age_mem_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_age_mem_spad {
	uint32_t u;
	struct bdk_tns_se_age_mem_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_mem_spad_s   cn88xx; */
	/* struct bdk_tns_se_age_mem_spad_s   cn88xxp1; */
} bdk_tns_se_age_mem_spad_t;

#define BDK_TNS_SE_AGE_MEM_SPAD BDK_TNS_SE_AGE_MEM_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_AGE_MEM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_MEM_SPAD_FUNC(void)
{
	return 0x000084205601004Cull;
}
#define typedef_BDK_TNS_SE_AGE_MEM_SPAD bdk_tns_se_age_mem_spad_t
#define bustype_BDK_TNS_SE_AGE_MEM_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_MEM_SPAD 0
#define arguments_BDK_TNS_SE_AGE_MEM_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_AGE_MEM_SPAD "TNS_SE_AGE_MEM_SPAD"


/**
 * NCB32b - tns_se_age_tbl#_cfg_id#
 *
 * --
 *
 */
typedef union bdk_tns_se_age_tblx_cfg_idx {
	uint32_t u;
	struct bdk_tns_se_age_tblx_cfg_idx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t age_en                      : 1;  /**< R/W - -- */
		uint32_t cfg_id                      : 6;  /**< R/W - Out of the 168 total tables, only 64 table can be age enabled.
                                                                 This ID number points to one of the 64 configration entries for
                                                                 this table. */
#else
		uint32_t cfg_id                      : 6;
		uint32_t age_en                      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_se_age_tblx_cfg_idx_s cn88xx; */
	/* struct bdk_tns_se_age_tblx_cfg_idx_s cn88xxp1; */
} bdk_tns_se_age_tblx_cfg_idx_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_CFG_IDX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_CFG_IDX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 83)))
		return 0x0000842056080000ull + (param1 & 1) * 0x1000ull + (param2 & 127) * 0x4ull;
	csr_fatal("BDK_TNS_SE_AGE_TBLX_CFG_IDX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_TBLX_CFG_IDX(...) bdk_tns_se_age_tblx_cfg_idx_t
#define bustype_BDK_TNS_SE_AGE_TBLX_CFG_IDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_TBLX_CFG_IDX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_AGE_TBLX_CFG_IDX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_AGE_TBLX_CFG_IDX(...) "TNS_SE_AGE_TBLX_CFG_IDX"


/**
 * NCB32b - tns_se_age_tbl#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_age_tblx_lock {
	uint32_t u;
	struct bdk_tns_se_age_tblx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_tblx_lock_s  cn88xx; */
	/* struct bdk_tns_se_age_tblx_lock_s  cn88xxp1; */
} bdk_tns_se_age_tblx_lock_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056080250ull + (param1 & 1) * 0x1000ull;
	csr_fatal("BDK_TNS_SE_AGE_TBLX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_TBLX_LOCK(...) bdk_tns_se_age_tblx_lock_t
#define bustype_BDK_TNS_SE_AGE_TBLX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_TBLX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_AGE_TBLX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_AGE_TBLX_LOCK(...) "TNS_SE_AGE_TBLX_LOCK"


/**
 * NCB32b - tns_se_age_tbl#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_age_tblx_spad {
	uint32_t u;
	struct bdk_tns_se_age_tblx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_age_tblx_spad_s  cn88xx; */
	/* struct bdk_tns_se_age_tblx_spad_s  cn88xxp1; */
} bdk_tns_se_age_tblx_spad_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLX_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056080254ull + (param1 & 1) * 0x1000ull;
	csr_fatal("BDK_TNS_SE_AGE_TBLX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_TBLX_SPAD(...) bdk_tns_se_age_tblx_spad_t
#define bustype_BDK_TNS_SE_AGE_TBLX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_AGE_TBLX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_AGE_TBLX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_AGE_TBLX_SPAD(...) "TNS_SE_AGE_TBLX_SPAD"


/**
 * NCB - tns_se_age_tbl#c#
 *
 * --
 *
 */
typedef union bdk_tns_se_age_tblxcx {
	uint64_t u;
	struct bdk_tns_se_age_tblxcx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_39_63              : 25;
		uint64_t mark_en                     : 1;  /**< R/W - enable age marking for this table */
		uint64_t period_expo                 : 6;  /**< R/W - Aging cycle is 2**period_exp time unit, as defined by
                                                                 xp_se_age_refresh.unit_time */
		uint64_t mem_offset                  : 15; /**< R/W - In unit of 64-bit rows */
		uint64_t mem_row_inc                 : 15; /**< R/W - offset+row_inc is the last age mark memory row for each SRAM pool */
		uint64_t mask_rst_en                 : 1;  /**< R/W - age_mem reset is done at next aging cycle for each table.
                                                                 triggered at rising edge as sampled at start point of each aging
                                                                 cycle. */
		uint64_t mask_rst_val                : 1;  /**< R/W - 1'b1 for enable aging intterupt and 1'b0 for disable. */
#else
		uint64_t mask_rst_val                : 1;
		uint64_t mask_rst_en                 : 1;
		uint64_t mem_row_inc                 : 15;
		uint64_t mem_offset                  : 15;
		uint64_t period_expo                 : 6;
		uint64_t mark_en                     : 1;
		uint64_t reserved_39_63              : 25;
#endif
	} s;
	/* struct bdk_tns_se_age_tblxcx_s     cn88xx; */
	/* struct bdk_tns_se_age_tblxcx_s     cn88xxp1; */
} bdk_tns_se_age_tblxcx_t;

static inline uint64_t BDK_TNS_SE_AGE_TBLXCX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_AGE_TBLXCX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 31)))
		return 0x0000842056080150ull + (param1 & 1) * 0x1000ull + (param2 & 31) * 0x8ull;
	csr_fatal("BDK_TNS_SE_AGE_TBLXCX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_AGE_TBLXCX(...) bdk_tns_se_age_tblxcx_t
#define bustype_BDK_TNS_SE_AGE_TBLXCX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_AGE_TBLXCX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_AGE_TBLXCX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_AGE_TBLXCX(...) "TNS_SE_AGE_TBLXCX"


/**
 * NCB - tns_se_cfg_spare
 *
 * --
 *
 */
typedef union bdk_tns_se_cfg_spare {
	uint64_t u;
	struct bdk_tns_se_cfg_spare_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t xp_se_spare                 : 64; /**< R/W - Spare register with an SE debug signature 0x0FEDCBA987654321 */
#else
		uint64_t xp_se_spare                 : 64;
#endif
	} s;
	/* struct bdk_tns_se_cfg_spare_s      cn88xx; */
	/* struct bdk_tns_se_cfg_spare_s      cn88xxp1; */
} bdk_tns_se_cfg_spare_t;

#define BDK_TNS_SE_CFG_SPARE BDK_TNS_SE_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_SE_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_CFG_SPARE_FUNC(void)
{
	return 0x0000842052200040ull;
}
#define typedef_BDK_TNS_SE_CFG_SPARE bdk_tns_se_cfg_spare_t
#define bustype_BDK_TNS_SE_CFG_SPARE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_CFG_SPARE 0
#define arguments_BDK_TNS_SE_CFG_SPARE -1,-1,-1,-1
#define basename_BDK_TNS_SE_CFG_SPARE "TNS_SE_CFG_SPARE"


/**
 * NCB32b - tns_se_direct_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_direct_lock {
	uint32_t u;
	struct bdk_tns_se_direct_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_direct_lock_s    cn88xx; */
	/* struct bdk_tns_se_direct_lock_s    cn88xxp1; */
} bdk_tns_se_direct_lock_t;

#define BDK_TNS_SE_DIRECT_LOCK BDK_TNS_SE_DIRECT_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_DIRECT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_LOCK_FUNC(void)
{
	return 0x0000842056102100ull;
}
#define typedef_BDK_TNS_SE_DIRECT_LOCK bdk_tns_se_direct_lock_t
#define bustype_BDK_TNS_SE_DIRECT_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_DIRECT_LOCK 0
#define arguments_BDK_TNS_SE_DIRECT_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_DIRECT_LOCK "TNS_SE_DIRECT_LOCK"


/**
 * NCB32b - tns_se_direct_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_direct_spad {
	uint32_t u;
	struct bdk_tns_se_direct_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_direct_spad_s    cn88xx; */
	/* struct bdk_tns_se_direct_spad_s    cn88xxp1; */
} bdk_tns_se_direct_spad_t;

#define BDK_TNS_SE_DIRECT_SPAD BDK_TNS_SE_DIRECT_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_DIRECT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_SPAD_FUNC(void)
{
	return 0x0000842056102104ull;
}
#define typedef_BDK_TNS_SE_DIRECT_SPAD bdk_tns_se_direct_spad_t
#define bustype_BDK_TNS_SE_DIRECT_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_DIRECT_SPAD 0
#define arguments_BDK_TNS_SE_DIRECT_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_DIRECT_SPAD "TNS_SE_DIRECT_SPAD"


/**
 * NCB32b - tns_se_direct_tbl_direct#
 *
 * --
 *
 */
typedef union bdk_tns_se_direct_tbl_directx {
	uint32_t u;
	struct bdk_tns_se_direct_tbl_directx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t data_size                   : 4;  /**< R/W - 0x2: 64-bit
                                                                 0x4: 128-bit
                                                                 0x8: 256-bit */
		uint32_t pool                        : 3;  /**< R/W - Pool ID out of the 8 pools, which this table resides. */
		uint32_t row_blk_inc                 : 6;  /**< R/W - Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
		uint32_t row_blk_start               : 6;  /**< R/W - Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
#else
		uint32_t row_blk_start               : 6;
		uint32_t row_blk_inc                 : 6;
		uint32_t pool                        : 3;
		uint32_t data_size                   : 4;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_se_direct_tbl_directx_s cn88xx; */
	/* struct bdk_tns_se_direct_tbl_directx_s cn88xxp1; */
} bdk_tns_se_direct_tbl_directx_t;

static inline uint64_t BDK_TNS_SE_DIRECT_TBL_DIRECTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_DIRECT_TBL_DIRECTX(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842056102000ull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_SE_DIRECT_TBL_DIRECTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_DIRECT_TBL_DIRECTX(...) bdk_tns_se_direct_tbl_directx_t
#define bustype_BDK_TNS_SE_DIRECT_TBL_DIRECTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_DIRECT_TBL_DIRECTX(p1) (p1)
#define arguments_BDK_TNS_SE_DIRECT_TBL_DIRECTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_DIRECT_TBL_DIRECTX(...) "TNS_SE_DIRECT_TBL_DIRECTX"


/**
 * NCB32b - tns_se_hash_hash_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_hash_hash_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_hash_hash_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t hash_dbg_sel                : 32; /**< R/W - SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else
		uint32_t hash_dbg_sel                : 32;
#endif
	} s;
	/* struct bdk_tns_se_hash_hash_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_hash_hash_dbg_sel_s cn88xxp1; */
} bdk_tns_se_hash_hash_dbg_sel_t;

#define BDK_TNS_SE_HASH_HASH_DBG_SEL BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_HASH_DBG_SEL_FUNC(void)
{
	return 0x0000842056109580ull;
}
#define typedef_BDK_TNS_SE_HASH_HASH_DBG_SEL bdk_tns_se_hash_hash_dbg_sel_t
#define bustype_BDK_TNS_SE_HASH_HASH_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_HASH_DBG_SEL 0
#define arguments_BDK_TNS_SE_HASH_HASH_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_HASH_HASH_DBG_SEL "TNS_SE_HASH_HASH_DBG_SEL"


/**
 * NCB32b - tns_se_hash_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_hash_lock {
	uint32_t u;
	struct bdk_tns_se_hash_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_hash_lock_s      cn88xx; */
	/* struct bdk_tns_se_hash_lock_s      cn88xxp1; */
} bdk_tns_se_hash_lock_t;

#define BDK_TNS_SE_HASH_LOCK BDK_TNS_SE_HASH_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_LOCK_FUNC(void)
{
	return 0x0000842056109584ull;
}
#define typedef_BDK_TNS_SE_HASH_LOCK bdk_tns_se_hash_lock_t
#define bustype_BDK_TNS_SE_HASH_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_LOCK 0
#define arguments_BDK_TNS_SE_HASH_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_HASH_LOCK "TNS_SE_HASH_LOCK"


/**
 * NCB32b - tns_se_hash_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_hash_spad {
	uint32_t u;
	struct bdk_tns_se_hash_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_hash_spad_s      cn88xx; */
	/* struct bdk_tns_se_hash_spad_s      cn88xxp1; */
} bdk_tns_se_hash_spad_t;

#define BDK_TNS_SE_HASH_SPAD BDK_TNS_SE_HASH_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_HASH_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_SPAD_FUNC(void)
{
	return 0x0000842056109588ull;
}
#define typedef_BDK_TNS_SE_HASH_SPAD bdk_tns_se_hash_spad_t
#define bustype_BDK_TNS_SE_HASH_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_SPAD 0
#define arguments_BDK_TNS_SE_HASH_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_HASH_SPAD "TNS_SE_HASH_SPAD"


/**
 * NCB32b - tns_se_hash_tbl_hash#_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_hash_tbl_hashx_w0 {
	uint32_t u;
	struct bdk_tns_se_hash_tbl_hashx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_blk_start_5             : 4;  /**< R/W - -- */
		uint32_t row_blk_start_6             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_7             : 6;  /**< R/W - -- */
		uint32_t hash_func_0                 : 2;  /**< R/W - Each way has a different set of 4 hash functions, choose one of them
                                                                 as hash function for way 0 (4,5,6,7 unused for 4-way hash in xpt) */
		uint32_t hash_func_1                 : 2;  /**< R/W - way 1 */
		uint32_t hash_func_2                 : 2;  /**< R/W - way 2 */
		uint32_t hash_func_3                 : 2;  /**< R/W - way 3 */
		uint32_t hash_func_4                 : 2;  /**< R/W - way 4 */
		uint32_t hash_func_5                 : 2;  /**< R/W - way 5 */
		uint32_t hash_func_6                 : 2;  /**< R/W - way 6 */
		uint32_t hash_func_7                 : 2;  /**< R/W - way 7 */
#else
		uint32_t hash_func_7                 : 2;
		uint32_t hash_func_6                 : 2;
		uint32_t hash_func_5                 : 2;
		uint32_t hash_func_4                 : 2;
		uint32_t hash_func_3                 : 2;
		uint32_t hash_func_2                 : 2;
		uint32_t hash_func_1                 : 2;
		uint32_t hash_func_0                 : 2;
		uint32_t row_blk_start_7             : 6;
		uint32_t row_blk_start_6             : 6;
		uint32_t row_blk_start_5             : 4;
#endif
	} s;
	/* struct bdk_tns_se_hash_tbl_hashx_w0_s cn88xx; */
	/* struct bdk_tns_se_hash_tbl_hashx_w0_s cn88xxp1; */
} bdk_tns_se_hash_tbl_hashx_w0_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W0(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842056109400ull + (param1 & 31) * 0xCull;
	csr_fatal("BDK_TNS_SE_HASH_TBL_HASHX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W0(...) bdk_tns_se_hash_tbl_hashx_w0_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W0(...) "TNS_SE_HASH_TBL_HASHX_W0"


/**
 * NCB32b - tns_se_hash_tbl_hash#_w1
 *
 * Continuation of structure defined in TNS_SE_HASH_TBL_HASH(0..31)_W0
 *
 */
typedef union bdk_tns_se_hash_tbl_hashx_w1 {
	uint32_t u;
	struct bdk_tns_se_hash_tbl_hashx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_blk_start_0             : 6;  /**< R/W - row_blk_start of hash way 0 (4,5,6,7 unused for 4-way hash in xpt). Each bucket
                                                                 is either 256-bit or 512-bit wide. */
		uint32_t row_blk_start_1             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_2             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_3             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_4             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_5             : 2;  /**< R/W - Continuation of MSBs of field ROW_BLK_START_5 from previous word. */
#else
		uint32_t row_blk_start_5             : 2;
		uint32_t row_blk_start_4             : 6;
		uint32_t row_blk_start_3             : 6;
		uint32_t row_blk_start_2             : 6;
		uint32_t row_blk_start_1             : 6;
		uint32_t row_blk_start_0             : 6;
#endif
	} s;
	/* struct bdk_tns_se_hash_tbl_hashx_w1_s cn88xx; */
	/* struct bdk_tns_se_hash_tbl_hashx_w1_s cn88xxp1; */
} bdk_tns_se_hash_tbl_hashx_w1_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W1(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842056109404ull + (param1 & 31) * 0xCull;
	csr_fatal("BDK_TNS_SE_HASH_TBL_HASHX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W1(...) bdk_tns_se_hash_tbl_hashx_w1_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W1(...) "TNS_SE_HASH_TBL_HASHX_W1"


/**
 * NCB32b - tns_se_hash_tbl_hash#_w2
 *
 * Continuation of structure defined in TNS_SE_HASH_TBL_HASH(0..31)_W0
 *
 */
typedef union bdk_tns_se_hash_tbl_hashx_w2 {
	uint32_t u;
	struct bdk_tns_se_hash_tbl_hashx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t key_size                    : 4;  /**< R/W - 32-bit key: 32/96/224-bit data
                                                                 64-bit key: 64/192-bit data
                                                                 72-bit key: 56/184-bit data
                                                                 128-bit key: 128-bit data
                                                                 256-bit key: 256-bit data (have to be dual-tile entry) */
		uint32_t bucket_cnt                  : 4;  /**< R/W - 32-bit key and 32-bit data is 256/64=4-bucket hash
                                                                 128-bit key and 128-bit data is 256/256=1-bucket hash */
		uint32_t way_bmp                     : 8;  /**< R/W - Which WAY(i), any buckt[i] uses pool 0. Valid i=0,1,2,3 */
		uint32_t way_depth                   : 3;  /**< R/W - hash bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
#else
		uint32_t way_depth                   : 3;
		uint32_t way_bmp                     : 8;
		uint32_t bucket_cnt                  : 4;
		uint32_t key_size                    : 4;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_se_hash_tbl_hashx_w2_s cn88xx; */
	/* struct bdk_tns_se_hash_tbl_hashx_w2_s cn88xxp1; */
} bdk_tns_se_hash_tbl_hashx_w2_t;

static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_HASH_TBL_HASHX_W2(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842056109408ull + (param1 & 31) * 0xCull;
	csr_fatal("BDK_TNS_SE_HASH_TBL_HASHX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_HASH_TBL_HASHX_W2(...) bdk_tns_se_hash_tbl_hashx_w2_t
#define bustype_BDK_TNS_SE_HASH_TBL_HASHX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_HASH_TBL_HASHX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_HASH_TBL_HASHX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_HASH_TBL_HASHX_W2(...) "TNS_SE_HASH_TBL_HASHX_W2"


/**
 * NCB32b - tns_se_int_ro_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_int_ro_w0 {
	uint32_t u;
	struct bdk_tns_se_int_ro_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tcam_scrb_db2               : 2;  /**< RO/H - -- */
		uint32_t tcam_scrb_db3               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db4               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db5               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db6               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db7               : 6;  /**< RO/H - -- */
#else
		uint32_t tcam_scrb_db7               : 6;
		uint32_t tcam_scrb_db6               : 6;
		uint32_t tcam_scrb_db5               : 6;
		uint32_t tcam_scrb_db4               : 6;
		uint32_t tcam_scrb_db3               : 6;
		uint32_t tcam_scrb_db2               : 2;
#endif
	} s;
	/* struct bdk_tns_se_int_ro_w0_s      cn88xx; */
	/* struct bdk_tns_se_int_ro_w0_s      cn88xxp1; */
} bdk_tns_se_int_ro_w0_t;

#define BDK_TNS_SE_INT_RO_W0 BDK_TNS_SE_INT_RO_W0_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W0_FUNC(void)
{
	return 0x0000842052201040ull;
}
#define typedef_BDK_TNS_SE_INT_RO_W0 bdk_tns_se_int_ro_w0_t
#define bustype_BDK_TNS_SE_INT_RO_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_INT_RO_W0 0
#define arguments_BDK_TNS_SE_INT_RO_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_INT_RO_W0 "TNS_SE_INT_RO_W0"


/**
 * NCB32b - tns_se_int_ro_w1
 *
 * Continuation of structure defined in TNS_SE_INT_RO_W0
 *
 */
typedef union bdk_tns_se_int_ro_w1 {
	uint32_t u;
	struct bdk_tns_se_int_ro_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t sram_pair                   : 8;  /**< RO/H - -- */
		uint32_t tsram                       : 8;  /**< RO/H - -- */
		uint32_t tcam_scrb_db0               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db1               : 6;  /**< RO/H - -- */
		uint32_t tcam_scrb_db2               : 4;  /**< RO/H - Continuation of MSBs of field TCAM_SCRUB_DB2 from previous word. */
#else
		uint32_t tcam_scrb_db2               : 4;
		uint32_t tcam_scrb_db1               : 6;
		uint32_t tcam_scrb_db0               : 6;
		uint32_t tsram                       : 8;
		uint32_t sram_pair                   : 8;
#endif
	} s;
	/* struct bdk_tns_se_int_ro_w1_s      cn88xx; */
	/* struct bdk_tns_se_int_ro_w1_s      cn88xxp1; */
} bdk_tns_se_int_ro_w1_t;

#define BDK_TNS_SE_INT_RO_W1 BDK_TNS_SE_INT_RO_W1_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W1_FUNC(void)
{
	return 0x0000842052201044ull;
}
#define typedef_BDK_TNS_SE_INT_RO_W1 bdk_tns_se_int_ro_w1_t
#define bustype_BDK_TNS_SE_INT_RO_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_INT_RO_W1 0
#define arguments_BDK_TNS_SE_INT_RO_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_INT_RO_W1 "TNS_SE_INT_RO_W1"


/**
 * NCB32b - tns_se_int_ro_w2
 *
 * Continuation of structure defined in TNS_SE_INT_RO_W0
 *
 */
typedef union bdk_tns_se_int_ro_w2 {
	uint32_t u;
	struct bdk_tns_se_int_ro_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t unused_tmp                  : 29; /**< RO/H - -- */
		uint32_t se0                         : 1;  /**< RO/H - -- */
		uint32_t se1                         : 1;  /**< RO/H - -- */
		uint32_t age                         : 1;  /**< RO/H - -- */
#else
		uint32_t age                         : 1;
		uint32_t se1                         : 1;
		uint32_t se0                         : 1;
		uint32_t unused_tmp                  : 29;
#endif
	} s;
	/* struct bdk_tns_se_int_ro_w2_s      cn88xx; */
	/* struct bdk_tns_se_int_ro_w2_s      cn88xxp1; */
} bdk_tns_se_int_ro_w2_t;

#define BDK_TNS_SE_INT_RO_W2 BDK_TNS_SE_INT_RO_W2_FUNC()
static inline uint64_t BDK_TNS_SE_INT_RO_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_INT_RO_W2_FUNC(void)
{
	return 0x0000842052201048ull;
}
#define typedef_BDK_TNS_SE_INT_RO_W2 bdk_tns_se_int_ro_w2_t
#define bustype_BDK_TNS_SE_INT_RO_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_INT_RO_W2 0
#define arguments_BDK_TNS_SE_INT_RO_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SE_INT_RO_W2 "TNS_SE_INT_RO_W2"


/**
 * NCB32b - tns_se_lde_srch_cmd#_w0
 *
 * Search command configuration, command 4*i through 4*i+3 constitute search
 * profile i.
 * LDE j can request for search profiel j*8 through j*8+7.
 * So, LDE j perform search of profile p, then commdn i looks up search
 * command configuration
 * as j*32+i*8+p
 */
typedef union bdk_tns_se_lde_srch_cmdx_w0 {
	uint32_t u;
	struct bdk_tns_se_lde_srch_cmdx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key_byte_bmp                : 11; /**< R/W - bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 Supported LPM key sizes are 6, 8 or 18 bytes only,
                                                                 if key_size is less than this value, LPM key is MSB aligned,
                                                                 for all other requests, keys are LSB aligned if key specified in
                                                                 search command is
                                                                 less than what specified in the table. */
		uint32_t key_size                    : 6;  /**< R/W - LPM: supported value are 4, 8, 18
                                                                 Hash: supported value are 4, 8, 9, 16, 32
                                                                 TCAM: supported value are: 8, 16, 24, 48 */
		uint32_t ecmp_en                     : 1;  /**< R/W - Enable ECMP, applicable only for LPM search command. */
		uint32_t ecmp_hash_byte_start        : 6;  /**< R/W - ecmp_hash is always 10-bit, occupying 2-byte in the master key,
                                                                 and it is applicable only for LPM search command. */
		uint32_t hash_way_cnt                : 4;  /**< R/W - Applicable only for hash search command. */
		uint32_t adm_id                      : 4;  /**< R/W - Each hash engine admits two command in a cycle, i.e. input port 0 and 1. And
                                                                 each command
                                                                 can potentially go to muliptle engines, so adm_id needs to be
                                                                 eng_id * 2 + input_id
                                                                 For hash command, each search command of each LDE is connected
                                                                 to 4 hash engines
                                                                 Since XPT has only 2 LDEs, to improve BW for average case, map
                                                                 LDE0 to input 0, LDE1 to input 1
                                                                 and map the LDE1 command backwards. Example: LDE0.CMD0 to
                                                                 ENG0.INP0; LDE0.CMD1 to ENG1.INP0,....
                                                                 LDE1.CMD0 to ENG3.INP1, LDE1.CMD1 to ENG2.INP1,....
                                                                 For LPM/direct/TCAM engines, each engine admits one command each
                                                                 cycle only,
                                                                 so adm_id is eng_id *2 (i.e. input_id is always 0)
                                                                 For direct-access table, search command i of each LDE is connected
                                                                 to 1 engine (CMD0 to ENG0, CMD1 to ENG1, etc...),
                                                                 which access SRAM pool.
                                                                 For LPM, all search commands connects to 1 LPM engine only (so
                                                                 adm_id always 0 since only 1 LPM engine).
                                                                 For TCAM, each search command connects to 4 TCAM engines. */
#else
		uint32_t adm_id                      : 4;
		uint32_t hash_way_cnt                : 4;
		uint32_t ecmp_hash_byte_start        : 6;
		uint32_t ecmp_en                     : 1;
		uint32_t key_size                    : 6;
		uint32_t key_byte_bmp                : 11;
#endif
	} s;
	/* struct bdk_tns_se_lde_srch_cmdx_w0_s cn88xx; */
	/* struct bdk_tns_se_lde_srch_cmdx_w0_s cn88xxp1; */
} bdk_tns_se_lde_srch_cmdx_w0_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W0(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842056104000ull + (param1 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDE_SRCH_CMDX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W0(...) bdk_tns_se_lde_srch_cmdx_w0_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W0(...) "TNS_SE_LDE_SRCH_CMDX_W0"


/**
 * NCB32b - tns_se_lde_srch_cmd#_w1
 *
 * Continuation of structure defined in TNS_SE_LDE_SRCH_CMD(0..63)_W0
 *
 */
typedef union bdk_tns_se_lde_srch_cmdx_w1 {
	uint32_t u;
	struct bdk_tns_se_lde_srch_cmdx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key_byte_bmp                : 32; /**< R/W - Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else
		uint32_t key_byte_bmp                : 32;
#endif
	} s;
	/* struct bdk_tns_se_lde_srch_cmdx_w1_s cn88xx; */
	/* struct bdk_tns_se_lde_srch_cmdx_w1_s cn88xxp1; */
} bdk_tns_se_lde_srch_cmdx_w1_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W1(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842056104004ull + (param1 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDE_SRCH_CMDX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W1(...) bdk_tns_se_lde_srch_cmdx_w1_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W1(...) "TNS_SE_LDE_SRCH_CMDX_W1"


/**
 * NCB32b - tns_se_lde_srch_cmd#_w2
 *
 * Continuation of structure defined in TNS_SE_LDE_SRCH_CMD(0..63)_W0
 *
 */
typedef union bdk_tns_se_lde_srch_cmdx_w2 {
	uint32_t u;
	struct bdk_tns_se_lde_srch_cmdx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_25_31              : 7;
		uint32_t lpm_load_balance            : 1;  /**< R/W - XPT has only 1 LPM engine. This should be set to 0 for XPT
                                                                 LPM engines process even numbered prefix tables and odd numbered
                                                                 prefix tables in
                                                                 two consecutive cycles. Set this field SE will automatically
                                                                 admits the LPM
                                                                 command into alternative LPM engines for load balancing. */
		uint32_t table_id                    : 8;  /**< R/W - Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 [0,63] for dire-access table.
                                                                 [64,95] for hash table
                                                                 [96,127] for TCAM table
                                                                 [128,135] for LPM table */
		uint32_t rslt_qw_start               : 5;  /**< R/W - The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive */
		uint32_t rslt_qw_inc                 : 4;  /**< R/W - -- */
		uint32_t regrettable                 : 1;  /**< R/W - a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
		uint32_t age_en                      : 1;  /**< R/W - enable age marking of the entry if hit. */
		uint32_t key_byte_bmp                : 5;  /**< R/W - Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else
		uint32_t key_byte_bmp                : 5;
		uint32_t age_en                      : 1;
		uint32_t regrettable                 : 1;
		uint32_t rslt_qw_inc                 : 4;
		uint32_t rslt_qw_start               : 5;
		uint32_t table_id                    : 8;
		uint32_t lpm_load_balance            : 1;
		uint32_t reserved_25_31              : 7;
#endif
	} s;
	/* struct bdk_tns_se_lde_srch_cmdx_w2_s cn88xx; */
	/* struct bdk_tns_se_lde_srch_cmdx_w2_s cn88xxp1; */
} bdk_tns_se_lde_srch_cmdx_w2_t;

static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDE_SRCH_CMDX_W2(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842056104008ull + (param1 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDE_SRCH_CMDX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDE_SRCH_CMDX_W2(...) bdk_tns_se_lde_srch_cmdx_w2_t
#define bustype_BDK_TNS_SE_LDE_SRCH_CMDX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDE_SRCH_CMDX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_LDE_SRCH_CMDX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDE_SRCH_CMDX_W2(...) "TNS_SE_LDE_SRCH_CMDX_W2"


/**
 * NCB32b - tns_se_ldecmd_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_ldecmd_lock {
	uint32_t u;
	struct bdk_tns_se_ldecmd_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldecmd_lock_s    cn88xx; */
	/* struct bdk_tns_se_ldecmd_lock_s    cn88xxp1; */
} bdk_tns_se_ldecmd_lock_t;

#define BDK_TNS_SE_LDECMD_LOCK BDK_TNS_SE_LDECMD_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LDECMD_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDECMD_LOCK_FUNC(void)
{
	return 0x0000842056104300ull;
}
#define typedef_BDK_TNS_SE_LDECMD_LOCK bdk_tns_se_ldecmd_lock_t
#define bustype_BDK_TNS_SE_LDECMD_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDECMD_LOCK 0
#define arguments_BDK_TNS_SE_LDECMD_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDECMD_LOCK "TNS_SE_LDECMD_LOCK"


/**
 * NCB32b - tns_se_ldecmd_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_ldecmd_spad {
	uint32_t u;
	struct bdk_tns_se_ldecmd_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldecmd_spad_s    cn88xx; */
	/* struct bdk_tns_se_ldecmd_spad_s    cn88xxp1; */
} bdk_tns_se_ldecmd_spad_t;

#define BDK_TNS_SE_LDECMD_SPAD BDK_TNS_SE_LDECMD_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LDECMD_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDECMD_SPAD_FUNC(void)
{
	return 0x0000842056104304ull;
}
#define typedef_BDK_TNS_SE_LDECMD_SPAD bdk_tns_se_ldecmd_spad_t
#define bustype_BDK_TNS_SE_LDECMD_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDECMD_SPAD 0
#define arguments_BDK_TNS_SE_LDECMD_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDECMD_SPAD "TNS_SE_LDECMD_SPAD"


/**
 * NCB32b - tns_se_ldei_cpu_rsl_ln#_w0
 *
 * A CPU search result can return upto 256-bit of data (for a single search
 * command).
 * The whole CPU search profile can return upto 512-bit of control data
 */
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w0 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_rsl_lnx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO/H - Each rslt_lane contains 64-bit control data */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w0_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w0_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_rsl_lnx_w0_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205610906Cull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(...) bdk_tns_se_ldei_cpu_rsl_lnx_w0_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W0(...) "TNS_SE_LDEI_CPU_RSL_LNX_W0"


/**
 * NCB32b - tns_se_ldei_cpu_rsl_ln#_w1
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_RSL_LN(0..7)_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w1 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_rsl_lnx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO/H - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w1_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w1_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_rsl_lnx_w1_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056109070ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(...) bdk_tns_se_ldei_cpu_rsl_lnx_w1_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W1(...) "TNS_SE_LDEI_CPU_RSL_LNX_W1"


/**
 * NCB32b - tns_se_ldei_cpu_rsl_ln#_w2
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_RSL_LN(0..7)_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_rsl_lnx_w2 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_rsl_lnx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t req_id                      : 6;  /**< RO/H - pass-through of req_id */
		uint32_t sorry                       : 1;  /**< RO/H - a regrettable search command may return sorry only. */
		uint32_t hit                         : 1;  /**< RO/H - search command has a hit when set */
		uint32_t hit_addr                    : 22; /**< RO/H - logic table address of the control data. for hash, it is {pool_ID, key_ID,
                                                                 bucket_idx}.
                                                                 where pool_ID is 3-bit, key_ID is up to 3-bit, and bucket_idx is
                                                                 16-bit
                                                                 for LPM/direct-access, it is {pool_ID, address}, where pool_ID is
                                                                 3-bit and address
                                                                 is 19-bit. */
#else
		uint32_t hit_addr                    : 22;
		uint32_t hit                         : 1;
		uint32_t sorry                       : 1;
		uint32_t req_id                      : 6;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w2_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_rsl_lnx_w2_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_rsl_lnx_w2_t;

static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056109074ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(...) bdk_tns_se_ldei_cpu_rsl_lnx_w2_t
#define bustype_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_RSL_LNX_W2(...) "TNS_SE_LDEI_CPU_RSL_LNX_W2"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w0
 *
 * CPU initiated search, it is muxed with LDE0, and result goes to
 * xp_se_cpu_search_rslt_lane's
 * Note that CPU request can only access control data up to 256-bit.
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w0 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 22; /**< R/W - Each of the 4 search command use part or all of the 384-bit input key. */
		uint32_t req_id                      : 6;  /**< R/W - Each request is accompanied with a unique req_id. */
		uint32_t cmd_en                      : 4;  /**< R/W - -- */
#else
		uint32_t cmd_en                      : 4;
		uint32_t req_id                      : 6;
		uint32_t key                         : 22;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w0_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w0_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w0_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0_FUNC(void)
{
	return 0x0000842056109038ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 bdk_tns_se_ldei_cpu_srch_req_w0_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W0 "TNS_SE_LDEI_CPU_SRCH_REQ_W0"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w1
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w1 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w1_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w1_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w1_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1_FUNC(void)
{
	return 0x000084205610903Cull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 bdk_tns_se_ldei_cpu_srch_req_w1_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W1 "TNS_SE_LDEI_CPU_SRCH_REQ_W1"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w10
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w10 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w10_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w10_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w10_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w10_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10_FUNC(void)
{
	return 0x0000842056109060ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 bdk_tns_se_ldei_cpu_srch_req_w10_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W10 "TNS_SE_LDEI_CPU_SRCH_REQ_W10"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w11
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w11 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w11_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w11_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w11_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w11_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11_FUNC(void)
{
	return 0x0000842056109064ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 bdk_tns_se_ldei_cpu_srch_req_w11_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W11 "TNS_SE_LDEI_CPU_SRCH_REQ_W11"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w12
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w12 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w12_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_17_31              : 15;
		uint32_t vld                         : 1;  /**< R/W - Rising edge of vld initiates a cpu seach request */
		uint32_t profile_id                  : 6;  /**< R/W - each profile contains upto 4 search commands. */
		uint32_t key                         : 10; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 10;
		uint32_t profile_id                  : 6;
		uint32_t vld                         : 1;
		uint32_t reserved_17_31              : 15;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w12_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w12_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w12_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12_FUNC(void)
{
	return 0x0000842056109068ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 bdk_tns_se_ldei_cpu_srch_req_w12_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W12 "TNS_SE_LDEI_CPU_SRCH_REQ_W12"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w2
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w2 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w2_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w2_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w2_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2_FUNC(void)
{
	return 0x0000842056109040ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 bdk_tns_se_ldei_cpu_srch_req_w2_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W2 "TNS_SE_LDEI_CPU_SRCH_REQ_W2"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w3
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w3 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w3_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w3_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w3_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3_FUNC(void)
{
	return 0x0000842056109044ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 bdk_tns_se_ldei_cpu_srch_req_w3_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W3 "TNS_SE_LDEI_CPU_SRCH_REQ_W3"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w4
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w4 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w4_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w4_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w4_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4_FUNC(void)
{
	return 0x0000842056109048ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 bdk_tns_se_ldei_cpu_srch_req_w4_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W4 "TNS_SE_LDEI_CPU_SRCH_REQ_W4"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w5
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w5 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w5_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w5_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w5_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5_FUNC(void)
{
	return 0x000084205610904Cull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 bdk_tns_se_ldei_cpu_srch_req_w5_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W5 "TNS_SE_LDEI_CPU_SRCH_REQ_W5"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w6
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w6 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w6_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w6_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w6_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6_FUNC(void)
{
	return 0x0000842056109050ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 bdk_tns_se_ldei_cpu_srch_req_w6_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W6 "TNS_SE_LDEI_CPU_SRCH_REQ_W6"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w7
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w7 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w7_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w7_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w7_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7_FUNC(void)
{
	return 0x0000842056109054ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 bdk_tns_se_ldei_cpu_srch_req_w7_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W7 "TNS_SE_LDEI_CPU_SRCH_REQ_W7"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w8
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w8 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w8_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w8_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w8_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w8_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8_FUNC(void)
{
	return 0x0000842056109058ull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 bdk_tns_se_ldei_cpu_srch_req_w8_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W8 "TNS_SE_LDEI_CPU_SRCH_REQ_W8"


/**
 * NCB32b - tns_se_ldei_cpu_srch_req_w9
 *
 * Continuation of structure defined in TNS_SE_LDEI_CPU_SRCH_REQ_W0
 *
 */
typedef union bdk_tns_se_ldei_cpu_srch_req_w9 {
	uint32_t u;
	struct bdk_tns_se_ldei_cpu_srch_req_w9_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< R/W - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_cpu_srch_req_w9_s cn88xx; */
	/* struct bdk_tns_se_ldei_cpu_srch_req_w9_s cn88xxp1; */
} bdk_tns_se_ldei_cpu_srch_req_w9_t;

#define BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9_FUNC(void)
{
	return 0x000084205610905Cull;
}
#define typedef_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 bdk_tns_se_ldei_cpu_srch_req_w9_t
#define bustype_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 0
#define arguments_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_CPU_SRCH_REQ_W9 "TNS_SE_LDEI_CPU_SRCH_REQ_W9"


/**
 * NCB32b - tns_se_ldei_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_ldei_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_ldei_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t ldeif_dbg_sel               : 32; /**< R/W - SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else
		uint32_t ldeif_dbg_sel               : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_dbg_sel_s   cn88xx; */
	/* struct bdk_tns_se_ldei_dbg_sel_s   cn88xxp1; */
} bdk_tns_se_ldei_dbg_sel_t;

#define BDK_TNS_SE_LDEI_DBG_SEL BDK_TNS_SE_LDEI_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_DBG_SEL_FUNC(void)
{
	return 0x0000842056109004ull;
}
#define typedef_BDK_TNS_SE_LDEI_DBG_SEL bdk_tns_se_ldei_dbg_sel_t
#define bustype_BDK_TNS_SE_LDEI_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_DBG_SEL 0
#define arguments_BDK_TNS_SE_LDEI_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_DBG_SEL "TNS_SE_LDEI_DBG_SEL"


/**
 * NCB32b - tns_se_ldei_hash_buf#
 *
 * SE start popping sorry fore regurettable commands once fill level of buffer
 * before
 * an engine excceds thd. There are 16 hash engines, the 4 engines
 * corresponding to
 * cmd_0 are engine 0-3, those 4 for cmd_1 are 4-7, etc.
 */
typedef union bdk_tns_se_ldei_hash_bufx {
	uint32_t u;
	struct bdk_tns_se_ldei_hash_bufx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t read_ptr                    : 4;  /**< R/W - -- */
		uint32_t sorry_thd                   : 4;  /**< R/W - -- */
#else
		uint32_t sorry_thd                   : 4;
		uint32_t read_ptr                    : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_ldei_hash_bufx_s cn88xx; */
	/* struct bdk_tns_se_ldei_hash_bufx_s cn88xxp1; */
} bdk_tns_se_ldei_hash_bufx_t;

static inline uint64_t BDK_TNS_SE_LDEI_HASH_BUFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_HASH_BUFX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x0000842056109008ull + (param1 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SE_LDEI_HASH_BUFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDEI_HASH_BUFX(...) bdk_tns_se_ldei_hash_bufx_t
#define bustype_BDK_TNS_SE_LDEI_HASH_BUFX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_HASH_BUFX(p1) (p1)
#define arguments_BDK_TNS_SE_LDEI_HASH_BUFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_HASH_BUFX(...) "TNS_SE_LDEI_HASH_BUFX"


/**
 * NCB32b - tns_se_ldei_ldeif_dbg
 *
 * --
 *
 */
typedef union bdk_tns_se_ldei_ldeif_dbg {
	uint32_t u;
	struct bdk_tns_se_ldei_ldeif_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t intf_bypass                 : 9;  /**< R/W - if set, the corresponding interface immediately return miss for all commands */
		uint32_t intf_disable                : 9;  /**< R/W - if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
		uint32_t req_log                     : 4;  /**< R/W - Status register to log last search reuqest from that interface
                                                                 0-11 for LDE 0-11 */
		uint32_t rslt_log                    : 4;  /**< R/W - Status register to log last returned search result from that interface
                                                                 Status can be read from register xp_se_lde_cpu_search_rslt_lane if
                                                                 xp_se_lde_cpu_search_req.vld field s not set */
#else
		uint32_t rslt_log                    : 4;
		uint32_t req_log                     : 4;
		uint32_t intf_disable                : 9;
		uint32_t intf_bypass                 : 9;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_se_ldei_ldeif_dbg_s cn88xx; */
	/* struct bdk_tns_se_ldei_ldeif_dbg_s cn88xxp1; */
} bdk_tns_se_ldei_ldeif_dbg_t;

#define BDK_TNS_SE_LDEI_LDEIF_DBG BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_LDEIF_DBG_FUNC(void)
{
	return 0x0000842056109000ull;
}
#define typedef_BDK_TNS_SE_LDEI_LDEIF_DBG bdk_tns_se_ldei_ldeif_dbg_t
#define bustype_BDK_TNS_SE_LDEI_LDEIF_DBG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_LDEIF_DBG 0
#define arguments_BDK_TNS_SE_LDEI_LDEIF_DBG -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_LDEIF_DBG "TNS_SE_LDEI_LDEIF_DBG"


/**
 * NCB32b - tns_se_ldei_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_ldei_lock {
	uint32_t u;
	struct bdk_tns_se_ldei_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_lock_s      cn88xx; */
	/* struct bdk_tns_se_ldei_lock_s      cn88xxp1; */
} bdk_tns_se_ldei_lock_t;

#define BDK_TNS_SE_LDEI_LOCK BDK_TNS_SE_LDEI_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_LOCK_FUNC(void)
{
	return 0x0000842056109100ull;
}
#define typedef_BDK_TNS_SE_LDEI_LOCK bdk_tns_se_ldei_lock_t
#define bustype_BDK_TNS_SE_LDEI_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_LOCK 0
#define arguments_BDK_TNS_SE_LDEI_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_LOCK "TNS_SE_LDEI_LOCK"


/**
 * NCB32b - tns_se_ldei_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_ldei_spad {
	uint32_t u;
	struct bdk_tns_se_ldei_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_spad_s      cn88xx; */
	/* struct bdk_tns_se_ldei_spad_s      cn88xxp1; */
} bdk_tns_se_ldei_spad_t;

#define BDK_TNS_SE_LDEI_SPAD BDK_TNS_SE_LDEI_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_SPAD_FUNC(void)
{
	return 0x0000842056109104ull;
}
#define typedef_BDK_TNS_SE_LDEI_SPAD bdk_tns_se_ldei_spad_t
#define bustype_BDK_TNS_SE_LDEI_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_SPAD 0
#define arguments_BDK_TNS_SE_LDEI_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_SPAD "TNS_SE_LDEI_SPAD"


/**
 * NCB - tns_se_ldei_sta_hash_buf#
 *
 * --
 *
 */
typedef union bdk_tns_se_ldei_sta_hash_bufx {
	uint64_t u;
	struct bdk_tns_se_ldei_sta_hash_bufx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_37_63              : 27;
		uint64_t intf_id                     : 6;  /**< RO/H - -- */
		uint64_t req_id                      : 6;  /**< RO/H - -- */
		uint64_t cmd_id                      : 2;  /**< RO/H - -- */
		uint64_t rslt_qw_start               : 5;  /**< RO/H - -- */
		uint64_t rslt_qw_inc                 : 4;  /**< RO/H - -- */
		uint64_t table_id                    : 8;  /**< RO/H - -- */
		uint64_t age_en                      : 1;  /**< RO/H - -- */
		uint64_t regrettable                 : 1;  /**< RO/H - -- */
		uint64_t usage                       : 4;  /**< RO/H - -- */
#else
		uint64_t usage                       : 4;
		uint64_t regrettable                 : 1;
		uint64_t age_en                      : 1;
		uint64_t table_id                    : 8;
		uint64_t rslt_qw_inc                 : 4;
		uint64_t rslt_qw_start               : 5;
		uint64_t cmd_id                      : 2;
		uint64_t req_id                      : 6;
		uint64_t intf_id                     : 6;
		uint64_t reserved_37_63              : 27;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_hash_bufx_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_hash_bufx_s cn88xxp1; */
} bdk_tns_se_ldei_sta_hash_bufx_t;

static inline uint64_t BDK_TNS_SE_LDEI_STA_HASH_BUFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_HASH_BUFX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x0000842056109018ull + (param1 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SE_LDEI_STA_HASH_BUFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LDEI_STA_HASH_BUFX(...) bdk_tns_se_ldei_sta_hash_bufx_t
#define bustype_BDK_TNS_SE_LDEI_STA_HASH_BUFX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_LDEI_STA_HASH_BUFX(p1) (p1)
#define arguments_BDK_TNS_SE_LDEI_STA_HASH_BUFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_HASH_BUFX(...) "TNS_SE_LDEI_STA_HASH_BUFX"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w0 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 7;  /**< RO/H - -- */
		uint32_t req_id                      : 6;  /**< RO/H - -- */
		uint32_t unused_tmp                  : 19; /**< RO/H - -- */
#else
		uint32_t unused_tmp                  : 19;
		uint32_t req_id                      : 6;
		uint32_t key                         : 7;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w0_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w0_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w0_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W0_FUNC(void)
{
	return 0x00008420561090CCull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 bdk_tns_se_ldei_sta_req_dbg_w0_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W0 "TNS_SE_LDEI_STA_REQ_DBG_W0"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w1
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w1 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w1_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w1_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w1_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W1_FUNC(void)
{
	return 0x00008420561090D0ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 bdk_tns_se_ldei_sta_req_dbg_w1_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W1 "TNS_SE_LDEI_STA_REQ_DBG_W1"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w10
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w10 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w10_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w10_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w10_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w10_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W10_FUNC(void)
{
	return 0x00008420561090F4ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 bdk_tns_se_ldei_sta_req_dbg_w10_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W10 "TNS_SE_LDEI_STA_REQ_DBG_W10"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w11
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w11 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w11_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w11_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w11_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w11_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W11_FUNC(void)
{
	return 0x00008420561090F8ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 bdk_tns_se_ldei_sta_req_dbg_w11_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W11 "TNS_SE_LDEI_STA_REQ_DBG_W11"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w12
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w12 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w12_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t profile_id                  : 7;  /**< RO/H - -- */
		uint32_t key                         : 25; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 25;
		uint32_t profile_id                  : 7;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w12_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w12_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w12_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W12_FUNC(void)
{
	return 0x00008420561090FCull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 bdk_tns_se_ldei_sta_req_dbg_w12_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W12 "TNS_SE_LDEI_STA_REQ_DBG_W12"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w2
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w2 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w2_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w2_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w2_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W2_FUNC(void)
{
	return 0x00008420561090D4ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 bdk_tns_se_ldei_sta_req_dbg_w2_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W2 "TNS_SE_LDEI_STA_REQ_DBG_W2"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w3
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w3 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w3_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w3_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w3_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W3_FUNC(void)
{
	return 0x00008420561090D8ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 bdk_tns_se_ldei_sta_req_dbg_w3_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W3 "TNS_SE_LDEI_STA_REQ_DBG_W3"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w4
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w4 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w4_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w4_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w4_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W4_FUNC(void)
{
	return 0x00008420561090DCull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 bdk_tns_se_ldei_sta_req_dbg_w4_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W4 "TNS_SE_LDEI_STA_REQ_DBG_W4"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w5
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w5 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w5_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w5_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w5_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W5_FUNC(void)
{
	return 0x00008420561090E0ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 bdk_tns_se_ldei_sta_req_dbg_w5_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W5 "TNS_SE_LDEI_STA_REQ_DBG_W5"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w6
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w6 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w6_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w6_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w6_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W6_FUNC(void)
{
	return 0x00008420561090E4ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 bdk_tns_se_ldei_sta_req_dbg_w6_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W6 "TNS_SE_LDEI_STA_REQ_DBG_W6"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w7
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w7 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w7_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w7_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w7_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W7_FUNC(void)
{
	return 0x00008420561090E8ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 bdk_tns_se_ldei_sta_req_dbg_w7_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W7 "TNS_SE_LDEI_STA_REQ_DBG_W7"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w8
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w8 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w8_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w8_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w8_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w8_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W8_FUNC(void)
{
	return 0x00008420561090ECull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 bdk_tns_se_ldei_sta_req_dbg_w8_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W8 "TNS_SE_LDEI_STA_REQ_DBG_W8"


/**
 * NCB32b - tns_se_ldei_sta_req_dbg_w9
 *
 * Continuation of structure defined in TNS_SE_LDEI_STA_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_ldei_sta_req_dbg_w9 {
	uint32_t u;
	struct bdk_tns_se_ldei_sta_req_dbg_w9_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_ldei_sta_req_dbg_w9_s cn88xx; */
	/* struct bdk_tns_se_ldei_sta_req_dbg_w9_s cn88xxp1; */
} bdk_tns_se_ldei_sta_req_dbg_w9_t;

#define BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC()
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LDEI_STA_REQ_DBG_W9_FUNC(void)
{
	return 0x00008420561090F0ull;
}
#define typedef_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 bdk_tns_se_ldei_sta_req_dbg_w9_t
#define bustype_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 0
#define arguments_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 -1,-1,-1,-1
#define basename_BDK_TNS_SE_LDEI_STA_REQ_DBG_W9 "TNS_SE_LDEI_STA_REQ_DBG_W9"


/**
 * NCB32b - tns_se_lpm_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_lpm_lock {
	uint32_t u;
	struct bdk_tns_se_lpm_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_lpm_lock_s       cn88xx; */
	/* struct bdk_tns_se_lpm_lock_s       cn88xxp1; */
} bdk_tns_se_lpm_lock_t;

#define BDK_TNS_SE_LPM_LOCK BDK_TNS_SE_LPM_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_LOCK_FUNC(void)
{
	return 0x00008420561070E4ull;
}
#define typedef_BDK_TNS_SE_LPM_LOCK bdk_tns_se_lpm_lock_t
#define bustype_BDK_TNS_SE_LPM_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_LOCK 0
#define arguments_BDK_TNS_SE_LPM_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_LPM_LOCK "TNS_SE_LPM_LOCK"


/**
 * NCB32b - tns_se_lpm_lpm_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_lpm_lpm_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_lpm_lpm_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lpm_dbg_sel                 : 32; /**< R/W - SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else
		uint32_t lpm_dbg_sel                 : 32;
#endif
	} s;
	/* struct bdk_tns_se_lpm_lpm_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_lpm_lpm_dbg_sel_s cn88xxp1; */
} bdk_tns_se_lpm_lpm_dbg_sel_t;

#define BDK_TNS_SE_LPM_LPM_DBG_SEL BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_LPM_DBG_SEL_FUNC(void)
{
	return 0x00008420561070E0ull;
}
#define typedef_BDK_TNS_SE_LPM_LPM_DBG_SEL bdk_tns_se_lpm_lpm_dbg_sel_t
#define bustype_BDK_TNS_SE_LPM_LPM_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_LPM_DBG_SEL 0
#define arguments_BDK_TNS_SE_LPM_LPM_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_LPM_LPM_DBG_SEL "TNS_SE_LPM_LPM_DBG_SEL"


/**
 * NCB32b - tns_se_lpm_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_lpm_spad {
	uint32_t u;
	struct bdk_tns_se_lpm_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_lpm_spad_s       cn88xx; */
	/* struct bdk_tns_se_lpm_spad_s       cn88xxp1; */
} bdk_tns_se_lpm_spad_t;

#define BDK_TNS_SE_LPM_SPAD BDK_TNS_SE_LPM_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_LPM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_SPAD_FUNC(void)
{
	return 0x00008420561070E8ull;
}
#define typedef_BDK_TNS_SE_LPM_SPAD bdk_tns_se_lpm_spad_t
#define bustype_BDK_TNS_SE_LPM_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_SPAD 0
#define arguments_BDK_TNS_SE_LPM_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_LPM_SPAD "TNS_SE_LPM_SPAD"


/**
 * NCB32b - tns_se_lpm_tbl_lpm#
 *
 * One LPM table can host a mixture of IPv4 (48-bit key) and IPv6 (144-bit key)
 * addresses.
 * 64-bit keys are also supported.
 */
typedef union bdk_tns_se_lpm_tbl_lpmx {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_lpmx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t prefix_bmp                  : 32; /**< R/W - Which prefix table to use, prefix table 0..31 always resides in pool 0 (only 1
                                                                 pool), */
#else
		uint32_t prefix_bmp                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_lpmx_s   cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_lpmx_s   cn88xxp1; */
} bdk_tns_se_lpm_tbl_lpmx_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_LPMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_LPMX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107000ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_LPMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_LPMX(...) bdk_tns_se_lpm_tbl_lpmx_t
#define bustype_BDK_TNS_SE_LPM_TBL_LPMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_LPMX(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_LPMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_LPMX(...) "TNS_SE_LPM_TBL_LPMX"


/**
 * NCB32b - tns_se_lpm_tbl_nh#_w0
 *
 * NH table i is associated with LPM table i.
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhx_w0 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_blk_start_2             : 1;  /**< R/W - -- */
		uint32_t row_blk_start_3             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_4             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_5             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_6             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_7             : 6;  /**< R/W - -- */
		uint32_t return_nh_addr              : 1;  /**< R/W - If set, use NH_addr as hit_addr return
                                                                 Otherwise, use NHI_addr as hit_addr return */
#else
		uint32_t return_nh_addr              : 1;
		uint32_t row_blk_start_7             : 6;
		uint32_t row_blk_start_6             : 6;
		uint32_t row_blk_start_5             : 6;
		uint32_t row_blk_start_4             : 6;
		uint32_t row_blk_start_3             : 6;
		uint32_t row_blk_start_2             : 1;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhx_w0_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhx_w0_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhx_w0_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W0(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107080ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W0(...) bdk_tns_se_lpm_tbl_nhx_w0_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W0(...) "TNS_SE_LPM_TBL_NHX_W0"


/**
 * NCB32b - tns_se_lpm_tbl_nh#_w1
 *
 * Continuation of structure defined in TNS_SE_LPM_TBL_NH(0..7)_W0
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhx_w1 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data_size                   : 1;  /**< R/W - in unit of 32-bit double word. */
		uint32_t pool_bmp                    : 8;  /**< R/W - NH table spreads across multiple SRAM pools */
		uint32_t row_blk_inc                 : 6;  /**< R/W - The entire NHI table can be equally divided among multiple pools.
                                                                 row_blk_inc can only be 2**i-1, i.e 0, 1, 3, 7, 15, 31, 63, */
		uint32_t row_blk_start_0             : 6;  /**< R/W - Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
		uint32_t row_blk_start_1             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_2             : 5;  /**< R/W - Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
#else
		uint32_t row_blk_start_2             : 5;
		uint32_t row_blk_start_1             : 6;
		uint32_t row_blk_start_0             : 6;
		uint32_t row_blk_inc                 : 6;
		uint32_t pool_bmp                    : 8;
		uint32_t data_size                   : 1;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhx_w1_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhx_w1_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhx_w1_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W1(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107084ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W1(...) bdk_tns_se_lpm_tbl_nhx_w1_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W1(...) "TNS_SE_LPM_TBL_NHX_W1"


/**
 * NCB32b - tns_se_lpm_tbl_nh#_w2
 *
 * Continuation of structure defined in TNS_SE_LPM_TBL_NH(0..7)_W0
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhx_w2 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t data_size                   : 3;  /**< R/W - Continuation of MSBs of field DATA_SIZE from previous word. */
#else
		uint32_t data_size                   : 3;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhx_w2_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhx_w2_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhx_w2_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHX_W2(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107088ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHX_W2(...) bdk_tns_se_lpm_tbl_nhx_w2_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHX_W2(...) "TNS_SE_LPM_TBL_NHX_W2"


/**
 * NCB32b - tns_se_lpm_tbl_nhi#_w0
 *
 * NHI table i is associated with LPM table i, nhi table is alwasy 128-bit wide
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhix_w0 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhix_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_blk_start_2             : 2;  /**< R/W - -- */
		uint32_t row_blk_start_3             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_4             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_5             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_6             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_7             : 6;  /**< R/W - -- */
#else
		uint32_t row_blk_start_7             : 6;
		uint32_t row_blk_start_6             : 6;
		uint32_t row_blk_start_5             : 6;
		uint32_t row_blk_start_4             : 6;
		uint32_t row_blk_start_3             : 6;
		uint32_t row_blk_start_2             : 2;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhix_w0_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhix_w0_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhix_w0_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W0(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107020ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHIX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W0(...) bdk_tns_se_lpm_tbl_nhix_w0_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W0(...) "TNS_SE_LPM_TBL_NHIX_W0"


/**
 * NCB32b - tns_se_lpm_tbl_nhi#_w1
 *
 * Continuation of structure defined in TNS_SE_LPM_TBL_NHI(0..7)_W0
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhix_w1 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhix_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t nhi_size                    : 2;  /**< R/W - Width of NH_blk_base, allowable: 10, 12, 14, 16, 18, 20 */
		uint32_t pool_bmp                    : 8;  /**< R/W - NHI table spreads across multiple SRAM pools */
		uint32_t row_blk_inc                 : 6;  /**< R/W - The entire NHI table can be equally divided among multiple pools, each pool
                                                                 with number
                                                                 of row blocks begin power of 2, i.e.  row_blk_inc can only be 0, 1,
                                                                 3, 7, 15, 31, 63. */
		uint32_t row_blk_start_0             : 6;  /**< R/W - row_blk_start point for SRAM pool 0 */
		uint32_t row_blk_start_1             : 6;  /**< R/W - -- */
		uint32_t row_blk_start_2             : 4;  /**< R/W - Continuation of MSBs of field ROW_BLK_START_2 from previous word. */
#else
		uint32_t row_blk_start_2             : 4;
		uint32_t row_blk_start_1             : 6;
		uint32_t row_blk_start_0             : 6;
		uint32_t row_blk_inc                 : 6;
		uint32_t pool_bmp                    : 8;
		uint32_t nhi_size                    : 2;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhix_w1_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhix_w1_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhix_w1_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W1(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107024ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHIX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W1(...) bdk_tns_se_lpm_tbl_nhix_w1_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W1(...) "TNS_SE_LPM_TBL_NHIX_W1"


/**
 * NCB32b - tns_se_lpm_tbl_nhi#_w2
 *
 * Continuation of structure defined in TNS_SE_LPM_TBL_NHI(0..7)_W0
 *
 */
typedef union bdk_tns_se_lpm_tbl_nhix_w2 {
	uint32_t u;
	struct bdk_tns_se_lpm_tbl_nhix_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t pair_per_entry              : 4;  /**< R/W - A NHI table is always 128-bit wide, each entry contains multple pairs of
                                                                 {NH_blk_size,NH_blk_base}
                                                                 allowed value: 10, 8, 7, 6, correspondingly, a NHI pair is 12-bit,
                                                                 16-bit, 18-bit or 21-bit
                                                                 maximum allowed path for ECMP is 512, i.e. only 8 LSB of
                                                                 NH_blk_size is valid. */
		uint32_t nhi_size                    : 3;  /**< R/W - Continuation of MSBs of field NHI_SIZE from previous word. */
#else
		uint32_t nhi_size                    : 3;
		uint32_t pair_per_entry              : 4;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_se_lpm_tbl_nhix_w2_s cn88xx; */
	/* struct bdk_tns_se_lpm_tbl_nhix_w2_s cn88xxp1; */
} bdk_tns_se_lpm_tbl_nhix_w2_t;

static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_LPM_TBL_NHIX_W2(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056107028ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_LPM_TBL_NHIX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_LPM_TBL_NHIX_W2(...) bdk_tns_se_lpm_tbl_nhix_w2_t
#define bustype_BDK_TNS_SE_LPM_TBL_NHIX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_LPM_TBL_NHIX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_LPM_TBL_NHIX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_LPM_TBL_NHIX_W2(...) "TNS_SE_LPM_TBL_NHIX_W2"


/**
 * NCB32b - tns_se_prfx_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_prfx_lock {
	uint32_t u;
	struct bdk_tns_se_prfx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_prfx_lock_s      cn88xx; */
	/* struct bdk_tns_se_prfx_lock_s      cn88xxp1; */
} bdk_tns_se_prfx_lock_t;

#define BDK_TNS_SE_PRFX_LOCK BDK_TNS_SE_PRFX_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_PRFX_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_LOCK_FUNC(void)
{
	return 0x0000842056108200ull;
}
#define typedef_BDK_TNS_SE_PRFX_LOCK bdk_tns_se_prfx_lock_t
#define bustype_BDK_TNS_SE_PRFX_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_PRFX_LOCK 0
#define arguments_BDK_TNS_SE_PRFX_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_PRFX_LOCK "TNS_SE_PRFX_LOCK"


/**
 * NCB32b - tns_se_prfx_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_prfx_spad {
	uint32_t u;
	struct bdk_tns_se_prfx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_prfx_spad_s      cn88xx; */
	/* struct bdk_tns_se_prfx_spad_s      cn88xxp1; */
} bdk_tns_se_prfx_spad_t;

#define BDK_TNS_SE_PRFX_SPAD BDK_TNS_SE_PRFX_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_PRFX_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_SPAD_FUNC(void)
{
	return 0x0000842056108204ull;
}
#define typedef_BDK_TNS_SE_PRFX_SPAD bdk_tns_se_prfx_spad_t
#define bustype_BDK_TNS_SE_PRFX_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_PRFX_SPAD 0
#define arguments_BDK_TNS_SE_PRFX_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_PRFX_SPAD "TNS_SE_PRFX_SPAD"


/**
 * NCB32b - tns_se_prfx_tbl_prefix#
 *
 * prefix table 32*i through 32*i+31 are associated with LPM table i.
 * Within the 32 prefix tables, all go to SRAM pool 0 (only one pool)
 */
typedef union bdk_tns_se_prfx_tbl_prefixx {
	uint32_t u;
	struct bdk_tns_se_prfx_tbl_prefixx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_23_31              : 9;
		uint32_t entry_size                  : 4;  /**< R/W - 0x4: 128-bit
                                                                 0x8: 256-bit */
		uint32_t tread                       : 8;  /**< R/W - Number of MSB bits to hash from */
		uint32_t way_depth                   : 3;  /**< R/W - prefix bucket depths is 2^(10+way_depth), up to 32K-entries,
                                                                 so way_depth is ceiled at 3'd5. */
		uint32_t hash_func                   : 2;  /**< R/W - Each prefix table has a different set of 4 hash functions,
                                                                 choose one of them as hash function of this prefix table. */
		uint32_t row_blk_start               : 6;  /**< R/W - row_blk_start of prefix table. Each prefix table is either 128-bit or 256-bit
                                                                 wide */
#else
		uint32_t row_blk_start               : 6;
		uint32_t hash_func                   : 2;
		uint32_t way_depth                   : 3;
		uint32_t tread                       : 8;
		uint32_t entry_size                  : 4;
		uint32_t reserved_23_31              : 9;
#endif
	} s;
	/* struct bdk_tns_se_prfx_tbl_prefixx_s cn88xx; */
	/* struct bdk_tns_se_prfx_tbl_prefixx_s cn88xxp1; */
} bdk_tns_se_prfx_tbl_prefixx_t;

static inline uint64_t BDK_TNS_SE_PRFX_TBL_PREFIXX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_PRFX_TBL_PREFIXX(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842056108000ull + (param1 & 127) * 0x4ull;
	csr_fatal("BDK_TNS_SE_PRFX_TBL_PREFIXX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_PRFX_TBL_PREFIXX(...) bdk_tns_se_prfx_tbl_prefixx_t
#define bustype_BDK_TNS_SE_PRFX_TBL_PREFIXX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_PRFX_TBL_PREFIXX(p1) (p1)
#define arguments_BDK_TNS_SE_PRFX_TBL_PREFIXX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_PRFX_TBL_PREFIXX(...) "TNS_SE_PRFX_TBL_PREFIXX"


/**
 * NCB32b - tns_se_sram_pair#_bist_stdn
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_bist_stdn {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t bist_status                 : 4;  /**< RO/H - -- */
		uint32_t bist_done                   : 4;  /**< RO/H - -- */
#else
		uint32_t bist_done                   : 4;
		uint32_t bist_status                 : 4;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_bist_stdn_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_bist_stdn_s cn88xxp1; */
} bdk_tns_se_sram_pairx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x00008420540200F8ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_BIST_STDN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(...) bdk_tns_se_sram_pairx_bist_stdn_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_BIST_STDN(...) "TNS_SE_SRAM_PAIRX_BIST_STDN"


/**
 * NCB32b - tns_se_sram_pair#_dbg_sel
 *
 * Debug select
 *
 */
typedef union bdk_tns_se_sram_pairx_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t sram_pair_dbg_sel           : 8;  /**< R/W - -- */
#else
		uint32_t sram_pair_dbg_sel           : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_dbg_sel_s cn88xxp1; */
} bdk_tns_se_sram_pairx_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020054ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DBG_SEL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(...) bdk_tns_se_sram_pairx_dbg_sel_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DBG_SEL(...) "TNS_SE_SRAM_PAIRX_DBG_SEL"


/**
 * NCB32b - tns_se_sram_pair#_dhsh#_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_dhshx_w0 {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_dhshx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t hash_err_cmd_id_0           : 2;  /**< RO/H - -- */
		uint32_t hash_err_table_id_0         : 8;  /**< RO/H - -- */
		uint32_t hash_err_intf_id_1          : 6;  /**< RO/H - -- */
		uint32_t hash_err_req_id_1           : 6;  /**< RO/H - -- */
		uint32_t hash_err_cmd_id_1           : 2;  /**< RO/H - -- */
		uint32_t hash_err_table_id_1         : 8;  /**< RO/H - -- */
#else
		uint32_t hash_err_table_id_1         : 8;
		uint32_t hash_err_cmd_id_1           : 2;
		uint32_t hash_err_req_id_1           : 6;
		uint32_t hash_err_intf_id_1          : 6;
		uint32_t hash_err_table_id_0         : 8;
		uint32_t hash_err_cmd_id_0           : 2;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_dhshx_w0_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_dhshx_w0_s cn88xxp1; */
} bdk_tns_se_sram_pairx_dhshx_w0_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020020ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0xCull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(...) bdk_tns_se_sram_pairx_dhshx_w0_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W0(...) "TNS_SE_SRAM_PAIRX_DHSHX_W0"


/**
 * NCB32b - tns_se_sram_pair#_dhsh#_w1
 *
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_DHSH(0..1)_W0
 *
 */
typedef union bdk_tns_se_sram_pairx_dhshx_w1 {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_dhshx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t hash_hang_intf_id           : 3;  /**< RO/H - -- */
		uint32_t hash_hang_req_id            : 6;  /**< RO/H - -- */
		uint32_t hash_hang_cmd_id            : 2;  /**< RO/H - -- */
		uint32_t hash_hang_table_id          : 8;  /**< RO/H - -- */
		uint32_t dual_tile_hash_err          : 1;  /**< RO/H - same as interrupt register definition, and it is sticky status as well */
		uint32_t hash_err_intf_id_0          : 6;  /**< RO/H - -- */
		uint32_t hash_err_req_id_0           : 6;  /**< RO/H - -- */
#else
		uint32_t hash_err_req_id_0           : 6;
		uint32_t hash_err_intf_id_0          : 6;
		uint32_t dual_tile_hash_err          : 1;
		uint32_t hash_hang_table_id          : 8;
		uint32_t hash_hang_cmd_id            : 2;
		uint32_t hash_hang_req_id            : 6;
		uint32_t hash_hang_intf_id           : 3;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_dhshx_w1_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_dhshx_w1_s cn88xxp1; */
} bdk_tns_se_sram_pairx_dhshx_w1_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020024ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0xCull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(...) bdk_tns_se_sram_pairx_dhshx_w1_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W1(...) "TNS_SE_SRAM_PAIRX_DHSHX_W1"


/**
 * NCB32b - tns_se_sram_pair#_dhsh#_w2
 *
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_DHSH(0..1)_W0
 *
 */
typedef union bdk_tns_se_sram_pairx_dhshx_w2 {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_dhshx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t dual_tile_hash_hang         : 2;  /**< RO/H - same as interrupt register definition, just it is non-sticky status */
		uint32_t hash_hang_intf_id           : 3;  /**< RO/H - Continuation of MSBs of field HASH_HANG_INTF_ID from previous word. */
#else
		uint32_t hash_hang_intf_id           : 3;
		uint32_t dual_tile_hash_hang         : 2;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_dhshx_w2_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_dhshx_w2_s cn88xxp1; */
} bdk_tns_se_sram_pairx_dhshx_w2_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020028ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0xCull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(...) bdk_tns_se_sram_pairx_dhshx_w2_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DHSHX_W2(...) "TNS_SE_SRAM_PAIRX_DHSHX_W2"


/**
 * NCB32b - tns_se_sram_pair#_done
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_done {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_done_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t flush_done                  : 1;  /**< RO/H - -- */
		uint32_t tile_rst_done               : 2;  /**< RO/H - -- */
		uint32_t mem_ready                   : 2;  /**< RO/H - memory ready, per tile */
#else
		uint32_t mem_ready                   : 2;
		uint32_t tile_rst_done               : 2;
		uint32_t flush_done                  : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_done_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_done_s cn88xxp1; */
} bdk_tns_se_sram_pairx_done_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DONE(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DONE(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020038ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DONE", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DONE(...) bdk_tns_se_sram_pairx_done_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DONE(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DONE(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DONE(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DONE(...) "TNS_SE_SRAM_PAIRX_DONE"


/**
 * NCB32b - tns_se_sram_pair#_dyn_dbg_w#
 *
 * No memoir memory in XPT. This register will return 0x0
 * Bits 31..8 of registers ending in _W2 are unused.
 */
typedef union bdk_tns_se_sram_pairx_dyn_dbg_wx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_dyn_dbg_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W/H - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_dyn_dbg_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_dyn_dbg_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_dyn_dbg_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 2)))
		return 0x000084205402005Cull + (param1 & 7) * 0x400000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(...) bdk_tns_se_sram_pairx_dyn_dbg_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_DYN_DBG_WX(...) "TNS_SE_SRAM_PAIRX_DYN_DBG_WX"


/**
 * NCB32b - tns_se_sram_pair#_ecc_ctl#
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_ecc_ctlx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_ecc_ctlx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t flip_db_ecc                 : 2;  /**< R/W - Flip 2 bits of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
		uint32_t flip_sb_ecc                 : 2;  /**< R/W - Flip 1 bit  of ECC syndrome in SRAM memory pair tiles. It's built out of 2
                                                                 memory tiles of 138 bits wide */
		uint32_t cor_dis                     : 1;  /**< R/W - Disable ECC correction for TCAM SRAM memory */
#else
		uint32_t cor_dis                     : 1;
		uint32_t flip_sb_ecc                 : 2;
		uint32_t flip_db_ecc                 : 2;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_ecc_ctlx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_ecc_ctlx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_ecc_ctlx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x000084205402004Cull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(...) bdk_tns_se_sram_pairx_ecc_ctlx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_ECC_CTLX(...) "TNS_SE_SRAM_PAIRX_ECC_CTLX"


/**
 * NCB32b - tns_se_sram_pair#_ecc_err#
 *
 * These are read only
 * Address is sticky on first error.  Re-armed after reading (of 4 registers
 * 1 and 3 not used. 0 is for sram_tile0, 2 is sram_tile1)
 */
typedef union bdk_tns_se_sram_pairx_ecc_errx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_ecc_errx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t sb_err                      : 2;  /**< R/W/H - single-bit memory error (logical tile = 2 physical tiles) */
		uint32_t db_err                      : 2;  /**< R/W/H - -- */
		uint32_t paddr                       : 15; /**< R/W/H - -- */
#else
		uint32_t paddr                       : 15;
		uint32_t db_err                      : 2;
		uint32_t sb_err                      : 2;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_ecc_errx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_ecc_errx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_ecc_errx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 3)))
		return 0x000084205402003Cull + (param1 & 7) * 0x400000ull + (param2 & 3) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(...) bdk_tns_se_sram_pairx_ecc_errx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_ECC_ERRX(...) "TNS_SE_SRAM_PAIRX_ECC_ERRX"


/**
 * NCB32b - tns_se_sram_pair#_flsh_mm_w#
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_mm_wx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_mm_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t val                         : 32; /**< R/W - if (entry & match_mask == match_pattern) then:
                                                                 entry = (entry & subst_mask) | (entry_pattern & ~subst_mask) */
#else
		uint32_t val                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_mm_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_mm_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_mm_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 7)))
		return 0x0000842054020074ull + (param1 & 7) * 0x400000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(...) bdk_tns_se_sram_pairx_flsh_mm_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_MM_WX(...) "TNS_SE_SRAM_PAIRX_FLSH_MM_WX"


/**
 * NCB32b - tns_se_sram_pair#_flsh_mp_w#
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_mp_wx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_mp_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t val                         : 32; /**< R/W - -- */
#else
		uint32_t val                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_mp_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_mp_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_mp_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 7)))
		return 0x0000842054020094ull + (param1 & 7) * 0x400000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(...) bdk_tns_se_sram_pairx_flsh_mp_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_MP_WX(...) "TNS_SE_SRAM_PAIRX_FLSH_MP_WX"


/**
 * NCB32b - tns_se_sram_pair#_flsh_sm_w#
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_sm_wx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_sm_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t subst_mask                  : 32; /**< R/W - -- */
#else
		uint32_t subst_mask                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_sm_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_sm_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_sm_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 7)))
		return 0x00008420540200B4ull + (param1 & 7) * 0x400000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(...) bdk_tns_se_sram_pairx_flsh_sm_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_SM_WX(...) "TNS_SE_SRAM_PAIRX_FLSH_SM_WX"


/**
 * NCB32b - tns_se_sram_pair#_flsh_sp_w#
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_sp_wx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_sp_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t subst_pattern               : 32; /**< R/W - -- */
#else
		uint32_t subst_pattern               : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_sp_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_sp_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_sp_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 7)))
		return 0x00008420540200D4ull + (param1 & 7) * 0x400000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(...) bdk_tns_se_sram_pairx_flsh_sp_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_SP_WX(...) "TNS_SE_SRAM_PAIRX_FLSH_SP_WX"


/**
 * NCB32b - tns_se_sram_pair#_flsh_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_w0 {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t prio                        : 1;  /**< R/W - If set, flush is higher priority than traffic */
		uint32_t start_tile_id               : 4;  /**< R/W - -- */
		uint32_t start_tile_addr             : 11; /**< R/W - -- */
		uint32_t end_tile_id                 : 4;  /**< R/W - -- */
		uint32_t end_tile_addr               : 11; /**< R/W - -- */
		uint32_t subst_tile_offset           : 1;  /**< R/W - If not set, the same SRAM data is matched, substituted and written back, one
                                                                 example
                                                                 usage case is entry removal of hash table whose key and data
                                                                 are both 256-bit wide.
                                                                 If set, SRAM data from the even numbered tile is read first, if
                                                                 matching, then read
                                                                 data of the same address from the immediate next odd numbered
                                                                 tile, substitued
                                                                 and write back, the usage case is a control data substitution
                                                                 for a hash table
                                                                 where both data and key are 256-bit wide, upon key match, the
                                                                 control data should
                                                                 be replaced.  Furthermore, in this mode, hardware only search
                                                                 in even numbered
                                                                 tiles for matching data. */
#else
		uint32_t subst_tile_offset           : 1;
		uint32_t end_tile_addr               : 11;
		uint32_t end_tile_id                 : 4;
		uint32_t start_tile_addr             : 11;
		uint32_t start_tile_id               : 4;
		uint32_t prio                        : 1;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_w0_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_w0_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_w0_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205402006Cull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(...) bdk_tns_se_sram_pairx_flsh_w0_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_W0(...) "TNS_SE_SRAM_PAIRX_FLSH_W0"


/**
 * NCB32b - tns_se_sram_pair#_flsh_w1
 *
 * Continuation of structure defined in TNS_SE_SRAM_PAIR(0..7)_FLSH_W0
 *
 */
typedef union bdk_tns_se_sram_pairx_flsh_w1 {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_flsh_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t en                          : 1;  /**< R/W - Rising edge triggered. */
#else
		uint32_t en                          : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_flsh_w1_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_flsh_w1_s cn88xxp1; */
} bdk_tns_se_sram_pairx_flsh_w1_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020070ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_FLSH_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(...) bdk_tns_se_sram_pairx_flsh_w1_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_FLSH_W1(...) "TNS_SE_SRAM_PAIRX_FLSH_W1"


/**
 * NCB32b - tns_se_sram_pair#_inf_frc
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_inf_frc {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_inf_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t rx_force_stop_b             : 2;  /**< R/W - -- */
		uint32_t rx_force_stop_a             : 2;  /**< R/W - -- */
		uint32_t tx_force_stop_b             : 2;  /**< R/W - -- */
		uint32_t tx_force_stop_a             : 2;  /**< R/W - -- */
#else
		uint32_t tx_force_stop_a             : 2;
		uint32_t tx_force_stop_b             : 2;
		uint32_t rx_force_stop_a             : 2;
		uint32_t rx_force_stop_b             : 2;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_inf_frc_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_inf_frc_s cn88xxp1; */
} bdk_tns_se_sram_pairx_inf_frc_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INF_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INF_FRC(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020068ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_INF_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(...) bdk_tns_se_sram_pairx_inf_frc_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_INF_FRC(...) "TNS_SE_SRAM_PAIRX_INF_FRC"


/**
 * NCB32b - tns_se_sram_pair#_int_en_hi#
 *
 * register 0 for port-A, 1 for port-B
 *
 */
typedef union bdk_tns_se_sram_pairx_int_en_hix {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_int_en_hix_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t dfc_rx_ovfl                 : 2;  /**< R/W - bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
		uint32_t odd_tile_prfx               : 1;  /**< R/W - Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
		uint32_t dual_tile_hash_hang         : 2;  /**< R/W - 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
		uint32_t dual_tile_hash_err          : 1;  /**< R/W - when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
		uint32_t sb_err                      : 2;  /**< R/W - single-bit memory error (logical tile = two physical tiles) */
		uint32_t db_err                      : 2;  /**< R/W - single-bit memory error (logical tile = two physical tiles) */
#else
		uint32_t db_err                      : 2;
		uint32_t sb_err                      : 2;
		uint32_t dual_tile_hash_err          : 1;
		uint32_t dual_tile_hash_hang         : 2;
		uint32_t odd_tile_prfx               : 1;
		uint32_t dfc_rx_ovfl                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_int_en_hix_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_int_en_hix_s cn88xxp1; */
} bdk_tns_se_sram_pairx_int_en_hix_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020004ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x10ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(...) bdk_tns_se_sram_pairx_int_en_hix_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_EN_HIX(...) "TNS_SE_SRAM_PAIRX_INT_EN_HIX"


/**
 * NCB32b - tns_se_sram_pair#_int_en_lo#
 *
 * register 0 for port-A, 1 for port-B
 *
 */
typedef union bdk_tns_se_sram_pairx_int_en_lox {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_int_en_lox_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t dfc_rx_ovfl                 : 2;  /**< R/W - bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
		uint32_t odd_tile_prfx               : 1;  /**< R/W - Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
		uint32_t dual_tile_hash_hang         : 2;  /**< R/W - 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
		uint32_t dual_tile_hash_err          : 1;  /**< R/W - when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
		uint32_t sb_err                      : 2;  /**< R/W - single-bit memory error (logical tile = two physical tiles) */
		uint32_t db_err                      : 2;  /**< R/W - single-bit memory error (logical tile = two physical tiles) */
#else
		uint32_t db_err                      : 2;
		uint32_t sb_err                      : 2;
		uint32_t dual_tile_hash_err          : 1;
		uint32_t dual_tile_hash_hang         : 2;
		uint32_t odd_tile_prfx               : 1;
		uint32_t dfc_rx_ovfl                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_int_en_lox_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_int_en_lox_s cn88xxp1; */
} bdk_tns_se_sram_pairx_int_en_lox_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020008ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x10ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(...) bdk_tns_se_sram_pairx_int_en_lox_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_EN_LOX(...) "TNS_SE_SRAM_PAIRX_INT_EN_LOX"


/**
 * NCB32b - tns_se_sram_pair#_int_frc#
 *
 * register 0 for port-A, 1 for port-B
 *
 */
typedef union bdk_tns_se_sram_pairx_int_frcx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_int_frcx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t dfc_rx_ovfl                 : 2;  /**< WO - bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
		uint32_t odd_tile_prfx               : 1;  /**< WO - Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
		uint32_t dual_tile_hash_hang         : 2;  /**< WO - 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
		uint32_t dual_tile_hash_err          : 1;  /**< WO - when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
		uint32_t sb_err                      : 2;  /**< WO - single-bit memory error (logical tile = two physical tiles) */
		uint32_t db_err                      : 2;  /**< WO - single-bit memory error (logical tile = two physical tiles) */
#else
		uint32_t db_err                      : 2;
		uint32_t sb_err                      : 2;
		uint32_t dual_tile_hash_err          : 1;
		uint32_t dual_tile_hash_hang         : 2;
		uint32_t odd_tile_prfx               : 1;
		uint32_t dfc_rx_ovfl                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_int_frcx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_int_frcx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_int_frcx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x000084205402000Cull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x10ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_INT_FRCX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(...) bdk_tns_se_sram_pairx_int_frcx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_FRCX(...) "TNS_SE_SRAM_PAIRX_INT_FRCX"


/**
 * NCB32b - tns_se_sram_pair#_int_w1c#
 *
 * register 0 for port-A, 1 for port-B
 *
 */
typedef union bdk_tns_se_sram_pairx_int_w1cx {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_int_w1cx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t dfc_rx_ovfl                 : 2;  /**< R/W1C/H - bit-0 for tile 0, bit-1 for tile 1, DFC RX FIFO overflows */
		uint32_t odd_tile_prfx               : 1;  /**< R/W1C/H - Only tile 0 should host prefix tables, any prefix tables in tile 1 will not be
                                                                 matched,
                                                                 and a forced miss is returned. */
		uint32_t dual_tile_hash_hang         : 2;  /**< R/W1C/H - 256-bit key 256-bit data hash table hangs for more than 1000 switch-clock
                                                                 cycles
                                                                 0x1: tile 0 is waiting for tile 1
                                                                 0x2: tile 1 is waiting for tile 0 */
		uint32_t dual_tile_hash_err          : 1;  /**< R/W1C/H - when set, tile 0 and tile 1 with different cmd_meta joins incorrectly */
		uint32_t sb_err                      : 2;  /**< R/W1C/H - single-bit memory error (logical tile = two physical tiles) */
		uint32_t db_err                      : 2;  /**< R/W1C/H - single-bit memory error (logical tile = two physical tiles) */
#else
		uint32_t db_err                      : 2;
		uint32_t sb_err                      : 2;
		uint32_t dual_tile_hash_err          : 1;
		uint32_t dual_tile_hash_hang         : 2;
		uint32_t odd_tile_prfx               : 1;
		uint32_t dfc_rx_ovfl                 : 2;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_int_w1cx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_int_w1cx_s cn88xxp1; */
} bdk_tns_se_sram_pairx_int_w1cx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 1)))
		return 0x0000842054020000ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x10ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_INT_W1CX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(...) bdk_tns_se_sram_pairx_int_w1cx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_INT_W1CX(...) "TNS_SE_SRAM_PAIRX_INT_W1CX"


/**
 * NCB32b - tns_se_sram_pair#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_sram_pairx_lock {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_lock_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_lock_s cn88xxp1; */
} bdk_tns_se_sram_pairx_lock_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_LOCK(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x00008420540200FCull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_LOCK(...) bdk_tns_se_sram_pairx_lock_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_LOCK(...) "TNS_SE_SRAM_PAIRX_LOCK"


/**
 * NCB32b - tns_se_sram_pair#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_sram_pairx_spad {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_spad_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_spad_s cn88xxp1; */
} bdk_tns_se_sram_pairx_spad_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SPAD(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020100ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_SPAD(...) bdk_tns_se_sram_pairx_spad_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_SPAD(...) "TNS_SE_SRAM_PAIRX_SPAD"


/**
 * NCB32b - tns_se_sram_pair#_sram_dbg
 *
 * debugging of memoir memory
 *
 */
typedef union bdk_tns_se_sram_pairx_sram_dbg {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_sram_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t en                          : 2;  /**< R/W - one bit per tile , when debug enabled, there should be NO functional requests
                                                                 to SRAM,
                                                                 i.e., all traffic needs to be stopped! */
		uint32_t tile_sel                    : 1;  /**< R/W - choose which tile to read/write */
		uint32_t bank                        : 5;  /**< R/W - -- */
		uint32_t addr                        : 11; /**< R/W - -- */
#else
		uint32_t addr                        : 11;
		uint32_t bank                        : 5;
		uint32_t tile_sel                    : 1;
		uint32_t en                          : 2;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_sram_dbg_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_sram_dbg_s cn88xxp1; */
} bdk_tns_se_sram_pairx_sram_dbg_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842054020058ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(...) bdk_tns_se_sram_pairx_sram_dbg_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_SRAM_DBG(...) "TNS_SE_SRAM_PAIRX_SRAM_DBG"


/**
 * NCB32b - tns_se_sram_pair#_tile_rst
 *
 * --
 *
 */
typedef union bdk_tns_se_sram_pairx_tile_rst {
	uint32_t u;
	struct bdk_tns_se_sram_pairx_tile_rst_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tile_rst_bmp                : 2;  /**< R/W - -- */
#else
		uint32_t tile_rst_bmp                : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairx_tile_rst_s cn88xx; */
	/* struct bdk_tns_se_sram_pairx_tile_rst_s cn88xxp1; */
} bdk_tns_se_sram_pairx_tile_rst_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_TILE_RST(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRX_TILE_RST(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x00008420540200F4ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRX_TILE_RST", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(...) bdk_tns_se_sram_pairx_tile_rst_t
#define bustype_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(p1) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_SRAM_PAIRX_TILE_RST(...) "TNS_SE_SRAM_PAIRX_TILE_RST"


/**
 * NCB - tns_se_sram_pair#tile#d#_w#
 *
 * 8K-row memory tiles, numbered 0-1
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_se_sram_pairxtilexdx_wx {
	uint64_t u;
	struct bdk_tns_se_sram_pairxtilexdx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_se_sram_pairxtilexdx_wx_s cn88xx; */
	/* struct bdk_tns_se_sram_pairxtilexdx_wx_s cn88xxp1; */
} bdk_tns_se_sram_pairxtilexdx_wx_t;

static inline uint64_t BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4)
{
	if (((param1 <= 7)) && ((param2 <= 1)) && ((param3 <= 2047)) && ((param4 <= 3)))
		return 0x0000842054000000ull + (param1 & 7) * 0x400000ull + (param2 & 1) * 0x10000ull + (param3 & 2047) * 0x20ull + (param4 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX", 4, param1, param2, param3, param4); /* No return */
}
#define typedef_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(...) bdk_tns_se_sram_pairxtilexdx_wx_t
#define bustype_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(p1,p2,p3,p4) (p1)
#define arguments_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(p1,p2,p3,p4) (p1),(p2),(p3),(p4)
#define basename_BDK_TNS_SE_SRAM_PAIRXTILEXDX_WX(...) "TNS_SE_SRAM_PAIRXTILEXDX_WX"


/**
 * NCB32b - tns_se_tcam#_dbg_sel
 *
 * Debug select
 *
 */
typedef union bdk_tns_se_tcamx_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_tcamx_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t tcam_sram_dbg_sel           : 8;  /**< R/W - -- */
#else
		uint32_t tcam_sram_dbg_sel           : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_se_tcamx_dbg_sel_s  cn88xxp1; */
} bdk_tns_se_tcamx_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_TCAMX_DBG_SEL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_DBG_SEL(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008018ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_DBG_SEL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_DBG_SEL(...) bdk_tns_se_tcamx_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAMX_DBG_SEL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_DBG_SEL(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_DBG_SEL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_DBG_SEL(...) "TNS_SE_TCAMX_DBG_SEL"


/**
 * NCB32b - tns_se_tcam#_ecc_ctl
 *
 * ECC configuration for TCAM SRAM memories
 *
 */
typedef union bdk_tns_se_tcamx_ecc_ctl {
	uint32_t u;
	struct bdk_tns_se_tcamx_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t flip_db_ecc                 : 2;  /**< R/W - Flip 2 bits of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
		uint32_t flip_sb_ecc                 : 2;  /**< R/W - Flip 1 bit of ECC syndrome in TCAM SRAM memory. It's built out of 2 logical
                                                                 memory tiles of 138 bits wide */
		uint32_t cor_dis                     : 1;  /**< R/W - Disable ECC correction for TCAM SRAM memory */
#else
		uint32_t cor_dis                     : 1;
		uint32_t flip_sb_ecc                 : 2;
		uint32_t flip_db_ecc                 : 2;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_ecc_ctl_s  cn88xx; */
	/* struct bdk_tns_se_tcamx_ecc_ctl_s  cn88xxp1; */
} bdk_tns_se_tcamx_ecc_ctl_t;

static inline uint64_t BDK_TNS_SE_TCAMX_ECC_CTL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_ECC_CTL(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008010ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_ECC_CTL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_ECC_CTL(...) bdk_tns_se_tcamx_ecc_ctl_t
#define bustype_BDK_TNS_SE_TCAMX_ECC_CTL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_ECC_CTL(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_ECC_CTL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_ECC_CTL(...) "TNS_SE_TCAMX_ECC_CTL"


/**
 * NCB - tns_se_tcam#_sram#_w#
 *
 * --
 * When writing, the MSBs (word 3) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_se_tcamx_sramx_wx {
	uint64_t u;
	struct bdk_tns_se_tcamx_sramx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sramx_wx_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sramx_wx_s cn88xxp1; */
} bdk_tns_se_tcamx_sramx_wx_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAMX_WX(unsigned long param1, unsigned long param2, unsigned long param3) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAMX_WX(unsigned long param1, unsigned long param2, unsigned long param3)
{
	if (((param1 <= 7)) && ((param2 <= 767)) && ((param3 <= 3)))
		return 0x0000842050000000ull + (param1 & 7) * 0x400000ull + (param2 & 1023) * 0x20ull + (param3 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAMX_WX", 3, param1, param2, param3, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAMX_WX(...) bdk_tns_se_tcamx_sramx_wx_t
#define bustype_BDK_TNS_SE_TCAMX_SRAMX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_SE_TCAMX_SRAMX_WX(p1,p2,p3) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAMX_WX(p1,p2,p3) (p1),(p2),(p3),-1
#define basename_BDK_TNS_SE_TCAMX_SRAMX_WX(...) "TNS_SE_TCAMX_SRAMX_WX"


/**
 * NCB32b - tns_se_tcam#_sram_ecc_log
 *
 * These are read only
 *
 */
typedef union bdk_tns_se_tcamx_sram_ecc_log {
	uint32_t u;
	struct bdk_tns_se_tcamx_sram_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t ecc_err_addr                : 10; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sram_ecc_log_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sram_ecc_log_s cn88xxp1; */
} bdk_tns_se_tcamx_sram_ecc_log_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008014ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAM_ECC_LOG", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(...) bdk_tns_se_tcamx_sram_ecc_log_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_SRAM_ECC_LOG(...) "TNS_SE_TCAMX_SRAM_ECC_LOG"


/**
 * NCB32b - tns_se_tcam#_sram_int_en_hi
 *
 * TCAM SRAM interrupt register
 *
 */
typedef union bdk_tns_se_tcamx_sram_int_en_hi {
	uint32_t u;
	struct bdk_tns_se_tcamx_sram_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t tcam_sram_db_err            : 2;  /**< R/W - TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
		uint32_t tcam_sram_sb_err            : 2;  /**< R/W - TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else
		uint32_t tcam_sram_sb_err            : 2;
		uint32_t tcam_sram_db_err            : 2;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sram_int_en_hi_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sram_int_en_hi_s cn88xxp1; */
} bdk_tns_se_tcamx_sram_int_en_hi_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008004ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(...) bdk_tns_se_tcamx_sram_int_en_hi_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_EN_HI(...) "TNS_SE_TCAMX_SRAM_INT_EN_HI"


/**
 * NCB32b - tns_se_tcam#_sram_int_en_lo
 *
 * TCAM SRAM interrupt register
 *
 */
typedef union bdk_tns_se_tcamx_sram_int_en_lo {
	uint32_t u;
	struct bdk_tns_se_tcamx_sram_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t tcam_sram_db_err            : 2;  /**< R/W - TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
		uint32_t tcam_sram_sb_err            : 2;  /**< R/W - TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else
		uint32_t tcam_sram_sb_err            : 2;
		uint32_t tcam_sram_db_err            : 2;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sram_int_en_lo_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sram_int_en_lo_s cn88xxp1; */
} bdk_tns_se_tcamx_sram_int_en_lo_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008008ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(...) bdk_tns_se_tcamx_sram_int_en_lo_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_EN_LO(...) "TNS_SE_TCAMX_SRAM_INT_EN_LO"


/**
 * NCB32b - tns_se_tcam#_sram_int_frc
 *
 * TCAM SRAM interrupt register
 *
 */
typedef union bdk_tns_se_tcamx_sram_int_frc {
	uint32_t u;
	struct bdk_tns_se_tcamx_sram_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t tcam_sram_db_err            : 2;  /**< WO - TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
		uint32_t tcam_sram_sb_err            : 2;  /**< WO - TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else
		uint32_t tcam_sram_sb_err            : 2;
		uint32_t tcam_sram_db_err            : 2;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sram_int_frc_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sram_int_frc_s cn88xxp1; */
} bdk_tns_se_tcamx_sram_int_frc_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_FRC(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_FRC(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205000800Cull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAM_INT_FRC", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(...) bdk_tns_se_tcamx_sram_int_frc_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_FRC(...) "TNS_SE_TCAMX_SRAM_INT_FRC"


/**
 * NCB32b - tns_se_tcam#_sram_int_w1c
 *
 * TCAM SRAM interrupt register
 *
 */
typedef union bdk_tns_se_tcamx_sram_int_w1c {
	uint32_t u;
	struct bdk_tns_se_tcamx_sram_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t tcam_sram_db_err            : 2;  /**< R/W1C/H - TCAM SRAM memory double bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
		uint32_t tcam_sram_sb_err            : 2;  /**< R/W1C/H - TCAM SRAM memory single bit ECC interrupt. It's built out of 2 logical memory
                                                                 tiles of 138 bits wide */
#else
		uint32_t tcam_sram_sb_err            : 2;
		uint32_t tcam_sram_db_err            : 2;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_se_tcamx_sram_int_w1c_s cn88xx; */
	/* struct bdk_tns_se_tcamx_sram_int_w1c_s cn88xxp1; */
} bdk_tns_se_tcamx_sram_int_w1c_t;

static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_W1C(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAMX_SRAM_INT_W1C(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008000ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAMX_SRAM_INT_W1C", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(...) bdk_tns_se_tcamx_sram_int_w1c_t
#define bustype_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(p1) (p1)
#define arguments_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAMX_SRAM_INT_W1C(...) "TNS_SE_TCAMX_SRAM_INT_W1C"


/**
 * NCB32b - tns_se_tcam_db#_bist_stdn
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_dbx_bist_stdn {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t bist_status                 : 6;  /**< RO/H - -- */
		uint32_t bist_done                   : 6;  /**< RO/H - -- */
		uint32_t cam_bist_status             : 6;  /**< RO/H - -- */
		uint32_t cam_bist_done               : 6;  /**< RO/H - -- */
#else
		uint32_t cam_bist_done               : 6;
		uint32_t cam_bist_status             : 6;
		uint32_t bist_done                   : 6;
		uint32_t bist_status                 : 6;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_bist_stdn_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_bist_stdn_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_BIST_STDN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_BIST_STDN(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C028ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_BIST_STDN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_BIST_STDN(...) bdk_tns_se_tcam_dbx_bist_stdn_t
#define bustype_BDK_TNS_SE_TCAM_DBX_BIST_STDN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_BIST_STDN(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_BIST_STDN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_BIST_STDN(...) "TNS_SE_TCAM_DBX_BIST_STDN"


/**
 * NCB32b - tns_se_tcam_db#_clk_en_bmap
 *
 * TCAM tile clk_en bit map
 *
 */
typedef union bdk_tns_se_tcam_dbx_clk_en_bmap {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_clk_en_bmap_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t clk_en_bmap                 : 6;  /**< R/W - -- */
#else
		uint32_t clk_en_bmap                 : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_clk_en_bmap_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_clk_en_bmap_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_clk_en_bmap_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C020ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(...) bdk_tns_se_tcam_dbx_clk_en_bmap_t
#define bustype_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_CLK_EN_BMAP(...) "TNS_SE_TCAM_DBX_CLK_EN_BMAP"


/**
 * NCB32b - tns_se_tcam_db#_db_dbg_sel
 *
 * Debug select
 *
 */
typedef union bdk_tns_se_tcam_dbx_db_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_db_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t tcam_db_dbg_sel             : 8;  /**< R/W - -- */
#else
		uint32_t tcam_db_dbg_sel             : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_db_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_db_dbg_sel_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_db_dbg_sel_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C024ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(...) bdk_tns_se_tcam_dbx_db_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_DB_DBG_SEL(...) "TNS_SE_TCAM_DBX_DB_DBG_SEL"


/**
 * NCB32b - tns_se_tcam_db#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_tcam_dbx_lock {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_lock_s  cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_lock_s  cn88xxp1; */
} bdk_tns_se_tcam_dbx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_LOCK(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C02Cull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_LOCK(...) bdk_tns_se_tcam_dbx_lock_t
#define bustype_BDK_TNS_SE_TCAM_DBX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_LOCK(...) "TNS_SE_TCAM_DBX_LOCK"


/**
 * NCB32b - tns_se_tcam_db#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_tcam_dbx_spad {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_spad_s  cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_spad_s  cn88xxp1; */
} bdk_tns_se_tcam_dbx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_SPAD(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C030ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_SPAD(...) bdk_tns_se_tcam_dbx_spad_t
#define bustype_BDK_TNS_SE_TCAM_DBX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_SPAD(...) "TNS_SE_TCAM_DBX_SPAD"


/**
 * NCB32b - tns_se_tcam_db#_tdb_rvld_w#
 *
 * Power optoin, each row_vld control 16 lines in a TCAM tile. Feature NOT
 * available in CN88XX custom TCAM
 */
typedef union bdk_tns_se_tcam_dbx_tdb_rvld_wx {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_tdb_rvld_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t row_vld                     : 32; /**< R/W - -- */
#else
		uint32_t row_vld                     : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_tdb_rvld_wx_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_tdb_rvld_wx_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_tdb_rvld_wx_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x000084205200C004ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(...) bdk_tns_se_tcam_dbx_tdb_rvld_wx_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_TDB_RVLD_WX(...) "TNS_SE_TCAM_DBX_TDB_RVLD_WX"


/**
 * NCB32b - tns_se_tcam_db#_tile_rst
 *
 * reset TCAM tile, rising edge trigger
 *
 */
typedef union bdk_tns_se_tcam_dbx_tile_rst {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_tile_rst_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t tile_rst                    : 6;  /**< R/W - -- */
#else
		uint32_t tile_rst                    : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_tile_rst_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_tile_rst_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_tile_rst_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TILE_RST(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TILE_RST(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C000ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_TILE_RST", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_TILE_RST(...) bdk_tns_se_tcam_dbx_tile_rst_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TILE_RST(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_TILE_RST(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_TILE_RST(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_TILE_RST(...) "TNS_SE_TCAM_DBX_TILE_RST"


/**
 * NCB32b - tns_se_tcam_db#_tpool_db
 *
 * configuration within a TCAM database, it has to be consistent with the
 * corresponding TCAM table definition.
 */
typedef union bdk_tns_se_tcam_dbx_tpool_db {
	uint32_t u;
	struct bdk_tns_se_tcam_dbx_tpool_db_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t mode                        : 4;  /**< R/W - 0x1: 64-bit  X 1.5K-entry
                                                                 0x2: 128-bit X 768-entry
                                                                 0x3: 192-bit X 512-entry
                                                                 0x6: 384-bit X 256-entry */
		uint32_t db_addr_base                : 8;  /**< R/W - starting table address for this database, in unit of 256-entry */
#else
		uint32_t db_addr_base                : 8;
		uint32_t mode                        : 4;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbx_tpool_db_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbx_tpool_db_s cn88xxp1; */
} bdk_tns_se_tcam_dbx_tpool_db_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBX_TPOOL_DB(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBX_TPOOL_DB(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205200C01Cull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBX_TPOOL_DB", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(...) bdk_tns_se_tcam_dbx_tpool_db_t
#define bustype_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_DBX_TPOOL_DB(...) "TNS_SE_TCAM_DBX_TPOOL_DB"


/**
 * NCB32b - tns_se_tcam_db#cn_vdm#d#_w#
 *
 * TCAM tile, {CN88XX cn_vld_data_mask[129:0]}
 * Bits[31:2] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_se_tcam_dbxcn_vdmxdx_wx {
	uint32_t u;
	struct bdk_tns_se_tcam_dbxcn_vdmxdx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t cn_vld_data_mask            : 32; /**< R/W - -- */
#else
		uint32_t cn_vld_data_mask            : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_dbxcn_vdmxdx_wx_s cn88xx; */
	/* struct bdk_tns_se_tcam_dbxcn_vdmxdx_wx_s cn88xxp1; */
} bdk_tns_se_tcam_dbxcn_vdmxdx_wx_t;

static inline uint64_t BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(unsigned long param1, unsigned long param2, unsigned long param3, unsigned long param4)
{
	if (((param1 <= 7)) && ((param2 <= 5)) && ((param3 <= 255)) && ((param4 <= 4)))
		return 0x0000842052000000ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x2000ull + (param3 & 255) * 0x20ull + (param4 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX", 4, param1, param2, param3, param4); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(...) bdk_tns_se_tcam_dbxcn_vdmxdx_wx_t
#define bustype_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(p1,p2,p3,p4) (p1)
#define arguments_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(p1,p2,p3,p4) (p1),(p2),(p3),(p4)
#define basename_BDK_TNS_SE_TCAM_DBXCN_VDMXDX_WX(...) "TNS_SE_TCAM_DBXCN_VDMXDX_WX"


/**
 * NCB32b - tns_se_tcam_eng_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_eng_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t age_dbg_sel                 : 8;  /**< R/W - -- */
#else
		uint32_t age_dbg_sel                 : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_tcam_eng_dbg_sel_s cn88xxp1; */
} bdk_tns_se_tcam_eng_dbg_sel_t;

#define BDK_TNS_SE_TCAM_ENG_DBG_SEL BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_DBG_SEL_FUNC(void)
{
	return 0x000084205220104Cull;
}
#define typedef_BDK_TNS_SE_TCAM_ENG_DBG_SEL bdk_tns_se_tcam_eng_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_ENG_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_DBG_SEL 0
#define arguments_BDK_TNS_SE_TCAM_ENG_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_DBG_SEL "TNS_SE_TCAM_ENG_DBG_SEL"


/**
 * NCB32b - tns_se_tcam_eng_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_tcam_eng_lock {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_lock_s  cn88xx; */
	/* struct bdk_tns_se_tcam_eng_lock_s  cn88xxp1; */
} bdk_tns_se_tcam_eng_lock_t;

#define BDK_TNS_SE_TCAM_ENG_LOCK BDK_TNS_SE_TCAM_ENG_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_LOCK_FUNC(void)
{
	return 0x0000842052201054ull;
}
#define typedef_BDK_TNS_SE_TCAM_ENG_LOCK bdk_tns_se_tcam_eng_lock_t
#define bustype_BDK_TNS_SE_TCAM_ENG_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_LOCK 0
#define arguments_BDK_TNS_SE_TCAM_ENG_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_LOCK "TNS_SE_TCAM_ENG_LOCK"


/**
 * NCB32b - tns_se_tcam_eng_rslt_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_eng_rslt_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_rslt_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t age_dbg_sel                 : 8;  /**< R/W - -- */
#else
		uint32_t age_dbg_sel                 : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_rslt_dbg_sel_s cn88xx; */
	/* struct bdk_tns_se_tcam_eng_rslt_dbg_sel_s cn88xxp1; */
} bdk_tns_se_tcam_eng_rslt_dbg_sel_t;

#define BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL_FUNC(void)
{
	return 0x0000842052201050ull;
}
#define typedef_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL bdk_tns_se_tcam_eng_rslt_dbg_sel_t
#define bustype_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL 0
#define arguments_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_RSLT_DBG_SEL "TNS_SE_TCAM_ENG_RSLT_DBG_SEL"


/**
 * NCB32b - tns_se_tcam_eng_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_tcam_eng_spad {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_spad_s  cn88xx; */
	/* struct bdk_tns_se_tcam_eng_spad_s  cn88xxp1; */
} bdk_tns_se_tcam_eng_spad_t;

#define BDK_TNS_SE_TCAM_ENG_SPAD BDK_TNS_SE_TCAM_ENG_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_ENG_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_SPAD_FUNC(void)
{
	return 0x0000842052201058ull;
}
#define typedef_BDK_TNS_SE_TCAM_ENG_SPAD bdk_tns_se_tcam_eng_spad_t
#define bustype_BDK_TNS_SE_TCAM_ENG_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_SPAD 0
#define arguments_BDK_TNS_SE_TCAM_ENG_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_SPAD "TNS_SE_TCAM_ENG_SPAD"


/**
 * NCB32b - tns_se_tcam_eng_tcam_dbbuf#
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_eng_tcam_dbbufx {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_tcam_dbbufx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t dbbuf_fc_thd                : 6;  /**< R/W - -- */
#else
		uint32_t dbbuf_fc_thd                : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_tcam_dbbufx_s cn88xx; */
	/* struct bdk_tns_se_tcam_eng_tcam_dbbufx_s cn88xxp1; */
} bdk_tns_se_tcam_eng_tcam_dbbufx_t;

static inline uint64_t BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842052201020ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(...) bdk_tns_se_tcam_eng_tcam_dbbufx_t
#define bustype_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_TCAM_DBBUFX(...) "TNS_SE_TCAM_ENG_TCAM_DBBUFX"


/**
 * NCB32b - tns_se_tcam_eng_tpool_vcod#
 *
 * configuration across TCAM databases, it has to be consistent with the
 * corresponding TCAM table definition.
 */
typedef union bdk_tns_se_tcam_eng_tpool_vcodx {
	uint32_t u;
	struct bdk_tns_se_tcam_eng_tpool_vcodx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t db_bmp                      : 8;  /**< R/W - bitmap for all databases in the table, they have to be a contiguous set of
                                                                 DB's. */
		uint32_t data_size                   : 4;  /**< R/W - In unit of 32-bit, max 256-bit return control data. Allowed data size: 64, 128,
                                                                 256-bit */
#else
		uint32_t data_size                   : 4;
		uint32_t db_bmp                      : 8;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_se_tcam_eng_tpool_vcodx_s cn88xx; */
	/* struct bdk_tns_se_tcam_eng_tpool_vcodx_s cn88xxp1; */
} bdk_tns_se_tcam_eng_tpool_vcodx_t;

static inline uint64_t BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842052201000ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(...) bdk_tns_se_tcam_eng_tpool_vcodx_t
#define bustype_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_ENG_TPOOL_VCODX(...) "TNS_SE_TCAM_ENG_TPOOL_VCODX"


/**
 * NCB32b - tns_se_tcam_scrb#_ecc#d#
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_scrbx_eccxdx {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_eccxdx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t ecc_data                    : 10; /**< R/W - -- */
#else
		uint32_t ecc_data                    : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_eccxdx_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_eccxdx_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_eccxdx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECCXDX(unsigned long param1, unsigned long param2, unsigned long param3) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECCXDX(unsigned long param1, unsigned long param2, unsigned long param3)
{
	if (((param1 <= 7)) && ((param2 <= 5)) && ((param3 <= 255)))
		return 0x0000842052100000ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x400ull + (param3 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_ECCXDX", 3, param1, param2, param3, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(...) bdk_tns_se_tcam_scrbx_eccxdx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(p1,p2,p3) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(p1,p2,p3) (p1),(p2),(p3),-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_ECCXDX(...) "TNS_SE_TCAM_SCRBX_ECCXDX"


/**
 * NCB32b - tns_se_tcam_scrb#_ecc_log#
 *
 * These are read only
 *
 */
typedef union bdk_tns_se_tcam_scrbx_ecc_logx {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_ecc_logx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_ecc_logx_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_ecc_logx_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_ecc_logx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x0000842052101878ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(...) bdk_tns_se_tcam_scrbx_ecc_logx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_ECC_LOGX(...) "TNS_SE_TCAM_SCRBX_ECC_LOGX"


/**
 * NCB32b - tns_se_tcam_scrb#_int_en_hi#
 *
 * TCAM scrub interrupt register
 *
 */
typedef union bdk_tns_se_tcam_scrbx_int_en_hix {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_int_en_hix_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tcam_scrb_db_err            : 1;  /**< R/W - TCAM scrub has double bit ECC interrupt */
		uint32_t tcam_scrb_sb_err            : 1;  /**< R/W - TCAM scrub has single bit ECC interrupt */
#else
		uint32_t tcam_scrb_sb_err            : 1;
		uint32_t tcam_scrb_db_err            : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_int_en_hix_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_int_en_hix_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_int_en_hix_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x000084205210181Cull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x10ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(...) bdk_tns_se_tcam_scrbx_int_en_hix_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_EN_HIX(...) "TNS_SE_TCAM_SCRBX_INT_EN_HIX"


/**
 * NCB32b - tns_se_tcam_scrb#_int_en_lo#
 *
 * TCAM scrub interrupt register
 *
 */
typedef union bdk_tns_se_tcam_scrbx_int_en_lox {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_int_en_lox_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tcam_scrb_db_err            : 1;  /**< R/W - TCAM scrub has double bit ECC interrupt */
		uint32_t tcam_scrb_sb_err            : 1;  /**< R/W - TCAM scrub has single bit ECC interrupt */
#else
		uint32_t tcam_scrb_sb_err            : 1;
		uint32_t tcam_scrb_db_err            : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_int_en_lox_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_int_en_lox_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_int_en_lox_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x0000842052101820ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x10ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(...) bdk_tns_se_tcam_scrbx_int_en_lox_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_EN_LOX(...) "TNS_SE_TCAM_SCRBX_INT_EN_LOX"


/**
 * NCB32b - tns_se_tcam_scrb#_int_frc#
 *
 * TCAM scrub interrupt register
 *
 */
typedef union bdk_tns_se_tcam_scrbx_int_frcx {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_int_frcx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tcam_scrb_db_err            : 1;  /**< WO - TCAM scrub has double bit ECC interrupt */
		uint32_t tcam_scrb_sb_err            : 1;  /**< WO - TCAM scrub has single bit ECC interrupt */
#else
		uint32_t tcam_scrb_sb_err            : 1;
		uint32_t tcam_scrb_db_err            : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_int_frcx_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_int_frcx_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_int_frcx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x0000842052101824ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x10ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_INT_FRCX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(...) bdk_tns_se_tcam_scrbx_int_frcx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_FRCX(...) "TNS_SE_TCAM_SCRBX_INT_FRCX"


/**
 * NCB32b - tns_se_tcam_scrb#_int_w1c#
 *
 * TCAM scrub interrupt register
 *
 */
typedef union bdk_tns_se_tcam_scrbx_int_w1cx {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_int_w1cx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tcam_scrb_db_err            : 1;  /**< R/W1C/H - TCAM scrub has double bit ECC interrupt */
		uint32_t tcam_scrb_sb_err            : 1;  /**< R/W1C/H - TCAM scrub has single bit ECC interrupt */
#else
		uint32_t tcam_scrb_sb_err            : 1;
		uint32_t tcam_scrb_db_err            : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_int_w1cx_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_int_w1cx_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_int_w1cx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x0000842052101818ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x10ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_INT_W1CX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(...) bdk_tns_se_tcam_scrbx_int_w1cx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_INT_W1CX(...) "TNS_SE_TCAM_SCRBX_INT_W1CX"


/**
 * NCB32b - tns_se_tcam_scrb#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_tcam_scrbx_lock {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_lock_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_lock_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_LOCK(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842052101890ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_LOCK(...) bdk_tns_se_tcam_scrbx_lock_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_LOCK(...) "TNS_SE_TCAM_SCRBX_LOCK"


/**
 * NCB32b - tns_se_tcam_scrb#_scrb#
 *
 * Hardware scrubbing of TCAMs
 *
 */
typedef union bdk_tns_se_tcam_scrbx_scrbx {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_scrbx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scrub_row_intvl             : 10; /**< R/W - When set to 0 scrubbing is disabled. When non-zero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing adjacent rows */
		uint32_t scrub_last_to_1st_row_intvl : 16; /**< R/W - When set to 0 this interval is disabled. When non-zero it is the interval in
                                                                 switch-clock cycles
                                                                 between scrubbing last row and first row (i.e. new scrub cycle)
                                                                 gives granularity upto 0.1ms with 600MHz switch-clock
                                                                 Not implemented in Pass1 */
		uint32_t reserved_5_5                : 1;
		uint32_t flip_sb_ecc                 : 1;  /**< R/W - -- */
		uint32_t flip_db_ecc                 : 1;  /**< R/W - -- */
		uint32_t cor_dis                     : 1;  /**< R/W - -- */
		uint32_t sw_scrb_wr                  : 1;  /**< R/W - When set to 1, HW will indicate the SBE erred address, SW will scrub that
                                                                 address by doing a CPU write to TCAM
                                                                 When set to 0 (default), HW will do the scrubbing */
		uint32_t use_ecc_rams                : 1;  /**< R/W - Hack to make Test bench work.
                                                                 This bit needs to be set by software before this feature can be
                                                                 used */
#else
		uint32_t use_ecc_rams                : 1;
		uint32_t sw_scrb_wr                  : 1;
		uint32_t cor_dis                     : 1;
		uint32_t flip_db_ecc                 : 1;
		uint32_t flip_sb_ecc                 : 1;
		uint32_t reserved_5_5                : 1;
		uint32_t scrub_last_to_1st_row_intvl : 16;
		uint32_t scrub_row_intvl             : 10;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_scrbx_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_scrbx_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_scrbx_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SCRBX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SCRBX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 7)) && ((param2 <= 5)))
		return 0x0000842052101800ull + (param1 & 7) * 0x20000ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_SCRBX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_SCRBX(...) bdk_tns_se_tcam_scrbx_scrbx_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_SCRBX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_SCRBX(p1,p2) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_SCRBX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_SCRBX(...) "TNS_SE_TCAM_SCRBX_SCRBX"


/**
 * NCB32b - tns_se_tcam_scrb#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_tcam_scrbx_spad {
	uint32_t u;
	struct bdk_tns_se_tcam_scrbx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_scrbx_spad_s cn88xx; */
	/* struct bdk_tns_se_tcam_scrbx_spad_s cn88xxp1; */
} bdk_tns_se_tcam_scrbx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SCRBX_SPAD(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842052101894ull + (param1 & 7) * 0x20000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SCRBX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SCRBX_SPAD(...) bdk_tns_se_tcam_scrbx_spad_t
#define bustype_BDK_TNS_SE_TCAM_SCRBX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SCRBX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SCRBX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SCRBX_SPAD(...) "TNS_SE_TCAM_SCRBX_SPAD"


/**
 * NCB32b - tns_se_tcam_sram#_bist_stdn
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_sramx_bist_stdn {
	uint32_t u;
	struct bdk_tns_se_tcam_sramx_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t bist_status                 : 2;  /**< RO/H - -- */
		uint32_t bist_done                   : 2;  /**< RO/H - -- */
#else
		uint32_t bist_done                   : 2;
		uint32_t bist_status                 : 2;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_se_tcam_sramx_bist_stdn_s cn88xx; */
	/* struct bdk_tns_se_tcam_sramx_bist_stdn_s cn88xxp1; */
} bdk_tns_se_tcam_sramx_bist_stdn_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008020ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SRAMX_BIST_STDN", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(...) bdk_tns_se_tcam_sramx_bist_stdn_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SRAMX_BIST_STDN(...) "TNS_SE_TCAM_SRAMX_BIST_STDN"


/**
 * NCB32b - tns_se_tcam_sram#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_tcam_sramx_lock {
	uint32_t u;
	struct bdk_tns_se_tcam_sramx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_sramx_lock_s cn88xx; */
	/* struct bdk_tns_se_tcam_sramx_lock_s cn88xxp1; */
} bdk_tns_se_tcam_sramx_lock_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_LOCK(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008024ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SRAMX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SRAMX_LOCK(...) bdk_tns_se_tcam_sramx_lock_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SRAMX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SRAMX_LOCK(...) "TNS_SE_TCAM_SRAMX_LOCK"


/**
 * NCB32b - tns_se_tcam_sram#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_tcam_sramx_spad {
	uint32_t u;
	struct bdk_tns_se_tcam_sramx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_sramx_spad_s cn88xx; */
	/* struct bdk_tns_se_tcam_sramx_spad_s cn88xxp1; */
} bdk_tns_se_tcam_sramx_spad_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_SPAD(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842050008028ull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SRAMX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SRAMX_SPAD(...) bdk_tns_se_tcam_sramx_spad_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SRAMX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SRAMX_SPAD(...) "TNS_SE_TCAM_SRAMX_SPAD"


/**
 * NCB32b - tns_se_tcam_sram#_tcam_rdbuf
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_sramx_tcam_rdbuf {
	uint32_t u;
	struct bdk_tns_se_tcam_sramx_tcam_rdbuf_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t rdbuf_fc_thd                : 6;  /**< R/W - -- */
#else
		uint32_t rdbuf_fc_thd                : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_se_tcam_sramx_tcam_rdbuf_s cn88xx; */
	/* struct bdk_tns_se_tcam_sramx_tcam_rdbuf_s cn88xxp1; */
} bdk_tns_se_tcam_sramx_tcam_rdbuf_t;

static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205000801Cull + (param1 & 7) * 0x400000ull;
	csr_fatal("BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(...) bdk_tns_se_tcam_sramx_tcam_rdbuf_t
#define bustype_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_SRAMX_TCAM_RDBUF(...) "TNS_SE_TCAM_SRAMX_TCAM_RDBUF"


/**
 * NCB32b - tns_se_tcam_tbl#
 *
 * --
 *
 */
typedef union bdk_tns_se_tcam_tblx {
	uint32_t u;
	struct bdk_tns_se_tcam_tblx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t key_size                    : 4;  /**< R/W - In unit of 32-bit, allowed values 64-bit, 128-bit, 192-bit, or 384-bit
                                                                 Note that control data size is configured in
                                                                 xp_se_config_tpool_vencoder. */
		uint32_t db_start                    : 5;  /**< R/W - The tcam pool has 8 databases. */
		uint32_t db_end                      : 5;  /**< R/W - -- */
#else
		uint32_t db_end                      : 5;
		uint32_t db_start                    : 5;
		uint32_t key_size                    : 4;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_se_tcam_tblx_s      cn88xx; */
	/* struct bdk_tns_se_tcam_tblx_s      cn88xxp1; */
} bdk_tns_se_tcam_tblx_t;

static inline uint64_t BDK_TNS_SE_TCAM_TBLX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBLX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842052200000ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_SE_TCAM_TBLX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_TCAM_TBLX(...) bdk_tns_se_tcam_tblx_t
#define bustype_BDK_TNS_SE_TCAM_TBLX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_TBLX(p1) (p1)
#define arguments_BDK_TNS_SE_TCAM_TBLX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_TBLX(...) "TNS_SE_TCAM_TBLX"


/**
 * NCB32b - tns_se_tcam_tbl_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_tcam_tbl_lock {
	uint32_t u;
	struct bdk_tns_se_tcam_tbl_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_tbl_lock_s  cn88xx; */
	/* struct bdk_tns_se_tcam_tbl_lock_s  cn88xxp1; */
} bdk_tns_se_tcam_tbl_lock_t;

#define BDK_TNS_SE_TCAM_TBL_LOCK BDK_TNS_SE_TCAM_TBL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_TBL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBL_LOCK_FUNC(void)
{
	return 0x0000842052200048ull;
}
#define typedef_BDK_TNS_SE_TCAM_TBL_LOCK bdk_tns_se_tcam_tbl_lock_t
#define bustype_BDK_TNS_SE_TCAM_TBL_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_TBL_LOCK 0
#define arguments_BDK_TNS_SE_TCAM_TBL_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_TBL_LOCK "TNS_SE_TCAM_TBL_LOCK"


/**
 * NCB32b - tns_se_tcam_tbl_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_tcam_tbl_spad {
	uint32_t u;
	struct bdk_tns_se_tcam_tbl_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_tcam_tbl_spad_s  cn88xx; */
	/* struct bdk_tns_se_tcam_tbl_spad_s  cn88xxp1; */
} bdk_tns_se_tcam_tbl_spad_t;

#define BDK_TNS_SE_TCAM_TBL_SPAD BDK_TNS_SE_TCAM_TBL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_TCAM_TBL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_TCAM_TBL_SPAD_FUNC(void)
{
	return 0x000084205220004Cull;
}
#define typedef_BDK_TNS_SE_TCAM_TBL_SPAD bdk_tns_se_tcam_tbl_spad_t
#define bustype_BDK_TNS_SE_TCAM_TBL_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_TCAM_TBL_SPAD 0
#define arguments_BDK_TNS_SE_TCAM_TBL_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_TCAM_TBL_SPAD "TNS_SE_TCAM_TBL_SPAD"


/**
 * NCB32b - tns_se_urw_tbl_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_urw_tbl_lock {
	uint32_t u;
	struct bdk_tns_se_urw_tbl_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_urw_tbl_lock_s   cn88xx; */
	/* struct bdk_tns_se_urw_tbl_lock_s   cn88xxp1; */
} bdk_tns_se_urw_tbl_lock_t;

#define BDK_TNS_SE_URW_TBL_LOCK BDK_TNS_SE_URW_TBL_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_URW_TBL_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_LOCK_FUNC(void)
{
	return 0x0000842056109880ull;
}
#define typedef_BDK_TNS_SE_URW_TBL_LOCK bdk_tns_se_urw_tbl_lock_t
#define bustype_BDK_TNS_SE_URW_TBL_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URW_TBL_LOCK 0
#define arguments_BDK_TNS_SE_URW_TBL_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_URW_TBL_LOCK "TNS_SE_URW_TBL_LOCK"


/**
 * NCB32b - tns_se_urw_tbl_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_urw_tbl_spad {
	uint32_t u;
	struct bdk_tns_se_urw_tbl_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_urw_tbl_spad_s   cn88xx; */
	/* struct bdk_tns_se_urw_tbl_spad_s   cn88xxp1; */
} bdk_tns_se_urw_tbl_spad_t;

#define BDK_TNS_SE_URW_TBL_SPAD BDK_TNS_SE_URW_TBL_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_URW_TBL_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_SPAD_FUNC(void)
{
	return 0x0000842056109884ull;
}
#define typedef_BDK_TNS_SE_URW_TBL_SPAD bdk_tns_se_urw_tbl_spad_t
#define bustype_BDK_TNS_SE_URW_TBL_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URW_TBL_SPAD 0
#define arguments_BDK_TNS_SE_URW_TBL_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_URW_TBL_SPAD "TNS_SE_URW_TBL_SPAD"


/**
 * NCB32b - tns_se_urw_tbl_urw#
 *
 * Same as xp_se_config_table_direct
 *
 */
typedef union bdk_tns_se_urw_tbl_urwx {
	uint32_t u;
	struct bdk_tns_se_urw_tbl_urwx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t data_size                   : 4;  /**< R/W - 0x2:     64-bit
                                                                 0x4:     128-bit
                                                                 0x8:     256-bit
                                                                 0x9(\>8): 512-bit */
		uint32_t pool                        : 3;  /**< R/W - Pool ID out of the 8 pools, which this table resides. */
		uint32_t row_blk_inc                 : 6;  /**< R/W - Each table occupies row blocks [row_blk_start, row_blk_start + row_blk_inc],
                                                                 inclusive */
		uint32_t row_blk_start               : 6;  /**< R/W - Each row_blk is 1K row, it is a logic concept, software need to assign tables
                                                                 in unit
                                                                 of tile, which are physical, for optimized performance. */
#else
		uint32_t row_blk_start               : 6;
		uint32_t row_blk_inc                 : 6;
		uint32_t pool                        : 3;
		uint32_t data_size                   : 4;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_se_urw_tbl_urwx_s   cn88xx; */
	/* struct bdk_tns_se_urw_tbl_urwx_s   cn88xxp1; */
} bdk_tns_se_urw_tbl_urwx_t;

static inline uint64_t BDK_TNS_SE_URW_TBL_URWX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URW_TBL_URWX(unsigned long param1)
{
	if (((param1 <= 31)))
		return 0x0000842056109800ull + (param1 & 31) * 0x4ull;
	csr_fatal("BDK_TNS_SE_URW_TBL_URWX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URW_TBL_URWX(...) bdk_tns_se_urw_tbl_urwx_t
#define bustype_BDK_TNS_SE_URW_TBL_URWX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URW_TBL_URWX(p1) (p1)
#define arguments_BDK_TNS_SE_URW_TBL_URWX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URW_TBL_URWX(...) "TNS_SE_URW_TBL_URWX"


/**
 * NCB32b - tns_se_urwcmd#_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_urwcmdx_lock {
	uint32_t u;
	struct bdk_tns_se_urwcmdx_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwcmdx_lock_s   cn88xx; */
	/* struct bdk_tns_se_urwcmdx_lock_s   cn88xxp1; */
} bdk_tns_se_urwcmdx_lock_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_LOCK(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_LOCK(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056105300ull + (param1 & 1) * 0x1000ull;
	csr_fatal("BDK_TNS_SE_URWCMDX_LOCK", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWCMDX_LOCK(...) bdk_tns_se_urwcmdx_lock_t
#define bustype_BDK_TNS_SE_URWCMDX_LOCK(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWCMDX_LOCK(p1) (p1)
#define arguments_BDK_TNS_SE_URWCMDX_LOCK(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URWCMDX_LOCK(...) "TNS_SE_URWCMDX_LOCK"


/**
 * NCB32b - tns_se_urwcmd#_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_urwcmdx_spad {
	uint32_t u;
	struct bdk_tns_se_urwcmdx_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwcmdx_spad_s   cn88xx; */
	/* struct bdk_tns_se_urwcmdx_spad_s   cn88xxp1; */
} bdk_tns_se_urwcmdx_spad_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SPAD(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SPAD(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x0000842056105304ull + (param1 & 1) * 0x1000ull;
	csr_fatal("BDK_TNS_SE_URWCMDX_SPAD", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWCMDX_SPAD(...) bdk_tns_se_urwcmdx_spad_t
#define bustype_BDK_TNS_SE_URWCMDX_SPAD(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWCMDX_SPAD(p1) (p1)
#define arguments_BDK_TNS_SE_URWCMDX_SPAD(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URWCMDX_SPAD(...) "TNS_SE_URWCMDX_SPAD"


/**
 * NCB32b - tns_se_urwcmd#_srch_cmd#_w0
 *
 * Search command configuration, command 4*i through 4*i+3 constitute search
 * profile i.
 * URW j in [0..1] can request for search profiel j*8 through j*8+7.
 * MRE can request for search profile 16 through 23
 * More Explanation (Let's use URW/MRE as example. LDE is similar):
 * Each instantiated block in this XML has 64 commands and we instantiate
 * two blocks for a total of 128 cmd registers.
 * Of these 128 registers:
 * - 32 are for URWVIF (00 to 31)
 * - 32 are for URWINS (32 to 63)
 * - 32 are for MRE (64 to 95)
 * - 32 are unused
 * Each incoming request can have upto 8 profiles and 4 commands. So that's
 * why 32 (i.e. 8x4).
 * So the mapping is
 * {..........P1C3,P1C2,P1C1,P1C0,P0C3,P0C2,P0C1,P0C0} where Px = Profile X, and
 * Cy = Command Y.
 * So for example URWINS starts at 32 and if it's command 3 of profile 0
 * then it has to be urw_cmd = 35.
 */
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w0 {
	uint32_t u;
	struct bdk_tns_se_urwcmdx_srch_cmdx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key_byte_bmp                : 11; /**< R/W - bitmap for forming search key out of the 384-bit (48-Byte) input key.
                                                                 bit 0-15: mask for byte selection
                                                                 bit 16-47: reserved, i.e. only lower 16-bytes of input master key
                                                                 are used to form search key. */
		uint32_t key_size                    : 6;  /**< R/W - in unit of byte */
		uint32_t ecmp_en                     : 1;  /**< R/W - Enable ECMP, applicable only for LPM search command. */
		uint32_t ecmp_hash_byte_start        : 6;  /**< R/W - rout_idx is always 2-byte long, and it is applicable only for LPM search
                                                                 command. */
		uint32_t hash_way_cnt                : 4;  /**< R/W - Applicable only for hash search command. */
		uint32_t adm_id                      : 4;  /**< R/W - see same field of xp_se_lde_search_command register (URW/MRE only do direct
                                                                 lookups). */
#else
		uint32_t adm_id                      : 4;
		uint32_t hash_way_cnt                : 4;
		uint32_t ecmp_hash_byte_start        : 6;
		uint32_t ecmp_en                     : 1;
		uint32_t key_size                    : 6;
		uint32_t key_byte_bmp                : 11;
#endif
	} s;
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w0_s cn88xx; */
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w0_s cn88xxp1; */
} bdk_tns_se_urwcmdx_srch_cmdx_w0_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 63)))
		return 0x0000842056105000ull + (param1 & 1) * 0x1000ull + (param2 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(...) bdk_tns_se_urwcmdx_srch_cmdx_w0_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(p1,p2) (p1)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W0(...) "TNS_SE_URWCMDX_SRCH_CMDX_W0"


/**
 * NCB32b - tns_se_urwcmd#_srch_cmd#_w1
 *
 * Continuation of structure defined in TNS_SE_URWCMD(0..1)_SRCH_CMD(0..63)_W0
 *
 */
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w1 {
	uint32_t u;
	struct bdk_tns_se_urwcmdx_srch_cmdx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key_byte_bmp                : 32; /**< R/W - Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else
		uint32_t key_byte_bmp                : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w1_s cn88xx; */
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w1_s cn88xxp1; */
} bdk_tns_se_urwcmdx_srch_cmdx_w1_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 63)))
		return 0x0000842056105004ull + (param1 & 1) * 0x1000ull + (param2 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(...) bdk_tns_se_urwcmdx_srch_cmdx_w1_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(p1,p2) (p1)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W1(...) "TNS_SE_URWCMDX_SRCH_CMDX_W1"


/**
 * NCB32b - tns_se_urwcmd#_srch_cmd#_w2
 *
 * Continuation of structure defined in TNS_SE_URWCMD(0..1)_SRCH_CMD(0..63)_W0
 *
 */
typedef union bdk_tns_se_urwcmdx_srch_cmdx_w2 {
	uint32_t u;
	struct bdk_tns_se_urwcmdx_srch_cmdx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_25_31              : 7;
		uint32_t lpm_load_balance            : 1;  /**< R/W - Not used for URW command, retained to be format compatible with
                                                                 xp_se_lde_search_command */
		uint32_t table_id                    : 8;  /**< R/W - Allowed value: 128-159, direct access only
                                                                 Table ID determines search command type as well as the exact table
                                                                 configuration
                                                                 There are only 32 table defined for URW and MRE, the higher-bits of
                                                                 table_id are used to identify */
		uint32_t rslt_qw_start               : 5;  /**< R/W - The total result of a profile is maximum 512-bit, divided into 8 64-bit quad-
                                                                 word
                                                                 The result for this search command is quad-word qw_start to
                                                                 qw_start+qw_inc, inclusive
                                                                 For URWVIF, there are 8 physical result lanes, maximum 16 QW, the
                                                                 restrictions are:
                                                                 1. for 512-bit result, rslt_qw_start can only be 0 or 8.
                                                                 2. for 256-bit result, rslt_qw_start can only be 0, 4, 8 or 12.
                                                                 3. for 128-bit result, rslt_qw_start can NOT be 3, 7 or 11.
                                                                 4. No restriction for 64 or 32-bit return data. */
		uint32_t rslt_qw_inc                 : 4;  /**< R/W - -- */
		uint32_t regrettable                 : 1;  /**< R/W - a regrettable search command may return sorry only if SE experiences
                                                                 congestions. */
		uint32_t age_en                      : 1;  /**< R/W - enable age marking of the entry if hit */
		uint32_t key_byte_bmp                : 5;  /**< R/W - Continuation of MSBs of field KEY_BYTE_BMP from previous word. */
#else
		uint32_t key_byte_bmp                : 5;
		uint32_t age_en                      : 1;
		uint32_t regrettable                 : 1;
		uint32_t rslt_qw_inc                 : 4;
		uint32_t rslt_qw_start               : 5;
		uint32_t table_id                    : 8;
		uint32_t lpm_load_balance            : 1;
		uint32_t reserved_25_31              : 7;
#endif
	} s;
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w2_s cn88xx; */
	/* struct bdk_tns_se_urwcmdx_srch_cmdx_w2_s cn88xxp1; */
} bdk_tns_se_urwcmdx_srch_cmdx_w2_t;

static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1)) && ((param2 <= 63)))
		return 0x0000842056105008ull + (param1 & 1) * 0x1000ull + (param2 & 63) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(...) bdk_tns_se_urwcmdx_srch_cmdx_w2_t
#define bustype_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(p1,p2) (p1)
#define arguments_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_SE_URWCMDX_SRCH_CMDX_W2(...) "TNS_SE_URWCMDX_SRCH_CMDX_W2"


/**
 * NCB32b - tns_se_urwif_dbg
 *
 * --
 *
 */
typedef union bdk_tns_se_urwif_dbg {
	uint32_t u;
	struct bdk_tns_se_urwif_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t intf_bypass                 : 9;  /**< R/W - if set, the corresponding interface immediately return miss for all commands */
		uint32_t intf_disable                : 9;  /**< R/W - if set, the corresponding interface desert req_fc_n and rejecting all future
                                                                 requests */
		uint32_t req_log                     : 4;  /**< R/W - Status register to log last search reuqest from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
		uint32_t rslt_log                    : 4;  /**< R/W - Status register to log last returned search result from that interface
                                                                 0-3 for URW INS interface
                                                                 4-7 for URW VIF interface
                                                                 8 for MRE interface */
#else
		uint32_t rslt_log                    : 4;
		uint32_t req_log                     : 4;
		uint32_t intf_disable                : 9;
		uint32_t intf_bypass                 : 9;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_se_urwif_dbg_s      cn88xx; */
	/* struct bdk_tns_se_urwif_dbg_s      cn88xxp1; */
} bdk_tns_se_urwif_dbg_t;

#define BDK_TNS_SE_URWIF_DBG BDK_TNS_SE_URWIF_DBG_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_DBG_FUNC(void)
{
	return 0x0000842056100000ull;
}
#define typedef_BDK_TNS_SE_URWIF_DBG bdk_tns_se_urwif_dbg_t
#define bustype_BDK_TNS_SE_URWIF_DBG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_DBG 0
#define arguments_BDK_TNS_SE_URWIF_DBG -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_DBG "TNS_SE_URWIF_DBG"


/**
 * NCB32b - tns_se_urwif_dbg_sel
 *
 * --
 *
 */
typedef union bdk_tns_se_urwif_dbg_sel {
	uint32_t u;
	struct bdk_tns_se_urwif_dbg_sel_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t urwif_dbg_sel               : 32; /**< R/W - SW should set this to 0, if dbg_sels in other blocks are set to select debug
                                                                 signals to OCLA */
#else
		uint32_t urwif_dbg_sel               : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_dbg_sel_s  cn88xx; */
	/* struct bdk_tns_se_urwif_dbg_sel_s  cn88xxp1; */
} bdk_tns_se_urwif_dbg_sel_t;

#define BDK_TNS_SE_URWIF_DBG_SEL BDK_TNS_SE_URWIF_DBG_SEL_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_DBG_SEL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_DBG_SEL_FUNC(void)
{
	return 0x0000842056100074ull;
}
#define typedef_BDK_TNS_SE_URWIF_DBG_SEL bdk_tns_se_urwif_dbg_sel_t
#define bustype_BDK_TNS_SE_URWIF_DBG_SEL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_DBG_SEL 0
#define arguments_BDK_TNS_SE_URWIF_DBG_SEL -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_DBG_SEL "TNS_SE_URWIF_DBG_SEL"


/**
 * NCB32b - tns_se_urwif_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_se_urwif_lock {
	uint32_t u;
	struct bdk_tns_se_urwif_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_lock_s     cn88xx; */
	/* struct bdk_tns_se_urwif_lock_s     cn88xxp1; */
} bdk_tns_se_urwif_lock_t;

#define BDK_TNS_SE_URWIF_LOCK BDK_TNS_SE_URWIF_LOCK_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_LOCK_FUNC(void)
{
	return 0x0000842056100078ull;
}
#define typedef_BDK_TNS_SE_URWIF_LOCK bdk_tns_se_urwif_lock_t
#define bustype_BDK_TNS_SE_URWIF_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_LOCK 0
#define arguments_BDK_TNS_SE_URWIF_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_LOCK "TNS_SE_URWIF_LOCK"


/**
 * NCB32b - tns_se_urwif_req_dbg_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_urwif_req_dbg_w0 {
	uint32_t u;
	struct bdk_tns_se_urwif_req_dbg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 7;  /**< RO/H - -- */
		uint32_t req_id                      : 6;  /**< RO/H - -- */
		uint32_t unused_tmp                  : 19; /**< RO/H - -- */
#else
		uint32_t unused_tmp                  : 19;
		uint32_t req_id                      : 6;
		uint32_t key                         : 7;
#endif
	} s;
	/* struct bdk_tns_se_urwif_req_dbg_w0_s cn88xx; */
	/* struct bdk_tns_se_urwif_req_dbg_w0_s cn88xxp1; */
} bdk_tns_se_urwif_req_dbg_w0_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W0 BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W0_FUNC(void)
{
	return 0x0000842056100004ull;
}
#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W0 bdk_tns_se_urwif_req_dbg_w0_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W0 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W0 "TNS_SE_URWIF_REQ_DBG_W0"


/**
 * NCB32b - tns_se_urwif_req_dbg_w1
 *
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_urwif_req_dbg_w1 {
	uint32_t u;
	struct bdk_tns_se_urwif_req_dbg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_req_dbg_w1_s cn88xx; */
	/* struct bdk_tns_se_urwif_req_dbg_w1_s cn88xxp1; */
} bdk_tns_se_urwif_req_dbg_w1_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W1 BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W1_FUNC(void)
{
	return 0x0000842056100008ull;
}
#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W1 bdk_tns_se_urwif_req_dbg_w1_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W1 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W1 "TNS_SE_URWIF_REQ_DBG_W1"


/**
 * NCB32b - tns_se_urwif_req_dbg_w2
 *
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_urwif_req_dbg_w2 {
	uint32_t u;
	struct bdk_tns_se_urwif_req_dbg_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t key                         : 32; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_req_dbg_w2_s cn88xx; */
	/* struct bdk_tns_se_urwif_req_dbg_w2_s cn88xxp1; */
} bdk_tns_se_urwif_req_dbg_w2_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W2 BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W2_FUNC(void)
{
	return 0x000084205610000Cull;
}
#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W2 bdk_tns_se_urwif_req_dbg_w2_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W2 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W2 -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W2 "TNS_SE_URWIF_REQ_DBG_W2"


/**
 * NCB32b - tns_se_urwif_req_dbg_w3
 *
 * Continuation of structure defined in TNS_SE_URWIF_REQ_DBG_W0
 *
 */
typedef union bdk_tns_se_urwif_req_dbg_w3 {
	uint32_t u;
	struct bdk_tns_se_urwif_req_dbg_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t profile_id                  : 7;  /**< RO/H - -- */
		uint32_t key                         : 25; /**< RO/H - Continuation of MSBs of field KEY from previous word. */
#else
		uint32_t key                         : 25;
		uint32_t profile_id                  : 7;
#endif
	} s;
	/* struct bdk_tns_se_urwif_req_dbg_w3_s cn88xx; */
	/* struct bdk_tns_se_urwif_req_dbg_w3_s cn88xxp1; */
} bdk_tns_se_urwif_req_dbg_w3_t;

#define BDK_TNS_SE_URWIF_REQ_DBG_W3 BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_REQ_DBG_W3_FUNC(void)
{
	return 0x0000842056100010ull;
}
#define typedef_BDK_TNS_SE_URWIF_REQ_DBG_W3 bdk_tns_se_urwif_req_dbg_w3_t
#define bustype_BDK_TNS_SE_URWIF_REQ_DBG_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_REQ_DBG_W3 0
#define arguments_BDK_TNS_SE_URWIF_REQ_DBG_W3 -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_REQ_DBG_W3 "TNS_SE_URWIF_REQ_DBG_W3"


/**
 * NCB32b - tns_se_urwif_rslt_dbg#_w0
 *
 * --
 *
 */
typedef union bdk_tns_se_urwif_rslt_dbgx_w0 {
	uint32_t u;
	struct bdk_tns_se_urwif_rslt_dbgx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO/H - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_rslt_dbgx_w0_s cn88xx; */
	/* struct bdk_tns_se_urwif_rslt_dbgx_w0_s cn88xxp1; */
} bdk_tns_se_urwif_rslt_dbgx_w0_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W0(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056100014ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWIF_RSLT_DBGX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(...) bdk_tns_se_urwif_rslt_dbgx_w0_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(p1) (p1)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W0(...) "TNS_SE_URWIF_RSLT_DBGX_W0"


/**
 * NCB32b - tns_se_urwif_rslt_dbg#_w1
 *
 * Continuation of structure defined in TNS_SE_URWIF_RSLT_DBG(0..7)_W0
 *
 */
typedef union bdk_tns_se_urwif_rslt_dbgx_w1 {
	uint32_t u;
	struct bdk_tns_se_urwif_rslt_dbgx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< RO/H - Continuation of MSBs of field DATA from previous word. */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_rslt_dbgx_w1_s cn88xx; */
	/* struct bdk_tns_se_urwif_rslt_dbgx_w1_s cn88xxp1; */
} bdk_tns_se_urwif_rslt_dbgx_w1_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W1(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x0000842056100018ull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWIF_RSLT_DBGX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(...) bdk_tns_se_urwif_rslt_dbgx_w1_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(p1) (p1)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W1(...) "TNS_SE_URWIF_RSLT_DBGX_W1"


/**
 * NCB32b - tns_se_urwif_rslt_dbg#_w2
 *
 * Continuation of structure defined in TNS_SE_URWIF_RSLT_DBG(0..7)_W0
 *
 */
typedef union bdk_tns_se_urwif_rslt_dbgx_w2 {
	uint32_t u;
	struct bdk_tns_se_urwif_rslt_dbgx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t req_id                      : 6;  /**< RO/H - -- */
		uint32_t sorry                       : 1;  /**< RO/H - -- */
		uint32_t hit                         : 1;  /**< RO/H - -- */
		uint32_t hit_addr                    : 24; /**< RO/H - -- */
#else
		uint32_t hit_addr                    : 24;
		uint32_t hit                         : 1;
		uint32_t sorry                       : 1;
		uint32_t req_id                      : 6;
#endif
	} s;
	/* struct bdk_tns_se_urwif_rslt_dbgx_w2_s cn88xx; */
	/* struct bdk_tns_se_urwif_rslt_dbgx_w2_s cn88xxp1; */
} bdk_tns_se_urwif_rslt_dbgx_w2_t;

static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_RSLT_DBGX_W2(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x000084205610001Cull + (param1 & 7) * 0xCull;
	csr_fatal("BDK_TNS_SE_URWIF_RSLT_DBGX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(...) bdk_tns_se_urwif_rslt_dbgx_w2_t
#define bustype_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(p1) (p1)
#define arguments_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_RSLT_DBGX_W2(...) "TNS_SE_URWIF_RSLT_DBGX_W2"


/**
 * NCB32b - tns_se_urwif_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_se_urwif_spad {
	uint32_t u;
	struct bdk_tns_se_urwif_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_se_urwif_spad_s     cn88xx; */
	/* struct bdk_tns_se_urwif_spad_s     cn88xxp1; */
} bdk_tns_se_urwif_spad_t;

#define BDK_TNS_SE_URWIF_SPAD BDK_TNS_SE_URWIF_SPAD_FUNC()
static inline uint64_t BDK_TNS_SE_URWIF_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_SE_URWIF_SPAD_FUNC(void)
{
	return 0x000084205610007Cull;
}
#define typedef_BDK_TNS_SE_URWIF_SPAD bdk_tns_se_urwif_spad_t
#define bustype_BDK_TNS_SE_URWIF_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_SE_URWIF_SPAD 0
#define arguments_BDK_TNS_SE_URWIF_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_SE_URWIF_SPAD "TNS_SE_URWIF_SPAD"


/**
 * NCB - tns_txq_cfg_spare
 *
 * Spare register with default signature value 0x210FEDCBA9876543 after reset.
 *
 */
typedef union bdk_tns_txq_cfg_spare {
	uint64_t u;
	struct bdk_tns_txq_cfg_spare_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_0_63               : 64;
#else
		uint64_t reserved_0_63               : 64;
#endif
	} s;
	/* struct bdk_tns_txq_cfg_spare_s     cn88xx; */
	/* struct bdk_tns_txq_cfg_spare_s     cn88xxp1; */
} bdk_tns_txq_cfg_spare_t;

#define BDK_TNS_TXQ_CFG_SPARE BDK_TNS_TXQ_CFG_SPARE_FUNC()
static inline uint64_t BDK_TNS_TXQ_CFG_SPARE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CFG_SPARE_FUNC(void)
{
	return 0x0000842070684910ull;
}
#define typedef_BDK_TNS_TXQ_CFG_SPARE bdk_tns_txq_cfg_spare_t
#define bustype_BDK_TNS_TXQ_CFG_SPARE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CFG_SPARE 0
#define arguments_BDK_TNS_TXQ_CFG_SPARE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CFG_SPARE "TNS_TXQ_CFG_SPARE"


/**
 * NCB32b - tns_txq_cnt_ct_go_neg_cfg
 *
 * Configuration to allow counters to go negative or saturate at 0 in RTL.
 * Setting to '1' allows the counter to go negative
 */
typedef union bdk_tns_txq_cnt_ct_go_neg_cfg {
	uint32_t u;
	struct bdk_tns_txq_cnt_ct_go_neg_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t q_length_negative           : 1;  /**< R/W - -- */
		uint32_t h1_length_negative          : 1;  /**< R/W - -- */
		uint32_t pt_length_negative          : 1;  /**< R/W - -- */
		uint32_t pfc_mc_ct_negative          : 1;  /**< R/W - -- */
		uint32_t pfc_cluster_ct_negative     : 1;  /**< R/W - -- */
		uint32_t pfc_tc_ct_negative          : 1;  /**< R/W - -- */
		uint32_t pfc_ct_negative             : 1;  /**< R/W - -- */
#else
		uint32_t pfc_ct_negative             : 1;
		uint32_t pfc_tc_ct_negative          : 1;
		uint32_t pfc_cluster_ct_negative     : 1;
		uint32_t pfc_mc_ct_negative          : 1;
		uint32_t pt_length_negative          : 1;
		uint32_t h1_length_negative          : 1;
		uint32_t q_length_negative           : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_ct_go_neg_cfg_s cn88xx; */
	/* struct bdk_tns_txq_cnt_ct_go_neg_cfg_s cn88xxp1; */
} bdk_tns_txq_cnt_ct_go_neg_cfg_t;

#define BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG_FUNC(void)
{
	return 0x00008420706D9CB4ull;
}
#define typedef_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG bdk_tns_txq_cnt_ct_go_neg_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_CT_GO_NEG_CFG "TNS_TXQ_CNT_CT_GO_NEG_CFG"


/**
 * NCB32b - tns_txq_cnt_ecc_ctl
 *
 * ECC configuration of TxQ Counters memories
 *
 */
typedef union bdk_tns_txq_cnt_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_cnt_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t h1_drop_len_db_ecc          : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 drop length memory */
		uint32_t h1_drop_len_sb_ecc          : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 drop length memory */
		uint32_t h1_drop_len_ecc_dis         : 1;  /**< R/W - Disable ECC for H1 drop length memory */
		uint32_t h1_drop_pkt_db_ecc          : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 drop packet memory */
		uint32_t h1_drop_pkt_sb_ecc          : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 drop packet memory */
		uint32_t h1_drop_pkt_ecc_dis         : 1;  /**< R/W - Disable ECC for H1 drop packet memory */
		uint32_t h1_fwd_len_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 forward length memory */
		uint32_t h1_fwd_len_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 forward length memory */
		uint32_t h1_fwd_len_ecc_dis          : 1;  /**< R/W - Disable ECC for H1 forward length memory */
		uint32_t h1_fwd_pkt_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 forward packet memory */
		uint32_t h1_fwd_pkt_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 forward packet memory */
		uint32_t h1_fwd_pkt_ecc_dis          : 1;  /**< R/W - Disable ECC for H1 forward packet memory */
		uint32_t q_drop_len_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q drop length memory */
		uint32_t q_drop_len_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q drop length memory */
		uint32_t q_drop_len_ecc_dis          : 1;  /**< R/W - Disable ECC for Q drop length memory */
		uint32_t q_drop_pkt_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q drop packet memory */
		uint32_t q_drop_pkt_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q drop packet memory */
		uint32_t q_drop_pkt_ecc_dis          : 1;  /**< R/W - Disable ECC for Q drop packet memory */
		uint32_t q_fwd_len_db_ecc            : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q forward length memory */
		uint32_t q_fwd_len_sb_ecc            : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q forward length memory */
		uint32_t q_fwd_len_ecc_dis           : 1;  /**< R/W - Disable ECC for Q forward length memory */
		uint32_t q_fwd_pkt_db_ecc            : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q forward packet memory */
		uint32_t q_fwd_pkt_sb_ecc            : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q forward packet memory */
		uint32_t q_fwd_pkt_ecc_dis           : 1;  /**< R/W - Disable ECC for Q forward packet memory */
		uint32_t q_old_len_db_ecc            : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q old length memory */
		uint32_t q_old_len_sb_ecc            : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q old length memory */
		uint32_t q_old_len_ecc_dis           : 1;  /**< R/W - Disable ECC for Q old length memory */
		uint32_t q_avg_len_db_ecc            : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q average length memory */
		uint32_t q_avg_len_sb_ecc            : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q average length memory */
		uint32_t q_avg_len_ecc_dis           : 1;  /**< R/W - Disable ECC for Q average length memory */
#else
		uint32_t q_avg_len_ecc_dis           : 1;
		uint32_t q_avg_len_sb_ecc            : 1;
		uint32_t q_avg_len_db_ecc            : 1;
		uint32_t q_old_len_ecc_dis           : 1;
		uint32_t q_old_len_sb_ecc            : 1;
		uint32_t q_old_len_db_ecc            : 1;
		uint32_t q_fwd_pkt_ecc_dis           : 1;
		uint32_t q_fwd_pkt_sb_ecc            : 1;
		uint32_t q_fwd_pkt_db_ecc            : 1;
		uint32_t q_fwd_len_ecc_dis           : 1;
		uint32_t q_fwd_len_sb_ecc            : 1;
		uint32_t q_fwd_len_db_ecc            : 1;
		uint32_t q_drop_pkt_ecc_dis          : 1;
		uint32_t q_drop_pkt_sb_ecc           : 1;
		uint32_t q_drop_pkt_db_ecc           : 1;
		uint32_t q_drop_len_ecc_dis          : 1;
		uint32_t q_drop_len_sb_ecc           : 1;
		uint32_t q_drop_len_db_ecc           : 1;
		uint32_t h1_fwd_pkt_ecc_dis          : 1;
		uint32_t h1_fwd_pkt_sb_ecc           : 1;
		uint32_t h1_fwd_pkt_db_ecc           : 1;
		uint32_t h1_fwd_len_ecc_dis          : 1;
		uint32_t h1_fwd_len_sb_ecc           : 1;
		uint32_t h1_fwd_len_db_ecc           : 1;
		uint32_t h1_drop_pkt_ecc_dis         : 1;
		uint32_t h1_drop_pkt_sb_ecc          : 1;
		uint32_t h1_drop_pkt_db_ecc          : 1;
		uint32_t h1_drop_len_ecc_dis         : 1;
		uint32_t h1_drop_len_sb_ecc          : 1;
		uint32_t h1_drop_len_db_ecc          : 1;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_ecc_ctl_s   cn88xx; */
	/* struct bdk_tns_txq_cnt_ecc_ctl_s   cn88xxp1; */
} bdk_tns_txq_cnt_ecc_ctl_t;

#define BDK_TNS_TXQ_CNT_ECC_CTL BDK_TNS_TXQ_CNT_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_ECC_CTL_FUNC(void)
{
	return 0x00008420706D9C60ull;
}
#define typedef_BDK_TNS_TXQ_CNT_ECC_CTL bdk_tns_txq_cnt_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_CNT_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_CNT_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_ECC_CTL "TNS_TXQ_CNT_ECC_CTL"


/**
 * NCB32b - tns_txq_cnt_frc_gbl_mcfc_off
 *
 * Configuration to force global Multiple copy flow control off
 *
 */
typedef union bdk_tns_txq_cnt_frc_gbl_mcfc_off {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_gbl_mcfc_off_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_gbl_mcfc_off_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_gbl_mcfc_off_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_gbl_mcfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF_FUNC(void)
{
	return 0x00008420706D9DD8ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF bdk_tns_txq_cnt_frc_gbl_mcfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_OFF "TNS_TXQ_CNT_FRC_GBL_MCFC_OFF"


/**
 * NCB32b - tns_txq_cnt_frc_gbl_mcfc_on
 *
 * Configuration to force global Multiple copy flow control on
 *
 */
typedef union bdk_tns_txq_cnt_frc_gbl_mcfc_on {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_gbl_mcfc_on_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_gbl_mcfc_on_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_gbl_mcfc_on_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_gbl_mcfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON_FUNC(void)
{
	return 0x00008420706D9DD4ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON bdk_tns_txq_cnt_frc_gbl_mcfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_GBL_MCFC_ON "TNS_TXQ_CNT_FRC_GBL_MCFC_ON"


/**
 * NCB32b - tns_txq_cnt_frc_pc_pfc_off
 *
 * Configuration to force PFC off per port cluster.  One bit per port
 *
 */
typedef union bdk_tns_txq_cnt_frc_pc_pfc_off {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_pc_pfc_off_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t data                        : 11; /**< R/W - -- */
#else
		uint32_t data                        : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_pc_pfc_off_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_pc_pfc_off_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_pc_pfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF_FUNC(void)
{
	return 0x00008420706D9DC8ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF bdk_tns_txq_cnt_frc_pc_pfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_PC_PFC_OFF "TNS_TXQ_CNT_FRC_PC_PFC_OFF"


/**
 * NCB32b - tns_txq_cnt_frc_pc_pfc_on
 *
 * Configuration to force PFC on per port cluster. One bit per port
 *
 */
typedef union bdk_tns_txq_cnt_frc_pc_pfc_on {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_pc_pfc_on_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t data                        : 11; /**< R/W - -- */
#else
		uint32_t data                        : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_pc_pfc_on_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_pc_pfc_on_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_pc_pfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON_FUNC(void)
{
	return 0x00008420706D9DC4ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON bdk_tns_txq_cnt_frc_pc_pfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_PC_PFC_ON "TNS_TXQ_CNT_FRC_PC_PFC_ON"


/**
 * NCB32b - tns_txq_cnt_frc_pfc_off_w#
 *
 * Configuration to force PFC off per flow control channel. One bit per FC channel
 * Bits 31..16 of registers ending in _W12 are unused.
 */
typedef union bdk_tns_txq_cnt_frc_pfc_off_wx {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_pfc_off_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_pfc_off_wx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_pfc_off_wx_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_pfc_off_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(unsigned long param1)
{
	if (((param1 <= 12)))
		return 0x00008420706D9D90ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(...) bdk_tns_txq_cnt_frc_pfc_off_wx_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_PFC_OFF_WX(...) "TNS_TXQ_CNT_FRC_PFC_OFF_WX"


/**
 * NCB32b - tns_txq_cnt_frc_pfc_on_w#
 *
 * Configuration to force PFC on per flow control channel.  One bit per FC channel
 * Bits 31..16 of registers ending in _W12 are unused.
 */
typedef union bdk_tns_txq_cnt_frc_pfc_on_wx {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_pfc_on_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_pfc_on_wx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_pfc_on_wx_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_pfc_on_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(unsigned long param1)
{
	if (((param1 <= 12)))
		return 0x00008420706D9D5Cull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(...) bdk_tns_txq_cnt_frc_pfc_on_wx_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_PFC_ON_WX(...) "TNS_TXQ_CNT_FRC_PFC_ON_WX"


/**
 * NCB32b - tns_txq_cnt_frc_tc_pfc_off
 *
 * Configuration to force PFC off per traffic class. One bit per TC
 *
 */
typedef union bdk_tns_txq_cnt_frc_tc_pfc_off {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_tc_pfc_off_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W - -- */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_tc_pfc_off_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_tc_pfc_off_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_tc_pfc_off_t;

#define BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF_FUNC(void)
{
	return 0x00008420706D9DD0ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF bdk_tns_txq_cnt_frc_tc_pfc_off_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_TC_PFC_OFF "TNS_TXQ_CNT_FRC_TC_PFC_OFF"


/**
 * NCB32b - tns_txq_cnt_frc_tc_pfc_on
 *
 * Configuration to force PFC on per traffic class.  One bit per TC
 *
 */
typedef union bdk_tns_txq_cnt_frc_tc_pfc_on {
	uint32_t u;
	struct bdk_tns_txq_cnt_frc_tc_pfc_on_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t data                        : 16; /**< R/W - -- */
#else
		uint32_t data                        : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_frc_tc_pfc_on_s cn88xx; */
	/* struct bdk_tns_txq_cnt_frc_tc_pfc_on_s cn88xxp1; */
} bdk_tns_txq_cnt_frc_tc_pfc_on_t;

#define BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON_FUNC(void)
{
	return 0x00008420706D9DCCull;
}
#define typedef_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON bdk_tns_txq_cnt_frc_tc_pfc_on_t
#define bustype_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON 0
#define arguments_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FRC_TC_PFC_ON "TNS_TXQ_CNT_FRC_TC_PFC_ON"


/**
 * NCB32b - tns_txq_cnt_fw_drp_rdclr_cfg
 *
 * Configuration indicating clear on read functionality for packet and packet
 * length forward and drop counters
 */
typedef union bdk_tns_txq_cnt_fw_drp_rdclr_cfg {
	uint32_t u;
	struct bdk_tns_txq_cnt_fw_drp_rdclr_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t fwd_pkt_cnt                 : 1;  /**< R/W - -- */
		uint32_t drop_pkt_cnt                : 1;  /**< R/W - -- */
		uint32_t fwd_len_cnt                 : 1;  /**< R/W - -- */
		uint32_t drop_len_cnt                : 1;  /**< R/W - -- */
#else
		uint32_t drop_len_cnt                : 1;
		uint32_t fwd_len_cnt                 : 1;
		uint32_t drop_pkt_cnt                : 1;
		uint32_t fwd_pkt_cnt                 : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_fw_drp_rdclr_cfg_s cn88xx; */
	/* struct bdk_tns_txq_cnt_fw_drp_rdclr_cfg_s cn88xxp1; */
} bdk_tns_txq_cnt_fw_drp_rdclr_cfg_t;

#define BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG_FUNC(void)
{
	return 0x00008420706D9CB0ull;
}
#define typedef_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG bdk_tns_txq_cnt_fw_drp_rdclr_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_FW_DRP_RDCLR_CFG "TNS_TXQ_CNT_FW_DRP_RDCLR_CFG"


/**
 * NCB32b - tns_txq_cnt_gbl_mc_ct
 *
 * Read/write access to global multi-cast count.
 *
 */
typedef union bdk_tns_txq_cnt_gbl_mc_ct {
	uint32_t u;
	struct bdk_tns_txq_cnt_gbl_mc_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< R/W/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_gbl_mc_ct_s cn88xx; */
	/* struct bdk_tns_txq_cnt_gbl_mc_ct_s cn88xxp1; */
} bdk_tns_txq_cnt_gbl_mc_ct_t;

#define BDK_TNS_TXQ_CNT_GBL_MC_CT BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_CT_FUNC(void)
{
	return 0x00008420706D9D58ull;
}
#define typedef_BDK_TNS_TXQ_CNT_GBL_MC_CT bdk_tns_txq_cnt_gbl_mc_ct_t
#define bustype_BDK_TNS_TXQ_CNT_GBL_MC_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_GBL_MC_CT 0
#define arguments_BDK_TNS_TXQ_CNT_GBL_MC_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_GBL_MC_CT "TNS_TXQ_CNT_GBL_MC_CT"


/**
 * NCB32b - tns_txq_cnt_gbl_mc_thr
 *
 * Provide Xon/Xoff profiles for the global MC count.
 *
 */
typedef union bdk_tns_txq_cnt_gbl_mc_thr {
	uint32_t u;
	struct bdk_tns_txq_cnt_gbl_mc_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t xoff                        : 15; /**< R/W - -- */
		uint32_t xon                         : 15; /**< R/W - -- */
#else
		uint32_t xon                         : 15;
		uint32_t xoff                        : 15;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_gbl_mc_thr_s cn88xx; */
	/* struct bdk_tns_txq_cnt_gbl_mc_thr_s cn88xxp1; */
} bdk_tns_txq_cnt_gbl_mc_thr_t;

#define BDK_TNS_TXQ_CNT_GBL_MC_THR BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_GBL_MC_THR_FUNC(void)
{
	return 0x00008420706D9D54ull;
}
#define typedef_BDK_TNS_TXQ_CNT_GBL_MC_THR bdk_tns_txq_cnt_gbl_mc_thr_t
#define bustype_BDK_TNS_TXQ_CNT_GBL_MC_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_GBL_MC_THR 0
#define arguments_BDK_TNS_TXQ_CNT_GBL_MC_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_GBL_MC_THR "TNS_TXQ_CNT_GBL_MC_THR"


/**
 * NCB32b - tns_txq_cnt_h1_dlcm_ecc_log
 *
 * H1 dropped length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_h1_dlcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_h1_dlcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_dlcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_dlcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_dlcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C6Cull;
}
#define typedef_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG bdk_tns_txq_cnt_h1_dlcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_DLCM_ECC_LOG "TNS_TXQ_CNT_H1_DLCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_h1_dpcm_ecc_log
 *
 * H1 dropped packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_h1_dpcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_h1_dpcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_dpcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_dpcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_dpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C68ull;
}
#define typedef_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG bdk_tns_txq_cnt_h1_dpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_DPCM_ECC_LOG "TNS_TXQ_CNT_H1_DPCM_ECC_LOG"


/**
 * NCB - tns_txq_cnt_h1_drp_len_ct#
 *
 * CPU access to H1 dropped packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_h1_drp_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_h1_drp_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_drp_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_drp_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x00008420706D7800ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(...) bdk_tns_txq_cnt_h1_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_DRP_LEN_CTX(...) "TNS_TXQ_CNT_H1_DRP_LEN_CTX"


/**
 * NCB - tns_txq_cnt_h1_drp_pkt_ct#
 *
 * CPU access to H1 dropped packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_h1_drp_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_h1_drp_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_drp_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_drp_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x00008420706D6800ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(...) bdk_tns_txq_cnt_h1_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_DRP_PKT_CTX(...) "TNS_TXQ_CNT_H1_DRP_PKT_CTX"


/**
 * NCB32b - tns_txq_cnt_h1_flcm_ecc_log
 *
 * H1 forwarded length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_h1_flcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_h1_flcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_flcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_flcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_flcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C74ull;
}
#define typedef_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG bdk_tns_txq_cnt_h1_flcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_FLCM_ECC_LOG "TNS_TXQ_CNT_H1_FLCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_h1_fpcm_ecc_log
 *
 * H1 forwarded packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_h1_fpcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_h1_fpcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_fpcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_fpcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_fpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C70ull;
}
#define typedef_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG bdk_tns_txq_cnt_h1_fpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_FPCM_ECC_LOG "TNS_TXQ_CNT_H1_FPCM_ECC_LOG"


/**
 * NCB - tns_txq_cnt_h1_fw_len_ct#
 *
 * CPU access to H1 forwarded packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_h1_fw_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_h1_fw_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_fw_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_fw_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x00008420706D7000ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(...) bdk_tns_txq_cnt_h1_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_FW_LEN_CTX(...) "TNS_TXQ_CNT_H1_FW_LEN_CTX"


/**
 * NCB - tns_txq_cnt_h1_fw_pkt_ct#
 *
 * CPU access to H1 forwarded packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_h1_fw_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_h1_fw_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_fw_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_fw_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x00008420706D6000ull + (param1 & 255) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(...) bdk_tns_txq_cnt_h1_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_FW_PKT_CTX(...) "TNS_TXQ_CNT_H1_FW_PKT_CTX"


/**
 * NCB32b - tns_txq_cnt_h1_len_ct#
 *
 * CPU access to H1 length counters memory
 *
 */
typedef union bdk_tns_txq_cnt_h1_len_ctx {
	uint32_t u;
	struct bdk_tns_txq_cnt_h1_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t length_count                : 15; /**< R/W - -- */
#else
		uint32_t length_count                : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_h1_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_h1_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_h1_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_H1_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_H1_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x00008420706D8800ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_H1_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_H1_LEN_CTX(...) bdk_tns_txq_cnt_h1_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_H1_LEN_CTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_H1_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_H1_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_H1_LEN_CTX(...) "TNS_TXQ_CNT_H1_LEN_CTX"


/**
 * NCB - tns_txq_cnt_int_en_hi
 *
 * CNT interrupt register
 *
 */
typedef union bdk_tns_txq_cnt_int_en_hi {
	uint64_t u;
	struct bdk_tns_txq_cnt_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t nic_crd_over_thr_err        : 1;  /**< R/W - NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
		uint64_t cluster_ct_rollover_err     : 1;  /**< R/W - Cluster PFC counter rolled over */
		uint64_t tc_ct_rollover_err          : 1;  /**< R/W - Traffic class PFC counter rolled over */
		uint64_t pfc_ct_rollover_err         : 1;  /**< R/W - Per-priority PFC counter rolled over */
		uint64_t q_length_ct_rollover_err    : 1;  /**< R/W - Q page length counter rolled over */
		uint64_t h1_length_ct_rollover_err   : 1;  /**< R/W - H1 page length counter rolled over */
		uint64_t pt_length_ct_rollover_err   : 1;  /**< R/W - Port page length counter rolled over */
		uint64_t global_mc_ct_neg_err        : 1;  /**< R/W - Global MC PFC counter tried to decrement pages to a negative value */
		uint64_t cluster_ct_neg_err          : 1;  /**< R/W - Cluster PFC counter tried to decrement pages to a negative value */
		uint64_t tc_ct_neg_err               : 1;  /**< R/W - Traffic class PFC counter tried to decrement pages to a negative value */
		uint64_t pfc_ct_neg_err              : 1;  /**< R/W - Per-priority PFC counter tried to decrement pages to a negative value */
		uint64_t q_length_ct_neg_err         : 1;  /**< R/W - Q page length counter tried to decrement pages to a negative value */
		uint64_t h1_length_ct_neg_err        : 1;  /**< R/W - H1 page length counter tried to decrement pages to a negative value */
		uint64_t pt_length_ct_neg_err        : 1;  /**< R/W - Port page length counter tried to decrement pages to a negative value */
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - CNT configuration input DFC Rx overflow */
		uint64_t h1_drop_len_db_err          : 1;  /**< R/W - H1 drop length memory double bit ECC interrupt */
		uint64_t h1_drop_len_sb_err          : 1;  /**< R/W - H1 drop length memory single bit ECC interrupt */
		uint64_t h1_drop_pkt_db_err          : 1;  /**< R/W - H1 drop packet memory double bit ECC interrupt */
		uint64_t h1_drop_pkt_sb_err          : 1;  /**< R/W - H1 drop packet memory single bit ECC interrupt */
		uint64_t h1_fwd_len_db_err           : 1;  /**< R/W - H1 forward length memory double bit ECC interrupt */
		uint64_t h1_fwd_len_sb_err           : 1;  /**< R/W - H1 forward length memory single bit ECC interrupt */
		uint64_t h1_fwd_pkt_db_err           : 1;  /**< R/W - H1 forward packet memory double bit ECC interrupt */
		uint64_t h1_fwd_pkt_sb_err           : 1;  /**< R/W - H1 forward packet memory single bit ECC interrupt */
		uint64_t q_drop_len_db_err           : 1;  /**< R/W - Q drop length memory double bit ECC interrupt */
		uint64_t q_drop_len_sb_err           : 1;  /**< R/W - Q drop length memory single bit ECC interrupt */
		uint64_t q_drop_pkt_db_err           : 1;  /**< R/W - Q drop packet memory double bit ECC interrupt */
		uint64_t q_drop_pkt_sb_err           : 1;  /**< R/W - Q drop packet memory single bit ECC interrupt */
		uint64_t q_fwd_len_db_err            : 1;  /**< R/W - Q forward length memory double bit ECC interrupt */
		uint64_t q_fwd_len_sb_err            : 1;  /**< R/W - Q forward length memory single bit ECC interrupt */
		uint64_t q_fwd_pkt_db_err            : 1;  /**< R/W - Q forward packet memory double bit ECC interrupt */
		uint64_t q_fwd_pkt_sb_err            : 1;  /**< R/W - Q forward packet memory single bit ECC interrupt */
		uint64_t q_old_len_db_err            : 1;  /**< R/W - Q old length memory double bit ECC interrupt */
		uint64_t q_old_len_sb_err            : 1;  /**< R/W - Q old length memory single bit ECC interrupt */
		uint64_t q_avg_len_db_err            : 1;  /**< R/W - Q average length memory double bit ECC interrupt */
		uint64_t q_avg_len_sb_err            : 1;  /**< R/W - Q average length memory single bit ECC interrupt */
#else
		uint64_t q_avg_len_sb_err            : 1;
		uint64_t q_avg_len_db_err            : 1;
		uint64_t q_old_len_sb_err            : 1;
		uint64_t q_old_len_db_err            : 1;
		uint64_t q_fwd_pkt_sb_err            : 1;
		uint64_t q_fwd_pkt_db_err            : 1;
		uint64_t q_fwd_len_sb_err            : 1;
		uint64_t q_fwd_len_db_err            : 1;
		uint64_t q_drop_pkt_sb_err           : 1;
		uint64_t q_drop_pkt_db_err           : 1;
		uint64_t q_drop_len_sb_err           : 1;
		uint64_t q_drop_len_db_err           : 1;
		uint64_t h1_fwd_pkt_sb_err           : 1;
		uint64_t h1_fwd_pkt_db_err           : 1;
		uint64_t h1_fwd_len_sb_err           : 1;
		uint64_t h1_fwd_len_db_err           : 1;
		uint64_t h1_drop_pkt_sb_err          : 1;
		uint64_t h1_drop_pkt_db_err          : 1;
		uint64_t h1_drop_len_sb_err          : 1;
		uint64_t h1_drop_len_db_err          : 1;
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint64_t pt_length_ct_neg_err        : 1;
		uint64_t h1_length_ct_neg_err        : 1;
		uint64_t q_length_ct_neg_err         : 1;
		uint64_t pfc_ct_neg_err              : 1;
		uint64_t tc_ct_neg_err               : 1;
		uint64_t cluster_ct_neg_err          : 1;
		uint64_t global_mc_ct_neg_err        : 1;
		uint64_t pt_length_ct_rollover_err   : 1;
		uint64_t h1_length_ct_rollover_err   : 1;
		uint64_t q_length_ct_rollover_err    : 1;
		uint64_t pfc_ct_rollover_err         : 1;
		uint64_t tc_ct_rollover_err          : 1;
		uint64_t cluster_ct_rollover_err     : 1;
		uint64_t nic_crd_over_thr_err        : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_cnt_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_cnt_int_en_hi_t;

#define BDK_TNS_TXQ_CNT_INT_EN_HI BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_HI_FUNC(void)
{
	return 0x00008420706D9C48ull;
}
#define typedef_BDK_TNS_TXQ_CNT_INT_EN_HI bdk_tns_txq_cnt_int_en_hi_t
#define bustype_BDK_TNS_TXQ_CNT_INT_EN_HI BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_CNT_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_INT_EN_HI "TNS_TXQ_CNT_INT_EN_HI"


/**
 * NCB - tns_txq_cnt_int_en_lo
 *
 * CNT interrupt register
 *
 */
typedef union bdk_tns_txq_cnt_int_en_lo {
	uint64_t u;
	struct bdk_tns_txq_cnt_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t nic_crd_over_thr_err        : 1;  /**< R/W - NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
		uint64_t cluster_ct_rollover_err     : 1;  /**< R/W - Cluster PFC counter rolled over */
		uint64_t tc_ct_rollover_err          : 1;  /**< R/W - Traffic class PFC counter rolled over */
		uint64_t pfc_ct_rollover_err         : 1;  /**< R/W - Per-priority PFC counter rolled over */
		uint64_t q_length_ct_rollover_err    : 1;  /**< R/W - Q page length counter rolled over */
		uint64_t h1_length_ct_rollover_err   : 1;  /**< R/W - H1 page length counter rolled over */
		uint64_t pt_length_ct_rollover_err   : 1;  /**< R/W - Port page length counter rolled over */
		uint64_t global_mc_ct_neg_err        : 1;  /**< R/W - Global MC PFC counter tried to decrement pages to a negative value */
		uint64_t cluster_ct_neg_err          : 1;  /**< R/W - Cluster PFC counter tried to decrement pages to a negative value */
		uint64_t tc_ct_neg_err               : 1;  /**< R/W - Traffic class PFC counter tried to decrement pages to a negative value */
		uint64_t pfc_ct_neg_err              : 1;  /**< R/W - Per-priority PFC counter tried to decrement pages to a negative value */
		uint64_t q_length_ct_neg_err         : 1;  /**< R/W - Q page length counter tried to decrement pages to a negative value */
		uint64_t h1_length_ct_neg_err        : 1;  /**< R/W - H1 page length counter tried to decrement pages to a negative value */
		uint64_t pt_length_ct_neg_err        : 1;  /**< R/W - Port page length counter tried to decrement pages to a negative value */
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - CNT configuration input DFC Rx overflow */
		uint64_t h1_drop_len_db_err          : 1;  /**< R/W - H1 drop length memory double bit ECC interrupt */
		uint64_t h1_drop_len_sb_err          : 1;  /**< R/W - H1 drop length memory single bit ECC interrupt */
		uint64_t h1_drop_pkt_db_err          : 1;  /**< R/W - H1 drop packet memory double bit ECC interrupt */
		uint64_t h1_drop_pkt_sb_err          : 1;  /**< R/W - H1 drop packet memory single bit ECC interrupt */
		uint64_t h1_fwd_len_db_err           : 1;  /**< R/W - H1 forward length memory double bit ECC interrupt */
		uint64_t h1_fwd_len_sb_err           : 1;  /**< R/W - H1 forward length memory single bit ECC interrupt */
		uint64_t h1_fwd_pkt_db_err           : 1;  /**< R/W - H1 forward packet memory double bit ECC interrupt */
		uint64_t h1_fwd_pkt_sb_err           : 1;  /**< R/W - H1 forward packet memory single bit ECC interrupt */
		uint64_t q_drop_len_db_err           : 1;  /**< R/W - Q drop length memory double bit ECC interrupt */
		uint64_t q_drop_len_sb_err           : 1;  /**< R/W - Q drop length memory single bit ECC interrupt */
		uint64_t q_drop_pkt_db_err           : 1;  /**< R/W - Q drop packet memory double bit ECC interrupt */
		uint64_t q_drop_pkt_sb_err           : 1;  /**< R/W - Q drop packet memory single bit ECC interrupt */
		uint64_t q_fwd_len_db_err            : 1;  /**< R/W - Q forward length memory double bit ECC interrupt */
		uint64_t q_fwd_len_sb_err            : 1;  /**< R/W - Q forward length memory single bit ECC interrupt */
		uint64_t q_fwd_pkt_db_err            : 1;  /**< R/W - Q forward packet memory double bit ECC interrupt */
		uint64_t q_fwd_pkt_sb_err            : 1;  /**< R/W - Q forward packet memory single bit ECC interrupt */
		uint64_t q_old_len_db_err            : 1;  /**< R/W - Q old length memory double bit ECC interrupt */
		uint64_t q_old_len_sb_err            : 1;  /**< R/W - Q old length memory single bit ECC interrupt */
		uint64_t q_avg_len_db_err            : 1;  /**< R/W - Q average length memory double bit ECC interrupt */
		uint64_t q_avg_len_sb_err            : 1;  /**< R/W - Q average length memory single bit ECC interrupt */
#else
		uint64_t q_avg_len_sb_err            : 1;
		uint64_t q_avg_len_db_err            : 1;
		uint64_t q_old_len_sb_err            : 1;
		uint64_t q_old_len_db_err            : 1;
		uint64_t q_fwd_pkt_sb_err            : 1;
		uint64_t q_fwd_pkt_db_err            : 1;
		uint64_t q_fwd_len_sb_err            : 1;
		uint64_t q_fwd_len_db_err            : 1;
		uint64_t q_drop_pkt_sb_err           : 1;
		uint64_t q_drop_pkt_db_err           : 1;
		uint64_t q_drop_len_sb_err           : 1;
		uint64_t q_drop_len_db_err           : 1;
		uint64_t h1_fwd_pkt_sb_err           : 1;
		uint64_t h1_fwd_pkt_db_err           : 1;
		uint64_t h1_fwd_len_sb_err           : 1;
		uint64_t h1_fwd_len_db_err           : 1;
		uint64_t h1_drop_pkt_sb_err          : 1;
		uint64_t h1_drop_pkt_db_err          : 1;
		uint64_t h1_drop_len_sb_err          : 1;
		uint64_t h1_drop_len_db_err          : 1;
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint64_t pt_length_ct_neg_err        : 1;
		uint64_t h1_length_ct_neg_err        : 1;
		uint64_t q_length_ct_neg_err         : 1;
		uint64_t pfc_ct_neg_err              : 1;
		uint64_t tc_ct_neg_err               : 1;
		uint64_t cluster_ct_neg_err          : 1;
		uint64_t global_mc_ct_neg_err        : 1;
		uint64_t pt_length_ct_rollover_err   : 1;
		uint64_t h1_length_ct_rollover_err   : 1;
		uint64_t q_length_ct_rollover_err    : 1;
		uint64_t pfc_ct_rollover_err         : 1;
		uint64_t tc_ct_rollover_err          : 1;
		uint64_t cluster_ct_rollover_err     : 1;
		uint64_t nic_crd_over_thr_err        : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_cnt_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_cnt_int_en_lo_t;

#define BDK_TNS_TXQ_CNT_INT_EN_LO BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_EN_LO_FUNC(void)
{
	return 0x00008420706D9C50ull;
}
#define typedef_BDK_TNS_TXQ_CNT_INT_EN_LO bdk_tns_txq_cnt_int_en_lo_t
#define bustype_BDK_TNS_TXQ_CNT_INT_EN_LO BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_CNT_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_INT_EN_LO "TNS_TXQ_CNT_INT_EN_LO"


/**
 * NCB - tns_txq_cnt_int_frc
 *
 * CNT interrupt register
 *
 */
typedef union bdk_tns_txq_cnt_int_frc {
	uint64_t u;
	struct bdk_tns_txq_cnt_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t nic_crd_over_thr_err        : 1;  /**< WO - NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
		uint64_t cluster_ct_rollover_err     : 1;  /**< WO - Cluster PFC counter rolled over */
		uint64_t tc_ct_rollover_err          : 1;  /**< WO - Traffic class PFC counter rolled over */
		uint64_t pfc_ct_rollover_err         : 1;  /**< WO - Per-priority PFC counter rolled over */
		uint64_t q_length_ct_rollover_err    : 1;  /**< WO - Q page length counter rolled over */
		uint64_t h1_length_ct_rollover_err   : 1;  /**< WO - H1 page length counter rolled over */
		uint64_t pt_length_ct_rollover_err   : 1;  /**< WO - Port page length counter rolled over */
		uint64_t global_mc_ct_neg_err        : 1;  /**< WO - Global MC PFC counter tried to decrement pages to a negative value */
		uint64_t cluster_ct_neg_err          : 1;  /**< WO - Cluster PFC counter tried to decrement pages to a negative value */
		uint64_t tc_ct_neg_err               : 1;  /**< WO - Traffic class PFC counter tried to decrement pages to a negative value */
		uint64_t pfc_ct_neg_err              : 1;  /**< WO - Per-priority PFC counter tried to decrement pages to a negative value */
		uint64_t q_length_ct_neg_err         : 1;  /**< WO - Q page length counter tried to decrement pages to a negative value */
		uint64_t h1_length_ct_neg_err        : 1;  /**< WO - H1 page length counter tried to decrement pages to a negative value */
		uint64_t pt_length_ct_neg_err        : 1;  /**< WO - Port page length counter tried to decrement pages to a negative value */
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< WO - CNT configuration input DFC Rx overflow */
		uint64_t h1_drop_len_db_err          : 1;  /**< WO - H1 drop length memory double bit ECC interrupt */
		uint64_t h1_drop_len_sb_err          : 1;  /**< WO - H1 drop length memory single bit ECC interrupt */
		uint64_t h1_drop_pkt_db_err          : 1;  /**< WO - H1 drop packet memory double bit ECC interrupt */
		uint64_t h1_drop_pkt_sb_err          : 1;  /**< WO - H1 drop packet memory single bit ECC interrupt */
		uint64_t h1_fwd_len_db_err           : 1;  /**< WO - H1 forward length memory double bit ECC interrupt */
		uint64_t h1_fwd_len_sb_err           : 1;  /**< WO - H1 forward length memory single bit ECC interrupt */
		uint64_t h1_fwd_pkt_db_err           : 1;  /**< WO - H1 forward packet memory double bit ECC interrupt */
		uint64_t h1_fwd_pkt_sb_err           : 1;  /**< WO - H1 forward packet memory single bit ECC interrupt */
		uint64_t q_drop_len_db_err           : 1;  /**< WO - Q drop length memory double bit ECC interrupt */
		uint64_t q_drop_len_sb_err           : 1;  /**< WO - Q drop length memory single bit ECC interrupt */
		uint64_t q_drop_pkt_db_err           : 1;  /**< WO - Q drop packet memory double bit ECC interrupt */
		uint64_t q_drop_pkt_sb_err           : 1;  /**< WO - Q drop packet memory single bit ECC interrupt */
		uint64_t q_fwd_len_db_err            : 1;  /**< WO - Q forward length memory double bit ECC interrupt */
		uint64_t q_fwd_len_sb_err            : 1;  /**< WO - Q forward length memory single bit ECC interrupt */
		uint64_t q_fwd_pkt_db_err            : 1;  /**< WO - Q forward packet memory double bit ECC interrupt */
		uint64_t q_fwd_pkt_sb_err            : 1;  /**< WO - Q forward packet memory single bit ECC interrupt */
		uint64_t q_old_len_db_err            : 1;  /**< WO - Q old length memory double bit ECC interrupt */
		uint64_t q_old_len_sb_err            : 1;  /**< WO - Q old length memory single bit ECC interrupt */
		uint64_t q_avg_len_db_err            : 1;  /**< WO - Q average length memory double bit ECC interrupt */
		uint64_t q_avg_len_sb_err            : 1;  /**< WO - Q average length memory single bit ECC interrupt */
#else
		uint64_t q_avg_len_sb_err            : 1;
		uint64_t q_avg_len_db_err            : 1;
		uint64_t q_old_len_sb_err            : 1;
		uint64_t q_old_len_db_err            : 1;
		uint64_t q_fwd_pkt_sb_err            : 1;
		uint64_t q_fwd_pkt_db_err            : 1;
		uint64_t q_fwd_len_sb_err            : 1;
		uint64_t q_fwd_len_db_err            : 1;
		uint64_t q_drop_pkt_sb_err           : 1;
		uint64_t q_drop_pkt_db_err           : 1;
		uint64_t q_drop_len_sb_err           : 1;
		uint64_t q_drop_len_db_err           : 1;
		uint64_t h1_fwd_pkt_sb_err           : 1;
		uint64_t h1_fwd_pkt_db_err           : 1;
		uint64_t h1_fwd_len_sb_err           : 1;
		uint64_t h1_fwd_len_db_err           : 1;
		uint64_t h1_drop_pkt_sb_err          : 1;
		uint64_t h1_drop_pkt_db_err          : 1;
		uint64_t h1_drop_len_sb_err          : 1;
		uint64_t h1_drop_len_db_err          : 1;
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint64_t pt_length_ct_neg_err        : 1;
		uint64_t h1_length_ct_neg_err        : 1;
		uint64_t q_length_ct_neg_err         : 1;
		uint64_t pfc_ct_neg_err              : 1;
		uint64_t tc_ct_neg_err               : 1;
		uint64_t cluster_ct_neg_err          : 1;
		uint64_t global_mc_ct_neg_err        : 1;
		uint64_t pt_length_ct_rollover_err   : 1;
		uint64_t h1_length_ct_rollover_err   : 1;
		uint64_t q_length_ct_rollover_err    : 1;
		uint64_t pfc_ct_rollover_err         : 1;
		uint64_t tc_ct_rollover_err          : 1;
		uint64_t cluster_ct_rollover_err     : 1;
		uint64_t nic_crd_over_thr_err        : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_int_frc_s   cn88xx; */
	/* struct bdk_tns_txq_cnt_int_frc_s   cn88xxp1; */
} bdk_tns_txq_cnt_int_frc_t;

#define BDK_TNS_TXQ_CNT_INT_FRC BDK_TNS_TXQ_CNT_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_FRC_FUNC(void)
{
	return 0x00008420706D9C58ull;
}
#define typedef_BDK_TNS_TXQ_CNT_INT_FRC bdk_tns_txq_cnt_int_frc_t
#define bustype_BDK_TNS_TXQ_CNT_INT_FRC BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_INT_FRC 0
#define arguments_BDK_TNS_TXQ_CNT_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_INT_FRC "TNS_TXQ_CNT_INT_FRC"


/**
 * NCB - tns_txq_cnt_int_w1c
 *
 * CNT interrupt register
 *
 */
typedef union bdk_tns_txq_cnt_int_w1c {
	uint64_t u;
	struct bdk_tns_txq_cnt_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_35_63              : 29;
		uint64_t nic_crd_over_thr_err        : 1;  /**< R/W1C/H - NIC flow control channel is over the xoff threshold even though credits are
                                                                 being used */
		uint64_t cluster_ct_rollover_err     : 1;  /**< R/W1C/H - Cluster PFC counter rolled over */
		uint64_t tc_ct_rollover_err          : 1;  /**< R/W1C/H - Traffic class PFC counter rolled over */
		uint64_t pfc_ct_rollover_err         : 1;  /**< R/W1C/H - Per-priority PFC counter rolled over */
		uint64_t q_length_ct_rollover_err    : 1;  /**< R/W1C/H - Q page length counter rolled over */
		uint64_t h1_length_ct_rollover_err   : 1;  /**< R/W1C/H - H1 page length counter rolled over */
		uint64_t pt_length_ct_rollover_err   : 1;  /**< R/W1C/H - Port page length counter rolled over */
		uint64_t global_mc_ct_neg_err        : 1;  /**< R/W1C/H - Global MC PFC counter tried to decrement pages to a negative value */
		uint64_t cluster_ct_neg_err          : 1;  /**< R/W1C/H - Cluster PFC counter tried to decrement pages to a negative value */
		uint64_t tc_ct_neg_err               : 1;  /**< R/W1C/H - Traffic class PFC counter tried to decrement pages to a negative value */
		uint64_t pfc_ct_neg_err              : 1;  /**< R/W1C/H - Per-priority PFC counter tried to decrement pages to a negative value */
		uint64_t q_length_ct_neg_err         : 1;  /**< R/W1C/H - Q page length counter tried to decrement pages to a negative value */
		uint64_t h1_length_ct_neg_err        : 1;  /**< R/W1C/H - H1 page length counter tried to decrement pages to a negative value */
		uint64_t pt_length_ct_neg_err        : 1;  /**< R/W1C/H - Port page length counter tried to decrement pages to a negative value */
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W1C/H - CNT configuration input DFC Rx overflow */
		uint64_t h1_drop_len_db_err          : 1;  /**< R/W1C/H - H1 drop length memory double bit ECC interrupt */
		uint64_t h1_drop_len_sb_err          : 1;  /**< R/W1C/H - H1 drop length memory single bit ECC interrupt */
		uint64_t h1_drop_pkt_db_err          : 1;  /**< R/W1C/H - H1 drop packet memory double bit ECC interrupt */
		uint64_t h1_drop_pkt_sb_err          : 1;  /**< R/W1C/H - H1 drop packet memory single bit ECC interrupt */
		uint64_t h1_fwd_len_db_err           : 1;  /**< R/W1C/H - H1 forward length memory double bit ECC interrupt */
		uint64_t h1_fwd_len_sb_err           : 1;  /**< R/W1C/H - H1 forward length memory single bit ECC interrupt */
		uint64_t h1_fwd_pkt_db_err           : 1;  /**< R/W1C/H - H1 forward packet memory double bit ECC interrupt */
		uint64_t h1_fwd_pkt_sb_err           : 1;  /**< R/W1C/H - H1 forward packet memory single bit ECC interrupt */
		uint64_t q_drop_len_db_err           : 1;  /**< R/W1C/H - Q drop length memory double bit ECC interrupt */
		uint64_t q_drop_len_sb_err           : 1;  /**< R/W1C/H - Q drop length memory single bit ECC interrupt */
		uint64_t q_drop_pkt_db_err           : 1;  /**< R/W1C/H - Q drop packet memory double bit ECC interrupt */
		uint64_t q_drop_pkt_sb_err           : 1;  /**< R/W1C/H - Q drop packet memory single bit ECC interrupt */
		uint64_t q_fwd_len_db_err            : 1;  /**< R/W1C/H - Q forward length memory double bit ECC interrupt */
		uint64_t q_fwd_len_sb_err            : 1;  /**< R/W1C/H - Q forward length memory single bit ECC interrupt */
		uint64_t q_fwd_pkt_db_err            : 1;  /**< R/W1C/H - Q forward packet memory double bit ECC interrupt */
		uint64_t q_fwd_pkt_sb_err            : 1;  /**< R/W1C/H - Q forward packet memory single bit ECC interrupt */
		uint64_t q_old_len_db_err            : 1;  /**< R/W1C/H - Q old length memory double bit ECC interrupt */
		uint64_t q_old_len_sb_err            : 1;  /**< R/W1C/H - Q old length memory single bit ECC interrupt */
		uint64_t q_avg_len_db_err            : 1;  /**< R/W1C/H - Q average length memory double bit ECC interrupt */
		uint64_t q_avg_len_sb_err            : 1;  /**< R/W1C/H - Q average length memory single bit ECC interrupt */
#else
		uint64_t q_avg_len_sb_err            : 1;
		uint64_t q_avg_len_db_err            : 1;
		uint64_t q_old_len_sb_err            : 1;
		uint64_t q_old_len_db_err            : 1;
		uint64_t q_fwd_pkt_sb_err            : 1;
		uint64_t q_fwd_pkt_db_err            : 1;
		uint64_t q_fwd_len_sb_err            : 1;
		uint64_t q_fwd_len_db_err            : 1;
		uint64_t q_drop_pkt_sb_err           : 1;
		uint64_t q_drop_pkt_db_err           : 1;
		uint64_t q_drop_len_sb_err           : 1;
		uint64_t q_drop_len_db_err           : 1;
		uint64_t h1_fwd_pkt_sb_err           : 1;
		uint64_t h1_fwd_pkt_db_err           : 1;
		uint64_t h1_fwd_len_sb_err           : 1;
		uint64_t h1_fwd_len_db_err           : 1;
		uint64_t h1_drop_pkt_sb_err          : 1;
		uint64_t h1_drop_pkt_db_err          : 1;
		uint64_t h1_drop_len_sb_err          : 1;
		uint64_t h1_drop_len_db_err          : 1;
		uint64_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint64_t pt_length_ct_neg_err        : 1;
		uint64_t h1_length_ct_neg_err        : 1;
		uint64_t q_length_ct_neg_err         : 1;
		uint64_t pfc_ct_neg_err              : 1;
		uint64_t tc_ct_neg_err               : 1;
		uint64_t cluster_ct_neg_err          : 1;
		uint64_t global_mc_ct_neg_err        : 1;
		uint64_t pt_length_ct_rollover_err   : 1;
		uint64_t h1_length_ct_rollover_err   : 1;
		uint64_t q_length_ct_rollover_err    : 1;
		uint64_t pfc_ct_rollover_err         : 1;
		uint64_t tc_ct_rollover_err          : 1;
		uint64_t cluster_ct_rollover_err     : 1;
		uint64_t nic_crd_over_thr_err        : 1;
		uint64_t reserved_35_63              : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_int_w1c_s   cn88xx; */
	/* struct bdk_tns_txq_cnt_int_w1c_s   cn88xxp1; */
} bdk_tns_txq_cnt_int_w1c_t;

#define BDK_TNS_TXQ_CNT_INT_W1C BDK_TNS_TXQ_CNT_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_INT_W1C_FUNC(void)
{
	return 0x00008420706D9C40ull;
}
#define typedef_BDK_TNS_TXQ_CNT_INT_W1C bdk_tns_txq_cnt_int_w1c_t
#define bustype_BDK_TNS_TXQ_CNT_INT_W1C BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_INT_W1C 0
#define arguments_BDK_TNS_TXQ_CNT_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_INT_W1C "TNS_TXQ_CNT_INT_W1C"


/**
 * NCB32b - tns_txq_cnt_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_cnt_lock {
	uint32_t u;
	struct bdk_tns_txq_cnt_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_lock_s      cn88xx; */
	/* struct bdk_tns_txq_cnt_lock_s      cn88xxp1; */
} bdk_tns_txq_cnt_lock_t;

#define BDK_TNS_TXQ_CNT_LOCK BDK_TNS_TXQ_CNT_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_LOCK_FUNC(void)
{
	return 0x00008420706D9DDCull;
}
#define typedef_BDK_TNS_TXQ_CNT_LOCK bdk_tns_txq_cnt_lock_t
#define bustype_BDK_TNS_TXQ_CNT_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_LOCK 0
#define arguments_BDK_TNS_TXQ_CNT_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_LOCK "TNS_TXQ_CNT_LOCK"


/**
 * NCB - tns_txq_cnt_nic_crd_ov_thr_w#
 *
 * Log the status of flow control channels when any channel goes over the flow
 * control threshold.  The log only occurs when NIC credits are enabled in TNS PFC
 * mode.   In normal operation, the threshold should never be reached, as the NIC
 * flow controls itself with credits.  Log is sticky on first error.  Re-armed
 * after reading.
 */
typedef union bdk_tns_txq_cnt_nic_crd_ov_thr_wx {
	uint64_t u;
	struct bdk_tns_txq_cnt_nic_crd_ov_thr_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t over_threshold              : 64; /**< R/W/H - -- */
#else
		uint64_t over_threshold              : 64;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_nic_crd_ov_thr_wx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_nic_crd_ov_thr_wx_s cn88xxp1; */
} bdk_tns_txq_cnt_nic_crd_ov_thr_wx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x00008420706D9C90ull + (param1 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(...) bdk_tns_txq_cnt_nic_crd_ov_thr_wx_t
#define bustype_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_NIC_CRD_OV_THR_WX(...) "TNS_TXQ_CNT_NIC_CRD_OV_THR_WX"


/**
 * NCB32b - tns_txq_cnt_onthefly_pkt_ct
 *
 * Count of the total number of packets currently in the pipeline between the txq
 * reply to enqueuing operation
 */
typedef union bdk_tns_txq_cnt_onthefly_pkt_ct {
	uint32_t u;
	struct bdk_tns_txq_cnt_onthefly_pkt_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_onthefly_pkt_ct_s cn88xx; */
	/* struct bdk_tns_txq_cnt_onthefly_pkt_ct_s cn88xxp1; */
} bdk_tns_txq_cnt_onthefly_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT_FUNC(void)
{
	return 0x00008420706D9CF0ull;
}
#define typedef_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT bdk_tns_txq_cnt_onthefly_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_ONTHEFLY_PKT_CT "TNS_TXQ_CNT_ONTHEFLY_PKT_CT"


/**
 * NCB32b - tns_txq_cnt_pc_cnt_mem#
 *
 * CPU access to per-port cluster count
 *
 */
typedef union bdk_tns_txq_cnt_pc_cnt_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pc_cnt_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t pc_cnt                      : 15; /**< R/W - -- */
#else
		uint32_t pc_cnt                      : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pc_cnt_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pc_cnt_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_pc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PC_CNT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PC_CNT_MEMX(unsigned long param1)
{
	if (((param1 <= 10)))
		return 0x00008420706D9C00ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PC_CNT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(...) bdk_tns_txq_cnt_pc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PC_CNT_MEMX(...) "TNS_TXQ_CNT_PC_CNT_MEMX"


/**
 * NCB32b - tns_txq_cnt_pc_pfl_mem#
 *
 * CPU access to port cluster profile memory. Provide Xon/Xoff profiles for each
 * of the 11 port clusters.  address 0 corresponds to port cluster 0
 */
typedef union bdk_tns_txq_cnt_pc_pfl_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pc_pfl_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t xon                         : 15; /**< R/W - -- */
		uint32_t xoff                        : 15; /**< R/W - -- */
#else
		uint32_t xoff                        : 15;
		uint32_t xon                         : 15;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pc_pfl_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pc_pfl_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_pc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PC_PFL_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PC_PFL_MEMX(unsigned long param1)
{
	if (((param1 <= 10)))
		return 0x00008420706D9B40ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PC_PFL_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(...) bdk_tns_txq_cnt_pc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PC_PFL_MEMX(...) "TNS_TXQ_CNT_PC_PFL_MEMX"


/**
 * NCB32b - tns_txq_cnt_pfc_cfg
 *
 * PFC mode and NIC Credit Enable Configuration.
 *
 */
typedef union bdk_tns_txq_cnt_pfc_cfg {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t pfc_mode_cfg                : 1;  /**< R/W - -- */
		uint32_t pfc_nic_credits_cfg         : 1;  /**< R/W - -- */
#else
		uint32_t pfc_nic_credits_cfg         : 1;
		uint32_t pfc_mode_cfg                : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_cfg_s   cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_cfg_s   cn88xxp1; */
} bdk_tns_txq_cnt_pfc_cfg_t;

#define BDK_TNS_TXQ_CNT_PFC_CFG BDK_TNS_TXQ_CNT_PFC_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CFG_FUNC(void)
{
	return 0x00008420706D9D24ull;
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_CFG bdk_tns_txq_cnt_pfc_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_CFG "TNS_TXQ_CNT_PFC_CFG"


/**
 * NCB32b - tns_txq_cnt_pfc_cnt_mem#
 *
 * CPU access to PFC counters 400 channels (256 for NIC, 128 for BGX, 16 for CPU)
 *
 */
typedef union bdk_tns_txq_cnt_pfc_cnt_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_cnt_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t pfc_counter                 : 15; /**< R/W - -- */
#else
		uint32_t pfc_counter                 : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_cnt_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_cnt_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(unsigned long param1)
{
	if (((param1 <= 399)))
		return 0x00008420706D8000ull + (param1 & 511) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PFC_CNT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(...) bdk_tns_txq_cnt_pfc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_CNT_MEMX(...) "TNS_TXQ_CNT_PFC_CNT_MEMX"


/**
 * NCB32b - tns_txq_cnt_pfc_hw_init_sta
 *
 * Per memory HW init.  Read for status.  '1' indicates that HW init is completed
 *
 */
typedef union bdk_tns_txq_cnt_pfc_hw_init_sta {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_hw_init_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pfc_cnt_mem_init_done       : 1;  /**< RO/H - -- */
		uint32_t pc_cnt_mem_init_done        : 1;  /**< RO/H - -- */
		uint32_t tc_cnt_mem_init_done        : 1;  /**< RO/H - -- */
#else
		uint32_t tc_cnt_mem_init_done        : 1;
		uint32_t pc_cnt_mem_init_done        : 1;
		uint32_t pfc_cnt_mem_init_done       : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_hw_init_sta_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_hw_init_sta_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_hw_init_sta_t;

#define BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA_FUNC(void)
{
	return 0x00008420706D9CBCull;
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA bdk_tns_txq_cnt_pfc_hw_init_sta_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_HW_INIT_STA "TNS_TXQ_CNT_PFC_HW_INIT_STA"


/**
 * NCB32b - tns_txq_cnt_pfc_pfl_map_mem#
 *
 * CPU access to PFC profile map memory. Maps a PFC profile to each of the 400
 * flow control channels
 */
typedef union bdk_tns_txq_cnt_pfc_pfl_map_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_pfl_map_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t pfc_profile                 : 6;  /**< R/W - -- */
#else
		uint32_t pfc_profile                 : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_pfl_map_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_pfl_map_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_pfl_map_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(unsigned long param1)
{
	if (((param1 <= 399)))
		return 0x00008420706D9000ull + (param1 & 511) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(...) bdk_tns_txq_cnt_pfc_pfl_map_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_PFL_MAP_MEMX(...) "TNS_TXQ_CNT_PFC_PFL_MAP_MEMX"


/**
 * NCB32b - tns_txq_cnt_pfc_pfl_mem#
 *
 * CPU access to PFC profile memory. Provide Xon/Xoff profiles for the PFC
 * channels.  Each channel is assigned one of the 64 profiles to determine its
 * xon/xoff thresholds.
 */
typedef union bdk_tns_txq_cnt_pfc_pfl_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_pfl_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t xon                         : 15; /**< R/W - -- */
		uint32_t xoff                        : 15; /**< R/W - -- */
#else
		uint32_t xoff                        : 15;
		uint32_t xon                         : 15;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_pfl_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_pfl_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x00008420706D9800ull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PFC_PFL_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(...) bdk_tns_txq_cnt_pfc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_PFL_MEMX(...) "TNS_TXQ_CNT_PFC_PFL_MEMX"


/**
 * NCB32b - tns_txq_cnt_pfc_pt_clus_cfg#
 *
 * Configuration to assign port to a port cluster.  A registers exists for each
 * port to assign to a port cluster.  Port cluster values 0-10 are valid.
 */
typedef union bdk_tns_txq_cnt_pfc_pt_clus_cfgx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_pt_clus_cfgx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t pt_cluster                  : 4;  /**< R/W - -- */
#else
		uint32_t pt_cluster                  : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_pt_clus_cfgx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_pt_clus_cfgx_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_pt_clus_cfgx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(unsigned long param1)
{
	if (((param1 <= 10)))
		return 0x00008420706D9D28ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(...) bdk_tns_txq_cnt_pfc_pt_clus_cfgx_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_PT_CLUS_CFGX(...) "TNS_TXQ_CNT_PFC_PT_CLUS_CFGX"


/**
 * NCB32b - tns_txq_cnt_pfc_rst_cfg
 *
 * Reset configuration to auto-initialize counters in PFC block and start various
 * modules within TBM
 */
typedef union bdk_tns_txq_cnt_pfc_rst_cfg {
	uint32_t u;
	struct bdk_tns_txq_cnt_pfc_rst_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pfc_hw_auto_init            : 1;  /**< R/W - -- */
		uint32_t pc_hw_auto_init             : 1;  /**< R/W - -- */
		uint32_t tc_hw_auto_init             : 1;  /**< R/W - -- */
#else
		uint32_t tc_hw_auto_init             : 1;
		uint32_t pc_hw_auto_init             : 1;
		uint32_t pfc_hw_auto_init            : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pfc_rst_cfg_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pfc_rst_cfg_s cn88xxp1; */
} bdk_tns_txq_cnt_pfc_rst_cfg_t;

#define BDK_TNS_TXQ_CNT_PFC_RST_CFG BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PFC_RST_CFG_FUNC(void)
{
	return 0x00008420706D9CB8ull;
}
#define typedef_BDK_TNS_TXQ_CNT_PFC_RST_CFG bdk_tns_txq_cnt_pfc_rst_cfg_t
#define bustype_BDK_TNS_TXQ_CNT_PFC_RST_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PFC_RST_CFG 0
#define arguments_BDK_TNS_TXQ_CNT_PFC_RST_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PFC_RST_CFG "TNS_TXQ_CNT_PFC_RST_CFG"


/**
 * NCB - tns_txq_cnt_pt_drp_len_ct#
 *
 * CPU access to port dropped packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_pt_drp_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_pt_drp_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pt_drp_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pt_drp_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_pt_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9A80ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(...) bdk_tns_txq_cnt_pt_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PT_DRP_LEN_CTX(...) "TNS_TXQ_CNT_PT_DRP_LEN_CTX"


/**
 * NCB - tns_txq_cnt_pt_drp_pkt_ct#
 *
 * CPU access to port dropped packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_pt_drp_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_pt_drp_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pt_drp_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pt_drp_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_pt_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9980ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(...) bdk_tns_txq_cnt_pt_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PT_DRP_PKT_CTX(...) "TNS_TXQ_CNT_PT_DRP_PKT_CTX"


/**
 * NCB - tns_txq_cnt_pt_fw_len_ct#
 *
 * CPU access to port forwarded packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_pt_fw_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_pt_fw_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pt_fw_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pt_fw_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_pt_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9A00ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(...) bdk_tns_txq_cnt_pt_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PT_FW_LEN_CTX(...) "TNS_TXQ_CNT_PT_FW_LEN_CTX"


/**
 * NCB - tns_txq_cnt_pt_fw_pkt_ct#
 *
 * CPU access to port forwarded packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_pt_fw_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_pt_fw_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pt_fw_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pt_fw_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_pt_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9900ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(...) bdk_tns_txq_cnt_pt_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PT_FW_PKT_CTX(...) "TNS_TXQ_CNT_PT_FW_PKT_CTX"


/**
 * NCB32b - tns_txq_cnt_pt_len_ct#
 *
 * CPU access to PORT length counters memory
 *
 */
typedef union bdk_tns_txq_cnt_pt_len_ctx {
	uint32_t u;
	struct bdk_tns_txq_cnt_pt_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t length_count                : 15; /**< R/W - -- */
#else
		uint32_t length_count                : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_pt_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_pt_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_pt_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_PT_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_PT_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9B80ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_PT_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_PT_LEN_CTX(...) bdk_tns_txq_cnt_pt_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_PT_LEN_CTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_PT_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_PT_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_PT_LEN_CTX(...) "TNS_TXQ_CNT_PT_LEN_CTX"


/**
 * NCB32b - tns_txq_cnt_q_alcm_ecc_log
 *
 * Q average length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_q_alcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_alcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_alcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_alcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_alcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C88ull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG bdk_tns_txq_cnt_q_alcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_ALCM_ECC_LOG "TNS_TXQ_CNT_Q_ALCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_q_avg_len_ct#
 *
 * CPU access to Q avg_length counters memory
 *
 */
typedef union bdk_tns_txq_cnt_q_avg_len_ctx {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_avg_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t length_count                : 15; /**< R/W - -- */
#else
		uint32_t length_count                : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_avg_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_avg_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_avg_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706D2000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(...) bdk_tns_txq_cnt_q_avg_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_AVG_LEN_CTX(...) "TNS_TXQ_CNT_Q_AVG_LEN_CTX"


/**
 * NCB32b - tns_txq_cnt_q_dlcm_ecc_log
 *
 * Q dropped length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_q_dlcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_dlcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_dlcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_dlcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_dlcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C7Cull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG bdk_tns_txq_cnt_q_dlcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_DLCM_ECC_LOG "TNS_TXQ_CNT_Q_DLCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_q_dpcm_ecc_log
 *
 * Q dropped packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_q_dpcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_dpcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_dpcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_dpcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_dpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C78ull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG bdk_tns_txq_cnt_q_dpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_DPCM_ECC_LOG "TNS_TXQ_CNT_Q_DPCM_ECC_LOG"


/**
 * NCB - tns_txq_cnt_q_drp_len_ct#
 *
 * CPU access to Q dropped packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_q_drp_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_q_drp_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_drp_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_drp_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_drp_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706CC000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(...) bdk_tns_txq_cnt_q_drp_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_DRP_LEN_CTX(...) "TNS_TXQ_CNT_Q_DRP_LEN_CTX"


/**
 * NCB - tns_txq_cnt_q_drp_pkt_ct#
 *
 * CPU access to Q dropped packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_q_drp_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_q_drp_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_drp_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_drp_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_drp_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706C4000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(...) bdk_tns_txq_cnt_q_drp_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_DRP_PKT_CTX(...) "TNS_TXQ_CNT_Q_DRP_PKT_CTX"


/**
 * NCB32b - tns_txq_cnt_q_flcm_ecc_log
 *
 * Q forwarded length ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_q_flcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_flcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_flcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_flcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_flcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C84ull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG bdk_tns_txq_cnt_q_flcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_FLCM_ECC_LOG "TNS_TXQ_CNT_Q_FLCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_q_fpcm_ecc_log
 *
 * Q forwarded packet ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_cnt_q_fpcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_fpcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_fpcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_fpcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_fpcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C80ull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG bdk_tns_txq_cnt_q_fpcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_FPCM_ECC_LOG "TNS_TXQ_CNT_Q_FPCM_ECC_LOG"


/**
 * NCB - tns_txq_cnt_q_fw_len_ct#
 *
 * CPU access to Q forwarded packet byte count memory
 *
 */
typedef union bdk_tns_txq_cnt_q_fw_len_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_q_fw_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_fw_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_fw_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_fw_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706C8000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(...) bdk_tns_txq_cnt_q_fw_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_FW_LEN_CTX(...) "TNS_TXQ_CNT_Q_FW_LEN_CTX"


/**
 * NCB - tns_txq_cnt_q_fw_pkt_ct#
 *
 * CPU access to Q forwarded packet count memory
 *
 */
typedef union bdk_tns_txq_cnt_q_fw_pkt_ctx {
	uint64_t u;
	struct bdk_tns_txq_cnt_q_fw_pkt_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_41_63              : 23;
		uint64_t saturate                    : 1;  /**< R/W - -- */
		uint64_t count                       : 40; /**< R/W - -- */
#else
		uint64_t count                       : 40;
		uint64_t saturate                    : 1;
		uint64_t reserved_41_63              : 23;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_fw_pkt_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_fw_pkt_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_fw_pkt_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706C0000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(...) bdk_tns_txq_cnt_q_fw_pkt_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_FW_PKT_CTX(...) "TNS_TXQ_CNT_Q_FW_PKT_CTX"


/**
 * NCB32b - tns_txq_cnt_q_len_ct#
 *
 * CPU access to Q length counters memory
 *
 */
typedef union bdk_tns_txq_cnt_q_len_ctx {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t length_count                : 15; /**< R/W - -- */
#else
		uint32_t length_count                : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706D0000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_LEN_CTX(...) bdk_tns_txq_cnt_q_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_LEN_CTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_LEN_CTX(...) "TNS_TXQ_CNT_Q_LEN_CTX"


/**
 * NCB32b - tns_txq_cnt_q_olcm_ecc_log
 *
 * Q old length ECC error log.  Address is sticky on first error.  Re-armed after
 * reading
 */
typedef union bdk_tns_txq_cnt_q_olcm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_olcm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_olcm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_olcm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_cnt_q_olcm_ecc_log_t;

#define BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG_FUNC(void)
{
	return 0x00008420706D9C8Cull;
}
#define typedef_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG bdk_tns_txq_cnt_q_olcm_ecc_log_t
#define bustype_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_OLCM_ECC_LOG "TNS_TXQ_CNT_Q_OLCM_ECC_LOG"


/**
 * NCB32b - tns_txq_cnt_q_old_len_ct#
 *
 * CPU access to Q old_length counters memory
 *
 */
typedef union bdk_tns_txq_cnt_q_old_len_ctx {
	uint32_t u;
	struct bdk_tns_txq_cnt_q_old_len_ctx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t length_count                : 15; /**< R/W - -- */
#else
		uint32_t length_count                : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_q_old_len_ctx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_q_old_len_ctx_s cn88xxp1; */
} bdk_tns_txq_cnt_q_old_len_ctx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x00008420706D4000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(...) bdk_tns_txq_cnt_q_old_len_ctx_t
#define bustype_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_Q_OLD_LEN_CTX(...) "TNS_TXQ_CNT_Q_OLD_LEN_CTX"


/**
 * NCB32b - tns_txq_cnt_qac_bist_stdn
 *
 * TxQ QAC bist status and bist_done
 *
 */
typedef union bdk_tns_txq_cnt_qac_bist_stdn {
	uint32_t u;
	struct bdk_tns_txq_cnt_qac_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t q_old_len_mem_status        : 1;  /**< RO/H - -- */
		uint32_t q_avg_len_mem_status        : 1;  /**< RO/H - -- */
		uint32_t q_fwd_pkt_mem_status        : 1;  /**< RO/H - -- */
		uint32_t q_fwd_len_mem_status        : 1;  /**< RO/H - -- */
		uint32_t q_drop_pkt_mem_status       : 1;  /**< RO/H - -- */
		uint32_t q_drop_len_mem_status       : 1;  /**< RO/H - -- */
		uint32_t h1_fwd_pkt_mem_status       : 1;  /**< RO/H - -- */
		uint32_t h1_fwd_len_mem_status       : 1;  /**< RO/H - -- */
		uint32_t h1_drop_pkt_mem_status      : 1;  /**< RO/H - -- */
		uint32_t h1_drop_len_mem_status      : 1;  /**< RO/H - -- */
		uint32_t eq_cfg_mem_status           : 1;  /**< RO/H - -- */
		uint32_t qmap_table_mem_status       : 1;  /**< RO/H - -- */
		uint32_t q_old_len_mem_done          : 1;  /**< RO/H - -- */
		uint32_t q_avg_len_mem_done          : 1;  /**< RO/H - -- */
		uint32_t q_fwd_pkt_mem_done          : 1;  /**< RO/H - -- */
		uint32_t q_fwd_len_mem_done          : 1;  /**< RO/H - -- */
		uint32_t q_drop_pkt_mem_done         : 1;  /**< RO/H - -- */
		uint32_t q_drop_len_mem_done         : 1;  /**< RO/H - -- */
		uint32_t h1_fwd_pkt_mem_done         : 1;  /**< RO/H - -- */
		uint32_t h1_fwd_len_mem_done         : 1;  /**< RO/H - -- */
		uint32_t h1_drop_pkt_mem_done        : 1;  /**< RO/H - -- */
		uint32_t h1_drop_len_mem_done        : 1;  /**< RO/H - -- */
		uint32_t eq_cfg_mem_done             : 1;  /**< RO/H - -- */
		uint32_t qmap_table_mem_done         : 1;  /**< RO/H - -- */
#else
		uint32_t qmap_table_mem_done         : 1;
		uint32_t eq_cfg_mem_done             : 1;
		uint32_t h1_drop_len_mem_done        : 1;
		uint32_t h1_drop_pkt_mem_done        : 1;
		uint32_t h1_fwd_len_mem_done         : 1;
		uint32_t h1_fwd_pkt_mem_done         : 1;
		uint32_t q_drop_len_mem_done         : 1;
		uint32_t q_drop_pkt_mem_done         : 1;
		uint32_t q_fwd_len_mem_done          : 1;
		uint32_t q_fwd_pkt_mem_done          : 1;
		uint32_t q_avg_len_mem_done          : 1;
		uint32_t q_old_len_mem_done          : 1;
		uint32_t qmap_table_mem_status       : 1;
		uint32_t eq_cfg_mem_status           : 1;
		uint32_t h1_drop_len_mem_status      : 1;
		uint32_t h1_drop_pkt_mem_status      : 1;
		uint32_t h1_fwd_len_mem_status       : 1;
		uint32_t h1_fwd_pkt_mem_status       : 1;
		uint32_t q_drop_len_mem_status       : 1;
		uint32_t q_drop_pkt_mem_status       : 1;
		uint32_t q_fwd_len_mem_status        : 1;
		uint32_t q_fwd_pkt_mem_status        : 1;
		uint32_t q_avg_len_mem_status        : 1;
		uint32_t q_old_len_mem_status        : 1;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_qac_bist_stdn_s cn88xx; */
	/* struct bdk_tns_txq_cnt_qac_bist_stdn_s cn88xxp1; */
} bdk_tns_txq_cnt_qac_bist_stdn_t;

#define BDK_TNS_TXQ_CNT_QAC_BIST_STDN BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_QAC_BIST_STDN_FUNC(void)
{
	return 0x00008420706D9C64ull;
}
#define typedef_BDK_TNS_TXQ_CNT_QAC_BIST_STDN bdk_tns_txq_cnt_qac_bist_stdn_t
#define bustype_BDK_TNS_TXQ_CNT_QAC_BIST_STDN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_QAC_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_CNT_QAC_BIST_STDN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_QAC_BIST_STDN "TNS_TXQ_CNT_QAC_BIST_STDN"


/**
 * NCB32b - tns_txq_cnt_shrd_pkt_len#
 *
 * Count of the total number of pages currently in use by packets stored in the
 * token buffer shared pools
 */
typedef union bdk_tns_txq_cnt_shrd_pkt_lenx {
	uint32_t u;
	struct bdk_tns_txq_cnt_shrd_pkt_lenx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_shrd_pkt_lenx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_shrd_pkt_lenx_s cn88xxp1; */
} bdk_tns_txq_cnt_shrd_pkt_lenx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x00008420706D9CD0ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_SHRD_PKT_LENX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(...) bdk_tns_txq_cnt_shrd_pkt_lenx_t
#define bustype_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_SHRD_PKT_LENX(...) "TNS_TXQ_CNT_SHRD_PKT_LENX"


/**
 * NCB32b - tns_txq_cnt_shrd_pkt_len_max#
 *
 * Limit for the number of pages consumed by each shared pool before full is
 * asserted to AQM
 */
typedef union bdk_tns_txq_cnt_shrd_pkt_len_maxx {
	uint32_t u;
	struct bdk_tns_txq_cnt_shrd_pkt_len_maxx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_shrd_pkt_len_maxx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_shrd_pkt_len_maxx_s cn88xxp1; */
} bdk_tns_txq_cnt_shrd_pkt_len_maxx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(unsigned long param1)
{
	if (((param1 <= 7)))
		return 0x00008420706D9D04ull + (param1 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(...) bdk_tns_txq_cnt_shrd_pkt_len_maxx_t
#define bustype_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX(...) "TNS_TXQ_CNT_SHRD_PKT_LEN_MAXX"


/**
 * NCB32b - tns_txq_cnt_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_cnt_spad {
	uint32_t u;
	struct bdk_tns_txq_cnt_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_spad_s      cn88xx; */
	/* struct bdk_tns_txq_cnt_spad_s      cn88xxp1; */
} bdk_tns_txq_cnt_spad_t;

#define BDK_TNS_TXQ_CNT_SPAD BDK_TNS_TXQ_CNT_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_SPAD_FUNC(void)
{
	return 0x00008420706D9DE0ull;
}
#define typedef_BDK_TNS_TXQ_CNT_SPAD bdk_tns_txq_cnt_spad_t
#define bustype_BDK_TNS_TXQ_CNT_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_SPAD 0
#define arguments_BDK_TNS_TXQ_CNT_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_SPAD "TNS_TXQ_CNT_SPAD"


/**
 * NCB32b - tns_txq_cnt_tc_cnt_mem#
 *
 * CPU access to global per-TC count
 *
 */
typedef union bdk_tns_txq_cnt_tc_cnt_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_tc_cnt_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t tc_global_cnt               : 15; /**< R/W - -- */
#else
		uint32_t tc_global_cnt               : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tc_cnt_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tc_cnt_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_tc_cnt_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_TC_CNT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TC_CNT_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9BC0ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_TC_CNT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(...) bdk_tns_txq_cnt_tc_cnt_memx_t
#define bustype_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TC_CNT_MEMX(...) "TNS_TXQ_CNT_TC_CNT_MEMX"


/**
 * NCB32b - tns_txq_cnt_tc_pfl_mem#
 *
 * CPU access to traffic class  profile memory. Provide Xon/Xoff profiles for each
 * of the 16 PFC  channels.  address 0 corresponds to TC 0
 */
typedef union bdk_tns_txq_cnt_tc_pfl_memx {
	uint32_t u;
	struct bdk_tns_txq_cnt_tc_pfl_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t xon                         : 15; /**< R/W - -- */
		uint32_t xoff                        : 15; /**< R/W - -- */
#else
		uint32_t xoff                        : 15;
		uint32_t xon                         : 15;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tc_pfl_memx_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tc_pfl_memx_s cn88xxp1; */
} bdk_tns_txq_cnt_tc_pfl_memx_t;

static inline uint64_t BDK_TNS_TXQ_CNT_TC_PFL_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TC_PFL_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420706D9B00ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_CNT_TC_PFL_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(...) bdk_tns_txq_cnt_tc_pfl_memx_t
#define bustype_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TC_PFL_MEMX(...) "TNS_TXQ_CNT_TC_PFL_MEMX"


/**
 * NCB32b - tns_txq_cnt_tl_mc_pkt_ct
 *
 * Count of the total number of multi-copy packets currently stored by the switch
 *
 */
typedef union bdk_tns_txq_cnt_tl_mc_pkt_ct {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_mc_pkt_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_mc_pkt_ct_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_mc_pkt_ct_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_mc_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_TL_MC_PKT_CT BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_CT_FUNC(void)
{
	return 0x00008420706D9CC8ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT bdk_tns_txq_cnt_tl_mc_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_MC_PKT_CT "TNS_TXQ_CNT_TL_MC_PKT_CT"


/**
 * NCB32b - tns_txq_cnt_tl_mc_pkt_len
 *
 * Count of the total number of pages currently in use by multi-copy packet
 *
 */
typedef union bdk_tns_txq_cnt_tl_mc_pkt_len {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_mc_pkt_len_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_mc_pkt_len_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_mc_pkt_len_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_mc_pkt_len_t;

#define BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN_FUNC(void)
{
	return 0x00008420706D9CCCull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN bdk_tns_txq_cnt_tl_mc_pkt_len_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_MC_PKT_LEN "TNS_TXQ_CNT_TL_MC_PKT_LEN"


/**
 * NCB32b - tns_txq_cnt_tl_mcpkt_ct_max
 *
 * Limit for the number of MC packet before full is asserted to AQM
 *
 */
typedef union bdk_tns_txq_cnt_tl_mcpkt_ct_max {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_mcpkt_ct_max_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_mcpkt_ct_max_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_mcpkt_ct_max_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_mcpkt_ct_max_t;

#define BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX_FUNC(void)
{
	return 0x00008420706D9CFCull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX bdk_tns_txq_cnt_tl_mcpkt_ct_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_MCPKT_CT_MAX "TNS_TXQ_CNT_TL_MCPKT_CT_MAX"


/**
 * NCB32b - tns_txq_cnt_tl_mcpkt_len_max
 *
 * Limit for the number of pages consumed by MC packets before full is asserted to
 * AQM
 */
typedef union bdk_tns_txq_cnt_tl_mcpkt_len_max {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_mcpkt_len_max_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_mcpkt_len_max_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_mcpkt_len_max_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_mcpkt_len_max_t;

#define BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX_FUNC(void)
{
	return 0x00008420706D9D00ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX bdk_tns_txq_cnt_tl_mcpkt_len_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_MCPKT_LEN_MAX "TNS_TXQ_CNT_TL_MCPKT_LEN_MAX"


/**
 * NCB32b - tns_txq_cnt_tl_pkt_ct
 *
 * Count of the total number of packets currently stored by the switch
 *
 */
typedef union bdk_tns_txq_cnt_tl_pkt_ct {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_pkt_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_pkt_ct_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_pkt_ct_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_pkt_ct_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_CT BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_FUNC(void)
{
	return 0x00008420706D9CC0ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_CT bdk_tns_txq_cnt_tl_pkt_ct_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_CT 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_CT "TNS_TXQ_CNT_TL_PKT_CT"


/**
 * NCB32b - tns_txq_cnt_tl_pkt_ct_max
 *
 * Limit for the number of packets stored before full is asserted to AQM
 *
 */
typedef union bdk_tns_txq_cnt_tl_pkt_ct_max {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_pkt_ct_max_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_pkt_ct_max_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_pkt_ct_max_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_pkt_ct_max_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX_FUNC(void)
{
	return 0x00008420706D9CF4ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX bdk_tns_txq_cnt_tl_pkt_ct_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_CT_MAX "TNS_TXQ_CNT_TL_PKT_CT_MAX"


/**
 * NCB32b - tns_txq_cnt_tl_pkt_len
 *
 * Count of the total number of pages currently in use by the switch
 *
 */
typedef union bdk_tns_txq_cnt_tl_pkt_len {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_pkt_len_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< RO/H - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_pkt_len_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_pkt_len_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_pkt_len_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_LEN BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_FUNC(void)
{
	return 0x00008420706D9CC4ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_LEN bdk_tns_txq_cnt_tl_pkt_len_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_LEN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_LEN 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_LEN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_LEN "TNS_TXQ_CNT_TL_PKT_LEN"


/**
 * NCB32b - tns_txq_cnt_tl_pkt_len_max
 *
 * Limit for the number of pages consumed by all packets before full is asserted
 * to AQM
 */
typedef union bdk_tns_txq_cnt_tl_pkt_len_max {
	uint32_t u;
	struct bdk_tns_txq_cnt_tl_pkt_len_max_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_cnt_tl_pkt_len_max_s cn88xx; */
	/* struct bdk_tns_txq_cnt_tl_pkt_len_max_s cn88xxp1; */
} bdk_tns_txq_cnt_tl_pkt_len_max_t;

#define BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC()
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX_FUNC(void)
{
	return 0x00008420706D9CF8ull;
}
#define typedef_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX bdk_tns_txq_cnt_tl_pkt_len_max_t
#define bustype_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX 0
#define arguments_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_CNT_TL_PKT_LEN_MAX "TNS_TXQ_CNT_TL_PKT_LEN_MAX"


/**
 * NCB32b - tns_txq_dq_bist_stdn
 *
 * TxQ DQ bist status and bist_done
 *
 */
typedef union bdk_tns_txq_dq_bist_stdn {
	uint32_t u;
	struct bdk_tns_txq_dq_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t tb_access_mem_status        : 1;  /**< RO/H - -- */
		uint32_t qcn_qmap_mem_status         : 1;  /**< RO/H - -- */
		uint32_t qcn_mem_status              : 1;  /**< RO/H - -- */
		uint32_t h1_tm_mem_status            : 7;  /**< RO/H - -- */
		uint32_t q_slow_shp_mem_status       : 1;  /**< RO/H - -- */
		uint32_t h1_dwrr_mem_status          : 1;  /**< RO/H - -- */
		uint32_t h1_slow_shp_mem_status      : 1;  /**< RO/H - -- */
		uint32_t pt_dwrr_mem_status          : 1;  /**< RO/H - -- */
		uint32_t tb_access_mem_done          : 1;  /**< RO/H - -- */
		uint32_t qcn_qmap_mem_done           : 1;  /**< RO/H - -- */
		uint32_t qcn_mem_done                : 1;  /**< RO/H - -- */
		uint32_t h1_tm_mem_done              : 7;  /**< RO/H - -- */
		uint32_t q_slow_shp_mem_done         : 1;  /**< RO/H - -- */
		uint32_t h1_dwrr_mem_done            : 1;  /**< RO/H - -- */
		uint32_t h1_slow_shp_mem_done        : 1;  /**< RO/H - -- */
		uint32_t pt_dwrr_mem_done            : 1;  /**< RO/H - -- */
#else
		uint32_t pt_dwrr_mem_done            : 1;
		uint32_t h1_slow_shp_mem_done        : 1;
		uint32_t h1_dwrr_mem_done            : 1;
		uint32_t q_slow_shp_mem_done         : 1;
		uint32_t h1_tm_mem_done              : 7;
		uint32_t qcn_mem_done                : 1;
		uint32_t qcn_qmap_mem_done           : 1;
		uint32_t tb_access_mem_done          : 1;
		uint32_t pt_dwrr_mem_status          : 1;
		uint32_t h1_slow_shp_mem_status      : 1;
		uint32_t h1_dwrr_mem_status          : 1;
		uint32_t q_slow_shp_mem_status       : 1;
		uint32_t h1_tm_mem_status            : 7;
		uint32_t qcn_mem_status              : 1;
		uint32_t qcn_qmap_mem_status         : 1;
		uint32_t tb_access_mem_status        : 1;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_txq_dq_bist_stdn_s  cn88xx; */
	/* struct bdk_tns_txq_dq_bist_stdn_s  cn88xxp1; */
} bdk_tns_txq_dq_bist_stdn_t;

#define BDK_TNS_TXQ_DQ_BIST_STDN BDK_TNS_TXQ_DQ_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BIST_STDN_FUNC(void)
{
	return 0x0000842070488114ull;
}
#define typedef_BDK_TNS_TXQ_DQ_BIST_STDN bdk_tns_txq_dq_bist_stdn_t
#define bustype_BDK_TNS_TXQ_DQ_BIST_STDN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_DQ_BIST_STDN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BIST_STDN "TNS_TXQ_DQ_BIST_STDN"


/**
 * NCB32b - tns_txq_dq_byte_ct_off_w0
 *
 * Byte count offset for port/H1/Q DWRR and SHAPERS.  This byte count is
 * added/subtracted to every packet to account for CRC and IPG (XPH).  We use a
 * per port byte count offset because each port may have a different confguration
 * (e.g. XPH).  Bit 0-7 indicate number of bytes.  Bit 8 indicates positive or
 * negative (1=negative, 0=positive).
 */
typedef union bdk_tns_txq_dq_byte_ct_off_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_byte_ct_off_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t port3_bytes                 : 5;  /**< R/W - -- */
		uint32_t port2_bytes                 : 9;  /**< R/W - -- */
		uint32_t port1_bytes                 : 9;  /**< R/W - -- */
		uint32_t port0_bytes                 : 9;  /**< R/W - -- */
#else
		uint32_t port0_bytes                 : 9;
		uint32_t port1_bytes                 : 9;
		uint32_t port2_bytes                 : 9;
		uint32_t port3_bytes                 : 5;
#endif
	} s;
	/* struct bdk_tns_txq_dq_byte_ct_off_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_byte_ct_off_w0_s cn88xxp1; */
} bdk_tns_txq_dq_byte_ct_off_w0_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0_FUNC(void)
{
	return 0x000084207048811Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 bdk_tns_txq_dq_byte_ct_off_w0_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W0 "TNS_TXQ_DQ_BYTE_CT_OFF_W0"


/**
 * NCB32b - tns_txq_dq_byte_ct_off_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 *
 */
typedef union bdk_tns_txq_dq_byte_ct_off_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_byte_ct_off_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t port7_bytes                 : 1;  /**< R/W - -- */
		uint32_t port6_bytes                 : 9;  /**< R/W - -- */
		uint32_t port5_bytes                 : 9;  /**< R/W - -- */
		uint32_t port4_bytes                 : 9;  /**< R/W - -- */
		uint32_t port3_bytes                 : 4;  /**< R/W - Continuation of MSBs of field PORT3_BYTES from previous word. */
#else
		uint32_t port3_bytes                 : 4;
		uint32_t port4_bytes                 : 9;
		uint32_t port5_bytes                 : 9;
		uint32_t port6_bytes                 : 9;
		uint32_t port7_bytes                 : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_byte_ct_off_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_byte_ct_off_w1_s cn88xxp1; */
} bdk_tns_txq_dq_byte_ct_off_w1_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1_FUNC(void)
{
	return 0x0000842070488120ull;
}
#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 bdk_tns_txq_dq_byte_ct_off_w1_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W1 "TNS_TXQ_DQ_BYTE_CT_OFF_W1"


/**
 * NCB32b - tns_txq_dq_byte_ct_off_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 *
 */
typedef union bdk_tns_txq_dq_byte_ct_off_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_byte_ct_off_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t port10_bytes                : 6;  /**< R/W - -- */
		uint32_t port9_bytes                 : 9;  /**< R/W - -- */
		uint32_t port8_bytes                 : 9;  /**< R/W - -- */
		uint32_t port7_bytes                 : 8;  /**< R/W - Continuation of MSBs of field PORT7_BYTES from previous word. */
#else
		uint32_t port7_bytes                 : 8;
		uint32_t port8_bytes                 : 9;
		uint32_t port9_bytes                 : 9;
		uint32_t port10_bytes                : 6;
#endif
	} s;
	/* struct bdk_tns_txq_dq_byte_ct_off_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_byte_ct_off_w2_s cn88xxp1; */
} bdk_tns_txq_dq_byte_ct_off_w2_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2_FUNC(void)
{
	return 0x0000842070488124ull;
}
#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 bdk_tns_txq_dq_byte_ct_off_w2_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W2 "TNS_TXQ_DQ_BYTE_CT_OFF_W2"


/**
 * NCB32b - tns_txq_dq_byte_ct_off_w3
 *
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 *
 */
typedef union bdk_tns_txq_dq_byte_ct_off_w3 {
	uint32_t u;
	struct bdk_tns_txq_dq_byte_ct_off_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t port14_bytes                : 2;  /**< R/W - -- */
		uint32_t port13_bytes                : 9;  /**< R/W - -- */
		uint32_t port12_bytes                : 9;  /**< R/W - -- */
		uint32_t port11_bytes                : 9;  /**< R/W - -- */
		uint32_t port10_bytes                : 3;  /**< R/W - Continuation of MSBs of field PORT10_BYTES from previous word. */
#else
		uint32_t port10_bytes                : 3;
		uint32_t port11_bytes                : 9;
		uint32_t port12_bytes                : 9;
		uint32_t port13_bytes                : 9;
		uint32_t port14_bytes                : 2;
#endif
	} s;
	/* struct bdk_tns_txq_dq_byte_ct_off_w3_s cn88xx; */
	/* struct bdk_tns_txq_dq_byte_ct_off_w3_s cn88xxp1; */
} bdk_tns_txq_dq_byte_ct_off_w3_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3_FUNC(void)
{
	return 0x0000842070488128ull;
}
#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 bdk_tns_txq_dq_byte_ct_off_w3_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W3 "TNS_TXQ_DQ_BYTE_CT_OFF_W3"


/**
 * NCB32b - tns_txq_dq_byte_ct_off_w4
 *
 * Continuation of structure defined in TNS_TXQ_DQ_BYTE_CT_OFF_W0
 *
 */
typedef union bdk_tns_txq_dq_byte_ct_off_w4 {
	uint32_t u;
	struct bdk_tns_txq_dq_byte_ct_off_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t port15_bytes                : 9;  /**< R/W - -- */
		uint32_t port14_bytes                : 7;  /**< R/W - Continuation of MSBs of field PORT14_BYTES from previous word. */
#else
		uint32_t port14_bytes                : 7;
		uint32_t port15_bytes                : 9;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_byte_ct_off_w4_s cn88xx; */
	/* struct bdk_tns_txq_dq_byte_ct_off_w4_s cn88xxp1; */
} bdk_tns_txq_dq_byte_ct_off_w4_t;

#define BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4_FUNC(void)
{
	return 0x000084207048812Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 bdk_tns_txq_dq_byte_ct_off_w4_t
#define bustype_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 0
#define arguments_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_BYTE_CT_OFF_W4 "TNS_TXQ_DQ_BYTE_CT_OFF_W4"


/**
 * NCB32b - tns_txq_dq_drtbaf_int_en_hi
 *
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 *
 */
typedef union bdk_tns_txq_dq_drtbaf_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_dq_drtbaf_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t dfcr_ovfl                   : 1;  /**< R/W - DQ configuration input DFC Rx overflow */
		uint32_t tbaf_full                   : 1;  /**< R/W - Token Buffer access fifo full error.  Should never happen */
		uint32_t tbaf_dbe                    : 1;  /**< R/W - Token Buffer access fifo memory double bit ECC interrupt */
		uint32_t tbaf_sbe                    : 1;  /**< R/W - Token Buffer access fifo memory single bit ECC interrupt */
#else
		uint32_t tbaf_sbe                    : 1;
		uint32_t tbaf_dbe                    : 1;
		uint32_t tbaf_full                   : 1;
		uint32_t dfcr_ovfl                   : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_drtbaf_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_dq_drtbaf_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_dq_drtbaf_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI_FUNC(void)
{
	return 0x0000842070488108ull;
}
#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI bdk_tns_txq_dq_drtbaf_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_HI "TNS_TXQ_DQ_DRTBAF_INT_EN_HI"


/**
 * NCB32b - tns_txq_dq_drtbaf_int_en_lo
 *
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 *
 */
typedef union bdk_tns_txq_dq_drtbaf_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_dq_drtbaf_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t dfcr_ovfl                   : 1;  /**< R/W - DQ configuration input DFC Rx overflow */
		uint32_t tbaf_full                   : 1;  /**< R/W - Token Buffer access fifo full error.  Should never happen */
		uint32_t tbaf_dbe                    : 1;  /**< R/W - Token Buffer access fifo memory double bit ECC interrupt */
		uint32_t tbaf_sbe                    : 1;  /**< R/W - Token Buffer access fifo memory single bit ECC interrupt */
#else
		uint32_t tbaf_sbe                    : 1;
		uint32_t tbaf_dbe                    : 1;
		uint32_t tbaf_full                   : 1;
		uint32_t dfcr_ovfl                   : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_drtbaf_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_dq_drtbaf_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_dq_drtbaf_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO_FUNC(void)
{
	return 0x000084207048810Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO bdk_tns_txq_dq_drtbaf_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_EN_LO "TNS_TXQ_DQ_DRTBAF_INT_EN_LO"


/**
 * NCB32b - tns_txq_dq_drtbaf_int_frc
 *
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 *
 */
typedef union bdk_tns_txq_dq_drtbaf_int_frc {
	uint32_t u;
	struct bdk_tns_txq_dq_drtbaf_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t dfcr_ovfl                   : 1;  /**< WO - DQ configuration input DFC Rx overflow */
		uint32_t tbaf_full                   : 1;  /**< WO - Token Buffer access fifo full error.  Should never happen */
		uint32_t tbaf_dbe                    : 1;  /**< WO - Token Buffer access fifo memory double bit ECC interrupt */
		uint32_t tbaf_sbe                    : 1;  /**< WO - Token Buffer access fifo memory single bit ECC interrupt */
#else
		uint32_t tbaf_sbe                    : 1;
		uint32_t tbaf_dbe                    : 1;
		uint32_t tbaf_full                   : 1;
		uint32_t dfcr_ovfl                   : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_drtbaf_int_frc_s cn88xx; */
	/* struct bdk_tns_txq_dq_drtbaf_int_frc_s cn88xxp1; */
} bdk_tns_txq_dq_drtbaf_int_frc_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC_FUNC(void)
{
	return 0x0000842070488110ull;
}
#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC bdk_tns_txq_dq_drtbaf_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_FRC "TNS_TXQ_DQ_DRTBAF_INT_FRC"


/**
 * NCB32b - tns_txq_dq_drtbaf_int_w1c
 *
 * DQ DFC Rx FIFO and Token Buffer Access FIFO errors interrupt status register
 *
 */
typedef union bdk_tns_txq_dq_drtbaf_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_dq_drtbaf_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t dfcr_ovfl                   : 1;  /**< R/W1C/H - DQ configuration input DFC Rx overflow */
		uint32_t tbaf_full                   : 1;  /**< R/W1C/H - Token Buffer access fifo full error.  Should never happen */
		uint32_t tbaf_dbe                    : 1;  /**< R/W1C/H - Token Buffer access fifo memory double bit ECC interrupt */
		uint32_t tbaf_sbe                    : 1;  /**< R/W1C/H - Token Buffer access fifo memory single bit ECC interrupt */
#else
		uint32_t tbaf_sbe                    : 1;
		uint32_t tbaf_dbe                    : 1;
		uint32_t tbaf_full                   : 1;
		uint32_t dfcr_ovfl                   : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_drtbaf_int_w1c_s cn88xx; */
	/* struct bdk_tns_txq_dq_drtbaf_int_w1c_s cn88xxp1; */
} bdk_tns_txq_dq_drtbaf_int_w1c_t;

#define BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C_FUNC(void)
{
	return 0x0000842070488104ull;
}
#define typedef_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C bdk_tns_txq_dq_drtbaf_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_DRTBAF_INT_W1C "TNS_TXQ_DQ_DRTBAF_INT_W1C"


/**
 * NCB32b - tns_txq_dq_ecc_ctl
 *
 * ECC configuration of DQ token buffer access memory
 *
 */
typedef union bdk_tns_txq_dq_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_dq_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t tb_access_fifo_db_ecc       : 1;  /**< R/W - Flip 2 bits of ECC syndrome in TB access FIFO memory */
		uint32_t tb_access_fifo_sb_ecc       : 1;  /**< R/W - Flip 1 bit of ECC syndrome in TB access FIFO  memory */
		uint32_t tb_access_fifo_ecc_dis      : 1;  /**< R/W - Disable ECC for TB access FIFO memory */
#else
		uint32_t tb_access_fifo_ecc_dis      : 1;
		uint32_t tb_access_fifo_sb_ecc       : 1;
		uint32_t tb_access_fifo_db_ecc       : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_ecc_ctl_s    cn88xx; */
	/* struct bdk_tns_txq_dq_ecc_ctl_s    cn88xxp1; */
} bdk_tns_txq_dq_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_ECC_CTL BDK_TNS_TXQ_DQ_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_ECC_CTL_FUNC(void)
{
	return 0x0000842070488118ull;
}
#define typedef_BDK_TNS_TXQ_DQ_ECC_CTL bdk_tns_txq_dq_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_ECC_CTL "TNS_TXQ_DQ_ECC_CTL"


/**
 * NCB32b - tns_txq_dq_h1s_dwrr_cst_mem#
 *
 * Q DWRR weights and counters memory
 *
 */
typedef union bdk_tns_txq_dq_h1s_dwrr_cst_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_dwrr_cst_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 24; /**< R/W - -- */
		uint32_t weight                      : 8;  /**< R/W - -- */
#else
		uint32_t weight                      : 8;
		uint32_t count                       : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_dwrr_cst_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_dwrr_cst_memx_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070412000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(...) bdk_tns_txq_dq_h1s_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_DWRR_CST_MEMX(...) "TNS_TXQ_DQ_H1S_DWRR_CST_MEMX"


/**
 * NCB32b - tns_txq_dq_h1s_dwrr_ecc_log
 *
 * H1 scheduler DWRR configuration and state memory ECC error log.  Address is
 * sticky on first error.  Re-armed after reading
 */
typedef union bdk_tns_txq_dq_h1s_dwrr_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_dwrr_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_dwrr_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_dwrr_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_dwrr_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG_FUNC(void)
{
	return 0x000084207041C064ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG bdk_tns_txq_dq_h1s_dwrr_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_DWRR_ECC_LOG "TNS_TXQ_DQ_H1S_DWRR_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_h1s_ecc_ctl
 *
 * ECC configuration of DQ H1 scheduler memories
 *
 */
typedef union bdk_tns_txq_dq_h1s_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_27_31              : 5;
		uint32_t qcn_db_ecc                  : 1;  /**< R/W - Flip 2 bits of ECC syndrome in QCN configuration and state memory */
		uint32_t qcn_sb_ecc                  : 1;  /**< R/W - Flip 1 bit of ECC syndrome in QCN configuration and state  memory */
		uint32_t qcn_ecc_dis                 : 1;  /**< R/W - Disable ECC for QCN configuration and state memory */
		uint32_t qcn_qmap_db_ecc             : 1;  /**< R/W - Flip 2 bits of ECC syndrome in QCN Q mapping memory */
		uint32_t qcn_qmap_sb_ecc             : 1;  /**< R/W - Flip 1 bit of ECC syndrome in QCN Q mapping  memory */
		uint32_t qcn_qmap_ecc_dis            : 1;  /**< R/W - Disable ECC for QCN Q mapping memory */
		uint32_t h1_sch_tm_db_ecc            : 7;  /**< R/W - Flip 2 bits of ECC syndrome in H1 scheduler TM config and state memory */
		uint32_t h1_sch_tm_sb_ecc            : 7;  /**< R/W - Flip 1 bit of ECC syndrome in H1 scheduler TM config and state  memory */
		uint32_t h1_sch_tm_ecc_dis           : 1;  /**< R/W - Disable ECC for H1 scheduler TM config and state memory */
		uint32_t q_slow_shp_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Q slow shaper memory */
		uint32_t q_slow_shp_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Q slow shaper  memory */
		uint32_t q_slow_shp_ecc_dis          : 1;  /**< R/W - Disable ECC for Q slow shaper memory */
		uint32_t h1_sch_dwrr_db_ecc          : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 scheduler DWRR memory */
		uint32_t h1_sch_dwrr_sb_ecc          : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 scheduler DWRR memory */
		uint32_t h1_sch_dwrr_ecc_dis         : 1;  /**< R/W - Disable ECC for H1 scheduler DWRR memory */
#else
		uint32_t h1_sch_dwrr_ecc_dis         : 1;
		uint32_t h1_sch_dwrr_sb_ecc          : 1;
		uint32_t h1_sch_dwrr_db_ecc          : 1;
		uint32_t q_slow_shp_ecc_dis          : 1;
		uint32_t q_slow_shp_sb_ecc           : 1;
		uint32_t q_slow_shp_db_ecc           : 1;
		uint32_t h1_sch_tm_ecc_dis           : 1;
		uint32_t h1_sch_tm_sb_ecc            : 7;
		uint32_t h1_sch_tm_db_ecc            : 7;
		uint32_t qcn_qmap_ecc_dis            : 1;
		uint32_t qcn_qmap_sb_ecc             : 1;
		uint32_t qcn_qmap_db_ecc             : 1;
		uint32_t qcn_ecc_dis                 : 1;
		uint32_t qcn_sb_ecc                  : 1;
		uint32_t qcn_db_ecc                  : 1;
		uint32_t reserved_27_31              : 5;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_ecc_ctl_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_H1S_ECC_CTL BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_ECC_CTL_FUNC(void)
{
	return 0x000084207041C050ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_ECC_CTL bdk_tns_txq_dq_h1s_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_ECC_CTL "TNS_TXQ_DQ_H1S_ECC_CTL"


/**
 * NCB32b - tns_txq_dq_h1s_fshp_i2q#
 *
 * "Q CB shapers fast_update Q \# mapping memory. Maps the index of the fast shaper
 * to the associated Queue"
 */
typedef union bdk_tns_txq_dq_h1s_fshp_i2qx {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_fshp_i2qx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t q_node                      : 11; /**< R/W - -- */
#else
		uint32_t q_node                      : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_fshp_i2qx_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_fshp_i2qx_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_fshp_i2qx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(unsigned long param1)
{
	if (((param1 <= 159)))
		return 0x0000842070419000ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(...) bdk_tns_txq_dq_h1s_fshp_i2qx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_I2QX(...) "TNS_TXQ_DQ_H1S_FSHP_I2QX"


/**
 * NCB32b - tns_txq_dq_h1s_fshp_mem#_w0
 *
 * Q CB shapers fast_update memory
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_fshp_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bucket_size                 : 24; /**< R/W - current token bucket size (in bytes) */
		uint32_t rate_count                  : 8;  /**< R/W - update rate divider count */
#else
		uint32_t rate_count                  : 8;
		uint32_t bucket_size                 : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_fshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 159)))
		return 0x0000842070418000ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(...) bdk_tns_txq_dq_h1s_fshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W0(...) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W0"


/**
 * NCB32b - tns_txq_dq_h1s_fshp_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_FSHP_MEM(0..159)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_fshp_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t enable                      : 1;  /**< R/W - enable */
		uint32_t max_burst_size              : 8;  /**< R/W - shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
		uint32_t tokens_to_add               : 14; /**< R/W - tokens to add per shaper time-wheel (in bytes) */
		uint32_t rate_divider                : 8;  /**< R/W - update rate divider for shaper time-wheel */
		uint32_t bucket_size                 : 1;  /**< R/W - Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else
		uint32_t bucket_size                 : 1;
		uint32_t rate_divider                : 8;
		uint32_t tokens_to_add               : 14;
		uint32_t max_burst_size              : 8;
		uint32_t enable                      : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_fshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 159)))
		return 0x0000842070418004ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(...) bdk_tns_txq_dq_h1s_fshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W1(...) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_h1s_fshp_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_FSHP_MEM(0..159)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_fshp_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_fshp_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t comp_count                  : 19; /**< R/W - current shaper pending compensation count */
#else
		uint32_t comp_count                  : 19;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_fshp_memx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_fshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 159)))
		return 0x0000842070418008ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(...) bdk_tns_txq_dq_h1s_fshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_FSHP_MEMX_W2(...) "TNS_TXQ_DQ_H1S_FSHP_MEMX_W2"


/**
 * NCB32b - tns_txq_dq_h1s_int_en_hi
 *
 * H1 scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_h1s_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t q_fast_shp_neg_wrap_err     : 1;  /**< R/W - Q shaper credits wrapped from negative to positive */
		uint32_t q_slow_shp_neg_wrap_err     : 1;  /**< R/W - Q shaper credits wrapped from negative to positive */
		uint32_t q_pkt_ct_rollover_err       : 1;  /**< R/W - Q packet count rolled over */
		uint32_t q_pkt_ct_neg_err            : 1;  /**< R/W - Q packet count tried to decrement when count was zero */
		uint32_t qcn_mem_db_err              : 1;  /**< R/W - QCN configuration and state memory double bit ECC interrupt */
		uint32_t qcn_mem_sb_err              : 1;  /**< R/W - QCN configuration and state memory single bit ECC interrupt */
		uint32_t qcn_qmap_mem_db_err         : 1;  /**< R/W - QCN Q mapping memory double bit ECC interrupt */
		uint32_t qcn_qmap_mem_sb_err         : 1;  /**< R/W - QCN Q mapping memory single bit ECC interrupt */
		uint32_t h1_sch_tm_mem_db_err        : 7;  /**< R/W - H1 scheduler TM config and state memory double bit ECC interrupt */
		uint32_t h1_sch_tm_mem_sb_err        : 7;  /**< R/W - H1 scheduler TM config and state memory single bit ECC interrupt */
		uint32_t q_slow_shp_mem_db_err       : 1;  /**< R/W - Q slow shaper memory double bit ECC interrupt */
		uint32_t q_slow_shp_mem_sb_err       : 1;  /**< R/W - Q slow shaper memory single bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_db_err      : 1;  /**< R/W - H1 scheduler DWRR memory double bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;  /**< R/W - H1 scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;
		uint32_t h1_sch_dwrr_mem_db_err      : 1;
		uint32_t q_slow_shp_mem_sb_err       : 1;
		uint32_t q_slow_shp_mem_db_err       : 1;
		uint32_t h1_sch_tm_mem_sb_err        : 7;
		uint32_t h1_sch_tm_mem_db_err        : 7;
		uint32_t qcn_qmap_mem_sb_err         : 1;
		uint32_t qcn_qmap_mem_db_err         : 1;
		uint32_t qcn_mem_sb_err              : 1;
		uint32_t qcn_mem_db_err              : 1;
		uint32_t q_pkt_ct_neg_err            : 1;
		uint32_t q_pkt_ct_rollover_err       : 1;
		uint32_t q_slow_shp_neg_wrap_err     : 1;
		uint32_t q_fast_shp_neg_wrap_err     : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_EN_HI BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_HI_FUNC(void)
{
	return 0x000084207041C044ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI bdk_tns_txq_dq_h1s_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_EN_HI "TNS_TXQ_DQ_H1S_INT_EN_HI"


/**
 * NCB32b - tns_txq_dq_h1s_int_en_lo
 *
 * H1 scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_h1s_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t q_fast_shp_neg_wrap_err     : 1;  /**< R/W - Q shaper credits wrapped from negative to positive */
		uint32_t q_slow_shp_neg_wrap_err     : 1;  /**< R/W - Q shaper credits wrapped from negative to positive */
		uint32_t q_pkt_ct_rollover_err       : 1;  /**< R/W - Q packet count rolled over */
		uint32_t q_pkt_ct_neg_err            : 1;  /**< R/W - Q packet count tried to decrement when count was zero */
		uint32_t qcn_mem_db_err              : 1;  /**< R/W - QCN configuration and state memory double bit ECC interrupt */
		uint32_t qcn_mem_sb_err              : 1;  /**< R/W - QCN configuration and state memory single bit ECC interrupt */
		uint32_t qcn_qmap_mem_db_err         : 1;  /**< R/W - QCN Q mapping memory double bit ECC interrupt */
		uint32_t qcn_qmap_mem_sb_err         : 1;  /**< R/W - QCN Q mapping memory single bit ECC interrupt */
		uint32_t h1_sch_tm_mem_db_err        : 7;  /**< R/W - H1 scheduler TM config and state memory double bit ECC interrupt */
		uint32_t h1_sch_tm_mem_sb_err        : 7;  /**< R/W - H1 scheduler TM config and state memory single bit ECC interrupt */
		uint32_t q_slow_shp_mem_db_err       : 1;  /**< R/W - Q slow shaper memory double bit ECC interrupt */
		uint32_t q_slow_shp_mem_sb_err       : 1;  /**< R/W - Q slow shaper memory single bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_db_err      : 1;  /**< R/W - H1 scheduler DWRR memory double bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;  /**< R/W - H1 scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;
		uint32_t h1_sch_dwrr_mem_db_err      : 1;
		uint32_t q_slow_shp_mem_sb_err       : 1;
		uint32_t q_slow_shp_mem_db_err       : 1;
		uint32_t h1_sch_tm_mem_sb_err        : 7;
		uint32_t h1_sch_tm_mem_db_err        : 7;
		uint32_t qcn_qmap_mem_sb_err         : 1;
		uint32_t qcn_qmap_mem_db_err         : 1;
		uint32_t qcn_mem_sb_err              : 1;
		uint32_t qcn_mem_db_err              : 1;
		uint32_t q_pkt_ct_neg_err            : 1;
		uint32_t q_pkt_ct_rollover_err       : 1;
		uint32_t q_slow_shp_neg_wrap_err     : 1;
		uint32_t q_fast_shp_neg_wrap_err     : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_EN_LO BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_EN_LO_FUNC(void)
{
	return 0x000084207041C048ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO bdk_tns_txq_dq_h1s_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_EN_LO "TNS_TXQ_DQ_H1S_INT_EN_LO"


/**
 * NCB32b - tns_txq_dq_h1s_int_frc
 *
 * H1 scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_h1s_int_frc {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t q_fast_shp_neg_wrap_err     : 1;  /**< WO - Q shaper credits wrapped from negative to positive */
		uint32_t q_slow_shp_neg_wrap_err     : 1;  /**< WO - Q shaper credits wrapped from negative to positive */
		uint32_t q_pkt_ct_rollover_err       : 1;  /**< WO - Q packet count rolled over */
		uint32_t q_pkt_ct_neg_err            : 1;  /**< WO - Q packet count tried to decrement when count was zero */
		uint32_t qcn_mem_db_err              : 1;  /**< WO - QCN configuration and state memory double bit ECC interrupt */
		uint32_t qcn_mem_sb_err              : 1;  /**< WO - QCN configuration and state memory single bit ECC interrupt */
		uint32_t qcn_qmap_mem_db_err         : 1;  /**< WO - QCN Q mapping memory double bit ECC interrupt */
		uint32_t qcn_qmap_mem_sb_err         : 1;  /**< WO - QCN Q mapping memory single bit ECC interrupt */
		uint32_t h1_sch_tm_mem_db_err        : 7;  /**< WO - H1 scheduler TM config and state memory double bit ECC interrupt */
		uint32_t h1_sch_tm_mem_sb_err        : 7;  /**< WO - H1 scheduler TM config and state memory single bit ECC interrupt */
		uint32_t q_slow_shp_mem_db_err       : 1;  /**< WO - Q slow shaper memory double bit ECC interrupt */
		uint32_t q_slow_shp_mem_sb_err       : 1;  /**< WO - Q slow shaper memory single bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_db_err      : 1;  /**< WO - H1 scheduler DWRR memory double bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;  /**< WO - H1 scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;
		uint32_t h1_sch_dwrr_mem_db_err      : 1;
		uint32_t q_slow_shp_mem_sb_err       : 1;
		uint32_t q_slow_shp_mem_db_err       : 1;
		uint32_t h1_sch_tm_mem_sb_err        : 7;
		uint32_t h1_sch_tm_mem_db_err        : 7;
		uint32_t qcn_qmap_mem_sb_err         : 1;
		uint32_t qcn_qmap_mem_db_err         : 1;
		uint32_t qcn_mem_sb_err              : 1;
		uint32_t qcn_mem_db_err              : 1;
		uint32_t q_pkt_ct_neg_err            : 1;
		uint32_t q_pkt_ct_rollover_err       : 1;
		uint32_t q_slow_shp_neg_wrap_err     : 1;
		uint32_t q_fast_shp_neg_wrap_err     : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_int_frc_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_int_frc_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_int_frc_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_FRC BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_FRC_FUNC(void)
{
	return 0x000084207041C04Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_FRC bdk_tns_txq_dq_h1s_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_FRC "TNS_TXQ_DQ_H1S_INT_FRC"


/**
 * NCB32b - tns_txq_dq_h1s_int_w1c
 *
 * H1 scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_h1s_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_26_31              : 6;
		uint32_t q_fast_shp_neg_wrap_err     : 1;  /**< R/W1C/H - Q shaper credits wrapped from negative to positive */
		uint32_t q_slow_shp_neg_wrap_err     : 1;  /**< R/W1C/H - Q shaper credits wrapped from negative to positive */
		uint32_t q_pkt_ct_rollover_err       : 1;  /**< R/W1C/H - Q packet count rolled over */
		uint32_t q_pkt_ct_neg_err            : 1;  /**< R/W1C/H - Q packet count tried to decrement when count was zero */
		uint32_t qcn_mem_db_err              : 1;  /**< R/W1C/H - QCN configuration and state memory double bit ECC interrupt */
		uint32_t qcn_mem_sb_err              : 1;  /**< R/W1C/H - QCN configuration and state memory single bit ECC interrupt */
		uint32_t qcn_qmap_mem_db_err         : 1;  /**< R/W1C/H - QCN Q mapping memory double bit ECC interrupt */
		uint32_t qcn_qmap_mem_sb_err         : 1;  /**< R/W1C/H - QCN Q mapping memory single bit ECC interrupt */
		uint32_t h1_sch_tm_mem_db_err        : 7;  /**< R/W1C/H - H1 scheduler TM config and state memory double bit ECC interrupt */
		uint32_t h1_sch_tm_mem_sb_err        : 7;  /**< R/W1C/H - H1 scheduler TM config and state memory single bit ECC interrupt */
		uint32_t q_slow_shp_mem_db_err       : 1;  /**< R/W1C/H - Q slow shaper memory double bit ECC interrupt */
		uint32_t q_slow_shp_mem_sb_err       : 1;  /**< R/W1C/H - Q slow shaper memory single bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_db_err      : 1;  /**< R/W1C/H - H1 scheduler DWRR memory double bit ECC interrupt */
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;  /**< R/W1C/H - H1 scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t h1_sch_dwrr_mem_sb_err      : 1;
		uint32_t h1_sch_dwrr_mem_db_err      : 1;
		uint32_t q_slow_shp_mem_sb_err       : 1;
		uint32_t q_slow_shp_mem_db_err       : 1;
		uint32_t h1_sch_tm_mem_sb_err        : 7;
		uint32_t h1_sch_tm_mem_db_err        : 7;
		uint32_t qcn_qmap_mem_sb_err         : 1;
		uint32_t qcn_qmap_mem_db_err         : 1;
		uint32_t qcn_mem_sb_err              : 1;
		uint32_t qcn_mem_db_err              : 1;
		uint32_t q_pkt_ct_neg_err            : 1;
		uint32_t q_pkt_ct_rollover_err       : 1;
		uint32_t q_slow_shp_neg_wrap_err     : 1;
		uint32_t q_fast_shp_neg_wrap_err     : 1;
		uint32_t reserved_26_31              : 6;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_int_w1c_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_int_w1c_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_int_w1c_t;

#define BDK_TNS_TXQ_DQ_H1S_INT_W1C BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_INT_W1C_FUNC(void)
{
	return 0x000084207041C040ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_INT_W1C bdk_tns_txq_dq_h1s_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_INT_W1C "TNS_TXQ_DQ_H1S_INT_W1C"


/**
 * NCB32b - tns_txq_dq_h1s_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_dq_h1s_lock {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_lock_s   cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_lock_s   cn88xxp1; */
} bdk_tns_txq_dq_h1s_lock_t;

#define BDK_TNS_TXQ_DQ_H1S_LOCK BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_LOCK_FUNC(void)
{
	return 0x000084207041C0A0ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_LOCK bdk_tns_txq_dq_h1s_lock_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_LOCK "TNS_TXQ_DQ_H1S_LOCK"


/**
 * NCB32b - tns_txq_dq_h1s_q_gen_cfg
 *
 * Enable for shapers, DWRR, and slow compensation
 *
 */
typedef union bdk_tns_txq_dq_h1s_q_gen_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_q_gen_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t q_pkt_ct_neg_en             : 1;  /**< R/W - -- */
		uint32_t shapers_en                  : 1;  /**< R/W - -- */
		uint32_t dwrr_en                     : 1;  /**< R/W - -- */
		uint32_t slow_compensation_en        : 1;  /**< R/W - -- */
#else
		uint32_t slow_compensation_en        : 1;
		uint32_t dwrr_en                     : 1;
		uint32_t shapers_en                  : 1;
		uint32_t q_pkt_ct_neg_en             : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_q_gen_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_q_gen_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_q_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG_FUNC(void)
{
	return 0x000084207041C068ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG bdk_tns_txq_dq_h1s_q_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_Q_GEN_CFG "TNS_TXQ_DQ_H1S_Q_GEN_CFG"


/**
 * NCB32b - tns_txq_dq_h1s_qdwrr_mtu_cfg
 *
 * MTU configuration for H1 arbiter (MTU in bytes = 2^q_dwrr_mtu_cfg).
 *
 */
typedef union bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t data                        : 4;  /**< R/W - -- */
#else
		uint32_t data                        : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG_FUNC(void)
{
	return 0x000084207041C06Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG bdk_tns_txq_dq_h1s_qdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG "TNS_TXQ_DQ_H1S_QDWRR_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_h1s_qfshp_adr_map
 *
 * Configuration to map bits in Q array to FAST_UPD CB shapers list index
 *
 */
typedef union bdk_tns_txq_dq_h1s_qfshp_adr_map {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qfshp_adr_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t index_7                     : 4;  /**< R/W - -- */
		uint32_t index_6                     : 4;  /**< R/W - -- */
		uint32_t index_5                     : 4;  /**< R/W - -- */
		uint32_t index_4                     : 4;  /**< R/W - -- */
		uint32_t index_3                     : 4;  /**< R/W - -- */
		uint32_t index_2                     : 4;  /**< R/W - -- */
		uint32_t index_1                     : 4;  /**< R/W - -- */
		uint32_t index_0                     : 4;  /**< R/W - -- */
#else
		uint32_t index_0                     : 4;
		uint32_t index_1                     : 4;
		uint32_t index_2                     : 4;
		uint32_t index_3                     : 4;
		uint32_t index_4                     : 4;
		uint32_t index_5                     : 4;
		uint32_t index_6                     : 4;
		uint32_t index_7                     : 4;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qfshp_adr_map_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qfshp_adr_map_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qfshp_adr_map_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP_FUNC(void)
{
	return 0x000084207041C070ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP bdk_tns_txq_dq_h1s_qfshp_adr_map_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP "TNS_TXQ_DQ_H1S_QFSHP_ADR_MAP"


/**
 * NCB32b - tns_txq_dq_h1s_qfshp_chk_cfg
 *
 * Bitmap used to validate entry in FAST_UPD list
 *
 */
typedef union bdk_tns_txq_dq_h1s_qfshp_chk_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qfshp_chk_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t bitmap                      : 3;  /**< R/W - -- */
#else
		uint32_t bitmap                      : 3;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qfshp_chk_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qfshp_chk_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qfshp_chk_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG_FUNC(void)
{
	return 0x000084207041C078ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG bdk_tns_txq_dq_h1s_qfshp_chk_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG "TNS_TXQ_DQ_H1S_QFSHP_CHK_CFG"


/**
 * NCB32b - tns_txq_dq_h1s_qfshp_map_cfg
 *
 * Configuration to map bits in Q array used to validate entry in FAST_UPD list
 *
 */
typedef union bdk_tns_txq_dq_h1s_qfshp_map_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qfshp_map_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t index_2                     : 4;  /**< R/W - -- */
		uint32_t index_1                     : 4;  /**< R/W - -- */
		uint32_t index_0                     : 4;  /**< R/W - -- */
#else
		uint32_t index_0                     : 4;
		uint32_t index_1                     : 4;
		uint32_t index_2                     : 4;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qfshp_map_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qfshp_map_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qfshp_map_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG_FUNC(void)
{
	return 0x000084207041C074ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG bdk_tns_txq_dq_h1s_qfshp_map_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG "TNS_TXQ_DQ_H1S_QFSHP_MAP_CFG"


/**
 * NCB32b - tns_txq_dq_h1s_qpkt_ct_lmt#
 *
 * Q packet count limits
 *
 */
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_lmtx {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070419400ull + (param1 & 127) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(...) bdk_tns_txq_dq_h1s_qpkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_LMTX(...) "TNS_TXQ_DQ_H1S_QPKT_CT_LMTX"


/**
 * NCB32b - tns_txq_dq_h1s_qpkt_ct_mem#
 *
 * Q packet count memory
 *
 */
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qpkt_ct_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< R/W - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_memx_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qpkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070416000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(...) bdk_tns_txq_dq_h1s_qpkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_MEMX(...) "TNS_TXQ_DQ_H1S_QPKT_CT_MEMX"


/**
 * NCB32b - tns_txq_dq_h1s_qpkt_ct_nz#
 *
 * Use this to set Q nodes to have packet_count_not_zero to 0 or 1 for scheduling
 * purposes.  Useful for clearing a Q in case it has not flushed out properly
 */
typedef union bdk_tns_txq_dq_h1s_qpkt_ct_nzx {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qpkt_ct_nzx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_nzx_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qpkt_ct_nzx_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qpkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x000084207041A000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(...) bdk_tns_txq_dq_h1s_qpkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_CT_NZX(...) "TNS_TXQ_DQ_H1S_QPKT_CT_NZX"


/**
 * NCB32b - tns_txq_dq_h1s_qpkt_fprf_map
 *
 * Map Q address bits to a packet count limit profile
 *
 */
typedef union bdk_tns_txq_dq_h1s_qpkt_fprf_map {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qpkt_fprf_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t q_bit_to_limit_addr6        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr5        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr4        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr3        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr2        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr1        : 4;  /**< R/W - -- */
		uint32_t q_bit_to_limit_addr0        : 4;  /**< R/W - -- */
#else
		uint32_t q_bit_to_limit_addr0        : 4;
		uint32_t q_bit_to_limit_addr1        : 4;
		uint32_t q_bit_to_limit_addr2        : 4;
		uint32_t q_bit_to_limit_addr3        : 4;
		uint32_t q_bit_to_limit_addr4        : 4;
		uint32_t q_bit_to_limit_addr5        : 4;
		uint32_t q_bit_to_limit_addr6        : 4;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qpkt_fprf_map_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qpkt_fprf_map_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qpkt_fprf_map_t;

#define BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP_FUNC(void)
{
	return 0x000084207041C080ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP bdk_tns_txq_dq_h1s_qpkt_fprf_map_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP "TNS_TXQ_DQ_H1S_QPKT_FPRF_MAP"


/**
 * NCB32b - tns_txq_dq_h1s_qshp_mtu_cfg
 *
 * MTU configuration register (MTU in BYTES = 2^h2_cb_shapers_mtu_cfg)
 *
 */
typedef union bdk_tns_txq_dq_h1s_qshp_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qshp_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mtu                         : 4;  /**< R/W - -- */
#else
		uint32_t mtu                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qshp_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qshp_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG_FUNC(void)
{
	return 0x000084207041C07Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG bdk_tns_txq_dq_h1s_qshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QSHP_MTU_CFG "TNS_TXQ_DQ_H1S_QSHP_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_h1s_qsshp_ecc_log
 *
 * Q slow shaper memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_dq_h1s_qsshp_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_qsshp_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_qsshp_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_qsshp_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_qsshp_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG_FUNC(void)
{
	return 0x000084207041C060ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG bdk_tns_txq_dq_h1s_qsshp_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG "TNS_TXQ_DQ_H1S_QSSHP_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_h1s_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_dq_h1s_spad {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_spad_s   cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_spad_s   cn88xxp1; */
} bdk_tns_txq_dq_h1s_spad_t;

#define BDK_TNS_TXQ_DQ_H1S_SPAD BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SPAD_FUNC(void)
{
	return 0x000084207041C0A4ull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_SPAD bdk_tns_txq_dq_h1s_spad_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_SPAD "TNS_TXQ_DQ_H1S_SPAD"


/**
 * NCB32b - tns_txq_dq_h1s_sshp_mem#_w0
 *
 * Q CB shapers fast_update memory
 * Bits[31:19] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_sshp_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bucket_size                 : 24; /**< R/W - current token bucket size (in bytes) */
		uint32_t rate_count                  : 8;  /**< R/W - update rate divider count */
#else
		uint32_t rate_count                  : 8;
		uint32_t bucket_size                 : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_sshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070408000ull + (param1 & 2047) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(...) bdk_tns_txq_dq_h1s_sshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W0(...) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W0"


/**
 * NCB32b - tns_txq_dq_h1s_sshp_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_SSHP_MEM(0..2047)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_sshp_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t enable                      : 1;  /**< R/W - enable */
		uint32_t max_burst_size              : 8;  /**< R/W - shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
		uint32_t tokens_to_add               : 14; /**< R/W - tokens to add per shaper time-wheel (in bytes) */
		uint32_t rate_divider                : 8;  /**< R/W - update rate divider for shaper time-wheel */
		uint32_t bucket_size                 : 1;  /**< R/W - Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else
		uint32_t bucket_size                 : 1;
		uint32_t rate_divider                : 8;
		uint32_t tokens_to_add               : 14;
		uint32_t max_burst_size              : 8;
		uint32_t enable                      : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_sshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070408004ull + (param1 & 2047) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(...) bdk_tns_txq_dq_h1s_sshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W1(...) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_h1s_sshp_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_SSHP_MEM(0..2047)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_sshp_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_sshp_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t comp_count                  : 19; /**< R/W - current shaper pending compensation count */
#else
		uint32_t comp_count                  : 19;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_sshp_memx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_sshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070408008ull + (param1 & 2047) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(...) bdk_tns_txq_dq_h1s_sshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_SSHP_MEMX_W2(...) "TNS_TXQ_DQ_H1S_SSHP_MEMX_W2"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w0
 *
 * H1 scheduler TM config table
 * Bits[31:14] in _W[28] are unused.
 * When writing, the MSBs (word 28) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t strict_en                   : 32; /**< R/W - Strict priority enable for each of the 64 Queues assigned to this port */
#else
		uint32_t strict_en                   : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400000ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(...) bdk_tns_txq_dq_h1s_tm_cstx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W0(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W0"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t strict_en                   : 32; /**< R/W - Continuation of MSBs of field STRICT_EN from previous word. */
#else
		uint32_t strict_en                   : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400004ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(...) bdk_tns_txq_dq_h1s_tm_cstx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W1(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W1"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w10
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w10 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w10_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w10_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w10_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w10_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400028ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(...) bdk_tns_txq_dq_h1s_tm_cstx_w10_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W10(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W10"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w11
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w11 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w11_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w11_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w11_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w11_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040002Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(...) bdk_tns_txq_dq_h1s_tm_cstx_w11_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W11(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W11"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w12
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w12 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w12_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w12_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w12_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w12_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400030ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(...) bdk_tns_txq_dq_h1s_tm_cstx_w12_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W12(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W12"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w13
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w13 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w13_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w13_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w13_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w13_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400034ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(...) bdk_tns_txq_dq_h1s_tm_cstx_w13_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W13(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W13"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w14
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w14 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w14_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w14_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w14_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w14_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400038ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(...) bdk_tns_txq_dq_h1s_tm_cstx_w14_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W14(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W14"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w15
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w15 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w15_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w15_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w15_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w15_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040003Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(...) bdk_tns_txq_dq_h1s_tm_cstx_w15_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W15(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W15"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w16
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w16 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w16_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - TC array (4 bits each) for each of the 64 Queues assigned to this port.  This
                                                                 field is valid for all ports */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w16_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w16_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w16_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400040ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(...) bdk_tns_txq_dq_h1s_tm_cstx_w16_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W16(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W16"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w17
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w17 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w17_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w17_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w17_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w17_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400044ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(...) bdk_tns_txq_dq_h1s_tm_cstx_w17_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W17(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W17"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w18
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w18 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w18_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w18_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w18_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w18_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400048ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(...) bdk_tns_txq_dq_h1s_tm_cstx_w18_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W18(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W18"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w19
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w19 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w19_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w19_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w19_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w19_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040004Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(...) bdk_tns_txq_dq_h1s_tm_cstx_w19_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W19(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W19"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Channel array (7 bits each) for each of the 64 Queues assigned to this port.
                                                                 This field is only valid for H1 nodes associated with Ports 8 and 9 */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400008ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(...) bdk_tns_txq_dq_h1s_tm_cstx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W2(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W2"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w20
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w20 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w20_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w20_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w20_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w20_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400050ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(...) bdk_tns_txq_dq_h1s_tm_cstx_w20_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W20(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W20"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w21
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w21 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w21_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w21_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w21_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w21_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400054ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(...) bdk_tns_txq_dq_h1s_tm_cstx_w21_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W21(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W21"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w22
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w22 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w22_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w22_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w22_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w22_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400058ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(...) bdk_tns_txq_dq_h1s_tm_cstx_w22_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W22(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W22"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w23
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w23 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w23_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tc_array                    : 32; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint32_t tc_array                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w23_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w23_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w23_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040005Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(...) bdk_tns_txq_dq_h1s_tm_cstx_w23_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W23(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W23"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w24
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w24 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w24_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t dq_en                       : 32; /**< R/W - DQ enable for each of the 64 Queues assigned to this port */
#else
		uint32_t dq_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w24_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w24_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w24_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400060ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(...) bdk_tns_txq_dq_h1s_tm_cstx_w24_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W24(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W24"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w25
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w25 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w25_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t dq_en                       : 32; /**< R/W - Continuation of MSBs of field DQ_EN from previous word. */
#else
		uint32_t dq_en                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w25_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w25_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w25_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400064ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(...) bdk_tns_txq_dq_h1s_tm_cstx_w25_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W25(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W25"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w26
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w26 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w26_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t q_group2                    : 8;  /**< R/W - Queue group 2 index */
		uint32_t q_group1                    : 8;  /**< R/W - Queue group 1 index */
		uint32_t q_group0                    : 8;  /**< R/W - Queue group 0 index */
		uint32_t q_groups_valid              : 8;  /**< R/W - Queue groups valid vector, one bit for each of the 8 nodes */
#else
		uint32_t q_groups_valid              : 8;
		uint32_t q_group0                    : 8;
		uint32_t q_group1                    : 8;
		uint32_t q_group2                    : 8;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w26_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w26_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w26_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400068ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(...) bdk_tns_txq_dq_h1s_tm_cstx_w26_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W26(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W26"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w27
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w27 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w27_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t q_group6                    : 8;  /**< R/W - Queue group 6 index */
		uint32_t q_group5                    : 8;  /**< R/W - Queue group 5 index */
		uint32_t q_group4                    : 8;  /**< R/W - Queue group 4 index */
		uint32_t q_group3                    : 8;  /**< R/W - Queue group 3 index */
#else
		uint32_t q_group3                    : 8;
		uint32_t q_group4                    : 8;
		uint32_t q_group5                    : 8;
		uint32_t q_group6                    : 8;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w27_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w27_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w27_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040006Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(...) bdk_tns_txq_dq_h1s_tm_cstx_w27_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W27(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W27"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w28
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w28 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w28_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t last_q_index                : 6;  /**< R/W - Last Q index chosen for this H1 node */
		uint32_t q_group7                    : 8;  /**< R/W - Queue group 7 index */
#else
		uint32_t q_group7                    : 8;
		uint32_t last_q_index                : 6;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w28_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w28_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w28_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400070ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(...) bdk_tns_txq_dq_h1s_tm_cstx_w28_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W28(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W28"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w3
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w3 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w3_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w3_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w3_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040000Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(...) bdk_tns_txq_dq_h1s_tm_cstx_w3_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W3(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W3"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w4
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w4 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w4_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w4_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w4_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400010ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(...) bdk_tns_txq_dq_h1s_tm_cstx_w4_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W4(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W4"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w5
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w5 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w5_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w5_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w5_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400014ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(...) bdk_tns_txq_dq_h1s_tm_cstx_w5_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W5(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W5"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w6
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w6 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w6_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w6_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w6_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400018ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(...) bdk_tns_txq_dq_h1s_tm_cstx_w6_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W6(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W6"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w7
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w7 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w7_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w7_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w7_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w7_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207040001Cull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(...) bdk_tns_txq_dq_h1s_tm_cstx_w7_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W7(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W7"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w8
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w8 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w8_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w8_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w8_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w8_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400020ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(...) bdk_tns_txq_dq_h1s_tm_cstx_w8_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W8(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W8"


/**
 * NCB32b - tns_txq_dq_h1s_tm_cst#_w9
 *
 * Continuation of structure defined in TNS_TXQ_DQ_H1S_TM_CST(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_h1s_tm_cstx_w9 {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_cstx_w9_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t channel_array               : 32; /**< R/W - Continuation of MSBs of field CHANNEL_ARRAY from previous word. */
#else
		uint32_t channel_array               : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w9_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_cstx_w9_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_cstx_w9_t;

static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070400024ull + (param1 & 255) * 0x80ull;
	csr_fatal("BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(...) bdk_tns_txq_dq_h1s_tm_cstx_w9_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_CSTX_W9(...) "TNS_TXQ_DQ_H1S_TM_CSTX_W9"


/**
 * NCB32b - tns_txq_dq_h1s_tm_ecc_log
 *
 * H1 scheduler TM config and state memory ECC error log.  Address is sticky on
 * first error.  Re-armed after reading
 */
typedef union bdk_tns_txq_dq_h1s_tm_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_h1s_tm_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_h1s_tm_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_h1s_tm_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_h1s_tm_ecc_log_t;

#define BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG_FUNC(void)
{
	return 0x000084207041C05Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG bdk_tns_txq_dq_h1s_tm_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_H1S_TM_ECC_LOG "TNS_TXQ_DQ_H1S_TM_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_int_ro
 *
 * DQ top level interrupt status register
 *
 */
typedef union bdk_tns_txq_dq_int_ro {
	uint32_t u;
	struct bdk_tns_txq_dq_int_ro_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t h1_sch                      : 1;  /**< RO/H - H1 scheduler high interrupt. */
		uint32_t pt_sch                      : 1;  /**< RO/H - Port schedulerinterrupt. */
		uint32_t pipe_sch                    : 1;  /**< RO/H - Pipe scheduler interrupt. */
		uint32_t dfcr_tbaf                   : 1;  /**< RO/H - DFC RX or Token Buffer access fifo interrupts. */
#else
		uint32_t dfcr_tbaf                   : 1;
		uint32_t pipe_sch                    : 1;
		uint32_t pt_sch                      : 1;
		uint32_t h1_sch                      : 1;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_int_ro_s     cn88xx; */
	/* struct bdk_tns_txq_dq_int_ro_s     cn88xxp1; */
} bdk_tns_txq_dq_int_ro_t;

#define BDK_TNS_TXQ_DQ_INT_RO BDK_TNS_TXQ_DQ_INT_RO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_INT_RO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_INT_RO_FUNC(void)
{
	return 0x0000842070488100ull;
}
#define typedef_BDK_TNS_TXQ_DQ_INT_RO bdk_tns_txq_dq_int_ro_t
#define bustype_BDK_TNS_TXQ_DQ_INT_RO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_INT_RO 0
#define arguments_BDK_TNS_TXQ_DQ_INT_RO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_INT_RO "TNS_TXQ_DQ_INT_RO"


/**
 * NCB32b - tns_txq_dq_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_dq_lock {
	uint32_t u;
	struct bdk_tns_txq_dq_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_lock_s       cn88xx; */
	/* struct bdk_tns_txq_dq_lock_s       cn88xxp1; */
} bdk_tns_txq_dq_lock_t;

#define BDK_TNS_TXQ_DQ_LOCK BDK_TNS_TXQ_DQ_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_LOCK_FUNC(void)
{
	return 0x0000842070488140ull;
}
#define typedef_BDK_TNS_TXQ_DQ_LOCK bdk_tns_txq_dq_lock_t
#define bustype_BDK_TNS_TXQ_DQ_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_LOCK "TNS_TXQ_DQ_LOCK"


/**
 * NCB32b - tns_txq_dq_pps_dwrr_cst_mem#
 *
 * PORT DWRR weights and counters memory
 *
 */
typedef union bdk_tns_txq_dq_pps_dwrr_cst_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_dwrr_cst_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 24; /**< R/W - -- */
		uint32_t weight                      : 8;  /**< R/W - -- */
#else
		uint32_t weight                      : 8;
		uint32_t count                       : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_dwrr_cst_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_dwrr_cst_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070489080ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(...) bdk_tns_txq_dq_pps_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_DWRR_CST_MEMX(...) "TNS_TXQ_DQ_PPS_DWRR_CST_MEMX"


/**
 * NCB32b - tns_txq_dq_pps_frc_ptp_mskof
 *
 * Debug register to force port pacing mask on.  One bit for each port
 *
 */
typedef union bdk_tns_txq_dq_pps_frc_ptp_mskof {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_frc_ptp_mskof_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t force_port15_off            : 1;  /**< R/W - -- */
		uint32_t force_port14_off            : 1;  /**< R/W - -- */
		uint32_t force_port13_off            : 1;  /**< R/W - -- */
		uint32_t force_port12_off            : 1;  /**< R/W - -- */
		uint32_t force_port11_off            : 1;  /**< R/W - -- */
		uint32_t force_port10_off            : 1;  /**< R/W - -- */
		uint32_t force_port9_off             : 1;  /**< R/W - -- */
		uint32_t force_port8_off             : 1;  /**< R/W - -- */
		uint32_t force_port7_off             : 1;  /**< R/W - -- */
		uint32_t force_port6_off             : 1;  /**< R/W - -- */
		uint32_t force_port5_off             : 1;  /**< R/W - -- */
		uint32_t force_port4_off             : 1;  /**< R/W - -- */
		uint32_t force_port3_off             : 1;  /**< R/W - -- */
		uint32_t force_port2_off             : 1;  /**< R/W - -- */
		uint32_t force_port1_off             : 1;  /**< R/W - -- */
		uint32_t force_port0_off             : 1;  /**< R/W - -- */
#else
		uint32_t force_port0_off             : 1;
		uint32_t force_port1_off             : 1;
		uint32_t force_port2_off             : 1;
		uint32_t force_port3_off             : 1;
		uint32_t force_port4_off             : 1;
		uint32_t force_port5_off             : 1;
		uint32_t force_port6_off             : 1;
		uint32_t force_port7_off             : 1;
		uint32_t force_port8_off             : 1;
		uint32_t force_port9_off             : 1;
		uint32_t force_port10_off            : 1;
		uint32_t force_port11_off            : 1;
		uint32_t force_port12_off            : 1;
		uint32_t force_port13_off            : 1;
		uint32_t force_port14_off            : 1;
		uint32_t force_port15_off            : 1;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_frc_ptp_mskof_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_frc_ptp_mskof_s cn88xxp1; */
} bdk_tns_txq_dq_pps_frc_ptp_mskof_t;

#define BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF_FUNC(void)
{
	return 0x00008420704891F0ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF bdk_tns_txq_dq_pps_frc_ptp_mskof_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF "TNS_TXQ_DQ_PPS_FRC_PTP_MSKOF"


/**
 * NCB32b - tns_txq_dq_pps_frc_ptp_mskon
 *
 * Debug register to force port pacing mask on.  One bit for each port
 *
 */
typedef union bdk_tns_txq_dq_pps_frc_ptp_mskon {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_frc_ptp_mskon_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t force_port15_on             : 1;  /**< R/W - -- */
		uint32_t force_port14_on             : 1;  /**< R/W - -- */
		uint32_t force_port13_on             : 1;  /**< R/W - -- */
		uint32_t force_port12_on             : 1;  /**< R/W - -- */
		uint32_t force_port11_on             : 1;  /**< R/W - -- */
		uint32_t force_port10_on             : 1;  /**< R/W - -- */
		uint32_t force_port9_on              : 1;  /**< R/W - -- */
		uint32_t force_port8_on              : 1;  /**< R/W - -- */
		uint32_t force_port7_on              : 1;  /**< R/W - -- */
		uint32_t force_port6_on              : 1;  /**< R/W - -- */
		uint32_t force_port5_on              : 1;  /**< R/W - -- */
		uint32_t force_port4_on              : 1;  /**< R/W - -- */
		uint32_t force_port3_on              : 1;  /**< R/W - -- */
		uint32_t force_port2_on              : 1;  /**< R/W - -- */
		uint32_t force_port1_on              : 1;  /**< R/W - -- */
		uint32_t force_port0_on              : 1;  /**< R/W - -- */
#else
		uint32_t force_port0_on              : 1;
		uint32_t force_port1_on              : 1;
		uint32_t force_port2_on              : 1;
		uint32_t force_port3_on              : 1;
		uint32_t force_port4_on              : 1;
		uint32_t force_port5_on              : 1;
		uint32_t force_port6_on              : 1;
		uint32_t force_port7_on              : 1;
		uint32_t force_port8_on              : 1;
		uint32_t force_port9_on              : 1;
		uint32_t force_port10_on             : 1;
		uint32_t force_port11_on             : 1;
		uint32_t force_port12_on             : 1;
		uint32_t force_port13_on             : 1;
		uint32_t force_port14_on             : 1;
		uint32_t force_port15_on             : 1;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_frc_ptp_mskon_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_frc_ptp_mskon_s cn88xxp1; */
} bdk_tns_txq_dq_pps_frc_ptp_mskon_t;

#define BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON_FUNC(void)
{
	return 0x00008420704891ECull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON bdk_tns_txq_dq_pps_frc_ptp_mskon_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_FRC_PTP_MSKON "TNS_TXQ_DQ_PPS_FRC_PTP_MSKON"


/**
 * NCB - tns_txq_dq_pps_fshp_mem#
 *
 * PORT CB shapers fast_update memory
 *
 */
typedef union bdk_tns_txq_dq_pps_fshp_memx {
	uint64_t u;
	struct bdk_tns_txq_dq_pps_fshp_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t enable                      : 1;  /**< R/W - enable */
		uint64_t max_burst_size              : 8;  /**< R/W - shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
		uint64_t tokens_to_add               : 14; /**< R/W - tokens to add per shaper time-wheel (in bytes) */
		uint64_t rate_divider                : 8;  /**< R/W - update rate divider for shaper time-wheel */
		uint64_t bucket_size                 : 25; /**< R/W - current token bucket size (in bytes).  Signed two's complement number */
		uint64_t rate_count                  : 8;  /**< R/W - update rate divider count */
#else
		uint64_t rate_count                  : 8;
		uint64_t bucket_size                 : 25;
		uint64_t rate_divider                : 8;
		uint64_t tokens_to_add               : 14;
		uint64_t max_burst_size              : 8;
		uint64_t enable                      : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_fshp_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_fshp_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_fshp_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070489000ull + (param1 & 15) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(...) bdk_tns_txq_dq_pps_fshp_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_FSHP_MEMX(...) "TNS_TXQ_DQ_PPS_FSHP_MEMX"


/**
 * NCB32b - tns_txq_dq_pps_int_en_hi
 *
 * PIPE scheduler intr register
 *
 */
typedef union bdk_tns_txq_dq_pps_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pt_pkt_ct_rollover_err      : 1;  /**< R/W - Port packet count rolled over */
		uint32_t pt_pkt_ct_neg_err           : 1;  /**< R/W - Port packet count tried to decrement when count was zero */
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;  /**< R/W - Port shaper bucket count wrapped from negative to positive */
#else
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;
		uint32_t pt_pkt_ct_neg_err           : 1;
		uint32_t pt_pkt_ct_rollover_err      : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_dq_pps_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_EN_HI BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_HI_FUNC(void)
{
	return 0x00008420704891C4ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI bdk_tns_txq_dq_pps_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_EN_HI "TNS_TXQ_DQ_PPS_INT_EN_HI"


/**
 * NCB32b - tns_txq_dq_pps_int_en_lo
 *
 * PIPE scheduler intr register
 *
 */
typedef union bdk_tns_txq_dq_pps_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pt_pkt_ct_rollover_err      : 1;  /**< R/W - Port packet count rolled over */
		uint32_t pt_pkt_ct_neg_err           : 1;  /**< R/W - Port packet count tried to decrement when count was zero */
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;  /**< R/W - Port shaper bucket count wrapped from negative to positive */
#else
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;
		uint32_t pt_pkt_ct_neg_err           : 1;
		uint32_t pt_pkt_ct_rollover_err      : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_dq_pps_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_EN_LO BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_EN_LO_FUNC(void)
{
	return 0x00008420704891C8ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO bdk_tns_txq_dq_pps_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_EN_LO "TNS_TXQ_DQ_PPS_INT_EN_LO"


/**
 * NCB32b - tns_txq_dq_pps_int_frc
 *
 * PIPE scheduler intr register
 *
 */
typedef union bdk_tns_txq_dq_pps_int_frc {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pt_pkt_ct_rollover_err      : 1;  /**< WO - Port packet count rolled over */
		uint32_t pt_pkt_ct_neg_err           : 1;  /**< WO - Port packet count tried to decrement when count was zero */
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;  /**< WO - Port shaper bucket count wrapped from negative to positive */
#else
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;
		uint32_t pt_pkt_ct_neg_err           : 1;
		uint32_t pt_pkt_ct_rollover_err      : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_int_frc_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_int_frc_s cn88xxp1; */
} bdk_tns_txq_dq_pps_int_frc_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_FRC BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_FRC_FUNC(void)
{
	return 0x00008420704891CCull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_FRC bdk_tns_txq_dq_pps_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_FRC "TNS_TXQ_DQ_PPS_INT_FRC"


/**
 * NCB32b - tns_txq_dq_pps_int_w1c
 *
 * PIPE scheduler intr register
 *
 */
typedef union bdk_tns_txq_dq_pps_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pt_pkt_ct_rollover_err      : 1;  /**< R/W1C/H - Port packet count rolled over */
		uint32_t pt_pkt_ct_neg_err           : 1;  /**< R/W1C/H - Port packet count tried to decrement when count was zero */
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;  /**< R/W1C/H - Port shaper bucket count wrapped from negative to positive */
#else
		uint32_t pt_shp_bckt_ct_neg_wrap_err : 1;
		uint32_t pt_pkt_ct_neg_err           : 1;
		uint32_t pt_pkt_ct_rollover_err      : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_int_w1c_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_int_w1c_s cn88xxp1; */
} bdk_tns_txq_dq_pps_int_w1c_t;

#define BDK_TNS_TXQ_DQ_PPS_INT_W1C BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_INT_W1C_FUNC(void)
{
	return 0x00008420704891C0ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_INT_W1C bdk_tns_txq_dq_pps_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_INT_W1C "TNS_TXQ_DQ_PPS_INT_W1C"


/**
 * NCB32b - tns_txq_dq_pps_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_dq_pps_lock {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_lock_s   cn88xx; */
	/* struct bdk_tns_txq_dq_pps_lock_s   cn88xxp1; */
} bdk_tns_txq_dq_pps_lock_t;

#define BDK_TNS_TXQ_DQ_PPS_LOCK BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_LOCK_FUNC(void)
{
	return 0x0000842070489200ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_LOCK bdk_tns_txq_dq_pps_lock_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_LOCK "TNS_TXQ_DQ_PPS_LOCK"


/**
 * NCB32b - tns_txq_dq_pps_pdwrr_mtu_cfg
 *
 * MTU configuration for PIPE arbiter (MTU in bytes = 2^port_dwrr_mtu_cfg).
 *
 */
typedef union bdk_tns_txq_dq_pps_pdwrr_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mtu                         : 4;  /**< R/W - -- */
#else
		uint32_t mtu                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG_FUNC(void)
{
	return 0x00008420704891D4ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG bdk_tns_txq_dq_pps_pdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG "TNS_TXQ_DQ_PPS_PDWRR_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_pps_port_spd_mem#
 *
 * Port speed configuration used in computing the minimum number of cycles for
 * which a port is masked after scheduling. The assignment of speed values 0-7 is
 * based on the programming of the register port_pacing_mask_cycle
 */
typedef union bdk_tns_txq_dq_pps_port_spd_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_port_spd_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t speed                       : 3;  /**< R/W - -- */
#else
		uint32_t speed                       : 3;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_port_spd_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_port_spd_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_port_spd_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070489140ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(...) bdk_tns_txq_dq_pps_port_spd_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PORT_SPD_MEMX(...) "TNS_TXQ_DQ_PPS_PORT_SPD_MEMX"


/**
 * NCB32b - tns_txq_dq_pps_ppkt_ct_lmt#
 *
 * per-port packet count limits
 *
 */
typedef union bdk_tns_txq_dq_pps_ppkt_ct_lmtx {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ppkt_ct_lmtx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_lmtx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_lmtx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ppkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x00008420704890C0ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(...) bdk_tns_txq_dq_pps_ppkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_LMTX(...) "TNS_TXQ_DQ_PPS_PPKT_CT_LMTX"


/**
 * NCB32b - tns_txq_dq_pps_ppkt_ct_mem#
 *
 * per-port packet count memory
 *
 */
typedef union bdk_tns_txq_dq_pps_ppkt_ct_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ppkt_ct_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< R/W - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ppkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070489100ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(...) bdk_tns_txq_dq_pps_ppkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_MEMX(...) "TNS_TXQ_DQ_PPS_PPKT_CT_MEMX"


/**
 * NCB32b - tns_txq_dq_pps_ppkt_ct_nz#
 *
 * Use this to set/unset ports to have packet_count_not_zero to 0 or 1 for
 * scheduling purposes.  Useful for clearing a port in case it has not flushed out
 * properly
 */
typedef union bdk_tns_txq_dq_pps_ppkt_ct_nzx {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ppkt_ct_nzx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_nzx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ppkt_ct_nzx_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ppkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070489180ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(...) bdk_tns_txq_dq_pps_ppkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PPKT_CT_NZX(...) "TNS_TXQ_DQ_PPS_PPKT_CT_NZX"


/**
 * NCB32b - tns_txq_dq_pps_pshp_mtu_cfg
 *
 * MTU configuration register (MTU in BYTES = 2^port_cb_shapers_mtu_cfg)
 *
 */
typedef union bdk_tns_txq_dq_pps_pshp_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_pshp_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mtu                         : 4;  /**< R/W - -- */
#else
		uint32_t mtu                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_pshp_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_pshp_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pps_pshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG_FUNC(void)
{
	return 0x00008420704891D8ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG bdk_tns_txq_dq_pps_pshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PSHP_MTU_CFG "TNS_TXQ_DQ_PPS_PSHP_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_pps_pt_gen_cfg
 *
 * Enable for shapers and DWRR
 *
 */
typedef union bdk_tns_txq_dq_pps_pt_gen_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_pt_gen_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pt_pkt_ct_neg_en            : 1;  /**< R/W - -- */
		uint32_t shapers_en                  : 1;  /**< R/W - -- */
		uint32_t dwrr_en                     : 1;  /**< R/W - -- */
#else
		uint32_t dwrr_en                     : 1;
		uint32_t shapers_en                  : 1;
		uint32_t pt_pkt_ct_neg_en            : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_pt_gen_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_pt_gen_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pps_pt_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG_FUNC(void)
{
	return 0x00008420704891D0ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG bdk_tns_txq_dq_pps_pt_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PT_GEN_CFG "TNS_TXQ_DQ_PPS_PT_GEN_CFG"


/**
 * NCB32b - tns_txq_dq_pps_ptp_mskcy_w0
 *
 * "Indicates \# of cycles between scheduling a particular port
 * {40G,10G,1G,100M, 10M} is the order.   The number of masking cycles one
 * more than the programmed value.  A value of 9 will ensure that a port only has
 * one packet scheduled every 10 cycles."
 */
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ptp_mskcy_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mask_other0_cycles          : 16; /**< R/W - -- */
		uint32_t mask_other1_cycles          : 16; /**< R/W - -- */
#else
		uint32_t mask_other1_cycles          : 16;
		uint32_t mask_other0_cycles          : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w0_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ptp_mskcy_w0_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0_FUNC(void)
{
	return 0x00008420704891DCull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 bdk_tns_txq_dq_pps_ptp_mskcy_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W0 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W0"


/**
 * NCB32b - tns_txq_dq_pps_ptp_mskcy_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 *
 */
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ptp_mskcy_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mask_100m_cycles            : 16; /**< R/W - -- */
		uint32_t mask_10m_cycles             : 16; /**< R/W - -- */
#else
		uint32_t mask_10m_cycles             : 16;
		uint32_t mask_100m_cycles            : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w1_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ptp_mskcy_w1_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1_FUNC(void)
{
	return 0x00008420704891E0ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 bdk_tns_txq_dq_pps_ptp_mskcy_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W1 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W1"


/**
 * NCB32b - tns_txq_dq_pps_ptp_mskcy_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 *
 */
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ptp_mskcy_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mask_10g_cycles             : 16; /**< R/W - -- */
		uint32_t mask_1g_cycles              : 16; /**< R/W - -- */
#else
		uint32_t mask_1g_cycles              : 16;
		uint32_t mask_10g_cycles             : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w2_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ptp_mskcy_w2_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2_FUNC(void)
{
	return 0x00008420704891E4ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 bdk_tns_txq_dq_pps_ptp_mskcy_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W2 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W2"


/**
 * NCB32b - tns_txq_dq_pps_ptp_mskcy_w3
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PPS_PTP_MSKCY_W0
 *
 */
typedef union bdk_tns_txq_dq_pps_ptp_mskcy_w3 {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_ptp_mskcy_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t mask_40g_cycles             : 16; /**< R/W - -- */
		uint32_t mask_20g_cycles             : 16; /**< R/W - -- */
#else
		uint32_t mask_20g_cycles             : 16;
		uint32_t mask_40g_cycles             : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w3_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_ptp_mskcy_w3_s cn88xxp1; */
} bdk_tns_txq_dq_pps_ptp_mskcy_w3_t;

#define BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3_FUNC(void)
{
	return 0x00008420704891E8ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 bdk_tns_txq_dq_pps_ptp_mskcy_w3_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PTP_MSKCY_W3 "TNS_TXQ_DQ_PPS_PTP_MSKCY_W3"


/**
 * NCB32b - tns_txq_dq_pps_pus_4_cpu_acs
 *
 * Bit to pause DQ pipe TM_CFG from issuing valid which would stop the entire Dq
 * process
 */
typedef union bdk_tns_txq_dq_pps_pus_4_cpu_acs {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_pus_4_cpu_acs_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t pause                       : 1;  /**< R/W - -- */
#else
		uint32_t pause                       : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_pus_4_cpu_acs_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_pus_4_cpu_acs_s cn88xxp1; */
} bdk_tns_txq_dq_pps_pus_4_cpu_acs_t;

#define BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS_FUNC(void)
{
	return 0x00008420704891F4ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS bdk_tns_txq_dq_pps_pus_4_cpu_acs_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS "TNS_TXQ_DQ_PPS_PUS_4_CPU_ACS"


/**
 * NCB32b - tns_txq_dq_pps_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_dq_pps_spad {
	uint32_t u;
	struct bdk_tns_txq_dq_pps_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_spad_s   cn88xx; */
	/* struct bdk_tns_txq_dq_pps_spad_s   cn88xxp1; */
} bdk_tns_txq_dq_pps_spad_t;

#define BDK_TNS_TXQ_DQ_PPS_SPAD BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_SPAD_FUNC(void)
{
	return 0x0000842070489204ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_SPAD bdk_tns_txq_dq_pps_spad_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PPS_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_SPAD "TNS_TXQ_DQ_PPS_SPAD"


/**
 * NCB - tns_txq_dq_pps_tm_cfg_dat
 *
 * TM config and state information for various ports tied to a pipe
 *
 */
typedef union bdk_tns_txq_dq_pps_tm_cfg_dat {
	uint64_t u;
	struct bdk_tns_txq_dq_pps_tm_cfg_dat_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_52_63              : 12;
		uint64_t dq_en                       : 16; /**< R/W/H - DQ enable for each of the supported  16 ports */
		uint64_t strict_en                   : 16; /**< R/W/H - Strict prioirty enable for each of the supported 16 ports */
		uint64_t pt_valid                    : 16; /**< R/W/H - Port is valid for scheduling purposes */
		uint64_t last_port                   : 4;  /**< R/W/H - Last port scheduled by pipe scheduler */
#else
		uint64_t last_port                   : 4;
		uint64_t pt_valid                    : 16;
		uint64_t strict_en                   : 16;
		uint64_t dq_en                       : 16;
		uint64_t reserved_52_63              : 12;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pps_tm_cfg_dat_s cn88xx; */
	/* struct bdk_tns_txq_dq_pps_tm_cfg_dat_s cn88xxp1; */
} bdk_tns_txq_dq_pps_tm_cfg_dat_t;

#define BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT_FUNC(void)
{
	return 0x00008420704891F8ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT bdk_tns_txq_dq_pps_tm_cfg_dat_t
#define bustype_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT 0
#define arguments_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PPS_TM_CFG_DAT "TNS_TXQ_DQ_PPS_TM_CFG_DAT"


/**
 * NCB32b - tns_txq_dq_pts_dwrr_cst_mem#
 *
 * H1 DWRR weights and counters memory
 *
 */
typedef union bdk_tns_txq_dq_pts_dwrr_cst_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_dwrr_cst_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 24; /**< R/W - -- */
		uint32_t weight                      : 8;  /**< R/W - -- */
#else
		uint32_t weight                      : 8;
		uint32_t count                       : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_dwrr_cst_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_dwrr_cst_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_dwrr_cst_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070481400ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(...) bdk_tns_txq_dq_pts_dwrr_cst_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_DWRR_CST_MEMX(...) "TNS_TXQ_DQ_PTS_DWRR_CST_MEMX"


/**
 * NCB32b - tns_txq_dq_pts_dwrr_ecc_log
 *
 * Port scheduler DWRR configuration and state memory ECC error log.  Address is
 * sticky on first error.  Re-armed after reading
 */
typedef union bdk_tns_txq_dq_pts_dwrr_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_dwrr_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_dwrr_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_dwrr_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_pts_dwrr_ecc_log_t;

#define BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG_FUNC(void)
{
	return 0x0000842070482858ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG bdk_tns_txq_dq_pts_dwrr_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_DWRR_ECC_LOG "TNS_TXQ_DQ_PTS_DWRR_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_pts_ecc_ctl
 *
 * ECC configuration of DQ port scheduler memories
 *
 */
typedef union bdk_tns_txq_dq_pts_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t h1_slow_shp_db_ecc          : 1;  /**< R/W - Flip 2 bits of ECC syndrome in H1 slow shaper memory */
		uint32_t h1_slow_shp_sb_ecc          : 1;  /**< R/W - Flip 1 bit of ECC syndrome in H1 slow shaper  memory */
		uint32_t h1_slow_shp_ecc_dis         : 1;  /**< R/W - Disable ECC for H1 slow shaper memory */
		uint32_t pt_sch_dwrr_db_ecc          : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Port scheduler DWRR memory */
		uint32_t pt_sch_dwrr_sb_ecc          : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Port scheduler DWRR memory */
		uint32_t pt_sch_dwrr_ecc_dis         : 1;  /**< R/W - Disable ECC for Port scheduler DWRR memory */
#else
		uint32_t pt_sch_dwrr_ecc_dis         : 1;
		uint32_t pt_sch_dwrr_sb_ecc          : 1;
		uint32_t pt_sch_dwrr_db_ecc          : 1;
		uint32_t h1_slow_shp_ecc_dis         : 1;
		uint32_t h1_slow_shp_sb_ecc          : 1;
		uint32_t h1_slow_shp_db_ecc          : 1;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_ecc_ctl_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_ecc_ctl_s cn88xxp1; */
} bdk_tns_txq_dq_pts_ecc_ctl_t;

#define BDK_TNS_TXQ_DQ_PTS_ECC_CTL BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_ECC_CTL_FUNC(void)
{
	return 0x0000842070482850ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_ECC_CTL bdk_tns_txq_dq_pts_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_ECC_CTL "TNS_TXQ_DQ_PTS_ECC_CTL"


/**
 * NCB32b - tns_txq_dq_pts_fshp_i2h#
 *
 * "H1 CB shapers fast_update H1 \# memory.  Maps the index of the fast shaper to
 * the associated H1 node"
 */
typedef union bdk_tns_txq_dq_pts_fshp_i2hx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_fshp_i2hx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t h1_node                     : 8;  /**< R/W - -- */
#else
		uint32_t h1_node                     : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_fshp_i2hx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_fshp_i2hx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_fshp_i2hx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842070482200ull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(...) bdk_tns_txq_dq_pts_fshp_i2hx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_I2HX(...) "TNS_TXQ_DQ_PTS_FSHP_I2HX"


/**
 * NCB32b - tns_txq_dq_pts_fshp_mem#_w0
 *
 * H1 CB shapers fast_update memory
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_pts_fshp_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_fshp_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bucket_size                 : 24; /**< R/W - current token bucket size (in bytes) */
		uint32_t rate_count                  : 8;  /**< R/W - update rate divider count */
#else
		uint32_t rate_count                  : 8;
		uint32_t bucket_size                 : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_pts_fshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842070481800ull + (param1 & 63) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(...) bdk_tns_txq_dq_pts_fshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W0(...) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W0"


/**
 * NCB32b - tns_txq_dq_pts_fshp_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_FSHP_MEM(0..63)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_fshp_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_fshp_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t enable                      : 1;  /**< R/W - enable */
		uint32_t max_burst_size              : 8;  /**< R/W - shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
		uint32_t tokens_to_add               : 14; /**< R/W - tokens to add per shaper time-wheel (in bytes) */
		uint32_t rate_divider                : 8;  /**< R/W - update rate divider for shaper time-wheel */
		uint32_t bucket_size                 : 1;  /**< R/W - Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else
		uint32_t bucket_size                 : 1;
		uint32_t rate_divider                : 8;
		uint32_t tokens_to_add               : 14;
		uint32_t max_burst_size              : 8;
		uint32_t enable                      : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_pts_fshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842070481804ull + (param1 & 63) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(...) bdk_tns_txq_dq_pts_fshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W1(...) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_pts_fshp_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_FSHP_MEM(0..63)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_fshp_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_fshp_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t comp_count                  : 16; /**< R/W - current shaper pending compensation count */
#else
		uint32_t comp_count                  : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_fshp_memx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_pts_fshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842070481808ull + (param1 & 63) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(...) bdk_tns_txq_dq_pts_fshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_FSHP_MEMX_W2(...) "TNS_TXQ_DQ_PTS_FSHP_MEMX_W2"


/**
 * NCB32b - tns_txq_dq_pts_h1_gen_cfg
 *
 * Enable for shapers, DWRR, and propagated priority
 *
 */
typedef union bdk_tns_txq_dq_pts_h1_gen_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_h1_gen_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t h1_pkt_ct_neg_en            : 1;  /**< R/W - -- */
		uint32_t prop_prio_en                : 1;  /**< R/W - -- */
		uint32_t shapers_en                  : 1;  /**< R/W - -- */
		uint32_t dwrr_en                     : 1;  /**< R/W - -- */
		uint32_t slow_compensation_en        : 1;  /**< R/W - -- */
#else
		uint32_t slow_compensation_en        : 1;
		uint32_t dwrr_en                     : 1;
		uint32_t shapers_en                  : 1;
		uint32_t prop_prio_en                : 1;
		uint32_t h1_pkt_ct_neg_en            : 1;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_h1_gen_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_h1_gen_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pts_h1_gen_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG_FUNC(void)
{
	return 0x000084207048285Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG bdk_tns_txq_dq_pts_h1_gen_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_H1_GEN_CFG "TNS_TXQ_DQ_PTS_H1_GEN_CFG"


/**
 * NCB32b - tns_txq_dq_pts_hdwrr_mtu_cfg
 *
 * MTU configuration for PORT arbiter (MTU in bytes = 2^h1_dwrr_mtu_cfg).
 *
 */
typedef union bdk_tns_txq_dq_pts_hdwrr_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mtu                         : 4;  /**< R/W - -- */
#else
		uint32_t mtu                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG_FUNC(void)
{
	return 0x0000842070482860ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG bdk_tns_txq_dq_pts_hdwrr_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG "TNS_TXQ_DQ_PTS_HDWRR_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_pts_hfshp_adr_map
 *
 * Configuration to map bits in H1 array to FAST_UPD CB shapers list index
 *
 */
typedef union bdk_tns_txq_dq_pts_hfshp_adr_map {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hfshp_adr_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_18_31              : 14;
		uint32_t index_5                     : 3;  /**< R/W - -- */
		uint32_t index_4                     : 3;  /**< R/W - -- */
		uint32_t index_3                     : 3;  /**< R/W - -- */
		uint32_t index_2                     : 3;  /**< R/W - -- */
		uint32_t index_1                     : 3;  /**< R/W - -- */
		uint32_t index_0                     : 3;  /**< R/W - -- */
#else
		uint32_t index_0                     : 3;
		uint32_t index_1                     : 3;
		uint32_t index_2                     : 3;
		uint32_t index_3                     : 3;
		uint32_t index_4                     : 3;
		uint32_t index_5                     : 3;
		uint32_t reserved_18_31              : 14;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hfshp_adr_map_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hfshp_adr_map_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hfshp_adr_map_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP_FUNC(void)
{
	return 0x0000842070482864ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP bdk_tns_txq_dq_pts_hfshp_adr_map_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP "TNS_TXQ_DQ_PTS_HFSHP_ADR_MAP"


/**
 * NCB32b - tns_txq_dq_pts_hfshp_chk_cfg
 *
 * Bitmap used to validate entry in FAST_UPD list
 *
 */
typedef union bdk_tns_txq_dq_pts_hfshp_chk_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hfshp_chk_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t bitmap                      : 2;  /**< R/W - -- */
#else
		uint32_t bitmap                      : 2;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hfshp_chk_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hfshp_chk_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hfshp_chk_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG_FUNC(void)
{
	return 0x000084207048286Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG bdk_tns_txq_dq_pts_hfshp_chk_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG "TNS_TXQ_DQ_PTS_HFSHP_CHK_CFG"


/**
 * NCB32b - tns_txq_dq_pts_hfshp_map_cfg
 *
 * Configuration to map bits in H1 array used to validate entry in FAST_UPD list
 *
 */
typedef union bdk_tns_txq_dq_pts_hfshp_map_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hfshp_map_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t index_1                     : 3;  /**< R/W - -- */
		uint32_t index_0                     : 3;  /**< R/W - -- */
#else
		uint32_t index_0                     : 3;
		uint32_t index_1                     : 3;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hfshp_map_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hfshp_map_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hfshp_map_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG_FUNC(void)
{
	return 0x0000842070482868ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG bdk_tns_txq_dq_pts_hfshp_map_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG "TNS_TXQ_DQ_PTS_HFSHP_MAP_CFG"


/**
 * NCB32b - tns_txq_dq_pts_hpkt_ct_lmt#
 *
 * H1 packet count limits
 *
 */
typedef union bdk_tns_txq_dq_pts_hpkt_ct_lmtx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hpkt_ct_lmtx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t limit                       : 15; /**< R/W - -- */
#else
		uint32_t limit                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_lmtx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_lmtx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hpkt_ct_lmtx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070482000ull + (param1 & 127) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(...) bdk_tns_txq_dq_pts_hpkt_ct_lmtx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_LMTX(...) "TNS_TXQ_DQ_PTS_HPKT_CT_LMTX"


/**
 * NCB32b - tns_txq_dq_pts_hpkt_ct_mem#
 *
 * H1 packet count memory
 *
 */
typedef union bdk_tns_txq_dq_pts_hpkt_ct_memx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hpkt_ct_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_15_31              : 17;
		uint32_t count                       : 15; /**< R/W - -- */
#else
		uint32_t count                       : 15;
		uint32_t reserved_15_31              : 17;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_memx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_memx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hpkt_ct_memx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070481C00ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(...) bdk_tns_txq_dq_pts_hpkt_ct_memx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_MEMX(...) "TNS_TXQ_DQ_PTS_HPKT_CT_MEMX"


/**
 * NCB32b - tns_txq_dq_pts_hpkt_ct_nz#
 *
 * Use this to set H1 nodes to have packet_count_not_zero to 0 or 1 for scheduling
 * purposes.  Useful for clearing a H1 in case it has not flushed out properly
 */
typedef union bdk_tns_txq_dq_pts_hpkt_ct_nzx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hpkt_ct_nzx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_nzx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hpkt_ct_nzx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hpkt_ct_nzx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070482400ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(...) bdk_tns_txq_dq_pts_hpkt_ct_nzx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_CT_NZX(...) "TNS_TXQ_DQ_PTS_HPKT_CT_NZX"


/**
 * NCB32b - tns_txq_dq_pts_hpkt_fprf_map
 *
 * Map H1 address bits to a packet count limit profile
 *
 */
typedef union bdk_tns_txq_dq_pts_hpkt_fprf_map {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hpkt_fprf_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_21_31              : 11;
		uint32_t h1_bit_to_limit_addr6       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr5       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr4       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr3       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr2       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr1       : 3;  /**< R/W - -- */
		uint32_t h1_bit_to_limit_addr0       : 3;  /**< R/W - -- */
#else
		uint32_t h1_bit_to_limit_addr0       : 3;
		uint32_t h1_bit_to_limit_addr1       : 3;
		uint32_t h1_bit_to_limit_addr2       : 3;
		uint32_t h1_bit_to_limit_addr3       : 3;
		uint32_t h1_bit_to_limit_addr4       : 3;
		uint32_t h1_bit_to_limit_addr5       : 3;
		uint32_t h1_bit_to_limit_addr6       : 3;
		uint32_t reserved_21_31              : 11;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hpkt_fprf_map_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hpkt_fprf_map_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hpkt_fprf_map_t;

#define BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP_FUNC(void)
{
	return 0x0000842070482874ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP bdk_tns_txq_dq_pts_hpkt_fprf_map_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP "TNS_TXQ_DQ_PTS_HPKT_FPRF_MAP"


/**
 * NCB32b - tns_txq_dq_pts_hshp_mtu_cfg
 *
 * MTU configuration register (MTU in BYTES = 2^h2_cb_shapers_mtu_cfg)
 *
 */
typedef union bdk_tns_txq_dq_pts_hshp_mtu_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hshp_mtu_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t mtu                         : 4;  /**< R/W - -- */
#else
		uint32_t mtu                         : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hshp_mtu_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hshp_mtu_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hshp_mtu_cfg_t;

#define BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG_FUNC(void)
{
	return 0x0000842070482870ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG bdk_tns_txq_dq_pts_hshp_mtu_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HSHP_MTU_CFG "TNS_TXQ_DQ_PTS_HSHP_MTU_CFG"


/**
 * NCB32b - tns_txq_dq_pts_hsshp_ecc_log
 *
 * H1 slow shaper memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_dq_pts_hsshp_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_hsshp_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_hsshp_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_hsshp_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_pts_hsshp_ecc_log_t;

#define BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG_FUNC(void)
{
	return 0x0000842070482854ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG bdk_tns_txq_dq_pts_hsshp_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG "TNS_TXQ_DQ_PTS_HSSHP_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_pts_int_en_hi
 *
 * Port scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_pts_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;  /**< R/W - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_slow_shp_neg_wrap_err    : 1;  /**< R/W - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_pkt_ct_rollover_err      : 1;  /**< R/W - H1 packet count rolled over */
		uint32_t h1_pkt_ct_neg_err           : 1;  /**< R/W - H1 packet count tried to decrement when count was zero */
		uint32_t h1_slow_shp_mem_db_err      : 1;  /**< R/W - H1 slow shaper memory double bit ECC interrupt */
		uint32_t h1_slow_shp_mem_sb_err      : 1;  /**< R/W - H1 slow shaper memory single bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_db_err      : 1;  /**< R/W - Port scheduler DWRR memory double bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;  /**< R/W - Port scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;
		uint32_t pt_sch_dwrr_mem_db_err      : 1;
		uint32_t h1_slow_shp_mem_sb_err      : 1;
		uint32_t h1_slow_shp_mem_db_err      : 1;
		uint32_t h1_pkt_ct_neg_err           : 1;
		uint32_t h1_pkt_ct_rollover_err      : 1;
		uint32_t h1_slow_shp_neg_wrap_err    : 1;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_dq_pts_int_en_hi_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_EN_HI BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_HI_FUNC(void)
{
	return 0x0000842070482844ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI bdk_tns_txq_dq_pts_int_en_hi_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_EN_HI "TNS_TXQ_DQ_PTS_INT_EN_HI"


/**
 * NCB32b - tns_txq_dq_pts_int_en_lo
 *
 * Port scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_pts_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;  /**< R/W - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_slow_shp_neg_wrap_err    : 1;  /**< R/W - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_pkt_ct_rollover_err      : 1;  /**< R/W - H1 packet count rolled over */
		uint32_t h1_pkt_ct_neg_err           : 1;  /**< R/W - H1 packet count tried to decrement when count was zero */
		uint32_t h1_slow_shp_mem_db_err      : 1;  /**< R/W - H1 slow shaper memory double bit ECC interrupt */
		uint32_t h1_slow_shp_mem_sb_err      : 1;  /**< R/W - H1 slow shaper memory single bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_db_err      : 1;  /**< R/W - Port scheduler DWRR memory double bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;  /**< R/W - Port scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;
		uint32_t pt_sch_dwrr_mem_db_err      : 1;
		uint32_t h1_slow_shp_mem_sb_err      : 1;
		uint32_t h1_slow_shp_mem_db_err      : 1;
		uint32_t h1_pkt_ct_neg_err           : 1;
		uint32_t h1_pkt_ct_rollover_err      : 1;
		uint32_t h1_slow_shp_neg_wrap_err    : 1;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_dq_pts_int_en_lo_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_EN_LO BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_EN_LO_FUNC(void)
{
	return 0x0000842070482848ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO bdk_tns_txq_dq_pts_int_en_lo_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_EN_LO "TNS_TXQ_DQ_PTS_INT_EN_LO"


/**
 * NCB32b - tns_txq_dq_pts_int_frc
 *
 * Port scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_pts_int_frc {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;  /**< WO - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_slow_shp_neg_wrap_err    : 1;  /**< WO - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_pkt_ct_rollover_err      : 1;  /**< WO - H1 packet count rolled over */
		uint32_t h1_pkt_ct_neg_err           : 1;  /**< WO - H1 packet count tried to decrement when count was zero */
		uint32_t h1_slow_shp_mem_db_err      : 1;  /**< WO - H1 slow shaper memory double bit ECC interrupt */
		uint32_t h1_slow_shp_mem_sb_err      : 1;  /**< WO - H1 slow shaper memory single bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_db_err      : 1;  /**< WO - Port scheduler DWRR memory double bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;  /**< WO - Port scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;
		uint32_t pt_sch_dwrr_mem_db_err      : 1;
		uint32_t h1_slow_shp_mem_sb_err      : 1;
		uint32_t h1_slow_shp_mem_db_err      : 1;
		uint32_t h1_pkt_ct_neg_err           : 1;
		uint32_t h1_pkt_ct_rollover_err      : 1;
		uint32_t h1_slow_shp_neg_wrap_err    : 1;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_int_frc_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_int_frc_s cn88xxp1; */
} bdk_tns_txq_dq_pts_int_frc_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_FRC BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_FRC_FUNC(void)
{
	return 0x000084207048284Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_FRC bdk_tns_txq_dq_pts_int_frc_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_FRC 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_FRC "TNS_TXQ_DQ_PTS_INT_FRC"


/**
 * NCB32b - tns_txq_dq_pts_int_w1c
 *
 * Port scheduler interrupt register
 *
 */
typedef union bdk_tns_txq_dq_pts_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;  /**< R/W1C/H - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_slow_shp_neg_wrap_err    : 1;  /**< R/W1C/H - H1 shaper credits wrapped from negative to positive */
		uint32_t h1_pkt_ct_rollover_err      : 1;  /**< R/W1C/H - H1 packet count rolled over */
		uint32_t h1_pkt_ct_neg_err           : 1;  /**< R/W1C/H - H1 packet count tried to decrement when count was zero */
		uint32_t h1_slow_shp_mem_db_err      : 1;  /**< R/W1C/H - H1 slow shaper memory double bit ECC interrupt */
		uint32_t h1_slow_shp_mem_sb_err      : 1;  /**< R/W1C/H - H1 slow shaper memory single bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_db_err      : 1;  /**< R/W1C/H - Port scheduler DWRR memory double bit ECC interrupt */
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;  /**< R/W1C/H - Port scheduler DWRR memory single bit ECC interrupt */
#else
		uint32_t pt_sch_dwrr_mem_sb_err      : 1;
		uint32_t pt_sch_dwrr_mem_db_err      : 1;
		uint32_t h1_slow_shp_mem_sb_err      : 1;
		uint32_t h1_slow_shp_mem_db_err      : 1;
		uint32_t h1_pkt_ct_neg_err           : 1;
		uint32_t h1_pkt_ct_rollover_err      : 1;
		uint32_t h1_slow_shp_neg_wrap_err    : 1;
		uint32_t h1_fast_shp_neg_wrap_err    : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_int_w1c_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_int_w1c_s cn88xxp1; */
} bdk_tns_txq_dq_pts_int_w1c_t;

#define BDK_TNS_TXQ_DQ_PTS_INT_W1C BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_INT_W1C_FUNC(void)
{
	return 0x0000842070482840ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_INT_W1C bdk_tns_txq_dq_pts_int_w1c_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_INT_W1C 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_INT_W1C "TNS_TXQ_DQ_PTS_INT_W1C"


/**
 * NCB32b - tns_txq_dq_pts_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_dq_pts_lock {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_lock_s   cn88xx; */
	/* struct bdk_tns_txq_dq_pts_lock_s   cn88xxp1; */
} bdk_tns_txq_dq_pts_lock_t;

#define BDK_TNS_TXQ_DQ_PTS_LOCK BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_LOCK_FUNC(void)
{
	return 0x0000842070482878ull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_LOCK bdk_tns_txq_dq_pts_lock_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_LOCK 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_LOCK "TNS_TXQ_DQ_PTS_LOCK"


/**
 * NCB32b - tns_txq_dq_pts_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_dq_pts_spad {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_spad_s   cn88xx; */
	/* struct bdk_tns_txq_dq_pts_spad_s   cn88xxp1; */
} bdk_tns_txq_dq_pts_spad_t;

#define BDK_TNS_TXQ_DQ_PTS_SPAD BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SPAD_FUNC(void)
{
	return 0x000084207048287Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_SPAD bdk_tns_txq_dq_pts_spad_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_PTS_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_SPAD "TNS_TXQ_DQ_PTS_SPAD"


/**
 * NCB32b - tns_txq_dq_pts_sshp_mem#_w0
 *
 * H1 CB shapers fast_update memory
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_pts_sshp_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_sshp_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bucket_size                 : 24; /**< R/W - current token bucket size (in bytes) */
		uint32_t rate_count                  : 8;  /**< R/W - update rate divider count */
#else
		uint32_t rate_count                  : 8;
		uint32_t bucket_size                 : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_pts_sshp_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070480000ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(...) bdk_tns_txq_dq_pts_sshp_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W0(...) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W0"


/**
 * NCB32b - tns_txq_dq_pts_sshp_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_SSHP_MEM(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_sshp_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_sshp_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t enable                      : 1;  /**< R/W - enable */
		uint32_t max_burst_size              : 8;  /**< R/W - shaper maximum burst size.  This field is left shifted by the
                                                                 port_cb_shaper_mtu_cfg to determine the max burst size in bytes */
		uint32_t tokens_to_add               : 14; /**< R/W - tokens to add per shaper time-wheel (in bytes) */
		uint32_t rate_divider                : 8;  /**< R/W - update rate divider for shaper time-wheel */
		uint32_t bucket_size                 : 1;  /**< R/W - Continuation of MSBs of field BUCKET_SIZE from previous word. */
#else
		uint32_t bucket_size                 : 1;
		uint32_t rate_divider                : 8;
		uint32_t tokens_to_add               : 14;
		uint32_t max_burst_size              : 8;
		uint32_t enable                      : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_pts_sshp_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070480004ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(...) bdk_tns_txq_dq_pts_sshp_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W1(...) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_pts_sshp_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_SSHP_MEM(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_sshp_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_sshp_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t comp_count                  : 16; /**< R/W - current shaper pending compensation count */
#else
		uint32_t comp_count                  : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_sshp_memx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_pts_sshp_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070480008ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(...) bdk_tns_txq_dq_pts_sshp_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_SSHP_MEMX_W2(...) "TNS_TXQ_DQ_PTS_SSHP_MEMX_W2"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w0
 *
 * PORT scheduler TM config table
 * Bits[63:48] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w0 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t strict_en                   : 64; /**< R/W - Strict priority enable for each of the 64 H1 nodes assigned to this port */
#else
		uint64_t strict_en                   : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481000ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(...) bdk_tns_txq_dq_pts_tm_cfgx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W0(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W0"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w1 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t tc_array                    : 64; /**< R/W - TC array (4 bits each) for each of the 64 H1 nodes assigned to this port */
#else
		uint64_t tc_array                    : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481008ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(...) bdk_tns_txq_dq_pts_tm_cfgx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W1(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W1"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w2 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t tc_array                    : 64; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint64_t tc_array                    : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481010ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(...) bdk_tns_txq_dq_pts_tm_cfgx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W2(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W2"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w3
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w3 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t tc_array                    : 64; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint64_t tc_array                    : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w3_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w3_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w3_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481018ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(...) bdk_tns_txq_dq_pts_tm_cfgx_w3_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W3(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W3"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w4
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w4 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t tc_array                    : 64; /**< R/W - Continuation of MSBs of field TC_ARRAY from previous word. */
#else
		uint64_t tc_array                    : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w4_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w4_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w4_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481020ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(...) bdk_tns_txq_dq_pts_tm_cfgx_w4_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W4(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W4"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w5
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w5 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t dq_en                       : 64; /**< R/W - DQ enable for each of the 64 H1 nodes assigned to this port */
#else
		uint64_t dq_en                       : 64;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w5_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w5_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w5_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481028ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(...) bdk_tns_txq_dq_pts_tm_cfgx_w5_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W5(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W5"


/**
 * NCB - tns_txq_dq_pts_tm_cfg#_w6
 *
 * Continuation of structure defined in TNS_TXQ_DQ_PTS_TM_CFG(0..15)_W0
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_cfgx_w6 {
	uint64_t u;
	struct bdk_tns_txq_dq_pts_tm_cfgx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_48_63              : 16;
		uint64_t h1_group7                   : 5;  /**< R/W - H1 group 7 index */
		uint64_t h1_group6                   : 5;  /**< R/W - H1 group 6 index */
		uint64_t h1_group5                   : 5;  /**< R/W - H1 group 5 index */
		uint64_t h1_group4                   : 5;  /**< R/W - H1 group 4 index */
		uint64_t h1_group3                   : 5;  /**< R/W - H1 group 3 index */
		uint64_t h1_group2                   : 5;  /**< R/W - H1 group 2 index */
		uint64_t h1_group1                   : 5;  /**< R/W - H1 group 1 index */
		uint64_t h1_group0                   : 5;  /**< R/W - H1 group 0 index */
		uint64_t h1_groups_valid             : 8;  /**< R/W - H1 groups valid vector, one bit for each of the 8 nodes */
#else
		uint64_t h1_groups_valid             : 8;
		uint64_t h1_group0                   : 5;
		uint64_t h1_group1                   : 5;
		uint64_t h1_group2                   : 5;
		uint64_t h1_group3                   : 5;
		uint64_t h1_group4                   : 5;
		uint64_t h1_group5                   : 5;
		uint64_t h1_group6                   : 5;
		uint64_t h1_group7                   : 5;
		uint64_t reserved_48_63              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w6_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_cfgx_w6_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_cfgx_w6_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070481030ull + (param1 & 15) * 0x40ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(...) bdk_tns_txq_dq_pts_tm_cfgx_w6_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_CFGX_W6(...) "TNS_TXQ_DQ_PTS_TM_CFGX_W6"


/**
 * NCB32b - tns_txq_dq_pts_tm_stt#
 *
 * PORT scheduler TM state table
 *
 */
typedef union bdk_tns_txq_dq_pts_tm_sttx {
	uint32_t u;
	struct bdk_tns_txq_dq_pts_tm_sttx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t last_h1_index               : 6;  /**< R/W - -- */
#else
		uint32_t last_h1_index               : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_dq_pts_tm_sttx_s cn88xx; */
	/* struct bdk_tns_txq_dq_pts_tm_sttx_s cn88xxp1; */
} bdk_tns_txq_dq_pts_tm_sttx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_STTX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_PTS_TM_STTX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070482800ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_PTS_TM_STTX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_PTS_TM_STTX(...) bdk_tns_txq_dq_pts_tm_sttx_t
#define bustype_BDK_TNS_TXQ_DQ_PTS_TM_STTX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_PTS_TM_STTX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_PTS_TM_STTX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_PTS_TM_STTX(...) "TNS_TXQ_DQ_PTS_TM_STTX"


/**
 * NCB - tns_txq_dq_qcn_change
 *
 * This register is written when a QCN packet arrives and the shaper rates need to
 * be updated.  Software determines the new target rate and current rate to use.
 */
typedef union bdk_tns_txq_dq_qcn_change {
	uint64_t u;
	struct bdk_tns_txq_dq_qcn_change_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_39_63              : 25;
		uint64_t rp                          : 9;  /**< R/W/H - Identify the QCN reaction point to update */
		uint64_t byte_en                     : 1;  /**< R/W/H - Value with which to update the byte_upd_en field of qcn_mem_cfg */
		uint64_t timer_en                    : 1;  /**< R/W/H - Value with which to update the timer_upd_en field of qcn_mem_cfg */
		uint64_t target_rate                 : 14; /**< R/W/H - If non-zero, update the target rate of qcn_mem_cfg */
		uint64_t current_rate                : 14; /**< R/W/H - If non-zero, update the current rate of qcn_mem_cfg */
#else
		uint64_t current_rate                : 14;
		uint64_t target_rate                 : 14;
		uint64_t timer_en                    : 1;
		uint64_t byte_en                     : 1;
		uint64_t rp                          : 9;
		uint64_t reserved_39_63              : 25;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_change_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_change_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_change_t;

#define BDK_TNS_TXQ_DQ_QCN_CHANGE BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_CHANGE_FUNC(void)
{
	return 0x000084207041C098ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_CHANGE bdk_tns_txq_dq_qcn_change_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_CHANGE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_QCN_CHANGE 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_CHANGE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_CHANGE "TNS_TXQ_DQ_QCN_CHANGE"


/**
 * NCB32b - tns_txq_dq_qcn_ecc_log
 *
 * QCN configuration and state memory ECC error log.  Address is sticky on first
 * error.  Re-armed after reading
 */
typedef union bdk_tns_txq_dq_qcn_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t ecc_err_addr                : 9;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 9;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_ecc_log_t;

#define BDK_TNS_TXQ_DQ_QCN_ECC_LOG BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_ECC_LOG_FUNC(void)
{
	return 0x000084207041C054ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_ECC_LOG bdk_tns_txq_dq_qcn_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_ECC_LOG "TNS_TXQ_DQ_QCN_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_qcn_gbl_cfg_w0
 *
 * QCN global configuration registers.  These configuration parameters apply to
 * all QCN CCF Queues
 */
typedef union bdk_tns_txq_dq_qcn_gbl_cfg_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_gbl_cfg_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t qcn_time_rate               : 27; /**< R/W - Number of switch-clock cycles between each QCN timer event.  Represents
                                                                 rpgTimeReset (15ms typical) */
		uint32_t qcn_time_rand               : 5;  /**< R/W - QCN random time shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_rand[6:0] will be shifted by this amount and added/subtracted
                                                                 from qcn_time_rate for the next round's time base.  Set to represent the
                                                                 closest power of 2 that results in less htna 15% of cnm_time_rate being
                                                                 randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Time[0] is randomized
                                                                 0x2 - Time[1:0] is randomized
                                                                 0x3 - Time[2:0] is randomized
                                                                 0x4 - Time[3:0] is randomized
                                                                 0x5 - Time[4:0] is randomized
                                                                 0x6 - Time[5:0] is randomized
                                                                 0x7 - Time[6:0] is randomized
                                                                 0x8 - Time[7:0] is randomized
                                                                 0x9 - Time[8:1] is randomized
                                                                 0xa - Time[9:2] is randomized
                                                                 0xb - Time[10:3] is randomized
                                                                 0xc - Time[11:4] is randomized
                                                                 0xd - Time[12:5] is randomized
                                                                 0xe - Time[13:6] is randomized
                                                                 0xf - Time[14:7] is randomized
                                                                 0x10 - Time[15:8] is randomized
                                                                 0x11 - Time[16:9] is randomized
                                                                 0x12 - Time[17:10] is randomized
                                                                 0x13 - Time[18:11] is randomized
                                                                 0x14 - Time[19:12] is randomized
                                                                 0x15 - Time[20:13] is randomized
                                                                 0x16 - Time[21:14] is randomized
                                                                 0x17 - Time[22:15] is randomized
                                                                 0x18 - Time[23:16] is randomized
                                                                 0x19 - Time[24:17] is randomized
                                                                 0x1A - Time[25:18] is randomized
                                                                 0x1B - Time[26:19] is randomized */
#else
		uint32_t qcn_time_rand               : 5;
		uint32_t qcn_time_rate               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_gbl_cfg_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_gbl_cfg_w0_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_gbl_cfg_w0_t;

#define BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0_FUNC(void)
{
	return 0x000084207041C084ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 bdk_tns_txq_dq_qcn_gbl_cfg_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W0 "TNS_TXQ_DQ_QCN_GBL_CFG_W0"


/**
 * NCB32b - tns_txq_dq_qcn_gbl_cfg_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_GBL_CFG_W0
 *
 */
typedef union bdk_tns_txq_dq_qcn_gbl_cfg_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_gbl_cfg_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_29_31              : 3;
		uint32_t qcn_thresh                  : 4;  /**< R/W - Number of fast recovery stages after which the RP state machine advances to AI
                                                                 or HAI. This applies to both byte and timer stages */
		uint32_t qcn_byte_reset              : 19; /**< R/W - Number of bytes in an CNM byte stage.  Represents rpgByteReset(150000 bytes
                                                                 typical) */
		uint32_t qcn_byte_rand               : 5;  /**< R/W - QCN random byte shift.  Bit 7 of the random number will indicate add/not-
                                                                 substract. qcn_byte_rand[6:0] will be shifted by this amount and
                                                                 added/subtracted from qcn_byte_reset for the next round's time base.  Set to
                                                                 represent the closest power of 2 that results in less than 15% of cnm_byte_rate
                                                                 being randomized
                                                                 0x0 - Randomization disabled
                                                                 0x1 - Byte[0] is randomized
                                                                 0x2 - Byte[1:0] is randomized
                                                                 0x3 - Byte[2:0] is randomized
                                                                 0x4 - Byte[3:0] is randomized
                                                                 0x5 - Byte[4:0] is randomized
                                                                 0x6 - Byte[5:0] is randomized
                                                                 0x7 - Byte[6:0] is randomized
                                                                 0x8 - Byte[7:0] is randomized
                                                                 0x9 - Byte[8:1] is randomized
                                                                 0xa - Byte[9:2] is randomized
                                                                 0xb - Byte[10:3] is randomized
                                                                 0xc - Byte[11:4] is randomized
                                                                 0xd - Byte[12:5] is randomized
                                                                 0xe - Byte[13:6] is randomized
                                                                 0xf - Byte[14:7] is randomized
                                                                 0x10 - Byte[15:8] is randomized
                                                                 0x11 - Byte[16:9] is randomized
                                                                 0x12 - Byte[17:10] is randomized
                                                                 0x13 - Byte[18:11] is randomized */
		uint32_t qcn_time_rate               : 1;  /**< R/W - Continuation of MSBs of field QCN_TIME_RATE from previous word. */
#else
		uint32_t qcn_time_rate               : 1;
		uint32_t qcn_byte_rand               : 5;
		uint32_t qcn_byte_reset              : 19;
		uint32_t qcn_thresh                  : 4;
		uint32_t reserved_29_31              : 3;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_gbl_cfg_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_gbl_cfg_w1_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_gbl_cfg_w1_t;

#define BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1_FUNC(void)
{
	return 0x000084207041C088ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 bdk_tns_txq_dq_qcn_gbl_cfg_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_GBL_CFG_W1 "TNS_TXQ_DQ_QCN_GBL_CFG_W1"


/**
 * NCB - tns_txq_dq_qcn_mem#_w0
 *
 * QCN configuration and state memory
 * Bits[63:48] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_qcn_memx_w0 {
	uint64_t u;
	struct bdk_tns_txq_dq_qcn_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t current_rate                : 10; /**< R/W - Current shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpCurrentRate */
		uint64_t hai_rate                    : 14; /**< R/W - QCN hyper active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgHaiRate */
		uint64_t ai_rate                     : 14; /**< R/W - QCN active increase rate in bytes to add to shaper per time-wheel turn.
                                                                 Corresponds to rpgAiRate */
		uint64_t peak_rate                   : 14; /**< R/W - Peak shaper rate in bytes to add to shaper per time-wheel turn.  Note that the
                                                                 rate divider and burst sizes are set separately in the actual Q shapers */
		uint64_t queue                       : 11; /**< R/W - Queue associated with this QCN CCF */
		uint64_t fast_shaper                 : 1;  /**< R/W - This queue managed by the fast shaper.  Else it goes into the slow shaper.
                                                                 User must ensure that the this corresponds correctly to the way the shapers are
                                                                 configured */
#else
		uint64_t fast_shaper                 : 1;
		uint64_t queue                       : 11;
		uint64_t peak_rate                   : 14;
		uint64_t ai_rate                     : 14;
		uint64_t hai_rate                    : 14;
		uint64_t current_rate                : 10;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 511)))
		return 0x0000842070410000ull + (param1 & 511) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(...) bdk_tns_txq_dq_qcn_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_MEMX_W0(...) "TNS_TXQ_DQ_QCN_MEMX_W0"


/**
 * NCB - tns_txq_dq_qcn_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_MEM(0..511)_W0
 *
 */
typedef union bdk_tns_txq_dq_qcn_memx_w1 {
	uint64_t u;
	struct bdk_tns_txq_dq_qcn_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_48_63              : 16;
		uint64_t time_stage                  : 4;  /**< R/W - QCN time stage.  Corresponds to rpTimeStage */
		uint64_t byte_stage                  : 4;  /**< R/W - QCN byte stage.  Corresponds to rpByteStage */
		uint64_t byte_upd_en                 : 1;  /**< R/W - QCN byte update enable */
		uint64_t timer_upd_en                : 1;  /**< R/W - QCN timer update enable */
		uint64_t byte_cnt                    : 20; /**< R/W - Number of bytes remaining in stage.  Signed integer */
		uint64_t target_rate                 : 14; /**< R/W - Target shaper rate in bytes to add to shaper per time-wheel turn.  Corresponds
                                                                 to rpTargetRate */
		uint64_t current_rate                : 4;  /**< R/W - Continuation of MSBs of field CURRENT_RATE from previous word. */
#else
		uint64_t current_rate                : 4;
		uint64_t target_rate                 : 14;
		uint64_t byte_cnt                    : 20;
		uint64_t timer_upd_en                : 1;
		uint64_t byte_upd_en                 : 1;
		uint64_t byte_stage                  : 4;
		uint64_t time_stage                  : 4;
		uint64_t reserved_48_63              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 511)))
		return 0x0000842070410008ull + (param1 & 511) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(...) bdk_tns_txq_dq_qcn_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_MEMX_W1(...) "TNS_TXQ_DQ_QCN_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_qcn_qmap_ecc_log
 *
 * QCN Q mapping memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_dq_qcn_qmap_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_qmap_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t ecc_err_addr                : 8;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 8;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_qmap_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_qmap_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_qmap_ecc_log_t;

#define BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG_FUNC(void)
{
	return 0x000084207041C058ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG bdk_tns_txq_dq_qcn_qmap_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_ECC_LOG "TNS_TXQ_DQ_QCN_QMAP_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_qcn_qmap_mem#_w0
 *
 * Map Queue to a QCN RP.  8 queue mappings to the QCN RPs are stored per line.
 * Software must ensure that only one queue is mapped to each reaction point, and
 * that only 512 of the possible 2048 queues are enabled.
 * Bits[31:16] in _W[2] are unused.
 * When writing, the MSBs (word 2) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_qmap_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reaction_point3             : 1;  /**< R/W - -- */
		uint32_t enable3                     : 1;  /**< R/W - -- */
		uint32_t reaction_point2             : 9;  /**< R/W - -- */
		uint32_t enable2                     : 1;  /**< R/W - -- */
		uint32_t reaction_point1             : 9;  /**< R/W - -- */
		uint32_t enable1                     : 1;  /**< R/W - -- */
		uint32_t reaction_point0             : 9;  /**< R/W - -- */
		uint32_t enable0                     : 1;  /**< R/W - -- */
#else
		uint32_t enable0                     : 1;
		uint32_t reaction_point0             : 9;
		uint32_t enable1                     : 1;
		uint32_t reaction_point1             : 9;
		uint32_t enable2                     : 1;
		uint32_t reaction_point2             : 9;
		uint32_t enable3                     : 1;
		uint32_t reaction_point3             : 1;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w0_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_qmap_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070414000ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(...) bdk_tns_txq_dq_qcn_qmap_memx_w0_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W0(...) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W0"


/**
 * NCB32b - tns_txq_dq_qcn_qmap_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_QMAP_MEM(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_qmap_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reaction_point6             : 3;  /**< R/W - -- */
		uint32_t enable6                     : 1;  /**< R/W - -- */
		uint32_t reaction_point5             : 9;  /**< R/W - -- */
		uint32_t enable5                     : 1;  /**< R/W - -- */
		uint32_t reaction_point4             : 9;  /**< R/W - -- */
		uint32_t enable4                     : 1;  /**< R/W - -- */
		uint32_t reaction_point3             : 8;  /**< R/W - Continuation of MSBs of field REACTION_POINT3 from previous word. */
#else
		uint32_t reaction_point3             : 8;
		uint32_t enable4                     : 1;
		uint32_t reaction_point4             : 9;
		uint32_t enable5                     : 1;
		uint32_t reaction_point5             : 9;
		uint32_t enable6                     : 1;
		uint32_t reaction_point6             : 3;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w1_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_qmap_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070414004ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(...) bdk_tns_txq_dq_qcn_qmap_memx_w1_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W1(...) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W1"


/**
 * NCB32b - tns_txq_dq_qcn_qmap_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_DQ_QCN_QMAP_MEM(0..255)_W0
 *
 */
typedef union bdk_tns_txq_dq_qcn_qmap_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_qmap_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t reaction_point7             : 9;  /**< R/W - -- */
		uint32_t enable7                     : 1;  /**< R/W - -- */
		uint32_t reaction_point6             : 6;  /**< R/W - Continuation of MSBs of field REACTION_POINT6 from previous word. */
#else
		uint32_t reaction_point6             : 6;
		uint32_t enable7                     : 1;
		uint32_t reaction_point7             : 9;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_qmap_memx_w2_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_qmap_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070414008ull + (param1 & 255) * 0x10ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(...) bdk_tns_txq_dq_qcn_qmap_memx_w2_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_QMAP_MEMX_W2(...) "TNS_TXQ_DQ_QCN_QMAP_MEMX_W2"


/**
 * NCB32b - tns_txq_dq_qcn_rng_cfg
 *
 * QCN random number generator configuration
 *
 */
typedef union bdk_tns_txq_dq_qcn_rng_cfg {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_rng_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t qcn_byte_rng_seed           : 16; /**< R/W - Byte counter RNG seed value */
		uint32_t qcn_timer_rng_seed          : 16; /**< R/W - Timer RNG seed value */
#else
		uint32_t qcn_timer_rng_seed          : 16;
		uint32_t qcn_byte_rng_seed           : 16;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_rng_cfg_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_rng_cfg_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_rng_cfg_t;

#define BDK_TNS_TXQ_DQ_QCN_RNG_CFG BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_RNG_CFG_FUNC(void)
{
	return 0x000084207041C08Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_RNG_CFG bdk_tns_txq_dq_qcn_rng_cfg_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_RNG_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_RNG_CFG 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_RNG_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_RNG_CFG "TNS_TXQ_DQ_QCN_RNG_CFG"


/**
 * NCB32b - tns_txq_dq_qcn_supd_fif#
 *
 * QCN slow update FIFO data
 *
 */
typedef union bdk_tns_txq_dq_qcn_supd_fifx {
	uint32_t u;
	struct bdk_tns_txq_dq_qcn_supd_fifx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_25_31              : 7;
		uint32_t tokens_to_add               : 14; /**< R/W - -- */
		uint32_t queue                       : 11; /**< R/W - -- */
#else
		uint32_t queue                       : 11;
		uint32_t tokens_to_add               : 14;
		uint32_t reserved_25_31              : 7;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_supd_fifx_s cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_supd_fifx_s cn88xxp1; */
} bdk_tns_txq_dq_qcn_supd_fifx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x000084207041C000ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(...) bdk_tns_txq_dq_qcn_supd_fifx_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_SUPD_FIFX(...) "TNS_TXQ_DQ_QCN_SUPD_FIFX"


/**
 * NCB - tns_txq_dq_qcn_time
 *
 * Status of QCN timer and RNG
 *
 */
typedef union bdk_tns_txq_dq_qcn_time {
	uint64_t u;
	struct bdk_tns_txq_dq_qcn_time_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_60_63              : 4;
		uint64_t current_time                : 28; /**< RO/H - Current QCN time, counting down to zero */
		uint64_t time_random                 : 16; /**< RO/H - Current random number used for QCN timer reset randomization.  Updated each
                                                                 time round */
		uint64_t byte_random                 : 16; /**< RO/H - Current random number used for QCN byte reset randomization.  Updated each byte
                                                                 reset */
#else
		uint64_t byte_random                 : 16;
		uint64_t time_random                 : 16;
		uint64_t current_time                : 28;
		uint64_t reserved_60_63              : 4;
#endif
	} s;
	/* struct bdk_tns_txq_dq_qcn_time_s   cn88xx; */
	/* struct bdk_tns_txq_dq_qcn_time_s   cn88xxp1; */
} bdk_tns_txq_dq_qcn_time_t;

#define BDK_TNS_TXQ_DQ_QCN_TIME BDK_TNS_TXQ_DQ_QCN_TIME_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_TIME_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_QCN_TIME_FUNC(void)
{
	return 0x000084207041C090ull;
}
#define typedef_BDK_TNS_TXQ_DQ_QCN_TIME bdk_tns_txq_dq_qcn_time_t
#define bustype_BDK_TNS_TXQ_DQ_QCN_TIME BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_DQ_QCN_TIME 0
#define arguments_BDK_TNS_TXQ_DQ_QCN_TIME -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_QCN_TIME "TNS_TXQ_DQ_QCN_TIME"


/**
 * NCB32b - tns_txq_dq_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_dq_spad {
	uint32_t u;
	struct bdk_tns_txq_dq_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_dq_spad_s       cn88xx; */
	/* struct bdk_tns_txq_dq_spad_s       cn88xxp1; */
} bdk_tns_txq_dq_spad_t;

#define BDK_TNS_TXQ_DQ_SPAD BDK_TNS_TXQ_DQ_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_SPAD_FUNC(void)
{
	return 0x0000842070488144ull;
}
#define typedef_BDK_TNS_TXQ_DQ_SPAD bdk_tns_txq_dq_spad_t
#define bustype_BDK_TNS_TXQ_DQ_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_SPAD 0
#define arguments_BDK_TNS_TXQ_DQ_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_SPAD "TNS_TXQ_DQ_SPAD"


/**
 * NCB32b - tns_txq_dq_tb_afif#
 *
 * TB access fifo
 *
 */
typedef union bdk_tns_txq_dq_tb_afifx {
	uint32_t u;
	struct bdk_tns_txq_dq_tb_afifx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_30_31              : 2;
		uint32_t data                        : 30; /**< R/W - -- */
#else
		uint32_t data                        : 30;
		uint32_t reserved_30_31              : 2;
#endif
	} s;
	/* struct bdk_tns_txq_dq_tb_afifx_s   cn88xx; */
	/* struct bdk_tns_txq_dq_tb_afifx_s   cn88xxp1; */
} bdk_tns_txq_dq_tb_afifx_t;

static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIFX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIFX(unsigned long param1)
{
	if (((param1 <= 63)))
		return 0x0000842070488000ull + (param1 & 63) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_DQ_TB_AFIFX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_DQ_TB_AFIFX(...) bdk_tns_txq_dq_tb_afifx_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIFX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIFX(p1) (p1)
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIFX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_TB_AFIFX(...) "TNS_TXQ_DQ_TB_AFIFX"


/**
 * NCB32b - tns_txq_dq_tb_afif_ecc_log
 *
 * TB access FIFO memory ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_dq_tb_afif_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_dq_tb_afif_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t ecc_err_addr                : 6;  /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_dq_tb_afif_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_dq_tb_afif_ecc_log_s cn88xxp1; */
} bdk_tns_txq_dq_tb_afif_ecc_log_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG_FUNC(void)
{
	return 0x0000842070488134ull;
}
#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG bdk_tns_txq_dq_tb_afif_ecc_log_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_ECC_LOG "TNS_TXQ_DQ_TB_AFIF_ECC_LOG"


/**
 * NCB32b - tns_txq_dq_tb_afif_fc_thr
 *
 * TB access fifo flow control threshold
 *
 */
typedef union bdk_tns_txq_dq_tb_afif_fc_thr {
	uint32_t u;
	struct bdk_tns_txq_dq_tb_afif_fc_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t threshold                   : 7;  /**< R/W - -- */
#else
		uint32_t threshold                   : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_dq_tb_afif_fc_thr_s cn88xx; */
	/* struct bdk_tns_txq_dq_tb_afif_fc_thr_s cn88xxp1; */
} bdk_tns_txq_dq_tb_afif_fc_thr_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR_FUNC(void)
{
	return 0x0000842070488138ull;
}
#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR bdk_tns_txq_dq_tb_afif_fc_thr_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_FC_THR "TNS_TXQ_DQ_TB_AFIF_FC_THR"


/**
 * NCB32b - tns_txq_dq_tb_afif_ptr
 *
 * TB access fifo pointer debug register
 *
 */
typedef union bdk_tns_txq_dq_tb_afif_ptr {
	uint32_t u;
	struct bdk_tns_txq_dq_tb_afif_ptr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t debug                       : 14; /**< R/W/H - -- */
#else
		uint32_t debug                       : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_dq_tb_afif_ptr_s cn88xx; */
	/* struct bdk_tns_txq_dq_tb_afif_ptr_s cn88xxp1; */
} bdk_tns_txq_dq_tb_afif_ptr_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_PTR BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_PTR_FUNC(void)
{
	return 0x000084207048813Cull;
}
#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_PTR bdk_tns_txq_dq_tb_afif_ptr_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_PTR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_PTR 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_PTR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_PTR "TNS_TXQ_DQ_TB_AFIF_PTR"


/**
 * NCB32b - tns_txq_dq_tb_afif_usage
 *
 * DQ read token buffer access FIFO usage
 *
 */
typedef union bdk_tns_txq_dq_tb_afif_usage {
	uint32_t u;
	struct bdk_tns_txq_dq_tb_afif_usage_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t fifo_usage                  : 7;  /**< RO/H - -- */
#else
		uint32_t fifo_usage                  : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_dq_tb_afif_usage_s cn88xx; */
	/* struct bdk_tns_txq_dq_tb_afif_usage_s cn88xxp1; */
} bdk_tns_txq_dq_tb_afif_usage_t;

#define BDK_TNS_TXQ_DQ_TB_AFIF_USAGE BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_DQ_TB_AFIF_USAGE_FUNC(void)
{
	return 0x0000842070488130ull;
}
#define typedef_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE bdk_tns_txq_dq_tb_afif_usage_t
#define bustype_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE 0
#define arguments_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_DQ_TB_AFIF_USAGE "TNS_TXQ_DQ_TB_AFIF_USAGE"


/**
 * NCB32b - tns_txq_eq_3spd_wsarb_mode
 *
 * Multi-cast Speed FIFOs arbiter '0' - WRR, '1' - SP for 40G
 *
 */
typedef union bdk_tns_txq_eq_3spd_wsarb_mode {
	uint32_t u;
	struct bdk_tns_txq_eq_3spd_wsarb_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t mode                        : 1;  /**< R/W - -- */
#else
		uint32_t mode                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_eq_3spd_wsarb_mode_s cn88xx; */
	/* struct bdk_tns_txq_eq_3spd_wsarb_mode_s cn88xxp1; */
} bdk_tns_txq_eq_3spd_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE_FUNC(void)
{
	return 0x00008420706848F0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE bdk_tns_txq_eq_3spd_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_3SPD_WSARB_MODE "TNS_TXQ_EQ_3SPD_WSARB_MODE"


/**
 * NCB32b - tns_txq_eq_3spd_wsarb_wgt
 *
 * Multi-cast Speed FIFOs arbiter weights for 40G/10G/misc
 *
 */
typedef union bdk_tns_txq_eq_3spd_wsarb_wgt {
	uint32_t u;
	struct bdk_tns_txq_eq_3spd_wsarb_wgt_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t weight_misc                 : 8;  /**< R/W - -- */
		uint32_t weight_10g                  : 8;  /**< R/W - -- */
		uint32_t weight_40g                  : 8;  /**< R/W - -- */
#else
		uint32_t weight_40g                  : 8;
		uint32_t weight_10g                  : 8;
		uint32_t weight_misc                 : 8;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_txq_eq_3spd_wsarb_wgt_s cn88xx; */
	/* struct bdk_tns_txq_eq_3spd_wsarb_wgt_s cn88xxp1; */
} bdk_tns_txq_eq_3spd_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT_FUNC(void)
{
	return 0x00008420706848F4ull;
}
#define typedef_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT bdk_tns_txq_eq_3spd_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_3SPD_WSARB_WGT "TNS_TXQ_EQ_3SPD_WSARB_WGT"


/**
 * NCB32b - tns_txq_eq_aqm_lfif#_w#
 *
 * Target pipe based FIFOs used for latency matching during MC query-response
 * Bits[31:18] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_aqm_lfifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_aqm_lfifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_aqm_lfifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_aqm_lfifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_aqm_lfifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 4)))
		return 0x0000842070684000ull + (param1 & 15) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_AQM_LFIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(...) bdk_tns_txq_eq_aqm_lfifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_AQM_LFIFX_WX(...) "TNS_TXQ_EQ_AQM_LFIFX_WX"


/**
 * NCB32b - tns_txq_eq_aqmq_wsarb_mode
 *
 * AQM query pipeline arbiter '0' - WRR, '1' - SP for Multi-cast
 *
 */
typedef union bdk_tns_txq_eq_aqmq_wsarb_mode {
	uint32_t u;
	struct bdk_tns_txq_eq_aqmq_wsarb_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t mode                        : 1;  /**< R/W - -- */
#else
		uint32_t mode                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_eq_aqmq_wsarb_mode_s cn88xx; */
	/* struct bdk_tns_txq_eq_aqmq_wsarb_mode_s cn88xxp1; */
} bdk_tns_txq_eq_aqmq_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE_FUNC(void)
{
	return 0x00008420706848F8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE bdk_tns_txq_eq_aqmq_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_AQMQ_WSARB_MODE "TNS_TXQ_EQ_AQMQ_WSARB_MODE"


/**
 * NCB32b - tns_txq_eq_aqmq_wsarb_wgt
 *
 * AQM_query arbiter weights for egress mirror  and Multi-cast packets
 *
 */
typedef union bdk_tns_txq_eq_aqmq_wsarb_wgt {
	uint32_t u;
	struct bdk_tns_txq_eq_aqmq_wsarb_wgt_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t em_weight                   : 8;  /**< R/W - -- */
		uint32_t mc_weight                   : 8;  /**< R/W - -- */
#else
		uint32_t mc_weight                   : 8;
		uint32_t em_weight                   : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_aqmq_wsarb_wgt_s cn88xx; */
	/* struct bdk_tns_txq_eq_aqmq_wsarb_wgt_s cn88xxp1; */
} bdk_tns_txq_eq_aqmq_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT_FUNC(void)
{
	return 0x00008420706848FCull;
}
#define typedef_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT bdk_tns_txq_eq_aqmq_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_AQMQ_WSARB_WGT "TNS_TXQ_EQ_AQMQ_WSARB_WGT"


/**
 * NCB32b - tns_txq_eq_bist_stdn
 *
 * TxQ EQ bist status and bist_done
 *
 */
typedef union bdk_tns_txq_eq_bist_stdn {
	uint32_t u;
	struct bdk_tns_txq_eq_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t pfc_map_mem_status          : 1;  /**< RO/H - -- */
		uint32_t pfc_map_mem_done            : 1;  /**< RO/H - -- */
#else
		uint32_t pfc_map_mem_done            : 1;
		uint32_t pfc_map_mem_status          : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_txq_eq_bist_stdn_s  cn88xx; */
	/* struct bdk_tns_txq_eq_bist_stdn_s  cn88xxp1; */
} bdk_tns_txq_eq_bist_stdn_t;

#define BDK_TNS_TXQ_EQ_BIST_STDN BDK_TNS_TXQ_EQ_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_BIST_STDN_FUNC(void)
{
	return 0x0000842070684890ull;
}
#define typedef_BDK_TNS_TXQ_EQ_BIST_STDN bdk_tns_txq_eq_bist_stdn_t
#define bustype_BDK_TNS_TXQ_EQ_BIST_STDN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_EQ_BIST_STDN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_BIST_STDN "TNS_TXQ_EQ_BIST_STDN"


/**
 * NCB32b - tns_txq_eq_clr_pt_wait_eop
 *
 * Debug/initialization to clear out waiting for EOP status on port in case of
 * errors, or unclean port disabling
 */
typedef union bdk_tns_txq_eq_clr_pt_wait_eop {
	uint32_t u;
	struct bdk_tns_txq_eq_clr_pt_wait_eop_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t port15                      : 1;  /**< R/W - -- */
		uint32_t port14                      : 1;  /**< R/W - -- */
		uint32_t port13                      : 1;  /**< R/W - -- */
		uint32_t port12                      : 1;  /**< R/W - -- */
		uint32_t port11                      : 1;  /**< R/W - -- */
		uint32_t port10                      : 1;  /**< R/W - -- */
		uint32_t port9                       : 1;  /**< R/W - -- */
		uint32_t port8                       : 1;  /**< R/W - -- */
		uint32_t port7                       : 1;  /**< R/W - -- */
		uint32_t port6                       : 1;  /**< R/W - -- */
		uint32_t port5                       : 1;  /**< R/W - -- */
		uint32_t port4                       : 1;  /**< R/W - -- */
		uint32_t port3                       : 1;  /**< R/W - -- */
		uint32_t port2                       : 1;  /**< R/W - -- */
		uint32_t port1                       : 1;  /**< R/W - -- */
		uint32_t port0                       : 1;  /**< R/W - -- */
#else
		uint32_t port0                       : 1;
		uint32_t port1                       : 1;
		uint32_t port2                       : 1;
		uint32_t port3                       : 1;
		uint32_t port4                       : 1;
		uint32_t port5                       : 1;
		uint32_t port6                       : 1;
		uint32_t port7                       : 1;
		uint32_t port8                       : 1;
		uint32_t port9                       : 1;
		uint32_t port10                      : 1;
		uint32_t port11                      : 1;
		uint32_t port12                      : 1;
		uint32_t port13                      : 1;
		uint32_t port14                      : 1;
		uint32_t port15                      : 1;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_clr_pt_wait_eop_s cn88xx; */
	/* struct bdk_tns_txq_eq_clr_pt_wait_eop_s cn88xxp1; */
} bdk_tns_txq_eq_clr_pt_wait_eop_t;

#define BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP_FUNC(void)
{
	return 0x00008420706848ACull;
}
#define typedef_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP bdk_tns_txq_eq_clr_pt_wait_eop_t
#define bustype_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP 0
#define arguments_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_CLR_PT_WAIT_EOP "TNS_TXQ_EQ_CLR_PT_WAIT_EOP"


/**
 * NCB32b - tns_txq_eq_cut_thru_bcnt_cfg
 *
 * Byte count in case of cut thru mode for statistics, AQM, etc
 *
 */
typedef union bdk_tns_txq_eq_cut_thru_bcnt_cfg {
	uint32_t u;
	struct bdk_tns_txq_eq_cut_thru_bcnt_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t data                        : 14; /**< R/W - -- */
#else
		uint32_t data                        : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_eq_cut_thru_bcnt_cfg_s cn88xx; */
	/* struct bdk_tns_txq_eq_cut_thru_bcnt_cfg_s cn88xxp1; */
} bdk_tns_txq_eq_cut_thru_bcnt_cfg_t;

#define BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG_FUNC(void)
{
	return 0x000084207068489Cull;
}
#define typedef_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG bdk_tns_txq_eq_cut_thru_bcnt_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_CUT_THRU_BCNT_CFG "TNS_TXQ_EQ_CUT_THRU_BCNT_CFG"


/**
 * NCB32b - tns_txq_eq_cut_thru_npgs_cfg
 *
 * Pages used in case of cut thru mode for statistics, AQM, etc.
 *
 */
typedef union bdk_tns_txq_eq_cut_thru_npgs_cfg {
	uint32_t u;
	struct bdk_tns_txq_eq_cut_thru_npgs_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t data                        : 7;  /**< R/W - -- */
#else
		uint32_t data                        : 7;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_eq_cut_thru_npgs_cfg_s cn88xx; */
	/* struct bdk_tns_txq_eq_cut_thru_npgs_cfg_s cn88xxp1; */
} bdk_tns_txq_eq_cut_thru_npgs_cfg_t;

#define BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG_FUNC(void)
{
	return 0x00008420706848A0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG bdk_tns_txq_eq_cut_thru_npgs_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_CUT_THRU_NPGS_CFG "TNS_TXQ_EQ_CUT_THRU_NPGS_CFG"


/**
 * NCB - tns_txq_eq_dist_fif_usage
 *
 * All distributor FIFO usage
 *
 */
typedef union bdk_tns_txq_eq_dist_fif_usage {
	uint64_t u;
	struct bdk_tns_txq_eq_dist_fif_usage_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_46_63              : 18;
		uint64_t source_em_fifo              : 5;  /**< RO/H - Distributor source egress mirror FIFO usage */
		uint64_t mc_fifo                     : 5;  /**< RO/H - Distributor source multi-cast FIFO usage */
		uint64_t uc_drop_fifo                : 5;  /**< RO/H - Distributor source unicast and drop FIFO usage */
		uint64_t mc_40g_fifo                 : 5;  /**< RO/H - Distributor 40G speed multi-cast FIFO usage */
		uint64_t mc_10g_fifo                 : 5;  /**< RO/H - Distributor 10G speed multi-cast FIFO usage */
		uint64_t mc_misc_fifo                : 5;  /**< RO/H - Distributor misc speed multi-cast FIFO usage */
		uint64_t mc2drop_fifo                : 5;  /**< RO/H - Distributor Multi-cast drop FIFO usage */
		uint64_t aqm_lat_fifo                : 5;  /**< RO/H - Distributor AQM query latency FIFO usage */
		uint64_t query_out_fifo              : 6;  /**< RO/H - Distributor post-AQM query FIFO usage */
#else
		uint64_t query_out_fifo              : 6;
		uint64_t aqm_lat_fifo                : 5;
		uint64_t mc2drop_fifo                : 5;
		uint64_t mc_misc_fifo                : 5;
		uint64_t mc_10g_fifo                 : 5;
		uint64_t mc_40g_fifo                 : 5;
		uint64_t uc_drop_fifo                : 5;
		uint64_t mc_fifo                     : 5;
		uint64_t source_em_fifo              : 5;
		uint64_t reserved_46_63              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_eq_dist_fif_usage_s cn88xx; */
	/* struct bdk_tns_txq_eq_dist_fif_usage_s cn88xxp1; */
} bdk_tns_txq_eq_dist_fif_usage_t;

#define BDK_TNS_TXQ_EQ_DIST_FIF_USAGE BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DIST_FIF_USAGE_FUNC(void)
{
	return 0x00008420706848B0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE bdk_tns_txq_eq_dist_fif_usage_t
#define bustype_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_DIST_FIF_USAGE "TNS_TXQ_EQ_DIST_FIF_USAGE"


/**
 * NCB32b - tns_txq_eq_disto_wsarb_mode
 *
 * Distributer Output aribter '0' - WRR, '1' - SP for Unicast
 *
 */
typedef union bdk_tns_txq_eq_disto_wsarb_mode {
	uint32_t u;
	struct bdk_tns_txq_eq_disto_wsarb_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t mode                        : 1;  /**< R/W - -- */
#else
		uint32_t mode                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_eq_disto_wsarb_mode_s cn88xx; */
	/* struct bdk_tns_txq_eq_disto_wsarb_mode_s cn88xxp1; */
} bdk_tns_txq_eq_disto_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE_FUNC(void)
{
	return 0x0000842070684900ull;
}
#define typedef_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE bdk_tns_txq_eq_disto_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_DISTO_WSARB_MODE "TNS_TXQ_EQ_DISTO_WSARB_MODE"


/**
 * NCB32b - tns_txq_eq_disto_wsarb_wgt
 *
 * Distributer Output ariber weights for Unicast, MC drop, and MC/EM packets
 *
 */
typedef union bdk_tns_txq_eq_disto_wsarb_wgt {
	uint32_t u;
	struct bdk_tns_txq_eq_disto_wsarb_wgt_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t mc_em_weight                : 8;  /**< R/W - -- */
		uint32_t mc_drop_weight              : 8;  /**< R/W - -- */
		uint32_t uc_weight                   : 8;  /**< R/W - -- */
#else
		uint32_t uc_weight                   : 8;
		uint32_t mc_drop_weight              : 8;
		uint32_t mc_em_weight                : 8;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_txq_eq_disto_wsarb_wgt_s cn88xx; */
	/* struct bdk_tns_txq_eq_disto_wsarb_wgt_s cn88xxp1; */
} bdk_tns_txq_eq_disto_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT_FUNC(void)
{
	return 0x0000842070684904ull;
}
#define typedef_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT bdk_tns_txq_eq_disto_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_DISTO_WSARB_WGT "TNS_TXQ_EQ_DISTO_WSARB_WGT"


/**
 * NCB32b - tns_txq_eq_dists_em_drp_ct
 *
 * Counter of Egress Mirror packet drops made by distributor (source) due to EM
 * copy FIFO being full.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
typedef union bdk_tns_txq_eq_dists_em_drp_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_dists_em_drp_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_dists_em_drp_ct_s cn88xx; */
	/* struct bdk_tns_txq_eq_dists_em_drp_ct_s cn88xxp1; */
} bdk_tns_txq_eq_dists_em_drp_ct_t;

#define BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT_FUNC(void)
{
	return 0x00008420706848C0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT bdk_tns_txq_eq_dists_em_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_DISTS_EM_DRP_CT "TNS_TXQ_EQ_DISTS_EM_DRP_CT"


/**
 * NCB32b - tns_txq_eq_dists_mc_drp_ct
 *
 * Counter of TXQ multi-cast packet drops made by distributor (source) due to MC
 * FIFO being full.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
typedef union bdk_tns_txq_eq_dists_mc_drp_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_dists_mc_drp_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_dists_mc_drp_ct_s cn88xx; */
	/* struct bdk_tns_txq_eq_dists_mc_drp_ct_s cn88xxp1; */
} bdk_tns_txq_eq_dists_mc_drp_ct_t;

#define BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT_FUNC(void)
{
	return 0x00008420706848C4ull;
}
#define typedef_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT bdk_tns_txq_eq_dists_mc_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_DISTS_MC_DRP_CT "TNS_TXQ_EQ_DISTS_MC_DRP_CT"


/**
 * NCB32b - tns_txq_eq_ecc_ctl
 *
 * ECC configuration of Token Buffer memories
 *
 */
typedef union bdk_tns_txq_eq_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_eq_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t pfc_map_db_ecc              : 1;  /**< R/W - Flip 2 bits of ECC syndrome in PFC mapping memory */
		uint32_t pfc_map_sb_ecc              : 1;  /**< R/W - Flip 1 bit of ECC syndrome in PFC mapping  memory */
		uint32_t pfc_map_ecc_dis             : 1;  /**< R/W - Disable ECC for PFC mapping memory */
#else
		uint32_t pfc_map_ecc_dis             : 1;
		uint32_t pfc_map_sb_ecc              : 1;
		uint32_t pfc_map_db_ecc              : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_eq_ecc_ctl_s    cn88xx; */
	/* struct bdk_tns_txq_eq_ecc_ctl_s    cn88xxp1; */
} bdk_tns_txq_eq_ecc_ctl_t;

#define BDK_TNS_TXQ_EQ_ECC_CTL BDK_TNS_TXQ_EQ_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_ECC_CTL_FUNC(void)
{
	return 0x0000842070684894ull;
}
#define typedef_BDK_TNS_TXQ_EQ_ECC_CTL bdk_tns_txq_eq_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_EQ_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_EQ_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_ECC_CTL "TNS_TXQ_EQ_ECC_CTL"


/**
 * NCB32b - tns_txq_eq_em_copy_cfg
 *
 * Egress mirror configuration
 *
 */
typedef union bdk_tns_txq_eq_em_copy_cfg {
	uint32_t u;
	struct bdk_tns_txq_eq_em_copy_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_28_31              : 4;
		uint32_t tc                          : 4;  /**< R/W - -- */
		uint32_t dst_port                    : 8;  /**< R/W - -- */
		uint32_t txq_sel_vect                : 16; /**< R/W - -- */
#else
		uint32_t txq_sel_vect                : 16;
		uint32_t dst_port                    : 8;
		uint32_t tc                          : 4;
		uint32_t reserved_28_31              : 4;
#endif
	} s;
	/* struct bdk_tns_txq_eq_em_copy_cfg_s cn88xx; */
	/* struct bdk_tns_txq_eq_em_copy_cfg_s cn88xxp1; */
} bdk_tns_txq_eq_em_copy_cfg_t;

#define BDK_TNS_TXQ_EQ_EM_COPY_CFG BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_COPY_CFG_FUNC(void)
{
	return 0x0000842070684908ull;
}
#define typedef_BDK_TNS_TXQ_EQ_EM_COPY_CFG bdk_tns_txq_eq_em_copy_cfg_t
#define bustype_BDK_TNS_TXQ_EQ_EM_COPY_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EM_COPY_CFG 0
#define arguments_BDK_TNS_TXQ_EQ_EM_COPY_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EM_COPY_CFG "TNS_TXQ_EQ_EM_COPY_CFG"


/**
 * NCB32b - tns_txq_eq_em_fif#_w#
 *
 * EM_token input FIFO to Cut-thru check
 * Bits[31:26] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_em_fifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_em_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t em_token                    : 32; /**< R/W - -- */
#else
		uint32_t em_token                    : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_em_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_em_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_em_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 4)))
		return 0x0000842070683800ull + (param1 & 15) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_EM_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_EM_FIFX_WX(...) bdk_tns_txq_eq_em_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_EM_FIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EM_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_EM_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_EM_FIFX_WX(...) "TNS_TXQ_EQ_EM_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_em_fif_fc_thr
 *
 * Distributor egress mirror input FIFO flow control threshold
 *
 */
typedef union bdk_tns_txq_eq_em_fif_fc_thr {
	uint32_t u;
	struct bdk_tns_txq_eq_em_fif_fc_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t theshold                    : 5;  /**< R/W - -- */
#else
		uint32_t theshold                    : 5;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_eq_em_fif_fc_thr_s cn88xx; */
	/* struct bdk_tns_txq_eq_em_fif_fc_thr_s cn88xxp1; */
} bdk_tns_txq_eq_em_fif_fc_thr_t;

#define BDK_TNS_TXQ_EQ_EM_FIF_FC_THR BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_FIF_FC_THR_FUNC(void)
{
	return 0x00008420706848D8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR bdk_tns_txq_eq_em_fif_fc_thr_t
#define bustype_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EM_FIF_FC_THR "TNS_TXQ_EQ_EM_FIF_FC_THR"


/**
 * NCB32b - tns_txq_eq_em_pkt_drp_ct
 *
 * Egress Mirror drop count due to FIFO full in Egress mirror generation.
 * Saturates at 32'hffffffff.  Read-only, clear on read.
 */
typedef union bdk_tns_txq_eq_em_pkt_drp_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_em_pkt_drp_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_em_pkt_drp_ct_s cn88xx; */
	/* struct bdk_tns_txq_eq_em_pkt_drp_ct_s cn88xxp1; */
} bdk_tns_txq_eq_em_pkt_drp_ct_t;

#define BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT_FUNC(void)
{
	return 0x00008420706848BCull;
}
#define typedef_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT bdk_tns_txq_eq_em_pkt_drp_ct_t
#define bustype_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EM_PKT_DRP_CT "TNS_TXQ_EQ_EM_PKT_DRP_CT"


/**
 * NCB32b - tns_txq_eq_emsd_wsarb_mode
 *
 * Cut-thru Egress Mirror and SDMA token WRR/SP arbiter mode; '0' - WRR, '1' - SP
 * for SDMA
 */
typedef union bdk_tns_txq_eq_emsd_wsarb_mode {
	uint32_t u;
	struct bdk_tns_txq_eq_emsd_wsarb_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_eq_emsd_wsarb_mode_s cn88xx; */
	/* struct bdk_tns_txq_eq_emsd_wsarb_mode_s cn88xxp1; */
} bdk_tns_txq_eq_emsd_wsarb_mode_t;

#define BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE_FUNC(void)
{
	return 0x00008420706848A4ull;
}
#define typedef_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE bdk_tns_txq_eq_emsd_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EMSD_WSARB_MODE "TNS_TXQ_EQ_EMSD_WSARB_MODE"


/**
 * NCB32b - tns_txq_eq_emsd_wsarb_wgt
 *
 * Cut-Thru Egress Mirror and SDMA WRR/SP arbiter weights
 *
 */
typedef union bdk_tns_txq_eq_emsd_wsarb_wgt {
	uint32_t u;
	struct bdk_tns_txq_eq_emsd_wsarb_wgt_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t em_weight                   : 8;  /**< R/W - -- */
		uint32_t sdma_weight                 : 8;  /**< R/W - -- */
#else
		uint32_t sdma_weight                 : 8;
		uint32_t em_weight                   : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_emsd_wsarb_wgt_s cn88xx; */
	/* struct bdk_tns_txq_eq_emsd_wsarb_wgt_s cn88xxp1; */
} bdk_tns_txq_eq_emsd_wsarb_wgt_t;

#define BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT_FUNC(void)
{
	return 0x00008420706848A8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT bdk_tns_txq_eq_emsd_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EMSD_WSARB_WGT "TNS_TXQ_EQ_EMSD_WSARB_WGT"


/**
 * NCB32b - tns_txq_eq_eop_mem#
 *
 * Packet ID memory for storing packet ID of last EOP on port
 *
 */
typedef union bdk_tns_txq_eq_eop_memx {
	uint32_t u;
	struct bdk_tns_txq_eq_eop_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t packet_id                   : 10; /**< R/W - -- */
#else
		uint32_t packet_id                   : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_txq_eq_eop_memx_s   cn88xx; */
	/* struct bdk_tns_txq_eq_eop_memx_s   cn88xxp1; */
} bdk_tns_txq_eq_eop_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EOP_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EOP_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070684800ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_EOP_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_EOP_MEMX(...) bdk_tns_txq_eq_eop_memx_t
#define bustype_BDK_TNS_TXQ_EQ_EOP_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EOP_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_EQ_EOP_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_EOP_MEMX(...) "TNS_TXQ_EQ_EOP_MEMX"


/**
 * NCB32b - tns_txq_eq_eqem_fif#_w#
 *
 * Source pipe based FIFOs used in emcopy path
 * Bits[31:26] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_eqem_fifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_eqem_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_eqem_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_eqem_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_eqem_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 4)))
		return 0x0000842070683A00ull + (param1 & 15) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_EQEM_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(...) bdk_tns_txq_eq_eqem_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_EQEM_FIFX_WX(...) "TNS_TXQ_EQ_EQEM_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_fif_usage
 *
 * EQ cut thru and write token FIFO usage
 *
 */
typedef union bdk_tns_txq_eq_fif_usage {
	uint32_t u;
	struct bdk_tns_txq_eq_fif_usage_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_20_31              : 12;
		uint32_t em_fifo                     : 5;  /**< RO/H - Cut-thru EM FIFO usage */
		uint32_t lat_fifo                    : 5;  /**< RO/H - Write token latency FIFO usage */
		uint32_t pool_fifo                   : 5;  /**< RO/H - Write token pool FIFO usage */
		uint32_t tail_fifo                   : 5;  /**< RO/H - Write token tail FIFO usage */
#else
		uint32_t tail_fifo                   : 5;
		uint32_t pool_fifo                   : 5;
		uint32_t lat_fifo                    : 5;
		uint32_t em_fifo                     : 5;
		uint32_t reserved_20_31              : 12;
#endif
	} s;
	/* struct bdk_tns_txq_eq_fif_usage_s  cn88xx; */
	/* struct bdk_tns_txq_eq_fif_usage_s  cn88xxp1; */
} bdk_tns_txq_eq_fif_usage_t;

#define BDK_TNS_TXQ_EQ_FIF_USAGE BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_FIF_USAGE_FUNC(void)
{
	return 0x00008420706848B8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_FIF_USAGE bdk_tns_txq_eq_fif_usage_t
#define bustype_BDK_TNS_TXQ_EQ_FIF_USAGE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_EQ_FIF_USAGE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_FIF_USAGE "TNS_TXQ_EQ_FIF_USAGE"


/**
 * NCB32b - tns_txq_eq_int_en_hi
 *
 * EQ Interrupt register
 *
 */
typedef union bdk_tns_txq_eq_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_eq_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;  /**< R/W - -- */
		uint32_t post_query_fifo_ovfl        : 1;  /**< R/W - -- */
		uint32_t lat_fifo_ovfl               : 1;  /**< R/W - -- */
		uint32_t pool_fifo_ovfl              : 1;  /**< R/W - -- */
		uint32_t tail_fifo_ovfl              : 1;  /**< R/W - -- */
		uint32_t em_pkt_drop                 : 1;  /**< R/W - -- */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - EQ configuration input DFC Rx overflow */
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1; /**< R/W - TBM to EQ tail pointer input DFC Rx overflow */
		uint32_t sdma_eq_dfc_ovfl_err        : 1;  /**< R/W - SDMA to EQ token input DFC Rx overflow */
		uint32_t pfc_map_mem_db_err          : 1;  /**< R/W - PFC mapping memory double bit ECC interrupt */
		uint32_t pfc_map_mem_sb_err          : 1;  /**< R/W - PFC mapping memory single bit ECC interrupt */
#else
		uint32_t pfc_map_mem_sb_err          : 1;
		uint32_t pfc_map_mem_db_err          : 1;
		uint32_t sdma_eq_dfc_ovfl_err        : 1;
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t em_pkt_drop                 : 1;
		uint32_t tail_fifo_ovfl              : 1;
		uint32_t pool_fifo_ovfl              : 1;
		uint32_t lat_fifo_ovfl               : 1;
		uint32_t post_query_fifo_ovfl        : 1;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_eq_int_en_hi_s  cn88xx; */
	/* struct bdk_tns_txq_eq_int_en_hi_s  cn88xxp1; */
} bdk_tns_txq_eq_int_en_hi_t;

#define BDK_TNS_TXQ_EQ_INT_EN_HI BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_HI_FUNC(void)
{
	return 0x0000842070684884ull;
}
#define typedef_BDK_TNS_TXQ_EQ_INT_EN_HI bdk_tns_txq_eq_int_en_hi_t
#define bustype_BDK_TNS_TXQ_EQ_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_EQ_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_INT_EN_HI "TNS_TXQ_EQ_INT_EN_HI"


/**
 * NCB32b - tns_txq_eq_int_en_lo
 *
 * EQ Interrupt register
 *
 */
typedef union bdk_tns_txq_eq_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_eq_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;  /**< R/W - -- */
		uint32_t post_query_fifo_ovfl        : 1;  /**< R/W - -- */
		uint32_t lat_fifo_ovfl               : 1;  /**< R/W - -- */
		uint32_t pool_fifo_ovfl              : 1;  /**< R/W - -- */
		uint32_t tail_fifo_ovfl              : 1;  /**< R/W - -- */
		uint32_t em_pkt_drop                 : 1;  /**< R/W - -- */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - EQ configuration input DFC Rx overflow */
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1; /**< R/W - TBM to EQ tail pointer input DFC Rx overflow */
		uint32_t sdma_eq_dfc_ovfl_err        : 1;  /**< R/W - SDMA to EQ token input DFC Rx overflow */
		uint32_t pfc_map_mem_db_err          : 1;  /**< R/W - PFC mapping memory double bit ECC interrupt */
		uint32_t pfc_map_mem_sb_err          : 1;  /**< R/W - PFC mapping memory single bit ECC interrupt */
#else
		uint32_t pfc_map_mem_sb_err          : 1;
		uint32_t pfc_map_mem_db_err          : 1;
		uint32_t sdma_eq_dfc_ovfl_err        : 1;
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t em_pkt_drop                 : 1;
		uint32_t tail_fifo_ovfl              : 1;
		uint32_t pool_fifo_ovfl              : 1;
		uint32_t lat_fifo_ovfl               : 1;
		uint32_t post_query_fifo_ovfl        : 1;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_eq_int_en_lo_s  cn88xx; */
	/* struct bdk_tns_txq_eq_int_en_lo_s  cn88xxp1; */
} bdk_tns_txq_eq_int_en_lo_t;

#define BDK_TNS_TXQ_EQ_INT_EN_LO BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_EN_LO_FUNC(void)
{
	return 0x0000842070684888ull;
}
#define typedef_BDK_TNS_TXQ_EQ_INT_EN_LO bdk_tns_txq_eq_int_en_lo_t
#define bustype_BDK_TNS_TXQ_EQ_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_EQ_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_INT_EN_LO "TNS_TXQ_EQ_INT_EN_LO"


/**
 * NCB32b - tns_txq_eq_int_frc
 *
 * EQ Interrupt register
 *
 */
typedef union bdk_tns_txq_eq_int_frc {
	uint32_t u;
	struct bdk_tns_txq_eq_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;  /**< WO - -- */
		uint32_t post_query_fifo_ovfl        : 1;  /**< WO - -- */
		uint32_t lat_fifo_ovfl               : 1;  /**< WO - -- */
		uint32_t pool_fifo_ovfl              : 1;  /**< WO - -- */
		uint32_t tail_fifo_ovfl              : 1;  /**< WO - -- */
		uint32_t em_pkt_drop                 : 1;  /**< WO - -- */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< WO - EQ configuration input DFC Rx overflow */
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1; /**< WO - TBM to EQ tail pointer input DFC Rx overflow */
		uint32_t sdma_eq_dfc_ovfl_err        : 1;  /**< WO - SDMA to EQ token input DFC Rx overflow */
		uint32_t pfc_map_mem_db_err          : 1;  /**< WO - PFC mapping memory double bit ECC interrupt */
		uint32_t pfc_map_mem_sb_err          : 1;  /**< WO - PFC mapping memory single bit ECC interrupt */
#else
		uint32_t pfc_map_mem_sb_err          : 1;
		uint32_t pfc_map_mem_db_err          : 1;
		uint32_t sdma_eq_dfc_ovfl_err        : 1;
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t em_pkt_drop                 : 1;
		uint32_t tail_fifo_ovfl              : 1;
		uint32_t pool_fifo_ovfl              : 1;
		uint32_t lat_fifo_ovfl               : 1;
		uint32_t post_query_fifo_ovfl        : 1;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_eq_int_frc_s    cn88xx; */
	/* struct bdk_tns_txq_eq_int_frc_s    cn88xxp1; */
} bdk_tns_txq_eq_int_frc_t;

#define BDK_TNS_TXQ_EQ_INT_FRC BDK_TNS_TXQ_EQ_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_FRC_FUNC(void)
{
	return 0x000084207068488Cull;
}
#define typedef_BDK_TNS_TXQ_EQ_INT_FRC bdk_tns_txq_eq_int_frc_t
#define bustype_BDK_TNS_TXQ_EQ_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_INT_FRC 0
#define arguments_BDK_TNS_TXQ_EQ_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_INT_FRC "TNS_TXQ_EQ_INT_FRC"


/**
 * NCB32b - tns_txq_eq_int_w1c
 *
 * EQ Interrupt register
 *
 */
typedef union bdk_tns_txq_eq_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_eq_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;  /**< R/W1C/H - -- */
		uint32_t post_query_fifo_ovfl        : 1;  /**< R/W1C/H - -- */
		uint32_t lat_fifo_ovfl               : 1;  /**< R/W1C/H - -- */
		uint32_t pool_fifo_ovfl              : 1;  /**< R/W1C/H - -- */
		uint32_t tail_fifo_ovfl              : 1;  /**< R/W1C/H - -- */
		uint32_t em_pkt_drop                 : 1;  /**< R/W1C/H - -- */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W1C/H - EQ configuration input DFC Rx overflow */
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1; /**< R/W1C/H - TBM to EQ tail pointer input DFC Rx overflow */
		uint32_t sdma_eq_dfc_ovfl_err        : 1;  /**< R/W1C/H - SDMA to EQ token input DFC Rx overflow */
		uint32_t pfc_map_mem_db_err          : 1;  /**< R/W1C/H - PFC mapping memory double bit ECC interrupt */
		uint32_t pfc_map_mem_sb_err          : 1;  /**< R/W1C/H - PFC mapping memory single bit ECC interrupt */
#else
		uint32_t pfc_map_mem_sb_err          : 1;
		uint32_t pfc_map_mem_db_err          : 1;
		uint32_t sdma_eq_dfc_ovfl_err        : 1;
		uint32_t tbm_eq_tail_ptr_dfc_ovfl_err : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t em_pkt_drop                 : 1;
		uint32_t tail_fifo_ovfl              : 1;
		uint32_t pool_fifo_ovfl              : 1;
		uint32_t lat_fifo_ovfl               : 1;
		uint32_t post_query_fifo_ovfl        : 1;
		uint32_t cut_thru_2_tkns_bef_eop_err : 1;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_eq_int_w1c_s    cn88xx; */
	/* struct bdk_tns_txq_eq_int_w1c_s    cn88xxp1; */
} bdk_tns_txq_eq_int_w1c_t;

#define BDK_TNS_TXQ_EQ_INT_W1C BDK_TNS_TXQ_EQ_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_INT_W1C_FUNC(void)
{
	return 0x0000842070684880ull;
}
#define typedef_BDK_TNS_TXQ_EQ_INT_W1C bdk_tns_txq_eq_int_w1c_t
#define bustype_BDK_TNS_TXQ_EQ_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_INT_W1C 0
#define arguments_BDK_TNS_TXQ_EQ_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_INT_W1C "TNS_TXQ_EQ_INT_W1C"


/**
 * NCB32b - tns_txq_eq_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_eq_lock {
	uint32_t u;
	struct bdk_tns_txq_eq_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_lock_s       cn88xx; */
	/* struct bdk_tns_txq_eq_lock_s       cn88xxp1; */
} bdk_tns_txq_eq_lock_t;

#define BDK_TNS_TXQ_EQ_LOCK BDK_TNS_TXQ_EQ_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_LOCK_FUNC(void)
{
	return 0x0000842070684918ull;
}
#define typedef_BDK_TNS_TXQ_EQ_LOCK bdk_tns_txq_eq_lock_t
#define bustype_BDK_TNS_TXQ_EQ_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_LOCK 0
#define arguments_BDK_TNS_TXQ_EQ_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_LOCK "TNS_TXQ_EQ_LOCK"


/**
 * NCB32b - tns_txq_eq_lp2pp_mem#
 *
 * Logical Source Port to Physical Source Port Mapping.
 *
 */
typedef union bdk_tns_txq_eq_lp2pp_memx {
	uint32_t u;
	struct bdk_tns_txq_eq_lp2pp_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_4_31               : 28;
		uint32_t physical_port               : 4;  /**< R/W - -- */
#else
		uint32_t physical_port               : 4;
		uint32_t reserved_4_31               : 28;
#endif
	} s;
	/* struct bdk_tns_txq_eq_lp2pp_memx_s cn88xx; */
	/* struct bdk_tns_txq_eq_lp2pp_memx_s cn88xxp1; */
} bdk_tns_txq_eq_lp2pp_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_LP2PP_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_LP2PP_MEMX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x0000842070684400ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_LP2PP_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_LP2PP_MEMX(...) bdk_tns_txq_eq_lp2pp_memx_t
#define bustype_BDK_TNS_TXQ_EQ_LP2PP_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_LP2PP_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_EQ_LP2PP_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_LP2PP_MEMX(...) "TNS_TXQ_EQ_LP2PP_MEMX"


/**
 * NCB32b - tns_txq_eq_mc2drop_ct
 *
 * Counter of TXQ multi-cast packet drops made by distributor due to per-speed MC
 * FIFO being full.  Saturates at 32'hffffffff.  Read only, clear on read.
 */
typedef union bdk_tns_txq_eq_mc2drop_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_mc2drop_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc2drop_ct_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc2drop_ct_s cn88xxp1; */
} bdk_tns_txq_eq_mc2drop_ct_t;

#define BDK_TNS_TXQ_EQ_MC2DROP_CT BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_CT_FUNC(void)
{
	return 0x00008420706848C8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_MC2DROP_CT bdk_tns_txq_eq_mc2drop_ct_t
#define bustype_BDK_TNS_TXQ_EQ_MC2DROP_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC2DROP_CT 0
#define arguments_BDK_TNS_TXQ_EQ_MC2DROP_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC2DROP_CT "TNS_TXQ_EQ_MC2DROP_CT"


/**
 * NCB32b - tns_txq_eq_mc2drop_fif#_w#
 *
 * Target pipe based FIFOs used for MC drop tokens
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_mc2drop_fifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_mc2drop_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc2drop_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc2drop_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_mc2drop_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 4)))
		return 0x0000842070683E00ull + (param1 & 15) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(...) bdk_tns_txq_eq_mc2drop_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC2DROP_FIFX_WX(...) "TNS_TXQ_EQ_MC2DROP_FIFX_WX"


/**
 * NCB - tns_txq_eq_mc_10g_rep_fif#_w#
 *
 * Target pipe based FIFOs used for 10G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_mc_10g_rep_fifx_wx {
	uint64_t u;
	struct bdk_tns_txq_eq_mc_10g_rep_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_10g_rep_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_10g_rep_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_mc_10g_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 6)))
		return 0x0000842070682C00ull + (param1 & 15) * 0x40ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(...) bdk_tns_txq_eq_mc_10g_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_10G_REP_FIFX_WX(...) "TNS_TXQ_EQ_MC_10G_REP_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_mc_10g_spd_map
 *
 * Ports that are 10G mode.  Bit 0 = port 0, bit 1 = port 1, etc
 *
 */
typedef union bdk_tns_txq_eq_mc_10g_spd_map {
	uint32_t u;
	struct bdk_tns_txq_eq_mc_10g_spd_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t pt_bitmap                   : 16; /**< R/W - -- */
#else
		uint32_t pt_bitmap                   : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_10g_spd_map_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_10g_spd_map_s cn88xxp1; */
} bdk_tns_txq_eq_mc_10g_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP_FUNC(void)
{
	return 0x00008420706848E8ull;
}
#define typedef_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP bdk_tns_txq_eq_mc_10g_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_10G_SPD_MAP "TNS_TXQ_EQ_MC_10G_SPD_MAP"


/**
 * NCB - tns_txq_eq_mc_40g_rep_fif#_w#
 *
 * Target pipe based FIFOs used for 40G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_mc_40g_rep_fifx_wx {
	uint64_t u;
	struct bdk_tns_txq_eq_mc_40g_rep_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_40g_rep_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_40g_rep_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_mc_40g_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 6)))
		return 0x0000842070682800ull + (param1 & 15) * 0x40ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(...) bdk_tns_txq_eq_mc_40g_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_40G_REP_FIFX_WX(...) "TNS_TXQ_EQ_MC_40G_REP_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_mc_40g_spd_map
 *
 * Ports that are in 40G mode.  Bit 0 = port 0, bit 1 = port 1, etc
 *
 */
typedef union bdk_tns_txq_eq_mc_40g_spd_map {
	uint32_t u;
	struct bdk_tns_txq_eq_mc_40g_spd_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t pt_bitmap                   : 16; /**< R/W - -- */
#else
		uint32_t pt_bitmap                   : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_40g_spd_map_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_40g_spd_map_s cn88xxp1; */
} bdk_tns_txq_eq_mc_40g_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP_FUNC(void)
{
	return 0x00008420706848E4ull;
}
#define typedef_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP bdk_tns_txq_eq_mc_40g_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_40G_SPD_MAP "TNS_TXQ_EQ_MC_40G_SPD_MAP"


/**
 * NCB - tns_txq_eq_mc_fif#_w#
 *
 * Source pipe based FIFOs used in multi-cast path
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_mc_fifx_wx {
	uint64_t u;
	struct bdk_tns_txq_eq_mc_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_mc_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 6)))
		return 0x0000842070682400ull + (param1 & 15) * 0x40ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_MC_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_MC_FIFX_WX(...) bdk_tns_txq_eq_mc_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_FIFX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_MC_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_MC_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_FIFX_WX(...) "TNS_TXQ_EQ_MC_FIFX_WX"


/**
 * NCB - tns_txq_eq_mc_misc_rep_fif#_w#
 *
 * Target pipe based FIFOs used for less than 10G replication copies
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_mc_misc_rep_fifx_wx {
	uint64_t u;
	struct bdk_tns_txq_eq_mc_misc_rep_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_misc_rep_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_misc_rep_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_mc_misc_rep_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 6)))
		return 0x0000842070683000ull + (param1 & 15) * 0x40ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(...) bdk_tns_txq_eq_mc_misc_rep_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX(...) "TNS_TXQ_EQ_MC_MISC_REP_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_mc_misc_spd_map
 *
 * Ports that are 1G or less mode.  Bit 0 = port 0, bit 1 = port 1, etc
 *
 */
typedef union bdk_tns_txq_eq_mc_misc_spd_map {
	uint32_t u;
	struct bdk_tns_txq_eq_mc_misc_spd_map_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t pt_bitmap                   : 16; /**< R/W - -- */
#else
		uint32_t pt_bitmap                   : 16;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_misc_spd_map_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_misc_spd_map_s cn88xxp1; */
} bdk_tns_txq_eq_mc_misc_spd_map_t;

#define BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP_FUNC(void)
{
	return 0x00008420706848ECull;
}
#define typedef_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP bdk_tns_txq_eq_mc_misc_spd_map_t
#define bustype_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP 0
#define arguments_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_MISC_SPD_MAP "TNS_TXQ_EQ_MC_MISC_SPD_MAP"


/**
 * NCB32b - tns_txq_eq_mc_src_fif_fc_thr
 *
 * Distributor source multi-cast FIFO flow control threshold.  Lower this to 0 to
 * turn off TxQ multi-cast replication.
 */
typedef union bdk_tns_txq_eq_mc_src_fif_fc_thr {
	uint32_t u;
	struct bdk_tns_txq_eq_mc_src_fif_fc_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t theshold                    : 5;  /**< R/W - -- */
#else
		uint32_t theshold                    : 5;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_eq_mc_src_fif_fc_thr_s cn88xx; */
	/* struct bdk_tns_txq_eq_mc_src_fif_fc_thr_s cn88xxp1; */
} bdk_tns_txq_eq_mc_src_fif_fc_thr_t;

#define BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR_FUNC(void)
{
	return 0x00008420706848DCull;
}
#define typedef_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR bdk_tns_txq_eq_mc_src_fif_fc_thr_t
#define bustype_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR 0
#define arguments_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_MC_SRC_FIF_FC_THR "TNS_TXQ_EQ_MC_SRC_FIF_FC_THR"


/**
 * NCB32b - tns_txq_eq_pfc_map_ecc_log
 *
 * PFC mapping memory ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_eq_pfc_map_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_eq_pfc_map_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_10_31              : 22;
		uint32_t ecc_err_addr                : 10; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 10;
		uint32_t reserved_10_31              : 22;
#endif
	} s;
	/* struct bdk_tns_txq_eq_pfc_map_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_eq_pfc_map_ecc_log_s cn88xxp1; */
} bdk_tns_txq_eq_pfc_map_ecc_log_t;

#define BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG_FUNC(void)
{
	return 0x0000842070684898ull;
}
#define typedef_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG bdk_tns_txq_eq_pfc_map_ecc_log_t
#define bustype_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_PFC_MAP_ECC_LOG "TNS_TXQ_EQ_PFC_MAP_ECC_LOG"


/**
 * NCB - tns_txq_eq_pfc_map_mem#
 *
 * Virtual port/TC to physical port/TC/channel mapping.  There are 4 entries
 * stored per line.  Logically, this is a 4k x 11 memory.
 * The index is {virtual_port[7:0], tc[3:0]}.  The result is
 * {physical_port[3:0], tc_channel[6:0]}.  The tc_channel is overloaded
 * to mean both TC and channel.  On ports 8 and 9, it is a full 7 bit
 * channel.   On other ports, it is a 4 bit TC.
 */
typedef union bdk_tns_txq_eq_pfc_map_memx {
	uint64_t u;
	struct bdk_tns_txq_eq_pfc_map_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_44_63              : 20;
		uint64_t data                        : 44; /**< R/W - -- */
#else
		uint64_t data                        : 44;
		uint64_t reserved_44_63              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_eq_pfc_map_memx_s cn88xx; */
	/* struct bdk_tns_txq_eq_pfc_map_memx_s cn88xxp1; */
} bdk_tns_txq_eq_pfc_map_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(unsigned long param1)
{
	if (((param1 <= 1023)))
		return 0x0000842070680000ull + (param1 & 1023) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_PFC_MAP_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(...) bdk_tns_txq_eq_pfc_map_memx_t
#define bustype_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_PFC_MAP_MEMX(...) "TNS_TXQ_EQ_PFC_MAP_MEMX"


/**
 * NCB32b - tns_txq_eq_pg_clr_ct
 *
 * Counter of TXQ page clear requests to BM.  Saturates at 32'hffffffff.  Read
 * only, clear on read.
 */
typedef union bdk_tns_txq_eq_pg_clr_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_pg_clr_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_pg_clr_ct_s  cn88xx; */
	/* struct bdk_tns_txq_eq_pg_clr_ct_s  cn88xxp1; */
} bdk_tns_txq_eq_pg_clr_ct_t;

#define BDK_TNS_TXQ_EQ_PG_CLR_CT BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PG_CLR_CT_FUNC(void)
{
	return 0x00008420706848CCull;
}
#define typedef_BDK_TNS_TXQ_EQ_PG_CLR_CT bdk_tns_txq_eq_pg_clr_ct_t
#define bustype_BDK_TNS_TXQ_EQ_PG_CLR_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_PG_CLR_CT 0
#define arguments_BDK_TNS_TXQ_EQ_PG_CLR_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_PG_CLR_CT "TNS_TXQ_EQ_PG_CLR_CT"


/**
 * NCB32b - tns_txq_eq_pt_spd_mem#
 *
 * Unicast_Port_Speed_Map.  0=10M, 1=100M, 2=1G, 3=10G, 4=40G, 5=100G
 *
 */
typedef union bdk_tns_txq_eq_pt_spd_memx {
	uint32_t u;
	struct bdk_tns_txq_eq_pt_spd_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t data                        : 3;  /**< R/W - -- */
#else
		uint32_t data                        : 3;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_eq_pt_spd_memx_s cn88xx; */
	/* struct bdk_tns_txq_eq_pt_spd_memx_s cn88xxp1; */
} bdk_tns_txq_eq_pt_spd_memx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_PT_SPD_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_PT_SPD_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x0000842070684840ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_PT_SPD_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(...) bdk_tns_txq_eq_pt_spd_memx_t
#define bustype_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_PT_SPD_MEMX(...) "TNS_TXQ_EQ_PT_SPD_MEMX"


/**
 * NCB32b - tns_txq_eq_query_ofif#_w#
 *
 * Target pipe based FIFOs used for absorbing pending replies when lower module is
 * flow controlling
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_query_ofifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_query_ofifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_query_ofifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_query_ofifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_query_ofifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 31)) && ((param2 <= 4)))
		return 0x0000842070683400ull + (param1 & 31) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(...) bdk_tns_txq_eq_query_ofifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_QUERY_OFIFX_WX(...) "TNS_TXQ_EQ_QUERY_OFIFX_WX"


/**
 * NCB32b - tns_txq_eq_query_ofif_maxcrd
 *
 * Post-query FIFO maxium credit.  The total number of entries of the FIFO is 32.
 * This can be set to lower number to limit the outstanding EQ QMAP/AQM requests.
 * Once all the crdits are used, EQ should stop issuing queries to QMAP/AQM. This
 * is for debug use only.
 */
typedef union bdk_tns_txq_eq_query_ofif_maxcrd {
	uint32_t u;
	struct bdk_tns_txq_eq_query_ofif_maxcrd_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t theshold                    : 6;  /**< R/W - -- */
#else
		uint32_t theshold                    : 6;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_eq_query_ofif_maxcrd_s cn88xx; */
	/* struct bdk_tns_txq_eq_query_ofif_maxcrd_s cn88xxp1; */
} bdk_tns_txq_eq_query_ofif_maxcrd_t;

#define BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD_FUNC(void)
{
	return 0x00008420706848E0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD bdk_tns_txq_eq_query_ofif_maxcrd_t
#define bustype_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD 0
#define arguments_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_QUERY_OFIF_MAXCRD "TNS_TXQ_EQ_QUERY_OFIF_MAXCRD"


/**
 * NCB32b - tns_txq_eq_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_eq_spad {
	uint32_t u;
	struct bdk_tns_txq_eq_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_spad_s       cn88xx; */
	/* struct bdk_tns_txq_eq_spad_s       cn88xxp1; */
} bdk_tns_txq_eq_spad_t;

#define BDK_TNS_TXQ_EQ_SPAD BDK_TNS_TXQ_EQ_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_SPAD_FUNC(void)
{
	return 0x000084207068491Cull;
}
#define typedef_BDK_TNS_TXQ_EQ_SPAD bdk_tns_txq_eq_spad_t
#define bustype_BDK_TNS_TXQ_EQ_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_SPAD 0
#define arguments_BDK_TNS_TXQ_EQ_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_SPAD "TNS_TXQ_EQ_SPAD"


/**
 * NCB32b - tns_txq_eq_tail_req_ct
 *
 * Counter of TXQ tail pointer requests to TBM.  Saturates at 32'hffffffff.  Read
 * only, clear on read.
 */
typedef union bdk_tns_txq_eq_tail_req_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_tail_req_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_tail_req_ct_s cn88xx; */
	/* struct bdk_tns_txq_eq_tail_req_ct_s cn88xxp1; */
} bdk_tns_txq_eq_tail_req_ct_t;

#define BDK_TNS_TXQ_EQ_TAIL_REQ_CT BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TAIL_REQ_CT_FUNC(void)
{
	return 0x00008420706848D0ull;
}
#define typedef_BDK_TNS_TXQ_EQ_TAIL_REQ_CT bdk_tns_txq_eq_tail_req_ct_t
#define bustype_BDK_TNS_TXQ_EQ_TAIL_REQ_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_TAIL_REQ_CT 0
#define arguments_BDK_TNS_TXQ_EQ_TAIL_REQ_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_TAIL_REQ_CT "TNS_TXQ_EQ_TAIL_REQ_CT"


/**
 * NCB32b - tns_txq_eq_tb_wr_ct
 *
 * Counter of TXQ writes to token buffer.  Saturates at 32'hffffffff.  Read only,
 * clear on read.
 */
typedef union bdk_tns_txq_eq_tb_wr_ct {
	uint32_t u;
	struct bdk_tns_txq_eq_tb_wr_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_tb_wr_ct_s   cn88xx; */
	/* struct bdk_tns_txq_eq_tb_wr_ct_s   cn88xxp1; */
} bdk_tns_txq_eq_tb_wr_ct_t;

#define BDK_TNS_TXQ_EQ_TB_WR_CT BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TB_WR_CT_FUNC(void)
{
	return 0x00008420706848D4ull;
}
#define typedef_BDK_TNS_TXQ_EQ_TB_WR_CT bdk_tns_txq_eq_tb_wr_ct_t
#define bustype_BDK_TNS_TXQ_EQ_TB_WR_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_TB_WR_CT 0
#define arguments_BDK_TNS_TXQ_EQ_TB_WR_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_TB_WR_CT "TNS_TXQ_EQ_TB_WR_CT"


/**
 * NCB - tns_txq_eq_token_mem#_w#
 *
 * Token memory for Cut-thru waiting
 * Bits[63:35] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_token_memx_wx {
	uint64_t u;
	struct bdk_tns_txq_eq_token_memx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t token                       : 64; /**< R/W - -- */
#else
		uint64_t token                       : 64;
#endif
	} s;
	/* struct bdk_tns_txq_eq_token_memx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_token_memx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_token_memx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 6)))
		return 0x0000842070682000ull + (param1 & 15) * 0x40ull + (param2 & 7) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(...) bdk_tns_txq_eq_token_memx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_TOKEN_MEMX_WX(...) "TNS_TXQ_EQ_TOKEN_MEMX_WX"


/**
 * NCB32b - tns_txq_eq_uc_fif#_w#
 *
 * Source pipe based FIFOs used in UC and drop path
 * Bits[31:27] in _W[4] are unused.
 * When writing, the MSBs (word 4) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_eq_uc_fifx_wx {
	uint32_t u;
	struct bdk_tns_txq_eq_uc_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t data                        : 32; /**< R/W - -- */
#else
		uint32_t data                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_eq_uc_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_eq_uc_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_eq_uc_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_EQ_UC_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_UC_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 15)) && ((param2 <= 4)))
		return 0x0000842070683C00ull + (param1 & 15) * 0x20ull + (param2 & 7) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_EQ_UC_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_EQ_UC_FIFX_WX(...) bdk_tns_txq_eq_uc_fifx_wx_t
#define bustype_BDK_TNS_TXQ_EQ_UC_FIFX_WX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_UC_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_EQ_UC_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_EQ_UC_FIFX_WX(...) "TNS_TXQ_EQ_UC_FIFX_WX"


/**
 * NCB32b - tns_txq_eq_wr_token_lfif_thr
 *
 * Write token latency fifo flow control threshold configuration
 *
 */
typedef union bdk_tns_txq_eq_wr_token_lfif_thr {
	uint32_t u;
	struct bdk_tns_txq_eq_wr_token_lfif_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t theshold                    : 5;  /**< R/W - -- */
#else
		uint32_t theshold                    : 5;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_eq_wr_token_lfif_thr_s cn88xx; */
	/* struct bdk_tns_txq_eq_wr_token_lfif_thr_s cn88xxp1; */
} bdk_tns_txq_eq_wr_token_lfif_thr_t;

#define BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR_FUNC(void)
{
	return 0x000084207068490Cull;
}
#define typedef_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR bdk_tns_txq_eq_wr_token_lfif_thr_t
#define bustype_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR 0
#define arguments_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_EQ_WR_TOKEN_LFIF_THR "TNS_TXQ_EQ_WR_TOKEN_LFIF_THR"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w0
 *
 * AQM Profile Table
 * Bits[31:19] in _W[6] are unused.
 * When writing, the MSBs (word 6) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w0 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t qcn_prob_shift0             : 7;  /**< R/W - -- */
		uint32_t qcn_prob_shift1             : 8;  /**< R/W - -- */
		uint32_t qcn_prob_shift2             : 8;  /**< R/W - -- */
		uint32_t qcn_fb_shift_val            : 5;  /**< R/W - -- */
		uint32_t q_share_en                  : 1;  /**< R/W - -- */
		uint32_t q_share_pool                : 3;  /**< R/W - -- */
#else
		uint32_t q_share_pool                : 3;
		uint32_t q_share_en                  : 1;
		uint32_t qcn_fb_shift_val            : 5;
		uint32_t qcn_prob_shift2             : 8;
		uint32_t qcn_prob_shift1             : 8;
		uint32_t qcn_prob_shift0             : 7;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w0_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w0_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w0_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608000ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(...) bdk_tns_txq_qmap_aqm_pfl_memx_w0_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W0(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W0"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w1
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w1 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t qcn_fb_max                  : 15; /**< R/W - -- */
		uint32_t qcn_fb_min_samp_prob        : 8;  /**< R/W - -- */
		uint32_t qcn_fb_max_samp_prob        : 8;  /**< R/W - -- */
		uint32_t qcn_prob_shift0             : 1;  /**< R/W - Continuation of MSBs of field QCN_PROB_SHIFT0 from previous word. */
#else
		uint32_t qcn_prob_shift0             : 1;
		uint32_t qcn_fb_max_samp_prob        : 8;
		uint32_t qcn_fb_min_samp_prob        : 8;
		uint32_t qcn_fb_max                  : 15;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w1_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w1_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w1_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608004ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(...) bdk_tns_txq_qmap_aqm_pfl_memx_w1_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W1(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W1"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w2
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w2 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t qcn_eq_param                : 6;  /**< R/W - -- */
		uint32_t qcn_weight_shift0           : 3;  /**< R/W - -- */
		uint32_t qcn_weight_shift1           : 3;  /**< R/W - -- */
		uint32_t qcn_weight_shift2           : 3;  /**< R/W - -- */
		uint32_t qcn_fb_max                  : 17; /**< R/W - Continuation of MSBs of field QCN_FB_MAX from previous word. */
#else
		uint32_t qcn_fb_max                  : 17;
		uint32_t qcn_weight_shift2           : 3;
		uint32_t qcn_weight_shift1           : 3;
		uint32_t qcn_weight_shift0           : 3;
		uint32_t qcn_eq_param                : 6;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w2_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w2_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w2_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608008ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(...) bdk_tns_txq_qmap_aqm_pfl_memx_w2_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W2(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W2"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w3
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w3 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t wred_mark_drop_prob         : 4;  /**< R/W - -- */
		uint32_t dctcp_mark_en               : 1;  /**< R/W - -- */
		uint32_t dctcp_mark_th               : 15; /**< R/W - -- */
		uint32_t phantom_q_en                : 1;  /**< R/W - -- */
		uint32_t qcn_mode                    : 2;  /**< R/W - -- */
		uint32_t qcn_eq_param                : 9;  /**< R/W - Continuation of MSBs of field QCN_EQ_PARAM from previous word. */
#else
		uint32_t qcn_eq_param                : 9;
		uint32_t qcn_mode                    : 2;
		uint32_t phantom_q_en                : 1;
		uint32_t dctcp_mark_th               : 15;
		uint32_t dctcp_mark_en               : 1;
		uint32_t wred_mark_drop_prob         : 4;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w3_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w3_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w3_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x000084207060800Cull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(...) bdk_tns_txq_qmap_aqm_pfl_memx_w3_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W3(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W3"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w4
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w4 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t wred_avg_length_weight      : 4;  /**< R/W - -- */
		uint32_t wred_shift0                 : 8;  /**< R/W - -- */
		uint32_t wred_shift1                 : 8;  /**< R/W - -- */
		uint32_t wred_shift2                 : 8;  /**< R/W - -- */
		uint32_t wred_mark_drop_prob         : 4;  /**< R/W - Continuation of MSBs of field WRED_MARK_DROP_PROB from previous word. */
#else
		uint32_t wred_mark_drop_prob         : 4;
		uint32_t wred_shift2                 : 8;
		uint32_t wred_shift1                 : 8;
		uint32_t wred_shift0                 : 8;
		uint32_t wred_avg_length_weight      : 4;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w4_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w4_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w4_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608010ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(...) bdk_tns_txq_qmap_aqm_pfl_memx_w4_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W4(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W4"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w5
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w5 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t wred_avg_length_min_th      : 13; /**< R/W - -- */
		uint32_t wred_avg_length_max_th      : 15; /**< R/W - -- */
		uint32_t wred_avg_length_weight      : 4;  /**< R/W - Continuation of MSBs of field WRED_AVG_LENGTH_WEIGHT from previous word. */
#else
		uint32_t wred_avg_length_weight      : 4;
		uint32_t wred_avg_length_max_th      : 15;
		uint32_t wred_avg_length_min_th      : 13;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w5_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w5_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w5_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608014ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(...) bdk_tns_txq_qmap_aqm_pfl_memx_w5_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W5(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W5"


/**
 * NCB32b - tns_txq_qmap_aqm_pfl_mem#_w6
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_AQM_PFL_MEM(0..127)_W0
 *
 */
typedef union bdk_tns_txq_qmap_aqm_pfl_memx_w6 {
	uint32_t u;
	struct bdk_tns_txq_qmap_aqm_pfl_memx_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_19_31              : 13;
		uint32_t length_max_th               : 15; /**< R/W - -- */
		uint32_t wred_mode                   : 2;  /**< R/W - -- */
		uint32_t wred_avg_length_min_th      : 2;  /**< R/W - Continuation of MSBs of field WRED_AVG_LENGTH_MIN_TH from previous word. */
#else
		uint32_t wred_avg_length_min_th      : 2;
		uint32_t wred_mode                   : 2;
		uint32_t length_max_th               : 15;
		uint32_t reserved_19_31              : 13;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w6_s cn88xx; */
	/* struct bdk_tns_txq_qmap_aqm_pfl_memx_w6_s cn88xxp1; */
} bdk_tns_txq_qmap_aqm_pfl_memx_w6_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(unsigned long param1)
{
	if (((param1 <= 127)))
		return 0x0000842070608018ull + (param1 & 127) * 0x20ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(...) bdk_tns_txq_qmap_aqm_pfl_memx_w6_t
#define bustype_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_AQM_PFL_MEMX_W6(...) "TNS_TXQ_QMAP_AQM_PFL_MEMX_W6"


/**
 * NCB32b - tns_txq_qmap_ecc_ctl
 *
 * ECC configuration of Token Buffer memories
 *
 */
typedef union bdk_tns_txq_qmap_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_qmap_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_6_31               : 26;
		uint32_t qmap_table_db_ecc           : 1;  /**< R/W - Flip 2 bits of ECC syndrome in QMAP memory */
		uint32_t qmap_table_sb_ecc           : 1;  /**< R/W - Flip 1 bit of ECC syndrome in QMAP memory */
		uint32_t qmap_table_ecc_dis          : 1;  /**< R/W - Disable ECC for QMAP memory */
		uint32_t eq_cfg_db_ecc               : 1;  /**< R/W - Flip 2 bits of ECC syndrome in EQ Configuration memory */
		uint32_t eq_cfg_sb_ecc               : 1;  /**< R/W - Flip 1 bit of ECC syndrome in EQ Configuration memory */
		uint32_t eq_cfg_ecc_dis              : 1;  /**< R/W - Disable ECC for EQ Configuration memory */
#else
		uint32_t eq_cfg_ecc_dis              : 1;
		uint32_t eq_cfg_sb_ecc               : 1;
		uint32_t eq_cfg_db_ecc               : 1;
		uint32_t qmap_table_ecc_dis          : 1;
		uint32_t qmap_table_sb_ecc           : 1;
		uint32_t qmap_table_db_ecc           : 1;
		uint32_t reserved_6_31               : 26;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_ecc_ctl_s  cn88xx; */
	/* struct bdk_tns_txq_qmap_ecc_ctl_s  cn88xxp1; */
} bdk_tns_txq_qmap_ecc_ctl_t;

#define BDK_TNS_TXQ_QMAP_ECC_CTL BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_ECC_CTL_FUNC(void)
{
	return 0x000084207060C470ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_ECC_CTL bdk_tns_txq_qmap_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_QMAP_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_QMAP_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_ECC_CTL "TNS_TXQ_QMAP_ECC_CTL"


/**
 * NCB32b - tns_txq_qmap_en_cfg
 *
 * QMap enabled to accept requests into its pipeline.
 *
 */
typedef union bdk_tns_txq_qmap_en_cfg {
	uint32_t u;
	struct bdk_tns_txq_qmap_en_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_en_cfg_s   cn88xx; */
	/* struct bdk_tns_txq_qmap_en_cfg_s   cn88xxp1; */
} bdk_tns_txq_qmap_en_cfg_t;

#define BDK_TNS_TXQ_QMAP_EN_CFG BDK_TNS_TXQ_QMAP_EN_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EN_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EN_CFG_FUNC(void)
{
	return 0x000084207060C48Cull;
}
#define typedef_BDK_TNS_TXQ_QMAP_EN_CFG bdk_tns_txq_qmap_en_cfg_t
#define bustype_BDK_TNS_TXQ_QMAP_EN_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_EN_CFG 0
#define arguments_BDK_TNS_TXQ_QMAP_EN_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_EN_CFG "TNS_TXQ_QMAP_EN_CFG"


/**
 * NCB32b - tns_txq_qmap_eq_cfg_ecc_log
 *
 * QMAP EQ configuration memory ECC error log.  Address is sticky on first error.
 * Re-armed after reading
 */
typedef union bdk_tns_txq_qmap_eq_cfg_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_qmap_eq_cfg_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_eq_cfg_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_qmap_eq_cfg_ecc_log_s cn88xxp1; */
} bdk_tns_txq_qmap_eq_cfg_ecc_log_t;

#define BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG_FUNC(void)
{
	return 0x000084207060C478ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG bdk_tns_txq_qmap_eq_cfg_ecc_log_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_EQ_CFG_ECC_LOG "TNS_TXQ_QMAP_EQ_CFG_ECC_LOG"


/**
 * NCB - tns_txq_qmap_eq_cfg_mem#
 *
 * Eq Configuration Table
 *
 */
typedef union bdk_tns_txq_qmap_eq_cfg_memx {
	uint64_t u;
	struct bdk_tns_txq_qmap_eq_cfg_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_39_63              : 25;
		uint64_t h1                          : 8;  /**< R/W - -- */
		uint64_t p                           : 4;  /**< R/W - -- */
		uint64_t q_pfl                       : 7;  /**< R/W - -- */
		uint64_t h1_pfl                      : 7;  /**< R/W - -- */
		uint64_t p_pfl                       : 7;  /**< R/W - -- */
		uint64_t q_eq_en                     : 1;  /**< R/W - -- */
		uint64_t h1_eq_en                    : 1;  /**< R/W - -- */
		uint64_t p_eq_en                     : 1;  /**< R/W - -- */
		uint64_t q_em_en                     : 1;  /**< R/W - -- */
		uint64_t h1_em_en                    : 1;  /**< R/W - -- */
		uint64_t p_em_en                     : 1;  /**< R/W - -- */
#else
		uint64_t p_em_en                     : 1;
		uint64_t h1_em_en                    : 1;
		uint64_t q_em_en                     : 1;
		uint64_t p_eq_en                     : 1;
		uint64_t h1_eq_en                    : 1;
		uint64_t q_eq_en                     : 1;
		uint64_t p_pfl                       : 7;
		uint64_t h1_pfl                      : 7;
		uint64_t q_pfl                       : 7;
		uint64_t p                           : 4;
		uint64_t h1                          : 8;
		uint64_t reserved_39_63              : 25;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_eq_cfg_memx_s cn88xx; */
	/* struct bdk_tns_txq_qmap_eq_cfg_memx_s cn88xxp1; */
} bdk_tns_txq_qmap_eq_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070604000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(...) bdk_tns_txq_qmap_eq_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_EQ_CFG_MEMX(...) "TNS_TXQ_QMAP_EQ_CFG_MEMX"


/**
 * NCB32b - tns_txq_qmap_eq_query_ct
 *
 * Counter of EQ queries.  Saturates at 32'hffffffff.  Read only, clear on read.
 *
 */
typedef union bdk_tns_txq_qmap_eq_query_ct {
	uint32_t u;
	struct bdk_tns_txq_qmap_eq_query_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_eq_query_ct_s cn88xx; */
	/* struct bdk_tns_txq_qmap_eq_query_ct_s cn88xxp1; */
} bdk_tns_txq_qmap_eq_query_ct_t;

#define BDK_TNS_TXQ_QMAP_EQ_QUERY_CT BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_QUERY_CT_FUNC(void)
{
	return 0x000084207060C480ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT bdk_tns_txq_qmap_eq_query_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_EQ_QUERY_CT "TNS_TXQ_QMAP_EQ_QUERY_CT"


/**
 * NCB32b - tns_txq_qmap_eq_reply_ct
 *
 * Counter of EQ replies.  Saturates at 32'hffffffff.  Read only, clear on read.
 *
 */
typedef union bdk_tns_txq_qmap_eq_reply_ct {
	uint32_t u;
	struct bdk_tns_txq_qmap_eq_reply_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_eq_reply_ct_s cn88xx; */
	/* struct bdk_tns_txq_qmap_eq_reply_ct_s cn88xxp1; */
} bdk_tns_txq_qmap_eq_reply_ct_t;

#define BDK_TNS_TXQ_QMAP_EQ_REPLY_CT BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_EQ_REPLY_CT_FUNC(void)
{
	return 0x000084207060C488ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT bdk_tns_txq_qmap_eq_reply_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_EQ_REPLY_CT "TNS_TXQ_QMAP_EQ_REPLY_CT"


/**
 * NCB32b - tns_txq_qmap_h1_full_cfg_mem#
 *
 * H1 full vector
 *
 */
typedef union bdk_tns_txq_qmap_h1_full_cfg_memx {
	uint32_t u;
	struct bdk_tns_txq_qmap_h1_full_cfg_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t full                        : 1;  /**< R/W - -- */
#else
		uint32_t full                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_h1_full_cfg_memx_s cn88xx; */
	/* struct bdk_tns_txq_qmap_h1_full_cfg_memx_s cn88xxp1; */
} bdk_tns_txq_qmap_h1_full_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(unsigned long param1)
{
	if (((param1 <= 255)))
		return 0x000084207060C000ull + (param1 & 255) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(...) bdk_tns_txq_qmap_h1_full_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_H1_FULL_CFG_MEMX(...) "TNS_TXQ_QMAP_H1_FULL_CFG_MEMX"


/**
 * NCB32b - tns_txq_qmap_int_en_hi
 *
 * QMAP interrupt register
 *
 */
typedef union bdk_tns_txq_qmap_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_qmap_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t cnt_return_data_err         : 1;  /**< R/W - Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;  /**< R/W - QMAP EQ query DFC Rx overflow */
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;  /**< R/W - QMAP URW query DFC Rx overflow */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - QMAP configuration input DFC Rx overflow */
		uint32_t qmap_table_db_err           : 1;  /**< R/W - QMAP memory double bit ECC interrupt */
		uint32_t qmap_table_sb_err           : 1;  /**< R/W - QMAP Buffer memory single bit ECC interrupt */
		uint32_t eq_cfg_db_err               : 1;  /**< R/W - EQ configuration memory double bit ECC interrupt */
		uint32_t eq_cfg_sb_err               : 1;  /**< R/W - EQ configuration Buffer memory single bit ECC interrupt */
#else
		uint32_t eq_cfg_sb_err               : 1;
		uint32_t eq_cfg_db_err               : 1;
		uint32_t qmap_table_sb_err           : 1;
		uint32_t qmap_table_db_err           : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;
		uint32_t cnt_return_data_err         : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_qmap_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_qmap_int_en_hi_t;

#define BDK_TNS_TXQ_QMAP_INT_EN_HI BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_HI_FUNC(void)
{
	return 0x000084207060C464ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_INT_EN_HI bdk_tns_txq_qmap_int_en_hi_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_INT_EN_HI "TNS_TXQ_QMAP_INT_EN_HI"


/**
 * NCB32b - tns_txq_qmap_int_en_lo
 *
 * QMAP interrupt register
 *
 */
typedef union bdk_tns_txq_qmap_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_qmap_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t cnt_return_data_err         : 1;  /**< R/W - Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;  /**< R/W - QMAP EQ query DFC Rx overflow */
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;  /**< R/W - QMAP URW query DFC Rx overflow */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W - QMAP configuration input DFC Rx overflow */
		uint32_t qmap_table_db_err           : 1;  /**< R/W - QMAP memory double bit ECC interrupt */
		uint32_t qmap_table_sb_err           : 1;  /**< R/W - QMAP Buffer memory single bit ECC interrupt */
		uint32_t eq_cfg_db_err               : 1;  /**< R/W - EQ configuration memory double bit ECC interrupt */
		uint32_t eq_cfg_sb_err               : 1;  /**< R/W - EQ configuration Buffer memory single bit ECC interrupt */
#else
		uint32_t eq_cfg_sb_err               : 1;
		uint32_t eq_cfg_db_err               : 1;
		uint32_t qmap_table_sb_err           : 1;
		uint32_t qmap_table_db_err           : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;
		uint32_t cnt_return_data_err         : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_qmap_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_qmap_int_en_lo_t;

#define BDK_TNS_TXQ_QMAP_INT_EN_LO BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_EN_LO_FUNC(void)
{
	return 0x000084207060C468ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_INT_EN_LO bdk_tns_txq_qmap_int_en_lo_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_INT_EN_LO "TNS_TXQ_QMAP_INT_EN_LO"


/**
 * NCB32b - tns_txq_qmap_int_frc
 *
 * QMAP interrupt register
 *
 */
typedef union bdk_tns_txq_qmap_int_frc {
	uint32_t u;
	struct bdk_tns_txq_qmap_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t cnt_return_data_err         : 1;  /**< WO - Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;  /**< WO - QMAP EQ query DFC Rx overflow */
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;  /**< WO - QMAP URW query DFC Rx overflow */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< WO - QMAP configuration input DFC Rx overflow */
		uint32_t qmap_table_db_err           : 1;  /**< WO - QMAP memory double bit ECC interrupt */
		uint32_t qmap_table_sb_err           : 1;  /**< WO - QMAP Buffer memory single bit ECC interrupt */
		uint32_t eq_cfg_db_err               : 1;  /**< WO - EQ configuration memory double bit ECC interrupt */
		uint32_t eq_cfg_sb_err               : 1;  /**< WO - EQ configuration Buffer memory single bit ECC interrupt */
#else
		uint32_t eq_cfg_sb_err               : 1;
		uint32_t eq_cfg_db_err               : 1;
		uint32_t qmap_table_sb_err           : 1;
		uint32_t qmap_table_db_err           : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;
		uint32_t cnt_return_data_err         : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_int_frc_s  cn88xx; */
	/* struct bdk_tns_txq_qmap_int_frc_s  cn88xxp1; */
} bdk_tns_txq_qmap_int_frc_t;

#define BDK_TNS_TXQ_QMAP_INT_FRC BDK_TNS_TXQ_QMAP_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_FRC_FUNC(void)
{
	return 0x000084207060C46Cull;
}
#define typedef_BDK_TNS_TXQ_QMAP_INT_FRC bdk_tns_txq_qmap_int_frc_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_INT_FRC 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_INT_FRC "TNS_TXQ_QMAP_INT_FRC"


/**
 * NCB32b - tns_txq_qmap_int_w1c
 *
 * QMAP interrupt register
 *
 */
typedef union bdk_tns_txq_qmap_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_qmap_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t cnt_return_data_err         : 1;  /**< R/W1C/H - Counters read return data did not match QMAP pipeline.  Fatal, should never
                                                                 happen */
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;  /**< R/W1C/H - QMAP EQ query DFC Rx overflow */
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;  /**< R/W1C/H - QMAP URW query DFC Rx overflow */
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;  /**< R/W1C/H - QMAP configuration input DFC Rx overflow */
		uint32_t qmap_table_db_err           : 1;  /**< R/W1C/H - QMAP memory double bit ECC interrupt */
		uint32_t qmap_table_sb_err           : 1;  /**< R/W1C/H - QMAP Buffer memory single bit ECC interrupt */
		uint32_t eq_cfg_db_err               : 1;  /**< R/W1C/H - EQ configuration memory double bit ECC interrupt */
		uint32_t eq_cfg_sb_err               : 1;  /**< R/W1C/H - EQ configuration Buffer memory single bit ECC interrupt */
#else
		uint32_t eq_cfg_sb_err               : 1;
		uint32_t eq_cfg_db_err               : 1;
		uint32_t qmap_table_sb_err           : 1;
		uint32_t qmap_table_db_err           : 1;
		uint32_t dfc_rx_cfg_i_ovfl_err       : 1;
		uint32_t dfc_rx_urw_query_ovfl_err   : 1;
		uint32_t dfc_rx_eq_query_ovfl_err    : 1;
		uint32_t cnt_return_data_err         : 1;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_int_w1c_s  cn88xx; */
	/* struct bdk_tns_txq_qmap_int_w1c_s  cn88xxp1; */
} bdk_tns_txq_qmap_int_w1c_t;

#define BDK_TNS_TXQ_QMAP_INT_W1C BDK_TNS_TXQ_QMAP_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_INT_W1C_FUNC(void)
{
	return 0x000084207060C460ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_INT_W1C bdk_tns_txq_qmap_int_w1c_t
#define bustype_BDK_TNS_TXQ_QMAP_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_INT_W1C 0
#define arguments_BDK_TNS_TXQ_QMAP_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_INT_W1C "TNS_TXQ_QMAP_INT_W1C"


/**
 * NCB32b - tns_txq_qmap_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_qmap_lock {
	uint32_t u;
	struct bdk_tns_txq_qmap_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_lock_s     cn88xx; */
	/* struct bdk_tns_txq_qmap_lock_s     cn88xxp1; */
} bdk_tns_txq_qmap_lock_t;

#define BDK_TNS_TXQ_QMAP_LOCK BDK_TNS_TXQ_QMAP_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_LOCK_FUNC(void)
{
	return 0x000084207060C4C0ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_LOCK bdk_tns_txq_qmap_lock_t
#define bustype_BDK_TNS_TXQ_QMAP_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_LOCK 0
#define arguments_BDK_TNS_TXQ_QMAP_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_LOCK "TNS_TXQ_QMAP_LOCK"


/**
 * NCB32b - tns_txq_qmap_ptf_cfg_mem#
 *
 * Port full vector
 *
 */
typedef union bdk_tns_txq_qmap_ptf_cfg_memx {
	uint32_t u;
	struct bdk_tns_txq_qmap_ptf_cfg_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t full                        : 1;  /**< R/W - -- */
#else
		uint32_t full                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_ptf_cfg_memx_s cn88xx; */
	/* struct bdk_tns_txq_qmap_ptf_cfg_memx_s cn88xxp1; */
} bdk_tns_txq_qmap_ptf_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(unsigned long param1)
{
	if (((param1 <= 15)))
		return 0x000084207060C400ull + (param1 & 15) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(...) bdk_tns_txq_qmap_ptf_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_PTF_CFG_MEMX(...) "TNS_TXQ_QMAP_PTF_CFG_MEMX"


/**
 * NCB32b - tns_txq_qmap_q_full_cfg_mem#
 *
 * Queue full vector
 *
 */
typedef union bdk_tns_txq_qmap_q_full_cfg_memx {
	uint32_t u;
	struct bdk_tns_txq_qmap_q_full_cfg_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t full                        : 1;  /**< R/W - -- */
#else
		uint32_t full                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_q_full_cfg_memx_s cn88xx; */
	/* struct bdk_tns_txq_qmap_q_full_cfg_memx_s cn88xxp1; */
} bdk_tns_txq_qmap_q_full_cfg_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x000084207060A000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(...) bdk_tns_txq_qmap_q_full_cfg_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_Q_FULL_CFG_MEMX(...) "TNS_TXQ_QMAP_Q_FULL_CFG_MEMX"


/**
 * NCB - tns_txq_qmap_qcn_cp_rng
 *
 * QCN congestion point RNG configuration
 *
 */
typedef union bdk_tns_txq_qmap_qcn_cp_rng {
	uint64_t u;
	struct bdk_tns_txq_qmap_qcn_cp_rng_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_33_63              : 31;
		uint64_t enable                      : 1;  /**< R/W - -- */
		uint64_t seed                        : 32; /**< R/W - -- */
#else
		uint64_t seed                        : 32;
		uint64_t enable                      : 1;
		uint64_t reserved_33_63              : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_qcn_cp_rng_s cn88xx; */
	/* struct bdk_tns_txq_qmap_qcn_cp_rng_s cn88xxp1; */
} bdk_tns_txq_qmap_qcn_cp_rng_t;

#define BDK_TNS_TXQ_QMAP_QCN_CP_RNG BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_QCN_CP_RNG_FUNC(void)
{
	return 0x000084207060C498ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_QCN_CP_RNG bdk_tns_txq_qmap_qcn_cp_rng_t
#define bustype_BDK_TNS_TXQ_QMAP_QCN_CP_RNG BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_QMAP_QCN_CP_RNG 0
#define arguments_BDK_TNS_TXQ_QMAP_QCN_CP_RNG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_QCN_CP_RNG "TNS_TXQ_QMAP_QCN_CP_RNG"


/**
 * NCB32b - tns_txq_qmap_sde_query_ct
 *
 * Counter of SDE queries.  Saturates at 32'hffffffff.  Read only, clear on read.
 *
 */
typedef union bdk_tns_txq_qmap_sde_query_ct {
	uint32_t u;
	struct bdk_tns_txq_qmap_sde_query_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_sde_query_ct_s cn88xx; */
	/* struct bdk_tns_txq_qmap_sde_query_ct_s cn88xxp1; */
} bdk_tns_txq_qmap_sde_query_ct_t;

#define BDK_TNS_TXQ_QMAP_SDE_QUERY_CT BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_QUERY_CT_FUNC(void)
{
	return 0x000084207060C47Cull;
}
#define typedef_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT bdk_tns_txq_qmap_sde_query_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_SDE_QUERY_CT "TNS_TXQ_QMAP_SDE_QUERY_CT"


/**
 * NCB32b - tns_txq_qmap_sde_reply_ct
 *
 * Counter of SDE replies.  Saturates at 32'hffffffff.  Read only, clear on read.
 *
 */
typedef union bdk_tns_txq_qmap_sde_reply_ct {
	uint32_t u;
	struct bdk_tns_txq_qmap_sde_reply_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_sde_reply_ct_s cn88xx; */
	/* struct bdk_tns_txq_qmap_sde_reply_ct_s cn88xxp1; */
} bdk_tns_txq_qmap_sde_reply_ct_t;

#define BDK_TNS_TXQ_QMAP_SDE_REPLY_CT BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SDE_REPLY_CT_FUNC(void)
{
	return 0x000084207060C484ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT bdk_tns_txq_qmap_sde_reply_ct_t
#define bustype_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT 0
#define arguments_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_SDE_REPLY_CT "TNS_TXQ_QMAP_SDE_REPLY_CT"


/**
 * NCB32b - tns_txq_qmap_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_qmap_spad {
	uint32_t u;
	struct bdk_tns_txq_qmap_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_spad_s     cn88xx; */
	/* struct bdk_tns_txq_qmap_spad_s     cn88xxp1; */
} bdk_tns_txq_qmap_spad_t;

#define BDK_TNS_TXQ_QMAP_SPAD BDK_TNS_TXQ_QMAP_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_SPAD_FUNC(void)
{
	return 0x000084207060C4C4ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_SPAD bdk_tns_txq_qmap_spad_t
#define bustype_BDK_TNS_TXQ_QMAP_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_SPAD 0
#define arguments_BDK_TNS_TXQ_QMAP_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_SPAD "TNS_TXQ_QMAP_SPAD"


/**
 * NCB32b - tns_txq_qmap_tbl_ecc_log
 *
 * QMAP table memory ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_qmap_tbl_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_qmap_tbl_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_tbl_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_qmap_tbl_ecc_log_s cn88xxp1; */
} bdk_tns_txq_qmap_tbl_ecc_log_t;

#define BDK_TNS_TXQ_QMAP_TBL_ECC_LOG BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_ECC_LOG_FUNC(void)
{
	return 0x000084207060C474ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG bdk_tns_txq_qmap_tbl_ecc_log_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_TBL_ECC_LOG "TNS_TXQ_QMAP_TBL_ECC_LOG"


/**
 * NCB32b - tns_txq_qmap_tbl_idx_cfg#_w0
 *
 * QMap Table index selection
 *
 */
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w0 {
	uint32_t u;
	struct bdk_tns_txq_qmap_tbl_idx_cfgx_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bit5_array_index            : 2;  /**< R/W - -- */
		uint32_t bit4_array_index            : 6;  /**< R/W - -- */
		uint32_t bit3_array_index            : 6;  /**< R/W - -- */
		uint32_t bit2_array_index            : 6;  /**< R/W - -- */
		uint32_t bit1_array_index            : 6;  /**< R/W - -- */
		uint32_t bit0_array_index            : 6;  /**< R/W - -- */
#else
		uint32_t bit0_array_index            : 6;
		uint32_t bit1_array_index            : 6;
		uint32_t bit2_array_index            : 6;
		uint32_t bit3_array_index            : 6;
		uint32_t bit4_array_index            : 6;
		uint32_t bit5_array_index            : 2;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w0_s cn88xx; */
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w0_s cn88xxp1; */
} bdk_tns_txq_qmap_tbl_idx_cfgx_w0_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084207060C4A8ull + (param1 & 1) * 0xCull;
	csr_fatal("BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(...) bdk_tns_txq_qmap_tbl_idx_cfgx_w0_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W0(...) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W0"


/**
 * NCB32b - tns_txq_qmap_tbl_idx_cfg#_w1
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_TBL_IDX_CFG(0..1)_W0
 *
 */
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w1 {
	uint32_t u;
	struct bdk_tns_txq_qmap_tbl_idx_cfgx_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t bit10_array_index           : 4;  /**< R/W - -- */
		uint32_t bit9_array_index            : 6;  /**< R/W - -- */
		uint32_t bit8_array_index            : 6;  /**< R/W - -- */
		uint32_t bit7_array_index            : 6;  /**< R/W - -- */
		uint32_t bit6_array_index            : 6;  /**< R/W - -- */
		uint32_t bit5_array_index            : 4;  /**< R/W - Continuation of MSBs of field BIT5_ARRAY_INDEX from previous word. */
#else
		uint32_t bit5_array_index            : 4;
		uint32_t bit6_array_index            : 6;
		uint32_t bit7_array_index            : 6;
		uint32_t bit8_array_index            : 6;
		uint32_t bit9_array_index            : 6;
		uint32_t bit10_array_index           : 4;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w1_s cn88xx; */
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w1_s cn88xxp1; */
} bdk_tns_txq_qmap_tbl_idx_cfgx_w1_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084207060C4ACull + (param1 & 1) * 0xCull;
	csr_fatal("BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(...) bdk_tns_txq_qmap_tbl_idx_cfgx_w1_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W1(...) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W1"


/**
 * NCB32b - tns_txq_qmap_tbl_idx_cfg#_w2
 *
 * Continuation of structure defined in TNS_TXQ_QMAP_TBL_IDX_CFG(0..1)_W0
 *
 */
typedef union bdk_tns_txq_qmap_tbl_idx_cfgx_w2 {
	uint32_t u;
	struct bdk_tns_txq_qmap_tbl_idx_cfgx_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_8_31               : 24;
		uint32_t bit11_array_index           : 6;  /**< R/W - -- */
		uint32_t bit10_array_index           : 2;  /**< R/W - Continuation of MSBs of field BIT10_ARRAY_INDEX from previous word. */
#else
		uint32_t bit10_array_index           : 2;
		uint32_t bit11_array_index           : 6;
		uint32_t reserved_8_31               : 24;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w2_s cn88xx; */
	/* struct bdk_tns_txq_qmap_tbl_idx_cfgx_w2_s cn88xxp1; */
} bdk_tns_txq_qmap_tbl_idx_cfgx_w2_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(unsigned long param1)
{
	if (((param1 <= 1)))
		return 0x000084207060C4B0ull + (param1 & 1) * 0xCull;
	csr_fatal("BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(...) bdk_tns_txq_qmap_tbl_idx_cfgx_w2_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_TBL_IDX_CFGX_W2(...) "TNS_TXQ_QMAP_TBL_IDX_CFGX_W2"


/**
 * NCB - tns_txq_qmap_tbl_mem#
 *
 * QMap Tbl (Each line contains four Q\#s - Q3,Q2,Q1,Q0)
 *
 */
typedef union bdk_tns_txq_qmap_tbl_memx {
	uint64_t u;
	struct bdk_tns_txq_qmap_tbl_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_44_63              : 20;
		uint64_t q3                          : 11; /**< R/W - -- */
		uint64_t q2                          : 11; /**< R/W - -- */
		uint64_t q1                          : 11; /**< R/W - -- */
		uint64_t q0                          : 11; /**< R/W - -- */
#else
		uint64_t q0                          : 11;
		uint64_t q1                          : 11;
		uint64_t q2                          : 11;
		uint64_t q3                          : 11;
		uint64_t reserved_44_63              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_tbl_memx_s cn88xx; */
	/* struct bdk_tns_txq_qmap_tbl_memx_s cn88xxp1; */
} bdk_tns_txq_qmap_tbl_memx_t;

static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_TBL_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070600000ull + (param1 & 2047) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_QMAP_TBL_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_QMAP_TBL_MEMX(...) bdk_tns_txq_qmap_tbl_memx_t
#define bustype_BDK_TNS_TXQ_QMAP_TBL_MEMX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_QMAP_TBL_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_QMAP_TBL_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_TBL_MEMX(...) "TNS_TXQ_QMAP_TBL_MEMX"


/**
 * NCB - tns_txq_qmap_wred_rng_cfg
 *
 * WRED Queue RNG configuration
 *
 */
typedef union bdk_tns_txq_qmap_wred_rng_cfg {
	uint64_t u;
	struct bdk_tns_txq_qmap_wred_rng_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t reserved_33_63              : 31;
		uint64_t enable                      : 1;  /**< R/W - -- */
		uint64_t seed                        : 32; /**< R/W - -- */
#else
		uint64_t seed                        : 32;
		uint64_t enable                      : 1;
		uint64_t reserved_33_63              : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_wred_rng_cfg_s cn88xx; */
	/* struct bdk_tns_txq_qmap_wred_rng_cfg_s cn88xxp1; */
} bdk_tns_txq_qmap_wred_rng_cfg_t;

#define BDK_TNS_TXQ_QMAP_WRED_RNG_CFG BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WRED_RNG_CFG_FUNC(void)
{
	return 0x000084207060C4A0ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG bdk_tns_txq_qmap_wred_rng_cfg_t
#define bustype_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG 0
#define arguments_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_WRED_RNG_CFG "TNS_TXQ_QMAP_WRED_RNG_CFG"


/**
 * NCB32b - tns_txq_qmap_wsarb_mode
 *
 * QMap WRR/SP arbiter mode; '0' - WRR, '1' - SP
 *
 */
typedef union bdk_tns_txq_qmap_wsarb_mode {
	uint32_t u;
	struct bdk_tns_txq_qmap_wsarb_mode_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_1_31               : 31;
		uint32_t data                        : 1;  /**< R/W - -- */
#else
		uint32_t data                        : 1;
		uint32_t reserved_1_31               : 31;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_wsarb_mode_s cn88xx; */
	/* struct bdk_tns_txq_qmap_wsarb_mode_s cn88xxp1; */
} bdk_tns_txq_qmap_wsarb_mode_t;

#define BDK_TNS_TXQ_QMAP_WSARB_MODE BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_MODE_FUNC(void)
{
	return 0x000084207060C490ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_WSARB_MODE bdk_tns_txq_qmap_wsarb_mode_t
#define bustype_BDK_TNS_TXQ_QMAP_WSARB_MODE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_WSARB_MODE 0
#define arguments_BDK_TNS_TXQ_QMAP_WSARB_MODE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_WSARB_MODE "TNS_TXQ_QMAP_WSARB_MODE"


/**
 * NCB32b - tns_txq_qmap_wsarb_wgt
 *
 * QMap WRR/SP arbiter weights
 *
 */
typedef union bdk_tns_txq_qmap_wsarb_wgt {
	uint32_t u;
	struct bdk_tns_txq_qmap_wsarb_wgt_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_16_31              : 16;
		uint32_t eq_weight                   : 8;  /**< R/W - -- */
		uint32_t sde_weight                  : 8;  /**< R/W - -- */
#else
		uint32_t sde_weight                  : 8;
		uint32_t eq_weight                   : 8;
		uint32_t reserved_16_31              : 16;
#endif
	} s;
	/* struct bdk_tns_txq_qmap_wsarb_wgt_s cn88xx; */
	/* struct bdk_tns_txq_qmap_wsarb_wgt_s cn88xxp1; */
} bdk_tns_txq_qmap_wsarb_wgt_t;

#define BDK_TNS_TXQ_QMAP_WSARB_WGT BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC()
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_QMAP_WSARB_WGT_FUNC(void)
{
	return 0x000084207060C494ull;
}
#define typedef_BDK_TNS_TXQ_QMAP_WSARB_WGT bdk_tns_txq_qmap_wsarb_wgt_t
#define bustype_BDK_TNS_TXQ_QMAP_WSARB_WGT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_QMAP_WSARB_WGT 0
#define arguments_BDK_TNS_TXQ_QMAP_WSARB_WGT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_QMAP_WSARB_WGT "TNS_TXQ_QMAP_WSARB_WGT"


/**
 * NCB - tns_txq_spt_qmap_tbl_cfg_w#
 *
 * QMap Tbl 0/1 selection based on source port
 *
 */
typedef union bdk_tns_txq_spt_qmap_tbl_cfg_wx {
	uint64_t u;
	struct bdk_tns_txq_spt_qmap_tbl_cfg_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t qmap_tbl_sel                : 64; /**< R/W - -- */
#else
		uint64_t qmap_tbl_sel                : 64;
#endif
	} s;
	/* struct bdk_tns_txq_spt_qmap_tbl_cfg_wx_s cn88xx; */
	/* struct bdk_tns_txq_spt_qmap_tbl_cfg_wx_s cn88xxp1; */
} bdk_tns_txq_spt_qmap_tbl_cfg_wx_t;

static inline uint64_t BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(unsigned long param1)
{
	if (((param1 <= 3)))
		return 0x000084207060C440ull + (param1 & 3) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(...) bdk_tns_txq_spt_qmap_tbl_cfg_wx_t
#define bustype_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(p1) (p1)
#define arguments_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_SPT_QMAP_TBL_CFG_WX(...) "TNS_TXQ_SPT_QMAP_TBL_CFG_WX"


/**
 * NCB32b - tns_txq_tb0_ecc_log
 *
 * Token Buffer memory 0 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_tb0_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tb0_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t ecc_err_addr                : 12; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_tb0_ecc_log_s   cn88xx; */
	/* struct bdk_tns_txq_tb0_ecc_log_s   cn88xxp1; */
} bdk_tns_txq_tb0_ecc_log_t;

#define BDK_TNS_TXQ_TB0_ECC_LOG BDK_TNS_TXQ_TB0_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB0_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB0_ECC_LOG_FUNC(void)
{
	return 0x0000842070040014ull;
}
#define typedef_BDK_TNS_TXQ_TB0_ECC_LOG bdk_tns_txq_tb0_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB0_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB0_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB0_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB0_ECC_LOG "TNS_TXQ_TB0_ECC_LOG"


/**
 * NCB32b - tns_txq_tb1_ecc_log
 *
 * Token Buffer memory 1 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_tb1_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tb1_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t ecc_err_addr                : 12; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_tb1_ecc_log_s   cn88xx; */
	/* struct bdk_tns_txq_tb1_ecc_log_s   cn88xxp1; */
} bdk_tns_txq_tb1_ecc_log_t;

#define BDK_TNS_TXQ_TB1_ECC_LOG BDK_TNS_TXQ_TB1_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB1_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB1_ECC_LOG_FUNC(void)
{
	return 0x0000842070040018ull;
}
#define typedef_BDK_TNS_TXQ_TB1_ECC_LOG bdk_tns_txq_tb1_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB1_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB1_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB1_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB1_ECC_LOG "TNS_TXQ_TB1_ECC_LOG"


/**
 * NCB32b - tns_txq_tb2_ecc_log
 *
 * Token Buffer memory 2 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_tb2_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tb2_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t ecc_err_addr                : 12; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_tb2_ecc_log_s   cn88xx; */
	/* struct bdk_tns_txq_tb2_ecc_log_s   cn88xxp1; */
} bdk_tns_txq_tb2_ecc_log_t;

#define BDK_TNS_TXQ_TB2_ECC_LOG BDK_TNS_TXQ_TB2_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB2_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB2_ECC_LOG_FUNC(void)
{
	return 0x000084207004001Cull;
}
#define typedef_BDK_TNS_TXQ_TB2_ECC_LOG bdk_tns_txq_tb2_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB2_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB2_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB2_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB2_ECC_LOG "TNS_TXQ_TB2_ECC_LOG"


/**
 * NCB32b - tns_txq_tb3_ecc_log
 *
 * Token Buffer memory 3 ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_tb3_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tb3_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_12_31              : 20;
		uint32_t ecc_err_addr                : 12; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 12;
		uint32_t reserved_12_31              : 20;
#endif
	} s;
	/* struct bdk_tns_txq_tb3_ecc_log_s   cn88xx; */
	/* struct bdk_tns_txq_tb3_ecc_log_s   cn88xxp1; */
} bdk_tns_txq_tb3_ecc_log_t;

#define BDK_TNS_TXQ_TB3_ECC_LOG BDK_TNS_TXQ_TB3_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB3_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB3_ECC_LOG_FUNC(void)
{
	return 0x0000842070040020ull;
}
#define typedef_BDK_TNS_TXQ_TB3_ECC_LOG bdk_tns_txq_tb3_ecc_log_t
#define bustype_BDK_TNS_TXQ_TB3_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB3_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TB3_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB3_ECC_LOG "TNS_TXQ_TB3_ECC_LOG"


/**
 * NCB32b - tns_txq_tb_ecc_ctl
 *
 * ECC configuration of Token Buffer memories
 *
 */
typedef union bdk_tns_txq_tb_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_tb_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t tb3_db_ecc                  : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Token Buffer memory */
		uint32_t tb3_sb_ecc                  : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Token Buffer memory */
		uint32_t tb2_db_ecc                  : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Token Buffer memory */
		uint32_t tb2_sb_ecc                  : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Token Buffer memory */
		uint32_t tb1_db_ecc                  : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Token Buffer memory */
		uint32_t tb1_sb_ecc                  : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Token Buffer memory */
		uint32_t tb0_db_ecc                  : 1;  /**< R/W - Flip 2 bits of ECC syndrome in Token Buffer memory */
		uint32_t tb0_sb_ecc                  : 1;  /**< R/W - Flip 1 bit of ECC syndrome in Token Buffer memory */
		uint32_t tb_ecc_dis                  : 1;  /**< R/W - Disable ECC for Token Buffer memory */
#else
		uint32_t tb_ecc_dis                  : 1;
		uint32_t tb0_sb_ecc                  : 1;
		uint32_t tb0_db_ecc                  : 1;
		uint32_t tb1_sb_ecc                  : 1;
		uint32_t tb1_db_ecc                  : 1;
		uint32_t tb2_sb_ecc                  : 1;
		uint32_t tb2_db_ecc                  : 1;
		uint32_t tb3_sb_ecc                  : 1;
		uint32_t tb3_db_ecc                  : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_txq_tb_ecc_ctl_s    cn88xx; */
	/* struct bdk_tns_txq_tb_ecc_ctl_s    cn88xxp1; */
} bdk_tns_txq_tb_ecc_ctl_t;

#define BDK_TNS_TXQ_TB_ECC_CTL BDK_TNS_TXQ_TB_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_ECC_CTL_FUNC(void)
{
	return 0x0000842070040010ull;
}
#define typedef_BDK_TNS_TXQ_TB_ECC_CTL bdk_tns_txq_tb_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_TB_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_TB_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_ECC_CTL "TNS_TXQ_TB_ECC_CTL"


/**
 * NCB32b - tns_txq_tb_int_en_hi
 *
 * TxQ Token Buffer interrupts
 *
 */
typedef union bdk_tns_txq_tb_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_tb_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;  /**< R/W - DFC Rx overflow on input from CNT config chain interface */
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;  /**< R/W - DFC Rx overflow on input from DQ config chain interface */
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;  /**< R/W - DFC Rx overflow on input from EQ config chain interface */
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;  /**< R/W - DFC Rx overflow on input from QMAP config chain interface */
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;  /**< R/W - DFC Rx overflow on input from top level config chain interface */
		uint32_t tb3_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb3_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb2_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb2_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb1_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb1_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb0_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb0_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
#else
		uint32_t tb0_mem_sb_err              : 1;
		uint32_t tb0_mem_db_err              : 1;
		uint32_t tb1_mem_sb_err              : 1;
		uint32_t tb1_mem_db_err              : 1;
		uint32_t tb2_mem_sb_err              : 1;
		uint32_t tb2_mem_db_err              : 1;
		uint32_t tb3_mem_sb_err              : 1;
		uint32_t tb3_mem_db_err              : 1;
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_txq_tb_int_en_hi_s  cn88xx; */
	/* struct bdk_tns_txq_tb_int_en_hi_s  cn88xxp1; */
} bdk_tns_txq_tb_int_en_hi_t;

#define BDK_TNS_TXQ_TB_INT_EN_HI BDK_TNS_TXQ_TB_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_HI_FUNC(void)
{
	return 0x0000842070040004ull;
}
#define typedef_BDK_TNS_TXQ_TB_INT_EN_HI bdk_tns_txq_tb_int_en_hi_t
#define bustype_BDK_TNS_TXQ_TB_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_TB_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_INT_EN_HI "TNS_TXQ_TB_INT_EN_HI"


/**
 * NCB32b - tns_txq_tb_int_en_lo
 *
 * TxQ Token Buffer interrupts
 *
 */
typedef union bdk_tns_txq_tb_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_tb_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;  /**< R/W - DFC Rx overflow on input from CNT config chain interface */
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;  /**< R/W - DFC Rx overflow on input from DQ config chain interface */
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;  /**< R/W - DFC Rx overflow on input from EQ config chain interface */
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;  /**< R/W - DFC Rx overflow on input from QMAP config chain interface */
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;  /**< R/W - DFC Rx overflow on input from top level config chain interface */
		uint32_t tb3_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb3_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb2_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb2_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb1_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb1_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
		uint32_t tb0_mem_db_err              : 1;  /**< R/W - Token Buffer memory double bit ECC interrupt */
		uint32_t tb0_mem_sb_err              : 1;  /**< R/W - Token Buffer memory single bit ECC interrupt */
#else
		uint32_t tb0_mem_sb_err              : 1;
		uint32_t tb0_mem_db_err              : 1;
		uint32_t tb1_mem_sb_err              : 1;
		uint32_t tb1_mem_db_err              : 1;
		uint32_t tb2_mem_sb_err              : 1;
		uint32_t tb2_mem_db_err              : 1;
		uint32_t tb3_mem_sb_err              : 1;
		uint32_t tb3_mem_db_err              : 1;
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_txq_tb_int_en_lo_s  cn88xx; */
	/* struct bdk_tns_txq_tb_int_en_lo_s  cn88xxp1; */
} bdk_tns_txq_tb_int_en_lo_t;

#define BDK_TNS_TXQ_TB_INT_EN_LO BDK_TNS_TXQ_TB_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_EN_LO_FUNC(void)
{
	return 0x0000842070040008ull;
}
#define typedef_BDK_TNS_TXQ_TB_INT_EN_LO bdk_tns_txq_tb_int_en_lo_t
#define bustype_BDK_TNS_TXQ_TB_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_TB_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_INT_EN_LO "TNS_TXQ_TB_INT_EN_LO"


/**
 * NCB32b - tns_txq_tb_int_frc
 *
 * TxQ Token Buffer interrupts
 *
 */
typedef union bdk_tns_txq_tb_int_frc {
	uint32_t u;
	struct bdk_tns_txq_tb_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;  /**< WO - DFC Rx overflow on input from CNT config chain interface */
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;  /**< WO - DFC Rx overflow on input from DQ config chain interface */
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;  /**< WO - DFC Rx overflow on input from EQ config chain interface */
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;  /**< WO - DFC Rx overflow on input from QMAP config chain interface */
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;  /**< WO - DFC Rx overflow on input from top level config chain interface */
		uint32_t tb3_mem_db_err              : 1;  /**< WO - Token Buffer memory double bit ECC interrupt */
		uint32_t tb3_mem_sb_err              : 1;  /**< WO - Token Buffer memory single bit ECC interrupt */
		uint32_t tb2_mem_db_err              : 1;  /**< WO - Token Buffer memory double bit ECC interrupt */
		uint32_t tb2_mem_sb_err              : 1;  /**< WO - Token Buffer memory single bit ECC interrupt */
		uint32_t tb1_mem_db_err              : 1;  /**< WO - Token Buffer memory double bit ECC interrupt */
		uint32_t tb1_mem_sb_err              : 1;  /**< WO - Token Buffer memory single bit ECC interrupt */
		uint32_t tb0_mem_db_err              : 1;  /**< WO - Token Buffer memory double bit ECC interrupt */
		uint32_t tb0_mem_sb_err              : 1;  /**< WO - Token Buffer memory single bit ECC interrupt */
#else
		uint32_t tb0_mem_sb_err              : 1;
		uint32_t tb0_mem_db_err              : 1;
		uint32_t tb1_mem_sb_err              : 1;
		uint32_t tb1_mem_db_err              : 1;
		uint32_t tb2_mem_sb_err              : 1;
		uint32_t tb2_mem_db_err              : 1;
		uint32_t tb3_mem_sb_err              : 1;
		uint32_t tb3_mem_db_err              : 1;
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_txq_tb_int_frc_s    cn88xx; */
	/* struct bdk_tns_txq_tb_int_frc_s    cn88xxp1; */
} bdk_tns_txq_tb_int_frc_t;

#define BDK_TNS_TXQ_TB_INT_FRC BDK_TNS_TXQ_TB_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_FRC_FUNC(void)
{
	return 0x000084207004000Cull;
}
#define typedef_BDK_TNS_TXQ_TB_INT_FRC bdk_tns_txq_tb_int_frc_t
#define bustype_BDK_TNS_TXQ_TB_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_INT_FRC 0
#define arguments_BDK_TNS_TXQ_TB_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_INT_FRC "TNS_TXQ_TB_INT_FRC"


/**
 * NCB32b - tns_txq_tb_int_w1c
 *
 * TxQ Token Buffer interrupts
 *
 */
typedef union bdk_tns_txq_tb_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_tb_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_13_31              : 19;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;  /**< R/W1C/H - DFC Rx overflow on input from CNT config chain interface */
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;  /**< R/W1C/H - DFC Rx overflow on input from DQ config chain interface */
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;  /**< R/W1C/H - DFC Rx overflow on input from EQ config chain interface */
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;  /**< R/W1C/H - DFC Rx overflow on input from QMAP config chain interface */
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;  /**< R/W1C/H - DFC Rx overflow on input from top level config chain interface */
		uint32_t tb3_mem_db_err              : 1;  /**< R/W1C/H - Token Buffer memory double bit ECC interrupt */
		uint32_t tb3_mem_sb_err              : 1;  /**< R/W1C/H - Token Buffer memory single bit ECC interrupt */
		uint32_t tb2_mem_db_err              : 1;  /**< R/W1C/H - Token Buffer memory double bit ECC interrupt */
		uint32_t tb2_mem_sb_err              : 1;  /**< R/W1C/H - Token Buffer memory single bit ECC interrupt */
		uint32_t tb1_mem_db_err              : 1;  /**< R/W1C/H - Token Buffer memory double bit ECC interrupt */
		uint32_t tb1_mem_sb_err              : 1;  /**< R/W1C/H - Token Buffer memory single bit ECC interrupt */
		uint32_t tb0_mem_db_err              : 1;  /**< R/W1C/H - Token Buffer memory double bit ECC interrupt */
		uint32_t tb0_mem_sb_err              : 1;  /**< R/W1C/H - Token Buffer memory single bit ECC interrupt */
#else
		uint32_t tb0_mem_sb_err              : 1;
		uint32_t tb0_mem_db_err              : 1;
		uint32_t tb1_mem_sb_err              : 1;
		uint32_t tb1_mem_db_err              : 1;
		uint32_t tb2_mem_sb_err              : 1;
		uint32_t tb2_mem_db_err              : 1;
		uint32_t tb3_mem_sb_err              : 1;
		uint32_t tb3_mem_db_err              : 1;
		uint32_t dfc_rx_txq_i_cfg_ovfl_err   : 1;
		uint32_t dfc_rx_qmap_o_cfg_ovfl_err  : 1;
		uint32_t dfc_rx_eq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_dq_o_cfg_ovfl_err    : 1;
		uint32_t dfc_rx_cnt_o_cfg_ovfl_err   : 1;
		uint32_t reserved_13_31              : 19;
#endif
	} s;
	/* struct bdk_tns_txq_tb_int_w1c_s    cn88xx; */
	/* struct bdk_tns_txq_tb_int_w1c_s    cn88xxp1; */
} bdk_tns_txq_tb_int_w1c_t;

#define BDK_TNS_TXQ_TB_INT_W1C BDK_TNS_TXQ_TB_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_INT_W1C_FUNC(void)
{
	return 0x0000842070040000ull;
}
#define typedef_BDK_TNS_TXQ_TB_INT_W1C bdk_tns_txq_tb_int_w1c_t
#define bustype_BDK_TNS_TXQ_TB_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_INT_W1C 0
#define arguments_BDK_TNS_TXQ_TB_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_INT_W1C "TNS_TXQ_TB_INT_W1C"


/**
 * NCB32b - tns_txq_tb_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_tb_lock {
	uint32_t u;
	struct bdk_tns_txq_tb_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tb_lock_s       cn88xx; */
	/* struct bdk_tns_txq_tb_lock_s       cn88xxp1; */
} bdk_tns_txq_tb_lock_t;

#define BDK_TNS_TXQ_TB_LOCK BDK_TNS_TXQ_TB_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_LOCK_FUNC(void)
{
	return 0x0000842070040028ull;
}
#define typedef_BDK_TNS_TXQ_TB_LOCK bdk_tns_txq_tb_lock_t
#define bustype_BDK_TNS_TXQ_TB_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_LOCK 0
#define arguments_BDK_TNS_TXQ_TB_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_LOCK "TNS_TXQ_TB_LOCK"


/**
 * NCB - tns_txq_tb_mem#_w#
 *
 * TxQ Token Buffer SRAM debug access
 * Bits[63:51] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_tb_memx_wx {
	uint64_t u;
	struct bdk_tns_txq_tb_memx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_tb_memx_wx_s    cn88xx; */
	/* struct bdk_tns_txq_tb_memx_wx_s    cn88xxp1; */
} bdk_tns_txq_tb_memx_wx_t;

static inline uint64_t BDK_TNS_TXQ_TB_MEMX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_MEMX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 14335)) && ((param2 <= 1)))
		return 0x0000842070000000ull + (param1 & 16383) * 0x10ull + (param2 & 1) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_TB_MEMX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_TB_MEMX_WX(...) bdk_tns_txq_tb_memx_wx_t
#define bustype_BDK_TNS_TXQ_TB_MEMX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_TB_MEMX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_TB_MEMX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_TB_MEMX_WX(...) "TNS_TXQ_TB_MEMX_WX"


/**
 * NCB32b - tns_txq_tb_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_tb_spad {
	uint32_t u;
	struct bdk_tns_txq_tb_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tb_spad_s       cn88xx; */
	/* struct bdk_tns_txq_tb_spad_s       cn88xxp1; */
} bdk_tns_txq_tb_spad_t;

#define BDK_TNS_TXQ_TB_SPAD BDK_TNS_TXQ_TB_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_TB_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TB_SPAD_FUNC(void)
{
	return 0x000084207004002Cull;
}
#define typedef_BDK_TNS_TXQ_TB_SPAD bdk_tns_txq_tb_spad_t
#define bustype_BDK_TNS_TXQ_TB_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TB_SPAD 0
#define arguments_BDK_TNS_TXQ_TB_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TB_SPAD "TNS_TXQ_TB_SPAD"


/**
 * NCB32b - tns_txq_tbc_bist_stdn
 *
 * TxQ TBC bist status and bist_done
 *
 */
typedef union bdk_tns_txq_tbc_bist_stdn {
	uint32_t u;
	struct bdk_tns_txq_tbc_bist_stdn_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t ft_fifo_mem_status          : 1;  /**< RO/H - -- */
		uint32_t tail_ptr_mem_status         : 1;  /**< RO/H - -- */
		uint32_t head_ptr_mem_status         : 1;  /**< RO/H - -- */
		uint32_t tb_mem_status               : 4;  /**< RO/H - -- */
		uint32_t ft_fifo_mem_done            : 1;  /**< RO/H - -- */
		uint32_t tail_ptr_mem_done           : 1;  /**< RO/H - -- */
		uint32_t head_ptr_mem_done           : 1;  /**< RO/H - -- */
		uint32_t tb_mem_done                 : 4;  /**< RO/H - -- */
#else
		uint32_t tb_mem_done                 : 4;
		uint32_t head_ptr_mem_done           : 1;
		uint32_t tail_ptr_mem_done           : 1;
		uint32_t ft_fifo_mem_done            : 1;
		uint32_t tb_mem_status               : 4;
		uint32_t head_ptr_mem_status         : 1;
		uint32_t tail_ptr_mem_status         : 1;
		uint32_t ft_fifo_mem_status          : 1;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbc_bist_stdn_s cn88xx; */
	/* struct bdk_tns_txq_tbc_bist_stdn_s cn88xxp1; */
} bdk_tns_txq_tbc_bist_stdn_t;

#define BDK_TNS_TXQ_TBC_BIST_STDN BDK_TNS_TXQ_TBC_BIST_STDN_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBC_BIST_STDN_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBC_BIST_STDN_FUNC(void)
{
	return 0x0000842070040024ull;
}
#define typedef_BDK_TNS_TXQ_TBC_BIST_STDN bdk_tns_txq_tbc_bist_stdn_t
#define bustype_BDK_TNS_TXQ_TBC_BIST_STDN BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBC_BIST_STDN 0
#define arguments_BDK_TNS_TXQ_TBC_BIST_STDN -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBC_BIST_STDN "TNS_TXQ_TBC_BIST_STDN"


/**
 * NCB32b - tns_txq_tbm_ecc_ctl
 *
 * ECC configuration of all TBM memories
 *
 */
typedef union bdk_tns_txq_tbm_ecc_ctl {
	uint32_t u;
	struct bdk_tns_txq_tbm_ecc_ctl_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_9_31               : 23;
		uint32_t head_ptr_flip_db_ecc        : 1;  /**< R/W - Flip 2 bits of ECC syndrome in head pointer memory */
		uint32_t head_ptr_flip_sb_ecc        : 1;  /**< R/W - Flip 1 bit of ECC syndrome in head pointer memory */
		uint32_t head_ptr_ecc_dis            : 1;  /**< R/W - Disable ECC for head pointer memory */
		uint32_t tail_ptr_flip_db_ecc        : 1;  /**< R/W - Flip 2 bits of ECC syndrome in tail pointer memory */
		uint32_t tail_ptr_flip_sb_ecc        : 1;  /**< R/W - Flip 1 bit of ECC syndrome in tail pointer memory */
		uint32_t tail_ptr_ecc_dis            : 1;  /**< R/W - Disable ECC for tail pointer memory */
		uint32_t ft_fifo_flip_db_ecc         : 1;  /**< R/W - Flip 2 bits of ECC syndrome in FT memory */
		uint32_t ft_fifo_flip_sb_ecc         : 1;  /**< R/W - Flip 1 bit of ECC syndrome in FT memory */
		uint32_t ft_fifo_ecc_dis             : 1;  /**< R/W - Disable ECC for Free token FIFO memory */
#else
		uint32_t ft_fifo_ecc_dis             : 1;
		uint32_t ft_fifo_flip_sb_ecc         : 1;
		uint32_t ft_fifo_flip_db_ecc         : 1;
		uint32_t tail_ptr_ecc_dis            : 1;
		uint32_t tail_ptr_flip_sb_ecc        : 1;
		uint32_t tail_ptr_flip_db_ecc        : 1;
		uint32_t head_ptr_ecc_dis            : 1;
		uint32_t head_ptr_flip_sb_ecc        : 1;
		uint32_t head_ptr_flip_db_ecc        : 1;
		uint32_t reserved_9_31               : 23;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ecc_ctl_s   cn88xx; */
	/* struct bdk_tns_txq_tbm_ecc_ctl_s   cn88xxp1; */
} bdk_tns_txq_tbm_ecc_ctl_t;

#define BDK_TNS_TXQ_TBM_ECC_CTL BDK_TNS_TXQ_TBM_ECC_CTL_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_ECC_CTL_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_ECC_CTL_FUNC(void)
{
	return 0x000084207050C010ull;
}
#define typedef_BDK_TNS_TXQ_TBM_ECC_CTL bdk_tns_txq_tbm_ecc_ctl_t
#define bustype_BDK_TNS_TXQ_TBM_ECC_CTL BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_ECC_CTL 0
#define arguments_BDK_TNS_TXQ_TBM_ECC_CTL -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_ECC_CTL "TNS_TXQ_TBM_ECC_CTL"


/**
 * NCB32b - tns_txq_tbm_ft_cnt_dat_cfg
 *
 * Indicates free token fifo counter data per bank
 *
 */
typedef union bdk_tns_txq_tbm_ft_cnt_dat_cfg {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_cnt_dat_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t cnt                         : 14; /**< RO/H - -- */
#else
		uint32_t cnt                         : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_cnt_dat_cfg_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_cnt_dat_cfg_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_cnt_dat_cfg_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG_FUNC(void)
{
	return 0x000084207050C030ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG bdk_tns_txq_tbm_ft_cnt_dat_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_DAT_CFG "TNS_TXQ_TBM_FT_CNT_DAT_CFG"


/**
 * NCB32b - tns_txq_tbm_ft_cnt_init_cfg
 *
 * Configuration to initialize free token count.  Note that 2k tokens are pre-
 * allocated to the queues with HW init.  This number should be adjusted
 * accordingly
 */
typedef union bdk_tns_txq_tbm_ft_cnt_init_cfg {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_cnt_init_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t cnt                         : 14; /**< R/W - -- */
#else
		uint32_t cnt                         : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_cnt_init_cfg_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_cnt_init_cfg_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_cnt_init_cfg_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG_FUNC(void)
{
	return 0x000084207050C028ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG bdk_tns_txq_tbm_ft_cnt_init_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_INIT_CFG "TNS_TXQ_TBM_FT_CNT_INIT_CFG"


/**
 * NCB32b - tns_txq_tbm_ft_cnt_thr
 *
 * Configuration to indicate threshold below which no free tokens are issued
 *
 */
typedef union bdk_tns_txq_tbm_ft_cnt_thr {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_cnt_thr_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t cnt                         : 14; /**< R/W - -- */
#else
		uint32_t cnt                         : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_cnt_thr_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_cnt_thr_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_cnt_thr_t;

#define BDK_TNS_TXQ_TBM_FT_CNT_THR BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_CNT_THR_FUNC(void)
{
	return 0x000084207050C02Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_CNT_THR bdk_tns_txq_tbm_ft_cnt_thr_t
#define bustype_BDK_TNS_TXQ_TBM_FT_CNT_THR BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_CNT_THR 0
#define arguments_BDK_TNS_TXQ_TBM_FT_CNT_THR -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_CNT_THR "TNS_TXQ_TBM_FT_CNT_THR"


/**
 * NCB - tns_txq_tbm_ft_fif#_w#
 *
 * TBM free token fifo CPU access
 * Bits[63:48] in _W[1] are unused.
 * When writing, the MSBs (word 1) of the entry must be written last.
 * When writing, make the access to this decoder atomic w.r.t. other writes to
 * this decoder.
 */
typedef union bdk_tns_txq_tbm_ft_fifx_wx {
	uint64_t u;
	struct bdk_tns_txq_tbm_ft_fifx_wx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint64_t data                        : 64; /**< R/W - -- */
#else
		uint64_t data                        : 64;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_fifx_wx_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_fifx_wx_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_fifx_wx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIFX_WX(unsigned long param1, unsigned long param2) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIFX_WX(unsigned long param1, unsigned long param2)
{
	if (((param1 <= 1791)) && ((param2 <= 1)))
		return 0x0000842070500000ull + (param1 & 2047) * 0x10ull + (param2 & 1) * 0x8ull;
	csr_fatal("BDK_TNS_TXQ_TBM_FT_FIFX_WX", 2, param1, param2, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_TBM_FT_FIFX_WX(...) bdk_tns_txq_tbm_ft_fifx_wx_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIFX_WX(...) BDK_CSR_TYPE_NCB
#define busnum_BDK_TNS_TXQ_TBM_FT_FIFX_WX(p1,p2) (p1)
#define arguments_BDK_TNS_TXQ_TBM_FT_FIFX_WX(p1,p2) (p1),(p2),-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_FIFX_WX(...) "TNS_TXQ_TBM_FT_FIFX_WX"


/**
 * NCB32b - tns_txq_tbm_ft_fif_dbg
 *
 * Free token fifo debug register
 *
 */
typedef union bdk_tns_txq_tbm_ft_fif_dbg {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_fif_dbg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_24_31              : 8;
		uint32_t debug                       : 24; /**< R/W/H - -- */
#else
		uint32_t debug                       : 24;
		uint32_t reserved_24_31              : 8;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_fif_dbg_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_fif_dbg_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_fif_dbg_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_DBG BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_DBG_FUNC(void)
{
	return 0x000084207050C060ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_DBG bdk_tns_txq_tbm_ft_fif_dbg_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_DBG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_DBG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_DBG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_DBG "TNS_TXQ_TBM_FT_FIF_DBG"


/**
 * NCB32b - tns_txq_tbm_ft_fif_ecc_log
 *
 * Free token fifo pointer ECC error log.  Address is sticky on first error.  Re-
 * armed after reading
 */
typedef union bdk_tns_txq_tbm_ft_fif_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_fif_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_fif_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_fif_ecc_log_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_fif_ecc_log_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG_FUNC(void)
{
	return 0x000084207050C01Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG bdk_tns_txq_tbm_ft_fif_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_ECC_LOG "TNS_TXQ_TBM_FT_FIF_ECC_LOG"


/**
 * NCB32b - tns_txq_tbm_ft_fif_usage
 *
 * Token buffer Free Token FIFO usage level
 *
 */
typedef union bdk_tns_txq_tbm_ft_fif_usage {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_fif_usage_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t fifo_usage                  : 11; /**< RO/H - -- */
#else
		uint32_t fifo_usage                  : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_fif_usage_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_fif_usage_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_fif_usage_t;

#define BDK_TNS_TXQ_TBM_FT_FIF_USAGE BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_FIF_USAGE_FUNC(void)
{
	return 0x000084207050C040ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_FIF_USAGE bdk_tns_txq_tbm_ft_fif_usage_t
#define bustype_BDK_TNS_TXQ_TBM_FT_FIF_USAGE BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_FIF_USAGE 0
#define arguments_BDK_TNS_TXQ_TBM_FT_FIF_USAGE -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_FIF_USAGE "TNS_TXQ_TBM_FT_FIF_USAGE"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_ct
 *
 * Count of the number of valid pre-fetched free-tokens in the ft_prefetch
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_ct {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_5_31               : 27;
		uint32_t count                       : 5;  /**< RO/H - -- */
#else
		uint32_t count                       : 5;
		uint32_t reserved_5_31               : 27;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_ct_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_ct_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_ct_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_CT BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_CT_FUNC(void)
{
	return 0x000084207050C034ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT bdk_tns_txq_tbm_ft_prefetch_ct_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_CT "TNS_TXQ_TBM_FT_PREFETCH_CT"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w0
 *
 * Read-out of pre-fetched free tokens in the tail pointer block.
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w0 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w0_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr13                    : 4;  /**< RO/H - -- */
		uint32_t tb_ptr14                    : 14; /**< RO/H - -- */
		uint32_t tb_ptr15                    : 14; /**< RO/H - -- */
#else
		uint32_t tb_ptr15                    : 14;
		uint32_t tb_ptr14                    : 14;
		uint32_t tb_ptr13                    : 4;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w0_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w0_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w0_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W0_FUNC(void)
{
	return 0x000084207050C044ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 bdk_tns_txq_tbm_ft_prefetch_w0_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W0 "TNS_TXQ_TBM_FT_PREFETCH_W0"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w1
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w1 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w1_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr11                    : 8;  /**< RO/H - -- */
		uint32_t tb_ptr12                    : 14; /**< RO/H - -- */
		uint32_t tb_ptr13                    : 10; /**< RO/H - Continuation of MSBs of field TB_PTR13 from previous word. */
#else
		uint32_t tb_ptr13                    : 10;
		uint32_t tb_ptr12                    : 14;
		uint32_t tb_ptr11                    : 8;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w1_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w1_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w1_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W1_FUNC(void)
{
	return 0x000084207050C048ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 bdk_tns_txq_tbm_ft_prefetch_w1_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W1 "TNS_TXQ_TBM_FT_PREFETCH_W1"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w2
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w2 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w2_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr9                     : 12; /**< RO/H - -- */
		uint32_t tb_ptr10                    : 14; /**< RO/H - -- */
		uint32_t tb_ptr11                    : 6;  /**< RO/H - Continuation of MSBs of field TB_PTR11 from previous word. */
#else
		uint32_t tb_ptr11                    : 6;
		uint32_t tb_ptr10                    : 14;
		uint32_t tb_ptr9                     : 12;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w2_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w2_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w2_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W2_FUNC(void)
{
	return 0x000084207050C04Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 bdk_tns_txq_tbm_ft_prefetch_w2_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W2 "TNS_TXQ_TBM_FT_PREFETCH_W2"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w3
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w3 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w3_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr6                     : 2;  /**< RO/H - -- */
		uint32_t tb_ptr7                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr8                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr9                     : 2;  /**< RO/H - Continuation of MSBs of field TB_PTR9 from previous word. */
#else
		uint32_t tb_ptr9                     : 2;
		uint32_t tb_ptr8                     : 14;
		uint32_t tb_ptr7                     : 14;
		uint32_t tb_ptr6                     : 2;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w3_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w3_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w3_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W3_FUNC(void)
{
	return 0x000084207050C050ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 bdk_tns_txq_tbm_ft_prefetch_w3_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W3 "TNS_TXQ_TBM_FT_PREFETCH_W3"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w4
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w4 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w4_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr4                     : 6;  /**< RO/H - -- */
		uint32_t tb_ptr5                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr6                     : 12; /**< RO/H - Continuation of MSBs of field TB_PTR6 from previous word. */
#else
		uint32_t tb_ptr6                     : 12;
		uint32_t tb_ptr5                     : 14;
		uint32_t tb_ptr4                     : 6;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w4_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w4_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w4_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W4_FUNC(void)
{
	return 0x000084207050C054ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 bdk_tns_txq_tbm_ft_prefetch_w4_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W4 "TNS_TXQ_TBM_FT_PREFETCH_W4"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w5
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w5 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w5_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr2                     : 10; /**< RO/H - -- */
		uint32_t tb_ptr3                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr4                     : 8;  /**< RO/H - Continuation of MSBs of field TB_PTR4 from previous word. */
#else
		uint32_t tb_ptr4                     : 8;
		uint32_t tb_ptr3                     : 14;
		uint32_t tb_ptr2                     : 10;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w5_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w5_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w5_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W5_FUNC(void)
{
	return 0x000084207050C058ull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 bdk_tns_txq_tbm_ft_prefetch_w5_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W5 "TNS_TXQ_TBM_FT_PREFETCH_W5"


/**
 * NCB32b - tns_txq_tbm_ft_prefetch_w6
 *
 * Continuation of structure defined in TNS_TXQ_TBM_FT_PREFETCH_W0
 *
 */
typedef union bdk_tns_txq_tbm_ft_prefetch_w6 {
	uint32_t u;
	struct bdk_tns_txq_tbm_ft_prefetch_w6_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t tb_ptr0                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr1                     : 14; /**< RO/H - -- */
		uint32_t tb_ptr2                     : 4;  /**< RO/H - Continuation of MSBs of field TB_PTR2 from previous word. */
#else
		uint32_t tb_ptr2                     : 4;
		uint32_t tb_ptr1                     : 14;
		uint32_t tb_ptr0                     : 14;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_ft_prefetch_w6_s cn88xx; */
	/* struct bdk_tns_txq_tbm_ft_prefetch_w6_s cn88xxp1; */
} bdk_tns_txq_tbm_ft_prefetch_w6_t;

#define BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_FT_PREFETCH_W6_FUNC(void)
{
	return 0x000084207050C05Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 bdk_tns_txq_tbm_ft_prefetch_w6_t
#define bustype_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 0
#define arguments_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_FT_PREFETCH_W6 "TNS_TXQ_TBM_FT_PREFETCH_W6"


/**
 * NCB32b - tns_txq_tbm_head_ptr_ecc_log
 *
 * TBM head pointer ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_tbm_head_ptr_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tbm_head_ptr_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_head_ptr_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_tbm_head_ptr_ecc_log_s cn88xxp1; */
} bdk_tns_txq_tbm_head_ptr_ecc_log_t;

#define BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG_FUNC(void)
{
	return 0x000084207050C014ull;
}
#define typedef_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG bdk_tns_txq_tbm_head_ptr_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_HEAD_PTR_ECC_LOG "TNS_TXQ_TBM_HEAD_PTR_ECC_LOG"


/**
 * NCB32b - tns_txq_tbm_head_ptr_mem#
 *
 * Queue Head pointer memory CPU access
 *
 */
typedef union bdk_tns_txq_tbm_head_ptr_memx {
	uint32_t u;
	struct bdk_tns_txq_tbm_head_ptr_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t data                        : 14; /**< R/W - -- */
#else
		uint32_t data                        : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_head_ptr_memx_s cn88xx; */
	/* struct bdk_tns_txq_tbm_head_ptr_memx_s cn88xxp1; */
} bdk_tns_txq_tbm_head_ptr_memx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x000084207050A000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(...) bdk_tns_txq_tbm_head_ptr_memx_t
#define bustype_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_HEAD_PTR_MEMX(...) "TNS_TXQ_TBM_HEAD_PTR_MEMX"


/**
 * NCB32b - tns_txq_tbm_hw_init_sta
 *
 * Per memory HW init.  Write '1' to force HW init.  Read for status.  '1'
 * indicates that HW init is completed
 */
typedef union bdk_tns_txq_tbm_hw_init_sta {
	uint32_t u;
	struct bdk_tns_txq_tbm_hw_init_sta_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_3_31               : 29;
		uint32_t tail_ptr_mem                : 1;  /**< RO/H - -- */
		uint32_t head_ptr_mem                : 1;  /**< RO/H - -- */
		uint32_t ft_fifo                     : 1;  /**< RO/H - -- */
#else
		uint32_t ft_fifo                     : 1;
		uint32_t head_ptr_mem                : 1;
		uint32_t tail_ptr_mem                : 1;
		uint32_t reserved_3_31               : 29;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_hw_init_sta_s cn88xx; */
	/* struct bdk_tns_txq_tbm_hw_init_sta_s cn88xxp1; */
} bdk_tns_txq_tbm_hw_init_sta_t;

#define BDK_TNS_TXQ_TBM_HW_INIT_STA BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_HW_INIT_STA_FUNC(void)
{
	return 0x000084207050C024ull;
}
#define typedef_BDK_TNS_TXQ_TBM_HW_INIT_STA bdk_tns_txq_tbm_hw_init_sta_t
#define bustype_BDK_TNS_TXQ_TBM_HW_INIT_STA BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_HW_INIT_STA 0
#define arguments_BDK_TNS_TXQ_TBM_HW_INIT_STA -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_HW_INIT_STA "TNS_TXQ_TBM_HW_INIT_STA"


/**
 * NCB32b - tns_txq_tbm_int_en_hi
 *
 * Token Buffer Manager Interrupt register
 *
 */
typedef union bdk_tns_txq_tbm_int_en_hi {
	uint32_t u;
	struct bdk_tns_txq_tbm_int_en_hi_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;  /**< R/W - DFC Rx overflow on EQ to TBM tail pointer interface */
		uint32_t ft_fifo_db_err              : 1;  /**< R/W - -- */
		uint32_t ft_fifo_sb_err              : 1;  /**< R/W - -- */
		uint32_t tail_ptr_mem_db_err         : 1;  /**< R/W - -- */
		uint32_t tail_ptr_mem_sb_err         : 1;  /**< R/W - -- */
		uint32_t head_ptr_mem_db_err         : 1;  /**< R/W - -- */
		uint32_t head_ptr_mem_sb_err         : 1;  /**< R/W - -- */
#else
		uint32_t head_ptr_mem_sb_err         : 1;
		uint32_t head_ptr_mem_db_err         : 1;
		uint32_t tail_ptr_mem_sb_err         : 1;
		uint32_t tail_ptr_mem_db_err         : 1;
		uint32_t ft_fifo_sb_err              : 1;
		uint32_t ft_fifo_db_err              : 1;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_int_en_hi_s cn88xx; */
	/* struct bdk_tns_txq_tbm_int_en_hi_s cn88xxp1; */
} bdk_tns_txq_tbm_int_en_hi_t;

#define BDK_TNS_TXQ_TBM_INT_EN_HI BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_HI_FUNC(void)
{
	return 0x000084207050C004ull;
}
#define typedef_BDK_TNS_TXQ_TBM_INT_EN_HI bdk_tns_txq_tbm_int_en_hi_t
#define bustype_BDK_TNS_TXQ_TBM_INT_EN_HI BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_INT_EN_HI 0
#define arguments_BDK_TNS_TXQ_TBM_INT_EN_HI -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_INT_EN_HI "TNS_TXQ_TBM_INT_EN_HI"


/**
 * NCB32b - tns_txq_tbm_int_en_lo
 *
 * Token Buffer Manager Interrupt register
 *
 */
typedef union bdk_tns_txq_tbm_int_en_lo {
	uint32_t u;
	struct bdk_tns_txq_tbm_int_en_lo_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;  /**< R/W - DFC Rx overflow on EQ to TBM tail pointer interface */
		uint32_t ft_fifo_db_err              : 1;  /**< R/W - -- */
		uint32_t ft_fifo_sb_err              : 1;  /**< R/W - -- */
		uint32_t tail_ptr_mem_db_err         : 1;  /**< R/W - -- */
		uint32_t tail_ptr_mem_sb_err         : 1;  /**< R/W - -- */
		uint32_t head_ptr_mem_db_err         : 1;  /**< R/W - -- */
		uint32_t head_ptr_mem_sb_err         : 1;  /**< R/W - -- */
#else
		uint32_t head_ptr_mem_sb_err         : 1;
		uint32_t head_ptr_mem_db_err         : 1;
		uint32_t tail_ptr_mem_sb_err         : 1;
		uint32_t tail_ptr_mem_db_err         : 1;
		uint32_t ft_fifo_sb_err              : 1;
		uint32_t ft_fifo_db_err              : 1;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_int_en_lo_s cn88xx; */
	/* struct bdk_tns_txq_tbm_int_en_lo_s cn88xxp1; */
} bdk_tns_txq_tbm_int_en_lo_t;

#define BDK_TNS_TXQ_TBM_INT_EN_LO BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_EN_LO_FUNC(void)
{
	return 0x000084207050C008ull;
}
#define typedef_BDK_TNS_TXQ_TBM_INT_EN_LO bdk_tns_txq_tbm_int_en_lo_t
#define bustype_BDK_TNS_TXQ_TBM_INT_EN_LO BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_INT_EN_LO 0
#define arguments_BDK_TNS_TXQ_TBM_INT_EN_LO -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_INT_EN_LO "TNS_TXQ_TBM_INT_EN_LO"


/**
 * NCB32b - tns_txq_tbm_int_frc
 *
 * Token Buffer Manager Interrupt register
 *
 */
typedef union bdk_tns_txq_tbm_int_frc {
	uint32_t u;
	struct bdk_tns_txq_tbm_int_frc_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;  /**< WO - DFC Rx overflow on EQ to TBM tail pointer interface */
		uint32_t ft_fifo_db_err              : 1;  /**< WO - -- */
		uint32_t ft_fifo_sb_err              : 1;  /**< WO - -- */
		uint32_t tail_ptr_mem_db_err         : 1;  /**< WO - -- */
		uint32_t tail_ptr_mem_sb_err         : 1;  /**< WO - -- */
		uint32_t head_ptr_mem_db_err         : 1;  /**< WO - -- */
		uint32_t head_ptr_mem_sb_err         : 1;  /**< WO - -- */
#else
		uint32_t head_ptr_mem_sb_err         : 1;
		uint32_t head_ptr_mem_db_err         : 1;
		uint32_t tail_ptr_mem_sb_err         : 1;
		uint32_t tail_ptr_mem_db_err         : 1;
		uint32_t ft_fifo_sb_err              : 1;
		uint32_t ft_fifo_db_err              : 1;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_int_frc_s   cn88xx; */
	/* struct bdk_tns_txq_tbm_int_frc_s   cn88xxp1; */
} bdk_tns_txq_tbm_int_frc_t;

#define BDK_TNS_TXQ_TBM_INT_FRC BDK_TNS_TXQ_TBM_INT_FRC_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_FRC_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_FRC_FUNC(void)
{
	return 0x000084207050C00Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_INT_FRC bdk_tns_txq_tbm_int_frc_t
#define bustype_BDK_TNS_TXQ_TBM_INT_FRC BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_INT_FRC 0
#define arguments_BDK_TNS_TXQ_TBM_INT_FRC -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_INT_FRC "TNS_TXQ_TBM_INT_FRC"


/**
 * NCB32b - tns_txq_tbm_int_w1c
 *
 * Token Buffer Manager Interrupt register
 *
 */
typedef union bdk_tns_txq_tbm_int_w1c {
	uint32_t u;
	struct bdk_tns_txq_tbm_int_w1c_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_7_31               : 25;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;  /**< R/W1C/H - DFC Rx overflow on EQ to TBM tail pointer interface */
		uint32_t ft_fifo_db_err              : 1;  /**< R/W1C/H - -- */
		uint32_t ft_fifo_sb_err              : 1;  /**< R/W1C/H - -- */
		uint32_t tail_ptr_mem_db_err         : 1;  /**< R/W1C/H - -- */
		uint32_t tail_ptr_mem_sb_err         : 1;  /**< R/W1C/H - -- */
		uint32_t head_ptr_mem_db_err         : 1;  /**< R/W1C/H - -- */
		uint32_t head_ptr_mem_sb_err         : 1;  /**< R/W1C/H - -- */
#else
		uint32_t head_ptr_mem_sb_err         : 1;
		uint32_t head_ptr_mem_db_err         : 1;
		uint32_t tail_ptr_mem_sb_err         : 1;
		uint32_t tail_ptr_mem_db_err         : 1;
		uint32_t ft_fifo_sb_err              : 1;
		uint32_t ft_fifo_db_err              : 1;
		uint32_t dfc_rx_eq_tbm_ovfl_err      : 1;
		uint32_t reserved_7_31               : 25;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_int_w1c_s   cn88xx; */
	/* struct bdk_tns_txq_tbm_int_w1c_s   cn88xxp1; */
} bdk_tns_txq_tbm_int_w1c_t;

#define BDK_TNS_TXQ_TBM_INT_W1C BDK_TNS_TXQ_TBM_INT_W1C_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_INT_W1C_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_INT_W1C_FUNC(void)
{
	return 0x000084207050C000ull;
}
#define typedef_BDK_TNS_TXQ_TBM_INT_W1C bdk_tns_txq_tbm_int_w1c_t
#define bustype_BDK_TNS_TXQ_TBM_INT_W1C BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_INT_W1C 0
#define arguments_BDK_TNS_TXQ_TBM_INT_W1C -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_INT_W1C "TNS_TXQ_TBM_INT_W1C"


/**
 * NCB32b - tns_txq_tbm_lock
 *
 * Lock Register
 *
 */
typedef union bdk_tns_txq_tbm_lock {
	uint32_t u;
	struct bdk_tns_txq_tbm_lock_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t lock                        : 32; /**< R/W/H - -- */
#else
		uint32_t lock                        : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_lock_s      cn88xx; */
	/* struct bdk_tns_txq_tbm_lock_s      cn88xxp1; */
} bdk_tns_txq_tbm_lock_t;

#define BDK_TNS_TXQ_TBM_LOCK BDK_TNS_TXQ_TBM_LOCK_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_LOCK_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_LOCK_FUNC(void)
{
	return 0x000084207050C064ull;
}
#define typedef_BDK_TNS_TXQ_TBM_LOCK bdk_tns_txq_tbm_lock_t
#define bustype_BDK_TNS_TXQ_TBM_LOCK BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_LOCK 0
#define arguments_BDK_TNS_TXQ_TBM_LOCK -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_LOCK "TNS_TXQ_TBM_LOCK"


/**
 * NCB32b - tns_txq_tbm_rst_cfg
 *
 * Reset configuration to initialize and start various modules within TBM
 *
 */
typedef union bdk_tns_txq_tbm_rst_cfg {
	uint32_t u;
	struct bdk_tns_txq_tbm_rst_cfg_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_2_31               : 30;
		uint32_t tbm_module_en               : 1;  /**< R/W - -- */
		uint32_t tbm_hw_init                 : 1;  /**< R/W - -- */
#else
		uint32_t tbm_hw_init                 : 1;
		uint32_t tbm_module_en               : 1;
		uint32_t reserved_2_31               : 30;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_rst_cfg_s   cn88xx; */
	/* struct bdk_tns_txq_tbm_rst_cfg_s   cn88xxp1; */
} bdk_tns_txq_tbm_rst_cfg_t;

#define BDK_TNS_TXQ_TBM_RST_CFG BDK_TNS_TXQ_TBM_RST_CFG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_RST_CFG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_RST_CFG_FUNC(void)
{
	return 0x000084207050C020ull;
}
#define typedef_BDK_TNS_TXQ_TBM_RST_CFG bdk_tns_txq_tbm_rst_cfg_t
#define bustype_BDK_TNS_TXQ_TBM_RST_CFG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_RST_CFG 0
#define arguments_BDK_TNS_TXQ_TBM_RST_CFG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_RST_CFG "TNS_TXQ_TBM_RST_CFG"


/**
 * NCB32b - tns_txq_tbm_spad
 *
 * Scratch Pad Register for XCAT
 *
 */
typedef union bdk_tns_txq_tbm_spad {
	uint32_t u;
	struct bdk_tns_txq_tbm_spad_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t scratchpad                  : 32; /**< R/W - -- */
#else
		uint32_t scratchpad                  : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_spad_s      cn88xx; */
	/* struct bdk_tns_txq_tbm_spad_s      cn88xxp1; */
} bdk_tns_txq_tbm_spad_t;

#define BDK_TNS_TXQ_TBM_SPAD BDK_TNS_TXQ_TBM_SPAD_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_SPAD_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_SPAD_FUNC(void)
{
	return 0x000084207050C068ull;
}
#define typedef_BDK_TNS_TXQ_TBM_SPAD bdk_tns_txq_tbm_spad_t
#define bustype_BDK_TNS_TXQ_TBM_SPAD BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_SPAD 0
#define arguments_BDK_TNS_TXQ_TBM_SPAD -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_SPAD "TNS_TXQ_TBM_SPAD"


/**
 * NCB32b - tns_txq_tbm_tail_ptr_ecc_log
 *
 * TBM tail pointer ECC error log.  Address is sticky on first error.  Re-armed
 * after reading
 */
typedef union bdk_tns_txq_tbm_tail_ptr_ecc_log {
	uint32_t u;
	struct bdk_tns_txq_tbm_tail_ptr_ecc_log_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_11_31              : 21;
		uint32_t ecc_err_addr                : 11; /**< R/W/H - -- */
#else
		uint32_t ecc_err_addr                : 11;
		uint32_t reserved_11_31              : 21;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_tail_ptr_ecc_log_s cn88xx; */
	/* struct bdk_tns_txq_tbm_tail_ptr_ecc_log_s cn88xxp1; */
} bdk_tns_txq_tbm_tail_ptr_ecc_log_t;

#define BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG_FUNC(void)
{
	return 0x000084207050C018ull;
}
#define typedef_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG bdk_tns_txq_tbm_tail_ptr_ecc_log_t
#define bustype_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG 0
#define arguments_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_TAIL_PTR_ECC_LOG "TNS_TXQ_TBM_TAIL_PTR_ECC_LOG"


/**
 * NCB32b - tns_txq_tbm_tail_ptr_mem#
 *
 * Queue Head pointer memory CPU access
 *
 */
typedef union bdk_tns_txq_tbm_tail_ptr_memx {
	uint32_t u;
	struct bdk_tns_txq_tbm_tail_ptr_memx_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t reserved_14_31              : 18;
		uint32_t data                        : 14; /**< R/W - -- */
#else
		uint32_t data                        : 14;
		uint32_t reserved_14_31              : 18;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_tail_ptr_memx_s cn88xx; */
	/* struct bdk_tns_txq_tbm_tail_ptr_memx_s cn88xxp1; */
} bdk_tns_txq_tbm_tail_ptr_memx_t;

static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(unsigned long param1) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(unsigned long param1)
{
	if (((param1 <= 2047)))
		return 0x0000842070508000ull + (param1 & 2047) * 0x4ull;
	csr_fatal("BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX", 1, param1, 0, 0, 0); /* No return */
}
#define typedef_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(...) bdk_tns_txq_tbm_tail_ptr_memx_t
#define bustype_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(...) BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(p1) (p1)
#define arguments_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(p1) (p1),-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_TAIL_PTR_MEMX(...) "TNS_TXQ_TBM_TAIL_PTR_MEMX"


/**
 * NCB32b - tns_txq_tbm_token_alloc_ct
 *
 * Counter of the number of tokens allocated by TBM.  Saturates at 32'hffffffff.
 * Read only, clear on read.
 */
typedef union bdk_tns_txq_tbm_token_alloc_ct {
	uint32_t u;
	struct bdk_tns_txq_tbm_token_alloc_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_token_alloc_ct_s cn88xx; */
	/* struct bdk_tns_txq_tbm_token_alloc_ct_s cn88xxp1; */
} bdk_tns_txq_tbm_token_alloc_ct_t;

#define BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT_FUNC(void)
{
	return 0x000084207050C038ull;
}
#define typedef_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT bdk_tns_txq_tbm_token_alloc_ct_t
#define bustype_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT 0
#define arguments_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_TOKEN_ALLOC_CT "TNS_TXQ_TBM_TOKEN_ALLOC_CT"


/**
 * NCB32b - tns_txq_tbm_token_free_ct
 *
 * Counter of the number of tokens freed back to TBM.  Saturates at 32'hffffffff.
 * Read only, clear on read.
 */
typedef union bdk_tns_txq_tbm_token_free_ct {
	uint32_t u;
	struct bdk_tns_txq_tbm_token_free_ct_s {
#if __BYTE_ORDER == __BIG_ENDIAN
		uint32_t count                       : 32; /**< R/W/H - -- */
#else
		uint32_t count                       : 32;
#endif
	} s;
	/* struct bdk_tns_txq_tbm_token_free_ct_s cn88xx; */
	/* struct bdk_tns_txq_tbm_token_free_ct_s cn88xxp1; */
} bdk_tns_txq_tbm_token_free_ct_t;

#define BDK_TNS_TXQ_TBM_TOKEN_FREE_CT BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC()
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC(void) __attribute__ ((pure, always_inline));
static inline uint64_t BDK_TNS_TXQ_TBM_TOKEN_FREE_CT_FUNC(void)
{
	return 0x000084207050C03Cull;
}
#define typedef_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT bdk_tns_txq_tbm_token_free_ct_t
#define bustype_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT BDK_CSR_TYPE_NCB32b
#define busnum_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT 0
#define arguments_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT -1,-1,-1,-1
#define basename_BDK_TNS_TXQ_TBM_TOKEN_FREE_CT "TNS_TXQ_TBM_TOKEN_FREE_CT"

#endif /* __BDK_CSRS_TNS_SST__ */
