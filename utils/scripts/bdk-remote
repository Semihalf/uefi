#!/usr/bin/env bdk-lua

--
-- Lua script supplying command line access to a remtoe Octeon
-- Run without arguments for help
--

require("strict")
require("utils")

local remote = {}

function remote.csr(args)
    -- csr <csr>
    -- csr <csr> <value>
    -- csr <csr> <value> decode
    assert(args[1] == "csr")
    if #args == 2 then
        oremote.decode_csr(args[2])
    elseif #args == 3 then
        oremote.write_csr(args[2], args[3])
    elseif #args == 4 then
        assert(args[4] == "decode")
        oremote.decode_csr(args[2], args[3])
    else
        error("Invalid number of args")
    end
end

function remote.boot(args)
    -- boot <filename>
    assert(args[1] == "boot")
    local f = io.open(args[2], "r")
    assert(f)
    local d = f:read("*a")
    f:close()
    oremote.reset(1)
    oremote.write_mem(0, d)
    oremote.write_register(0, 0x100 + 24*8, 0xffffffff80000000)
    oremote.start_cores(1)
end

function remote.reset(args)
    -- boot <filename>
    assert(args[1] == "reset")
    oremote.reset(0)
end

function remote.core(args)
    -- core <core>
    assert(args[1] == "core")
    local state = oremote.get_core_state(args[2])
    -- FIXME: pretty output
    pprint(state)
end

function remote.reg(args)
    -- reg <core> <register>
    -- reg <core> <register> <value>
    assert(args[1] == "reg")
    if #args == 3 then
        local v = oremote.read_register(args[2], args[3])
        printf("Core %d, register %s: hex 0x%016x decimal %d\n", args[2], args[3], v, v)
    elseif #args == 4 then
        oremote.write_register(args[2], args[3], args[4])
    else
        error("Invalid number of args")
    end
end

function remote.mem(args)
    -- mem <address>
    -- mem <width> <address>
    -- mem <width> <address> <value>
    -- mem load <filename> <address>
    -- mem save <filename> <address> <length>
    assert(args[1] == "mem")
    if args[2] == "load" then
        assert(#args == 4)
        local f = io.open(args[3], "r")
        assert(f)
        local d = f:read("*a")
        f:close()
        oremote.write_mem(args[4], d)
    elseif args[2] == "save" then
        assert(#args == 5)
        local f = io.open(args[3], "w")
        assert(f)
        local d = oremote.read_mem(args[4], args[5])
        f:write(d)
        f:close()
    elseif #args == 2 then
        local v = oremote.read_mem64(args[2])
        printf("Address 0x%016x = 0x%016x\n", args[2], v)
    elseif #args == 3 then
        if args[2] == 8 then
            local v = oremote.read_mem64(args[3])
            printf("Address 0x%016x = 0x%016x\n", args[3], v)
        elseif args[2] == 4 then
            local v = oremote.read_mem32(args[3])
            printf("Address 0x%016x = 0x%08x\n", args[3], v)
        elseif args[2] == 2 then
            local v = oremote.read_mem16(args[3])
            printf("Address 0x%016x = 0x%04x\n", args[3], v)
        elseif args[2] == 1 then
            local v = oremote.read_mem(args[3], 1)
            v = v:byte()
            printf("Address 0x%016x = 0x%02x\n", args[3], v)
        else
            error("Illegal width")
        end
    elseif #args == 4 then
        if args[2] == 8 then
            oremote.write_mem64(args[3], args[4])
        elseif args[2] == 4 then
            oremote.write_mem32(args[3], args[4])
        elseif args[2] == 2 then
            oremote.write_mem16(args[3], args[4])
        elseif args[2] == 1 then
            oremote.write_mem(args[3], string.char(args[4]))
        else
            error("Illegal width")
        end
    else
        error("Invalid number of args")
    end
end

function remote.profile(args)
    -- profile
    -- profile <coremask>
    local coremask = -1
    assert(args[1] == "profile")
    if #args == 1 then
        -- Do nothing
    elseif #args == 2 then
        coremask = args[2]
    else
        error("Invalid number of args")
    end
    local num_cores = oremote.get_num_cores()
    local profile_data = {}
    local show_time = os.time() + 5
    while true do
        local sample = oremote.get_sample(coremask)
        for core, pc in ipairs(sample) do
            if not profile_data[pc] then
                profile_data[pc] = {}
                for core = 1, 64 do
                    profile_data[pc][core] = 0
                end
            end
            profile_data[pc][core] = profile_data[pc][core] + 1
        end
        if os.time() > show_time then
            for _,pc in ipairs(table.sorted_keys(profile_data)) do
                printf("0x%016x:", pc)
                for core = 1, num_cores do
                    printf(" %d", profile_data[pc][core])
                end
                printf("\n")
            end
            printf("\n")
            profile_data = {}
            show_time = os.time() + 5
        end
    end
end

function remote.help(args)
    assert(args[1] == "help")
    local message =
[[
bdk-remote:
    csr <csr>
        Read the named CSR and decode it.
    csr <csr> <value>
        Write the named CSR.
    csr <csr> <value> decode
        Decode <value> as if it were the named CSR.

    boot <filename>
        Boot <filename> on Octeon.
    reset
        Reset Octeon.

    core <core>
        Dump all CPU registers, COP0, and TLB entries for <core>.

    reg <core> <register>
        Read CPU <register> for <core>.
    reg <core> <register> <value>
        Write <value> to CPU <register> for <core>.

    mem <address>
        Read eight bytes from <address>.
    mem <width> <address>
        Read <width> bytes from <address>.
    mem <width> <address> <value>
        Write <value> as <width> bytes to <address>.
    mem load <filename> <address>
        Load <filename> to <address>.
    mem save <filename> <address> <length>
        Save <length> bytes as <address> to <filename>.

    profile
        Profile all cores.
    profile <coremask>
        Profile cores in the supplied <coremask>.

    help
        Display this help.

Paramter descriptions:
    <csr>
        A name of a CSR, such as CIU_FUSE or CIU_INTX_SUM0(0).
    <value>
        A numeric value specified in either decimal or hexidecimal.
    <filename>
        Standard unix format file name.
    <core>
        Octeon CPU core number, startign at zero.
    <register>
        One of the following CPU register names.
            TBD
    <address>
        An Octeon physical memory address specified in either decimal or
        hexidecimal.
    <width>
        A byte width. Must be 8, 4, 2, or 1.
    <coremask>
        A decimal or hexidecimal number representing CPU cores. Each set bit
        represents a single CPU core. For example, 0x2f represents cores 0-3
        and 5.
]]
    print(message)
end

local function parse_args()
    local formats = {
        "csr <csr>",
        "csr <csr> <value>",
        "csr <csr> <value> decode",
        "boot <filename>",
        "reset",
        "core <core>",
        "reg <core> <register>",
        "reg <core> <register> <value>",
        "mem <address>",
        "mem <width> <address>",
        "mem <width> <address> <value>",
        "mem load <filename> <address>",
        "mem save <filename> <address> <length>",
        "profile",
        "profile <coremask>",
        "help"
    }

    for _,format in ipairs(formats) do
        local parsed = {}
        local index = 1
        for word in format:gmatch("%g+") do
            if index > #arg then
                -- Arguments are too short
                index = -1
                break
            end
            local n = tonumber(arg[index])
            if word == "<csr>" then
                table.insert(parsed, arg[index]:lower())
            elseif word == "<value>" then
                if n == nil then
                    -- Illegal number
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == "<filename>" then
                table.insert(parsed, arg[index])
            elseif word == "<core>" then
                if (n < 0) or (n > 64) then
                    -- Illegal core number
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == "<register>" then
                table.insert(parsed, arg[index]:lower())
            elseif word == "<address>" then
                if n == nil then
                    -- Illegal number
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == "<width>" then
                if (n ~= 1) and (n ~= 2) and (n ~= 4) and (n ~= 8) then
                    -- Illegal width
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == "<coremask>" then
                if n == nil then
                    -- Illegal number
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == "<length>" then
                if n < 1 then
                    -- Illegal length
                    index = -1
                    break
                end
                table.insert(parsed, n)
            elseif word == arg[index]:lower() then
                table.insert(parsed, word)
            else
                -- Illegal word
                index = -1
                break
            end
            -- Parsed correctly, move to next word
            index = index + 1
        end
        -- Return the arguments if all words parsed
        if index == #arg + 1 then
            return parsed
        end
    end
    error("Invalid command line")
end

local function main()
    local status, my_args = pcall(parse_args)
    if status then
        oremote.open()
        remote[my_args[1]](my_args)
        oremote.close()
    else
        print("ERROR:", my_args)
        remote.help({"help"})
    end
end

main()
