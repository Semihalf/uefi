
Bringup and Diagnostic Kit
==========================

Overview
--------

This directory contains the "Bringup and Diagnostic Kit" (BDK).  These
files support chip bringup, board bringup, and the creation of
diagnostics. The basic layout is as follows:

.docs/
	All documentation for the BDK.

.libbdk-arch/
	Library and C files related to Octeon II architecture. This
	contains the minimal code needed to write any code for Octeon II
	with the minimal amount of abstractions as possible. This contains
	CSR and assembly defines and access functions . Higher level APIs
	are not part of this library.

.libbdk-dram/
	Library and C files related to Octeon II DRAM initialization. These
	files are meant to be shared by all loaders and early diagnostics
	that need to setup DRAM.

.libbdk-hal/
	Library and C files providing a API for interfacing with Octeon II
	hardware. This is similar to the "executive" in the Octeon SDK.

.libbdk-lua/
	Libraries for accessing Octeon hardware from the Lua scripting language.

.libbdk-os/
	System call support and initialization code required for the C library
	to function.

.libbdk/
	This is a combined library and single header file for using all of
	the libbdk-* features. Normally, this contains the only C header
	and library that applications should ever reference. Make sure bdk.h
	is the very first line in C files to make sure the precompiled header
	works properly.

.libc/
	The Newlib C library configured for use with the BDK. Most all C
	standard library functions are supported.

.liblua/
	The Lua scripting language library http://www.lua.org/.

.lua/
	The main BDK application that starts a menu driven Lua environment.

.rom/
	All files in here are included into BDK applications for access using
	standard filesystem calls.


Lua Scripting
-------------

The BDK contains the scripting environment Lua.  Lua allows you to
write simple scripts to easily control Octeon tests and perform remote
operations.  Take a look at the link:lua/readme.html[documentation for
Lua] for more information about the Lua language.  Many BDK functions
can be called from Lua.  Under the Lua environment, a module *octeon*
is supplied.

TIP: The link:lua/contents.html[Lua Reference] can be useful.


Executing Lua on the Host
~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK supplies the executable *bdk-lua* for scripting on a host PC.
This should be used for the shell to execute Lua scripts for remote
controlling Octeon eithe on the command line, or through scripts.

.Command line
[source,sh]
----
$ bdk-lua script.lua
----

.In scripts
[source,lua]
----
#!/usr/bin/env bdk-lua
print("Hello World!")
----

.Usage of *bdk-lua*
----
usage: bdk-lua [options] [script [args]]
Available options are:
  -e stat  execute string 'stat'
  -i       enter interactive mode after executing 'script'
  -l name  require library 'name'
  -v       show version information
  --       stop handling options
  -        stop handling options and execute stdin
----

.Printing the functions in a module
----
$ bdk-lua -l utils -e "pprint(table)"
----
.Output of *table* print
----
{
    concat = function
    foreach = function
    foreachi = function
    getn = function
    insert = function
    maxn = function
    pack = function
    remove = function
    sort = function
    sorted_keys = function
    sorted_values = function
    unpack = function
}
----

Executing Lua on the Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~

TBD

.Booting using Uboot
----
Octeon ebb6300# dhcp
Octeon ebb6300# setenv serverip 192.168.162.148
Octeon ebb6300# tftpboot 0x400000 lua.bin
Octeon ebb6300# go 0x400000
----


Interactive Lua on the Octeon Target
------------------------------------

TBD

.Main Menu
----
Bring and Diagnostic Kit (BDK)
Setting up global data
Clearing BSS
Transfering to thread scheduler
Performing common initialization
Enabling hardware flow control on UART0
Switching to main
Lua 5.2.0 (work5)  Copyright (C) 1994-2010 Lua.org, PUC-Rio

Octeon Bringup and Diagnostic Kit
Copyright (C) 2010-2011 Cavium Networks

1       File operations
2       Flash operations
3       DDR memory options
4       HFA memory options
5       Interactive Lua prompt
6       Start remote call server
7       Traffic Gen
8       Reboot
(0INS)>
----

Line Editing
~~~~~~~~~~~~

Any prompt ending with `(0INS)>` supports full line editing and
history.  Line editing can also be used for any input using the
*octeon.readline()* function.

* Many vi style modes are available for command and history navigation.
* Use ARROW KEYS, HOME, END or ESC-h,ESC-j,ESC-k,ESC-l,ESC-0,ESC-$,ESC-w,ESC-b, or ESC-fx for navigation.
* Use TAB for commmand completion, multiple to cycle, or CTRL-D for a list of possible commands.
* Use ESC-i,ESC-A,ESC-a,ESC-c for insert mode, ESC-R,ESC-r for overwrite mode (behavior like vi).
* Use INSERT to toggle insert/overwrite mode, DELETE to delete, F1 for help.
* Use !!, !<num> or !<string> to repeat previous commands in the history.
* Use ::, :<num> or :<string> to recall previous commands in the history to current.
* Use ?<string>, /<string>, ESC-?<string>,ESC-/<string>,ESC-n,ESC-N to also recall to current.
* Use CTRL-l erase the screen, ESC-D to clear the rest of the current line.
* Use ESC-d<movement> to delete, ESC-~ to change case, ESC-u to undo (one level).
* See the vi man page for more info on the operation of various commands.


Lua Modules
-----------

Lua functions are organized in terms of packages. Each package implements
many functions related to a specific task. Octeon's Lua contains the default
Lua packages along with some new packages specifically designed for remote
control and testing of Octeon based hardware.

.Lua Base Modules
[options="header"]
|==========================================================================
|Standard Lua Module	|Lua documentation
|Basic functions	|link:lua/manual.html#6.1[]
|coroutine		|link:lua/manual.html#6.2[]
|package		|link:lua/manual.html#6.3[]
|string			|link:lua/manual.html#6.4[]
|table			|link:lua/manual.html#6.5[]
|math			|link:lua/manual.html#6.6[]
|bit32			|link:lua/manual.html#6.7[]
|io			|link:lua/manual.html#6.8[]
|os			|link:lua/manual.html#6.9[]
|debug			|link:lua/manual.html#6.10[]
|==========================================================================

Host Modules Specific to Octeon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on a
host PC.

oremote
^^^^^^^

The *oremote* module provides functions for remotely controlling an
Octeon over PCI or EJTAG. This allows Lua scripts to remotely probe and
boot Octeon. Below is a list of the functions supported.

oremote.open(protocol, debug)::
 * protocol = Remote protocol or nil
 * debug = Debug level or nil
 * No return value

oremote.close()::
 * No return value

oremote.read_csr(csr)::
 * csr = Name of CSR as a string
 * Return csr value as a number

oremote.write_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number
 * No return value

oremote.decode_csr(name, value)::
 * name = Name of CSR as a string
 * value = Value of CSR as a number. If nil, a read_csr is done
 * No return value. Output goes to stdout

oremote.read_mem(address, length)::
 * address = Physical address to read
 * length = Number of bytes to read
 * Returns string of length

oremote.write_mem(address, bytes)::
 * address = physical address to write
 * bytes = string of bytes to write
 * No return value

oremote.get_model()::
 * Returns Processor ID register as number

oremote.start_cores(mask)::
 * mask = Bitmask of cores to start
 * No return value

oremote.stop_cores(mask)::
 * mask = Bitmask of cores to stop
 * No return value

oremote.get_num_cores()::
 * Returns the number of cores as a number

oremote.get_running_cores()::
 * Returns the bitmask of cores that are running

oremote.get_core_state(core)::
 * core = Core state to get, starting at 0
 * Returns table
 * table[1][1-256] = Normal registers
 * table[2][1-256] = COP0 reg * 8 + sel
 * table[3][1-128][1-4] = TLB

oremote.set_core_state(core, state)::
 * core = Core state to set, starting at 0
 * state = table of format from get_core_state
 * No return value

oremote.read_register(core, register)::
 * core = Core starting at 0
 * register = register number to get
 * Return register as number

oremote.write_register(core, register, value)::
 * core = Core starting at 0
 * register = register number to set
 * value = Register value
 * No return value

oremote.reset(stop_cores)::
 * stop_cores = Cores should stop after reset
 * No return value

oremote.get_sample(mask)::
 * mask = Bitmask of cores to get samples for
 * Return table of PC values indexed by core num+1

oremote.write_mem16(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem32(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.write_mem64(address, data)::
 * address = Physical address
 * data = data to write
 * No return value

oremote.read_mem16(address)::
 * address = Physical address
 * Return data

oremote.read_mem32(address)::
 * address = Physical address
 * Return data

oremote.read_mem64(address)::
 * address = Physical address
 * Return data

Target modules specific to Octeon
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Cavium Networks provides some Lua modules specific for running Lua on
a target Octeon.

octeon
^^^^^^

octeon.is_model(model)::

Returns true if the current chip matches the supplied model.
* model = One of the `octeon.CN*` constants.
** octeon.CN63XX
** octeon.CN63XXP1
** octeon.CN63XXP2
** octeon.CN68XX
** octeon.CN68XXP1

octeon.BDK_CONFIG_*::

Constants for use with octeon.c.bdk_config_get() and
octeon.c.bdk_config_set().

octeon.csr()::

Returns an iterator that iterates through the possible CSR names.
+
.List all CSRs from Lua
[source,lua]
----
for name in octeon.csr()
do
    print (name)
end
----

octeon.csr.NAME.read()::

Read the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* Returns the CSR value

octeon.csr.NAME.write(value)::

Write the value of the CSR `NAME`.  `NAME` is name such as "CIU_FUSE"
or "CIU_INTX_SUM0(0)".
* value = Value to write
* No return value

octeon.c.*::

Many low level C functions are directly exported through this
interface.  No argument checking is performed on these functions, so
it is very important to get the arguments correct.  Errors may crash
the system.

octeon.readline(prompt, completion, timeout_us)::
Prompt the user for input with full line editing and history. Useful for
creating interactive command lines and menus.
* prompt = Prompt to show the user
* completion = Should be nil for now (unsupported)
* timeout_us = Microseconds to wait for input, of zero for no timeout.


bdktrafficgen
^^^^^^^^^^^^^

The module *bdktrafficgen* allows Lua to generate and receive etherent
traffic on all chip interfaces. A user friendly interactive interface is
available through *trafficgen.lua*.

bdktrafficgen.port_get(index)::
* index = 0 - .., sequencial through ports.
* Return port_info_t or nil

bdktrafficgen.port_add(set, pinfo)::
* set = port_set_t to add port too.
* pinfo = port_info_t returned from *bdktrafficgen.port_get()*.
* No return value

bdktrafficgen.do_clear(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.do_reset(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.do_update(bool do_clear)::
* do_clear = boolean whether status should be cleared during update.
* Return zero on success, negative on failure.

bdktrafficgen.do_transmit(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return zero on success, negative on failure.

bdktrafficgen.is_transmitting(range)::
* range = port_set_t created with *bdktrafficgen.port_add()*.
* Return true if any ports in hte range are transmitting.

.bdktrafficgen.port_info_t fields
----
	string name
	port_setup_t setup
	port_stats_t stats
----

.bdktrafficgen.port_stats_t fields
----
    number    tx_packets
    number    tx_octets
    number    tx_packets_total
    number    tx_octets_total
    number    tx_bits

    number    rx_packets
    number    rx_octets
    number    rx_packets_total
    number    rx_octets_total
    number    rx_dropped_octets
    number    rx_dropped_packets
    number    rx_errors
    number    rx_bits
    number    rx_backpressure
    number    rx_validation_errors
----

.bdktrafficgen.packet_type_t enumeration
----
    PACKET_TYPE_IPV4_UDP
    PACKET_TYPE_IPV6_UDP
    PACKET_TYPE_IPV4_TCP
    PACKET_TYPE_IPV6_TCP
    PACKET_TYPE_802_3_PAUSE
    PACKET_TYPE_CBFC_PAUSE
    PACKET_TYPE_CJPAT
----

.bdktrafficgen.payload_t enumeration
----
    DATA_TYPE_ABC=0
    DATA_TYPE_ZERO
    DATA_TYPE_ONE
    DATA_TYPE_INC
    DATA_TYPE_DEC
    DATA_TYPE_RAND
----

.bdktrafficgen.port_setup_t fields
----
    int                     output_rate
    bool                    output_rate_is_mbps
    bool                    output_enable
    int                     output_packet_size
    number                  output_count
    trafficgen_packet_type_t output_packet_type
    trafficgen_payload_t    output_packet_payload
    number                  src_mac
    int32_t                 src_mac_inc
    number                  src_mac_min
    number                  src_mac_max
    number                  dest_mac
    int32_t                 dest_mac_inc
    number                  dest_mac_min
    number                  dest_mac_max
    number                  vlan_size
    uint8_t                 vlan[8]
    uint32_t                src_ip
    int32_t                 src_ip_inc
    uint32_t                src_ip_min
    uint32_t                src_ip_max
    uint32_t                dest_ip
    int32_t                 dest_ip_inc
    uint32_t                dest_ip_min
    uint32_t                dest_ip_max
    uint32_t                ip_tos
    uint16_t                src_port
    int16_t                 src_port_inc
    uint16_t                src_port_min
    uint16_t                src_port_max
    uint16_t                dest_port
    int16_t                 dest_port_inc
    uint16_t                dest_port_min
    uint16_t                dest_port_max
    bool                    do_checksum
    bool                    display_packet
    bool                    validate
    bdk_srio_tx_message_header_t srio
----

bdktrafficgen.port_set_t::

This is a opaque object that represents a set of port_info_t objects.
Use *bdktrafficgen.port_add()* and *bdktrafficgen.port_get()* to build
this.


Source based modules available on both Host and Target
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Any modules written in pure Lua can be used on both the host and
target.  These modules are loaded using the standard *require()*
function call in Lua.  Here is a list of these extra modules provided
by Cavium Networks.

menu
^^^^

menu.show(choices)::
Show a menu to the user and prompt for a choice.
* choices = Table array of menu strings
* Return the selection number

rpc
^^^

This module allows you to make remote procedure calls to Lua.  All
target Lua functions and data can be accessed by a remote host.

.Example RPC client
[source,lua]
----
if #arg < 1 then
    print("You must specify the file to do RPC over. Example /dev/ttyS0")
    return
end

rpc = require("rpc")
r = rpc.connect(arg[1], arg[2])

for k in r.octeon.csr() do
    print(k)
end

print (r._VERSION)
r.foo = {1, 2, 3 ,4}
print("Length of new table:", #r.foo)
r.print("Hello World")
r.print(1, 2, nil, "foo", {foo=1}, true, false)
print("Octeon RCLK:", r.octeon.c.bdk_clock_get_rate(0))
print("Octeon SCLK:", r.octeon.c.bdk_clock_get_rate(1))
print("Octeon CIU_FUSE:", r.octeon.csr.ciu_fuse.read())
print("Is CN63XX?", r.octeon.is_model(r.octeon.CN63XX))
print("Is CN68XX?", r.octeon.is_model(r.octeon.CN68XX))
print("Lua mem:", r.collectgarbage("count"))
print("C mem:", r.octeon.get_sbrk() / 1024)
----

TIP: Lua garbage collection can cause issues with RPC.  The host
running the RPC client normally has lots more memory than the Octeon
RPC target.  This can cause Lua to not garbage collect old RPC
objects.  Since the RPC server can't free objects until the client
releases all references, this can cause the client to run out of
memory.  Simply calling *collectgarbage()* in the client periodically
can solve this issue.

rpc.connect(instream, outstream)::
Create a RPC connection to a remote Octeon.
* instream = Lua IO stream for input, or a filename to open. (Example: `/dev/ttyS0`)
* outstream = Lua IO stream for output, or a filename to open. (Example: `/dev/ttyS0`). If nil, then instream is used.
* Return value is an RPC object to make calls with.

rpc.serve(instream, outstream)::
Wait for RPC commands and execute them.
* instream = Lua IO stream for input, or a filename to open. (Example: `/dev/ttyS0`)
* outstream = Lua IO stream for output, or a filename to open. (Example: `/dev/ttyS0`). If nil, then instream is used.
* No return value.

strict
^^^^^^

Cavium Networks provides the *strict* module written by Thomas Lauer
to help in writing scripts.  By default Lua considers any new variable
names to be global.  This can make typos and programming errors very
difficult to find.  The *strict* module changes this behavior so that
all variables must be specifically defined.  Cavium Networks recommends
this to promote more robust script development.  Below is the original
description from Thomas Lauer.

----
* Lua Strict by Thomas Lauer
* http://thomaslauer.com/comp/LuaStrict

Strict implements a somewhat stricter handling of global variables than
Lua. There are two basic modes: weak and strong. In the weak mode you
don't need to declare a global but you'd have to initialize it in the
main part of your program (i.e not inside a function).

In strong mode anything not formally declared  (including non-local
functions) gets the whip.

See the examples for more on how to use the module.

Anything wrong or not working? An idea how to make this better? Please
send comments to thomas.lauer@gmail.com or visit my contact page:
http://thomaslauer.com/start/Contact.
----

utils
^^^^^

The *utils* module is a set of Lua functions written by Cavium
Networks to ease writing scripts that deal with Octeon's registers.
Below is a list of the functions provided.

printf::

C style printf function.  printf("format", ...).  See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.

str = "format" % {...}::

Python style string formatting.See
link:lua/manual.html#pdf-string.format[string.format] for format
specification rules.
* str = "format" % value
* str = "format" % {...}

pprint(...)::

Pretty print and data in a human readable format.  Tables are printed
recursively.

table.sorted_keys(table)::

Return a table's keys in sorted order.

table.sorted_values(table)::

Return a table's values in sorted order.

hexdump(file_handle)::

Hex dump a file.  "file_handle" is a file handle, not a name.  You can
do a seek before calling this to skip the start of the file.


Lua Startup Sequence on Octeon
------------------------------

The following details which Lua scripts are executed on Octeon during
boot of the BDK.

. bdk-boot.bin binary boots.

. */rom/init.lua* is executed.
+
[source,lua]
----
include::../rom/init.lua[]
----

. */rom/main.lua* is executed.
+
[source,lua]
----
include::../rom/main.lua[]
----

. Board specific file is loaded.
+
[source,lua]
----
include::../rom/board-ebb6300.lua[]
----


