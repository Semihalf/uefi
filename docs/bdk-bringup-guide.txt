
Board Validation with the Bringup and Diagnostic Kit
====================================================

Overview
--------

This document is a step by step procedure for verifying proper
hardware functionality of boards based on OCTEON processors.  The
target audience is either board designers or validation engineers
charged with the task of verifying hardware. By following this guide,
the following goals should be met.

.Final Goals
* The OCTEON processor booted and running software.
* All packet interfaces verified as operational.
* Miscellaneous I/O busses verified as operational, such as TWSI and SMI/MDIO.
* If applicable, PCIe as a root complex verified as operational.
* If applicable, SRIO verified as operational.
* DRAM configured and tested.
* Board ready to be handed to software for further development.

.Board Block Diagram

Below is a high level block diagram for a generic board.  The board
being tested will have connections similar to the diagram.

image::board_block_diagram.png[Board block diagram]

Step 1 - Minimum Prerequisites
------------------------------

Certain minimum requirements must be met before progress can continue.
OCTEON must progress through the reset sequence documented in the
hardware manual. OCTEON's UART0 must be connected to a serial terminal
in order to monitor the boot progress.

* OCTEON reference clock must be at 50 Mhz.
* OCTEON reset sequence must follow the hardware reference manual.
* UART0 connected to a serial terminal. Baud rate of 115200, no parity, one stop bit.
* If booting from flash, a NOR flash must be connected to OCTEON's bootbus.

Step 2 - Boot the BDK
---------------------

Burn bdk-boot.bin to NOR flash
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use a flash programmer to burn the image *bdk-boot.bin* to the
beginning of the NOR flash.  The first byte of *bdk-boot.bin* should
be at address zero, the second at address one, etc.

Boot over PCIe
~~~~~~~~~~~~~~

The target board must be connected as a PCIe endpoint to a PC system
running Linux.

. Apply any additional power need for the target board.
. Boot the PCIe host PC into Linux.
. Install the BDK on the PC by following the instructions in link:bdk.html[BDK documentation].
. Issue the following shell commands.

[source, sh]
----
$ export OCTEON_REMOTE_PROTOCOL=pci
$ bdk-remote boot target-bin/bdk-boot.bin
----

Boot over EJTAG
~~~~~~~~~~~~~~~

The BDK has been tested with multiple EJTAG probes.  The best
supported probe is the Macraigor mpDemon.  The following section
details the process of booting the BDK using the mpDemon. Other EJTAG
probes should be similar.

Get the latest mpDemon Firmware
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Firmware and software updates are available for free from the Macraigor
website. Be sure the software installed meets the minimum version lists
below.

----
Model		Minimum Firmware
-----		----------------
mpDemon		3.0.3.9
----

Macraigor website with details about the mpDemon::

link:http://www.macraigor.com/mpDemon.htm[]

Link to the latest firmware for the mpDemon::

link:http://www.macraigor.com/downloads/mpDemon_Update.zip[]


Setting up a Macraigor mpDemon for use with Octeon
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Connect to the 9 pin serial port on the mpDemon with a straight through
serial cable. Using a baud rate of 19200, no parity, 8 bits, and 1 stop bit,
you should get the following menu after hitting return:

----
    Macraigor Systems mpDemon(tm) version 3.0.3.9

Licenses           :
API Baud Rate      : 115200
Use DHCP?          : Yes
DHCP Hostname      : mpdemon1
TCP/IP Address     : 192.168.162.166
       Mask        : 255.255.255.  0
       Gateway     : 192.168.162.  1
MAC Address        : 00.60.bf.01.01.b7
API TCP/IP Port    : 1000
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=8893 <- TDI

   mpDemon Command Menu:

  B - Set Serial API baud Rate             D - Set DHCP option
  N - Set DHCP hostName
  O - Set OCDREMOTE Configuration          T - Test OCDREMOTE Configuration
  L - Update License Code(s)               C - Set Macraigor API TCP/IP port
  P - Ping TCP/IP address                  J - Analyze JTAG Scan Chain
  E - Display Error Log                    R - Reboot mpDemon
  Type Command (<Enter> will refresh screen) ->
----

. Choose "D" to enable DHCP for the probe.
+
----
Type Command (<Enter> will refresh screen) -> D
Use DHCP? (Y/N) ->y
----

. Choose "N" to set the hostname that will be used during DHCP to name the
device. The following example configures the probe to use the name of
"mpdemon1".
+
----
Type Command (<Enter> will refresh screen) -> N
DHCP hostname ->mpdemon1

MUST REBOOT mpDEMON FOR DHCP CHANGE TO TAKE EFFECT
----

. Choose "O" to configure the builtin GDB remote stub. This is used to allow
interactive debugging using the GDB remote protocol. Again, the following
example is from a CN63XX.
+
----
  Type Command (<Enter> will refresh screen) -> O

Initial JTAG speed (1 - 8) [1] ->1
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=
8893 <- TDI
Do you want to change the JTAG chain [no]? y
Number of Devices in Scan Chain (0 - 16) [6] ->6
Device List:
            ...
            Cavium 64-bit Family:
              301x CN300x CN3020 CN31xx CN36xx
              CN38xx CN502X CN52xx CN56xx CN58xx
              CN63xx CN68xx N3 O1P O2P
              O9N O52 O56 O5020
            ...

Device1 [CN63xx] --> CN63xx
TCP/IP port number : [8888] ->

Device2 [CN63xx] --> CN63xx
TCP/IP port number : [8889] ->

Device3 [CN63xx] --> CN63xx
TCP/IP port number : [8890] ->

Device4 [CN63xx] --> CN63xx
TCP/IP port number : [8891] ->

Device5 [CN63xx] --> CN63xx
TCP/IP port number : [8892] ->

Device6 [CN63xx] --> CN63xx
TCP/IP port number : [8893] ->
   Reboot mpDemon to run with new parameters
   hit any key to continue
----

. At this time, configuration is complete. Reboot the probe with the "R" command
and view the new configuration.
+
----
  Type Command (<Enter> will refresh screen) -> r
Are you sure you want to reboot? y
Rebooting...
OK

    Macraigor Systems mpDemon(tm) version 3.0.3.9

Licenses           :
API Baud Rate      : 115200
Use DHCP?          : Yes
DHCP Hostname      : mpdemon1
TCP/IP Address     : 192.168.162. 53
       Mask        : 255.255.255.  0
       Gateway     : 192.168.162.  1
MAC Address        : 00.60.bf.01.01.b7
API TCP/IP Port    : 1000
OCDREMOTE          : JTAG speed 1
                   : JTAG TDO <- [1]CN63xx=8888 [2]CN63xx=8889 [3]CN63xx=8890 [4]CN63xx=8891 [5]CN63xx=8892 [6]CN63xx=
8893 <- TDI

   mpDemon Command Menu:

  B - Set Serial API baud Rate             D - Set DHCP option
  N - Set DHCP hostName
  O - Set OCDREMOTE Configuration          T - Test OCDREMOTE Configuration
  L - Update License Code(s)               C - Set Macraigor API TCP/IP port
  P - Ping TCP/IP address                  J - Analyze JTAG Scan Chain
  E - Display Error Log                    R - Reboot mpDemon
  Type Command (<Enter> will refresh screen) ->
----


Configuring the BDK Host tools to use the mpDemon
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The environment variable *OCTEON_REMOTE_PROTOCOL* controls how the
*bdk-remote* utility communicates with OCTEON.  Tot use the native
capabilities of the Macraigor mpDemon, this variable should be set as
follows:

[source, sh]
----
export OCTEON_REMOTE_PROTOCOL=macraigor:mpdemon1,1000,1
----

The different parts of this environment variable are defined below.

macraigor::

This is the EJTAG protocol being used. For the mpdemon, this is the best
protocol.

mpdemon1::

This is the hostname of the mpDemon.  You can either use a name or
IPv4 address in X.X.X.X format.

1000::

This is the TCP/IP port number used to connect to the mpDemon.  This
matches the "API TCP/IP Port" configuration of the probe.  The default
port is '1000' for the mpDemon.

1::

This is the EJTAG clock speed divider.  Generally the fastest speed of
'1' is best.  If you have trouble, try increasing this value to '2' or
'3'.  If trouble persists, try '8'.

Booting the BDK
^^^^^^^^^^^^^^^

Now that the mpDemon is configured and the *OCTEON_REMOTE_PROTOCOL*
environment variable is set, the BDK can be booted on the board.  Issue
the following *bdk-remote* command.

[source, sh]
----
bdk-remote boot target-bin/bdk-boot.bin
----

Successful Booting
~~~~~~~~~~~~~~~~~~

If everything went well, the following output should be visible in the
serial terminal.  If booting did not succeed, re-check step 1.

.Example Successful Boot
----
include::boot_messages.capture[]
include::main_menu.capture[]
Menu choice: (0INS)>
----


Step 3 - Configure the Board
----------------------------

Before detailed testing begins, some parameters need to be set in order
to customize the BDK for the board.  For ethernet tests, covered
later, the PHY addresses and MAC address needs to be set.

CAUTION: Configuration options are *not saved* and will be lost on
reset.  Configuration needs to be redone after every boot.

.Sample Configuration Menu from CN68XX
----
include::configure_menu.capture[]
----

Configure the MAC Address
~~~~~~~~~~~~~~~~~~~~~~~~~

The BDK creates a semi random MAC address based on internal chip
parameters.  This default is normally good enough for lab testing, but
it should be replaced before the board is used on a large LAN.  The
BDK default starts with Cavium's OUI with the locally administered bit
set, '02:0f:b7'.  The next three bytes are derived based on internal
chip data.

Configure PHY Addresses
~~~~~~~~~~~~~~~~~~~~~~~

RGMII, MII, and SGMII ports on the board should have ethernet PHYs
connected to OCTEON using SMI/MDIO.  Before these ports can be used,
the SMI/MDIO address for each PHY needs to be programmed.  Choose the menu option
for each RGMII, MII, and SGMII port. When prompted, enter the PHY address encoded as follows:

----
Address = <SMI/MDIO address> + 256 * <OCTEON SMI/MDIO bus>
----

SMI/MDIO address::

This is the address of the PHY as configured by strapping on the board.

OCTEON SMI/MDIO bus::

This is the number of the SMI/MDIO bus used on Octeon.

TIP: If the PHY addresses are unknown, the scan utility in the
SMI/MDIO menu can be useful.  It will display all the devices OCTEON
can automatically find.


Step 4 - Test TWSI
------------------

The BDK support probing TWSI (I2C) using basic operations.  Testing
general connectivity is done using an automated device address scan.
Further details about individual TWSI devices can be probed using
manual reads and writes.  The first step is to choose an OCTEON TWSI
bus for testing.  This is done in the main TWSI menu.

.Sample TWSI Main Menu
----
include::twsi_main_menu.capture[]
----

Once a bus is selected, the TWSI sub menu allows operations on the bus.

.Sample TWSI Sub Menu
----
include::twsi_sub_menu.capture[]
----

Initialize TWSI
~~~~~~~~~~~~~~~

Perform one time bus initialization of the OCTEON TWSI controller.
This needs to be done once before any other transactions are issued.


Scan TWSI
~~~~~~~~~

Scan all valid TWSI addresses looking for devices.  Each device that
responds is displayed in a list.  This can be useful way of
determining what devices are available on a board.  Below is sample
scan from a EBB6800 board.

.TWSI Bus 0 scan on an EBB6800
----
TWSI0: Scanning bus...
TWSI0: Address   0 (0x00) responded
TWSI0: Address   1 (0x01) responded
TWSI0: Address   2 (0x02) responded
TWSI0: Address   3 (0x03) responded
TWSI0: Address   4 (0x04) responded
TWSI0: Address   5 (0x05) responded
TWSI0: Address   6 (0x06) responded
TWSI0: Address   7 (0x07) responded
TWSI0: Address   8 (0x08) responded
TWSI0: Address  27 (0x1b) responded
TWSI0: Address  76 (0x4c) responded
TWSI0: Address  86 (0x56) responded
TWSI0: Address  88 (0x58) responded
TWSI0: Address  90 (0x5a) responded
TWSI0: Address  91 (0x5b) responded
TWSI0: Address  96 (0x60) responded
TWSI0: Address 104 (0x68) responded
TWSI0: Address 112 (0x70) responded
TWSI0: Address 113 (0x71) responded
TWSI0: Address 116 (0x74) responded
TWSI0: Address 124 (0x7c) responded
TWSI0: Address 125 (0x7d) responded
TWSI0: Address 126 (0x7e) responded
TWSI0: Address 127 (0x7f) responded
----

TIP: Be sure to note the address and bus of any DIMMs.  Later when
DDR3 is tested, SPD data will need to be read from TWSI using these
addresses.

Read
~~~~

Perform a TWSI read.  Prompts will ask for the device address,
internal address width, internal address, and number of bytes to read
(1,2,4).

.Sample TWSI read
----
Device address(13INS)> 1
Internal address width (0, 1, or 2)(14INS)> 0
Number of bytes to read(15INS)> 1
Result: 246 (0xf6)
----

Write
~~~~~

Perform a TWSI write.  Prompts will ask for the device address,
internal address width, internal address, number of bytes to write
(1,2,4), and the data to write.

.Sample TWSI write
----
Device address(10INS)> 11
Internal address width (0, 1, or 2)(11INS)> 1
Internal address(12INS)> 0
Number of bytes to write(13INS)> 4
Data to write(14INS)> 0x11223344
----


Step 5 - Test SMI/MDIO
----------------------

SMI/MDIO busses are used to communicate with Ethernet PHYs.  PHYs
support one of two protocols, clause 22 and clause 45.  Both of these
protocols are supported through the BDK menuing interface.  The main
SMI/MDIO menu selects which of the OCTEON busses to access.

.Sample SMI/MDIO Main Menu
----
include::mdio_main_menu.capture[]
----

Once a bus is selected, various operations are available for both
protocol types.

.Sample SMI/MDIO Sub Menu
----
include::mdio_sub_menu.capture[]
----

Scan bus (Clause 22)
~~~~~~~~~~~~~~~~~~~~

Performs a read from all possible SMI/MDIO addresses and list the
addresses where the reads succeeded.  This can be used to quickly find
all the device connected to the bus.  Note that the scan performs
clause 22 reads and may not show clause 45 only devices.

TIP: Note that the PHY address found here should match the PHY address
set in the configuration menu.

Read a register (Clause 22)::

Performs a SMI/MDIO read using the clause 22 protocol.

Write a register (Clause 22)::

Performs a SMI/MDIO write using the clause 22 protocol.

Read a register (Clause 45)::

Performs a SMI/MDIO read using the clause 45 protocol.

Write a register (Clause 45)::

Performs a SMI/MDIO write using the clause 45 protocol.


Step 6 - Test PCIe
------------------

The BDK supports testing OCTEON's PCIe ports in root complex mode.
Basic bus initialization and enumeration can be performed even before
DDR3 is working.  The sequence is simply to perform the items in the
PCIe menu it order.

.Sample PCIe Menu
----
include::pcie_menu.capture[]
----

PCIe#: Initialize
~~~~~~~~~~~~~~~~~

Bringup PCIe link "#" and report the number of lanes and speed of the interface.

PCIe#: Scan for devices
~~~~~~~~~~~~~~~~~~~~~~~

Use PCIe config cycles to scan bus "#" for devices.  The devices found
can be displayed in a following menu option.  Note that this option
only finds devices and does not assign resources.  This makes it easier
to see device discovery when a PCIe analyzer is connected.

PCIe#: Enumerate devices
~~~~~~~~~~~~~~~~~~~~~~~~

Iterate through the devices found in the scan an assign resources to
them.  After this step is complete, devices will have valid BAR setups
and respond to memory transactions.

PCIe#: Display devices
~~~~~~~~~~~~~~~~~~~~~~

Display the devices found on the bus and show details about each BAR
register.

PCIe#: Perform a memory read
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a PCIe memory read transaction on the bus.  Prompts will be
issued for the PCIe address to read from and the number of bytes to
read.

PCIe#: Perform a memory write
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a PCIe memory write transaction on the bus.  Prompts will be
issued for the PCIe address to write and the data.  The data should be
input as a series of hex digits, two per byte.

PCIe#: Shutdown
~~~~~~~~~~~~~~~

Shutdown the PCIe link.  This might be useful if you want to test link
robustness by performing a series of initialization and shutdown
sequences.


Step 7 - Test QLMs with PRBS
----------------------------

Low level QLM signalling can be configured and tested using "QLM
Options" from the main menu.  The QLM options menu is most useful for
checking SERDES lane signalling.

.Sample QLM Main Menu
----
include::qlm_main_menu.capture[]
----

Once a QLM number is chosen from the main QLM menu, a sub menu of QLM
options is displayed.

.Sample QLM Sub Menu
----
include::qlm_sub_menu.capture[]
----

WARNING: Many QLM menu items place the SERDES in diagnostic modes
where normal operation is not possible.  Power cycle the board after
using the QLM menu options.

QLM#: Show configuration::

Displays the current configuration mode of the QLM.  The mode was
determined based on the hardware strapping of the OCTEON chip.

QLM#: Measure clock::

Measures the clock rate of the QLM's reference clock, using OCTEON's
clock as a reference.  Verify that the reported value is correct for
the QLM configuration.

QLM#: Change de-emphasis and margin::

Allows manual configuration of the QLM de-emphasis and margin
(amplitude).

QLM#: Reset and power down::

Places the QLM into a low power reset state.

QLM#: Shallow loopback::

Configure the QLM to repeat all received traffic at the SERDES level.
This allows signal traces to be verified using an external signal
generator.  Some OCTEON chips can only loopback a limited number of
lanes at a time.  If this is the case, this menu will show the
possible combinations.

QLM#: PRBS::

The QLM begins generation PRBS signal patterns and the receive lanes
lock on the incomming signal.  Statistics are displayed every 5
seconds showing the number of PRBS errors detected.

QLM#: Read JTAG field::

Provides a low level interface for reading fields internal to the QLM.
Only use this option at the specific direction of Cavium technical
support.

QLM#: Write JTAG field::

Provides a low level interface for controlling fields internal to the
QLM.  Only use this option at the specific direction of Cavium
technical support.


Step 8 - Test the RGMII/MII Management Ports
--------------------------------------------

TBD


Step 9 - Test SGMII
-------------------

TBD


Step 10 - Test XAUI
-------------------

TBD


Step 11 - Test Interlaken
-------------------------

TBD


Step 12 - Test SRIO
-------------------

Serial Rapid I/O ports support discovery, enumeration, and basic
transactions.  The main SRIO menu allows you to toggle global debug
options and select which hardware port to work with.

.Sample SRIO Main Menu
----
include::srio_main_menu.capture[]
----

SRIO port #::

Enter the SRIO sub menu for transaction for port "#".

Toggle extra debug output. Currently OFF::

Enable or disable extra debug option for SRIO operations.  These
generally give extra information about SRIO switches and devices as
they are discovered.

Toggle logging of maintenance. Currently OFF::

When this option is enable, every SRIO maintenance transaction is
logged to the console.  This can be useful for determining exactly
what transactions are happening to each device.

.Sample SRIO Sub Menu
----
include::srio_sub_menu.capture[]
----

SRIO#: Initialize
~~~~~~~~~~~~~~~~~

Bringup the SRIO link and report its status.

SRIO#: Scan for devices
~~~~~~~~~~~~~~~~~~~~~~~

Use maintenance transactions to scan the SRIO bus for devices.
Devices found can be displayed using a following menu option.

SRIO#: Enumerate devices
~~~~~~~~~~~~~~~~~~~~~~~~

Iterate through all devices found in the scan and assign device IDs,
set link enables, and program switch route tables.  After enumeration,
devices are capable of responding to SRIO transactions.

SRIO#: Display devices
~~~~~~~~~~~~~~~~~~~~~~

Display the known device SRIO devices along with information about
each device.

SRIO#: Perform a maintenance read
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a maintenance read transaction.  Prompts will request the device
ID to access, transaction format (8 or 16 bit), the SRIO hopcount, and
the register address to read.

SRIO#: Perform a maintenance write
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Issue a maintenance write transaction.  Prompts will request the
device ID to access, transaction format (8 or 16 bit), the SRIO
hopcount, the register address to write, and the write data.


More Advanced SRIO Testing
~~~~~~~~~~~~~~~~~~~~~~~~~~

After basic enumeration completes successfully, SRIO is known to be in
a working state.  If you have devices connected to SRIO which support
more advanced operation, you can perform more detailed probing.  The
exact sequence to perform varies based on the connected device.  The
following section give a brief overview of some of the functions
available in the BDK.

SRIO#: Send a doorbell
^^^^^^^^^^^^^^^^^^^^^^

Send a SRIO doorbell to a device.  Prompts will request the device ID
to access, transaction format (8 or 16 bit), the priority if the
doorbell (0-3), and the doorbell data (a 16bit number).

SRIO#: Receive a doorbell
^^^^^^^^^^^^^^^^^^^^^^^^^

Displays a list of all doorbells received.

SRIO#: Perform a memory read
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TBD

SRIO#: Perform a memory write
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

TBD


Step 13 - Configure and Test DDR
--------------------------------

Configuring DDR for a board can be quite involved, so it is best to
start with a working configuration and customize it.  The recommended
procedure is to copy an existing DDR configuration for one of Cavium's
evaluation boards and then perform the minimal changes needed for the
new board.  Starting in the DDR menu, follow these steps.

.Sample DDR Menu
----
include::ddr_menu.capture[]
----

Step 1 - Copy an Existing Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Choose one of the menu options which most closely matches the board.
Make sure to pick a board configuration that has the same OCTEON chip.

Step 2 - Set the DDR Clock Frequency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Choose the DDR frequency which memory will be clocked at.  The
frequency specified here is the base frequency of the clock.  DDR
DIMMs are generally labeled by data rate instead of clock rate.  Since
data is transferred on every clock edge, the clock rate is always half
the data rate.  For example, a DIMM labeled "DDR3 - 1333" has a
maximum data rate of 1333 64bit words per second, corresponding to a
clock rate of 666.5 Mhz.  This clock rate would be entered as
'666500000'.  During initial configuration, start with a low clock
rate and raise it later after DRAM is tested.  A good starting clock
rate is 500Mhz, so enter '500000000'.

Step 3 - Enter DIMM SPD Addresses
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When designing the board, the DIMM slots must be connected to one of
OCTEON's TWSI busses to allow for access to the DIMM SPD.  DDR
configuration must include the TWSI bus and address used for the
board.  Choose the menu option 'Set SPD TWSI addresses'.

.Sample SPD Entry
----
DDR interface (0 - 3): (14INS)> 0
Octeon TWSI interface number  (0-4): (15INS)> 0
Enter SPD address of 0 to end input.

SPD address for dimm 0: (16INS)> 0x50
SPD address for dimm 1: (17INS)> 0x51
SPD address for dimm 2: (18INS)> 0
----

Step 4 - Apply the new Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now that your DDR configuration has been customized for the board.
Apply the configuration using the menu option.  Choose 'Initialize DDR
controller using current config'.

Step 5 - Test DDR
~~~~~~~~~~~~~~~~~

Once DRAM is configured, test to make sure memory is working.  Two
menu options are available to facilitate testing.

.Test DDR from 64MB to 128MB

This option performs two quick memory tests over a fixed range.  The
first test sequentially writes to memory between 64MB and 128MB and
then reads the results, verifying data was correctly stored.  This
test finds gross errors in DDR, but may miss some errors.  The second
tests performs a random write/read access with XOR patterns.  This
test is much more thorough than the sequential test.  Once both tests
pass, you should move on to more detailed memory tests.

.Test DDR over a specified range

This option performs the same tests as the previous menu option with
the addition of allowing for the range of memory to be selected.  This
can be used to test all of memory except for the lower few megabytes.
The BDK is loaded as memory address zero and locks the entire L2
cache.  This means that the lower memory address can't be tested as
the BDK image would be erased.  The amount of memory reserved is equal
to the size of L2.

TIP: When specifying memory addresses, keep in mind that OCTEON's
memory is in two disjoint regions.  '0 - 256MB' and '512MB +'.  A
board with 4GB of memory uses addresses '0x0 - 0x01fffffff' and
'0x020000000 - 0x10fffffff'.

Dealing with Complex DDR Customization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The menu interface presents option to configure DDR on the most common
board configurations.  In the event that the board needs further
customization.  DDR configurations can be saved and restored from
files.  All DDR options may be customized by first saving a
configuration to a file.  Use either XMODEM or the builtin TFTP server
to transfer the file off of OCTEON.  After editing the configuration
file, transfer it back to OCTEON.

CAUTION: The DDR configuration file format may change in future BDKs.
Be sure to track your specific changes such that they can be applied
to a new configuration exported from a future BDK.

Asking for Help
~~~~~~~~~~~~~~~

When contacting Cavium's customer support, the following information
will be needed.  Detailed logs are _very_ important for diagnosing
DDR problems, so be sure to capture all output given.

. Give details about the board's configuration
. Enable Verbose Output
. Display the current DDR config
. Initialize DDR controller using current config


Step 14 - Test NAND
-------------------

TBD


Step 15 - Test USB
------------------

TBD


Step 16 - Test GPIO
-------------------

Many boards use Octeon GPIOs to control other parts of the board.  The
GPIO menu can be used to manually control the GPIO pins.

.The GPIO Menu
----
include::gpio_menu.capture[]
----

Configure a GPIO::

Choose this option to configure a GPIO.  Prompts ask for which GPIO
and its input or output state.  Here is an example configuring GPIO 0
as a high output.
+
----
GPIO number(29INS)> 0
Configure as output(y/n)(30INS)> y
GPIO state (0/1)(31INS)> 1
----

Read GPIO state::

Read the current state of a GPIO.
+
----
GPIO number(1INS)> 0
GPIO 0: 1
----


Next Steps
----------

After completing the test steps outlined in this document, most board
I/O interfaces have been validated.  With working DDR3 and validated
I/Os, software development can start on the board.  Software should
burn the normal bootloader into NOR flash, overwriting the BDK.  This
can be done either using a flash programmer, or the flash menu in the
BDK.

.The Flash Menu
----
include::flash_menu.capture[]
----

View flash::

Dumps the contents of flash in a hexadecimal dump.

Write flash::

Allows writing a file directly to flash.  Refer to the general BDK
documentation for information about files.

TIP: During the software development process it can be useful to have
known good binaries that exercise the board.  Keep the BDK around as
it makes a good test bench.  One board running the BDK can be used to
help debug software running on another board.
